<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=WINDOWS-1252">
<meta name="author" content="Jeffrey Richter">
<style type="text/css">
p
{
	margin-top: .5em;
	margin-bottom: .5em;
	text-indent: 0px;
}
blockquote
{
	margin-top: .5em;
	margin-bottom: .5em;
}
h1, h2, h3
{
	margin-top: 1em;
	margin-bottom: 1em;	
}
hr
{
	margin-top: 0px;
	margin-bottom: 0px;
}
</style>
<title>CLR via C#, Third Edition</title>
</head>
<body>
<p>PUBLISHED BY Microsoft Press</p>
<p>A Division of Microsoft Corporation</p>
<p>One Microsoft Way</p>
<p>Redmond, Washington 98052-6399</p>
<p>Copyright &copy; 2010 by Jeffrey Richter</p>
<p>All rights reserved. No part of the contents of this book may be reproduced or transmitted in any form or by any means without the written permission of the publisher.</p>
<p>Library of Congress Control Number: 2009943026 Printed and bound in the United States of America. 1 2 3 4 5 6 7 8 9 WCT 5 4 3 2 1 0</p>
<p>A CIP catalogue record for this book is available from the British Library.</p>
<p>Microsoft Press books are available through booksellers and distributors worldwide. For further information about international editions, contact your local Microsoft Corporation office or contact Microsoft Press International directly at fax (425) 936-7329. Visit our Web site at <a href="http://www.microsoft.com/mspress">www.microsoft.com/mspress</a>. Send comments to <a href="mailto:msinput@microsoft.com">msinput@microsoft.com</a>.</p>
<p>Microsoft, Microsoft Press, Active Accessibility, Active Directory, ActiveX, Authenticode, DirectX, Excel, IntelliSense, Internet Explorer, MSDN, Outlook, SideShow, Silverlight, SQL Server, Visual Basic, Visual Studio, Win32, Windows, Windows Live, Windows Media, Windows NT, Windows Server and Windows Vista are either registered trademarks or trademarks of the Microsoft group of companies. Other product and company names mentioned herein may be the trademarks of their respective owners.</p>
<p>The example companies, organizations, products, domain names, e-mail addresses, logos, people, places, and events depicted herein are fictitious. No association with any real company, organization, product, domain name, e-mail address, logo, person, place, or event is intended or should be inferred.</p>
<p>This book expresses the author's views and opinions. The information contained in this book is provided without any express, statutory, or implied warranties. Neither the authors, Microsoft Corporation, nor its resellers, or distributors will be held liable for any damages caused or alleged to be caused either directly or indirectly by this book.</p>
<p><b>Acquisitions Editor: </b>Ben Ryan <b>Developmental Editor: </b>Devon Musgrave <b>Project Editor: </b>Valerie Woolley</p>
<p><b>Editorial Production: </b>Custom Editorial Productions, Inc.</p>
<p><b>Technical Reviewer: </b>Christophe Nasarre; Technical Review services provided by Content Master, a member of CM Group, Ltd.</p>
<p><b>Cover: </b>Tom Draper Design</p>
<p>Body Part No. X16-61995</p>
<mbp:pagebreak/>
<a name="TOC"/>
<h1>Table of Contents</h1>
<a href="#Foreword">Foreword</a><br/>
<a href="#start">Introduction</a><br/>
<a href="#Chapter1">Chapter 1: The CLR's Execution Model</a><br/>
<a href="#Chapter2">Chapter 2: Building, Packaging, Deploying, and Administering Applications and Types</a><br/>
<a href="#Chapter3">Chapter 3: Shared Assemblies and Strongly Named Assemblies</a><br/>
<a href="#Chapter4">Chapter 4: Type Fundamentals</a><br/>
<a href="#Chapter5">Chapter 5: Primitive, Reference, and Value Types</a><br/>
<a href="#Chapter6">Chapter 6: Type and Member Basics</a><br/>
<a href="#Chapter7">Chapter 7: Constants and Fields</a><br/>
<a href="#Chapter8">Chapter 8: Methods</a><br/>
<a href="#Chapter9">Chapter 9: Parameters</a><br/>
<a href="#Chapter10">Chapter 10: Properties</a><br/>
<a href="#Chapter11">Chapter 11: Events</a><br/>
<a href="#Chapter12">Chapter 12: Generics</a><br/>
<a href="#Chapter13">Chapter 13: Interfaces</a><br/>
<a href="#Chapter14">Chapter 14: Chars, Strings, and Working with Text</a><br/>
<a href="#Chapter15">Chapter 15: Enumerated Types and Bit Flags</a><br/>
<a href="#Chapter16">Chapter 16: Arrays</a><br/>
<a href="#Chapter17">Chapter 17: Delegates</a><br/>
<a href="#Chapter18">Chapter 18: Custom Attributes</a><br/>
<a href="#Chapter19">Chapter 19: Nullable Value Types</a><br/>
<a href="#Chapter20">Chapter 20: Exceptions and State Management</a><br/>
<a href="#Chapter21">Chapter 21: Automatic Memory Management (Garbage Collection)</a><br/>
<a href="#Chapter22">Chapter 22: CLR Hosting and AppDomains</a><br/>
<a href="#Chapter23">Chapter 23: Assembly Loading and Reflection</a><br/>
<a href="#Chapter24">Chapter 24: Runtime Serialization</a><br/>
<a href="#Chapter25">Chapter 25: Thread Basics</a><br/>
<a href="#Chapter26">Chapter 26: Compute-Bound Asynchronous Operations</a><br/>
<a href="#Chapter27">Chapter 27: I/O-Bound Asynchronous Operations</a><br/>
<a href="#Chapter28">Chapter 28: Primitive Thread Synchronization Constructs</a><br/>
<a href="#Chapter29">Chapter 29: Hybrid Thread Synchronization Constructs</a><br/>
<a href="#Index">Index</a><br/>
<a href="#About">About the Author</a><br/>
<mbp:pagebreak/>
<a name="Foreword"/>
<h1>Foreword</h1>
<p>At first, when Jeff asked me to write the foreword for his book, I was so flattered! He must really respect me, I thought. Ladies, this is a common thought process error葉rust me, he doesn't respect you. It turns out that I was about #14 on his list of potential foreword writers and he had to settle for me. Apparently, none of the other candidates (Bill Gates, Steve Ballmer, Catherine Zeta-Jones,...) were that into him. At least he bought me dinner.</p>
<p>But no one can tell you more about this book than I can. I mean, Catherine could give you a mobile makeover, but I know all kinds of stuff about reflection and exceptions and C# language updates because he has been talking on and on about it for years This is standard dinner conversation in our house! Other people talk about the weather or stuff they heard at the water cooler, but we talk about.NET. Even Aidan, our six-year-old, asks questions about Jeff's book. Mostly about when he will be done writing it so they can play something &quot;cool.&quot; Grant (age 2) doesn't talk yet, but his first word will probably be &quot;Sequential.&quot;</p>
<p>In fact, if you want to know how this all started, it goes something like this. About 10 years ago, Jeff went to a &quot;Secret Summit&quot; at Microsoft. They pulled in a bunch of industry experts (Really, how do you get this title? Believe me, this isn't Jeff's college degree), and unveiled the new COM Late that night in bed (in our house, this is what we discuss in bed), he talked about how COM is dead. And he was enchanted. Lovestruck, actually. In a matter of days he was hanging around the halls of Building 42 on Microsoft's Redmond campus, hoping to learn more about this wonderful.NET. The affair hasn't ended, and this book is what he has to show for it.</p>
<p>For years, Jeff has told me about threading. He really likes this topic. One time, in New Orleans, we went on a two-hour walk, alone, holding hands, and he spoke the whole time about how he had enough content for a threading book: The art of threading. How misunderstood threading in Windows is It breaks his heart, all those threads out there Where do they all go? Why were they created if no one had a plan for them? These are the questions of the universe to Jeff, the deeper meanings in life. Finally, in this book, he has written it down. It is all here Believe me folks, if you want to know about threading, no one has thought about it more or worked with it more than Jeff has. And all those wasted hours of his life (he can't get them back) are here at your disposal. Please read it. Then send him an e-mail about how that information changed your life. Otherwise, he is just another tragic literary figure whose life ended without meaning or fulfillment. He will drink himself to death on diet soda.</p>
<p>This edition of the book even includes a new chapter about the runtime serializes Turns out, this is not a new breakfast food for kids. When I figured out it was more computer talk and not something to put on my grocery list, I tuned it out. So I don't know what it says, but it is in here and you should read it (with a glass of milk).</p>
<p>My hope is that now he is finished talking about garbage collection in theory and can get on with actually collecting our garbage and putting it on the curb. Seriously people, how hard is that?</p>
<p>Folks, here is the clincher葉his is Jeffrey Richter's magnum opus. This is it. There will be no more books. Of course, we say this every time he finishes one, but this time we really mean it. So, 13 books (give or take) later, this is the best and the last. Get it fast, because there are only a limited number and once they are gone用oof No more. Just like QVC or something. Back to real life for us, where we can discuss the important things, like what the kids broke today and whose turn is it to change the diapers.</p>
<p>Kristin Trace (Jeffrey's wife) November 24, 2009</p>
<img src="2.jpg"/>
<p>A typical family breakfast at the Richter household</p>
<mbp:pagebreak/>
<a name="start"/>
<h1>Introduction</h1>
<p>It was October 1999 when some people at Microsoft first demonstrated the Microsoft .NET Framework, the common language runtime (CLR), and the C# programming language to me. The moment I saw all of this, I was impressed and I knew that it was going to change the way I wrote software in a very significant way. I was asked to do some consulting for the team and immediately agreed. At first, I thought that the .NET Framework was an abstraction layer over the Win32 API and COM. As I invested more and more of my time into it, however, I realized that it was much bigger In a way, it is its own operating system. It has its own memory manager, its own security system, its own file loader, its own error handling mechanism, its own application isolation boundaries (AppDomains), its own threading models, and more. This book explains all these topics so that you can effectively design and implement software applications and components for this platform.</p>
<p>I have spent a good part of my life focusing on threading, concurrent execution, parallelism, synchronization, and so on. Today, with multicore computers becoming so prevalent, these subjects are becoming increasingly important. A few years ago, I decided to create a book dedicated to threading topics. However, one thing led to another and I never produced the book. When it came time to revise this book, I decided to incorporate all the threading information in here. So this book covers the .NET Framework's CLR and the C# programming language, and it also has my threading book embedded inside it (see Part V, &quot;Threading&quot;).</p>
<p>It is October 2009 as I write this text, making it 10 years now that I've worked with the .NET Framework and C# Over the 10 years, I have built all kinds of applications and, as a consultant to Microsoft, have contributed quite a bit to the .NET Framework itself As a partner in my own company, Wintellect (<a href="http://Wintellect.com">http://Wintellect.com</a>), I have worked with numerous customers to help them design software, debug software, performance-tune software, and solve issues they have with the .NET Framework. All these experiences have really helped me learn the spots that people have trouble with when trying to be productive with the .NET Framework. I have tried to sprinkle knowledge from these experiences through all the topics presented in this book.</p>
<h2>Who This Book Is For</h2>
<p>The purpose of this book is to explain how to develop applications and reusable classes for the .NET Framework. Specifically, this means that I intend to explain how the CLR works and the facilities that it offers. I'll also discuss various parts of the Framework Class Library (FCL). No book could fully explain the FCL擁t contains literally thousands of types now, and this number continues to grow at an alarming rate. Therefore, here I'm concentrating on the core types that every developer needs to be aware of And while this book isn't specifically about Windows Forms, Windows Presentation Foundation (WPF), Silverlight, XML Web services,</p>
<p>Web Forms, and so on, the technologies presented in the book are applicable to all these application types.</p>
<p>The book addresses Microsoft Visual Studio 2010,.NET Framework version 4. 0, and version 4. 0 of the C# programming language. Since Microsoft tries to maintain a large degree of backward compatibility when releasing a new version of these technologies, many of the things I discuss in this book apply to earlier versions as well. All the code samples use the C# programming language as a way to demonstrate the behavior of the various facilities. But, since the CLR is usable by many programming languages, the book's content is still quite applicable for the non-C# programmer</p>
<hr/>
<blockquote><b>Note </b>You can download the code shown in the book from Wintellect's Web site (<a href="http://Wintellect.com">http://Wintellect.com</a>). In some parts of the book, I describe classes in my own Power IThreading Library. This library is available free of charge and can also be downloaded from Wintellect's Web site.</blockquote>
<hr/>
<p>Today, Microsoft offers several versions of the CLR. There is the desktop/server version, which runs on 32-bit x86 versions of Microsoft Windows as well as 64-bit x64 and IA64 versions of Windows. There is the Silverlight version, which is produced from the same source code base as the desktop/server version of the .NET Framework's CLR. Therefore, everything in this book applies to building Silverlight applications, with the exception of some differences in how Silverlight loads assemblies. There is also a &quot;lite&quot; version of the .NET Framework called the .NET Compact Framework, which is available for Windows Mobile phones and other devices running the Windows CE operating system Much of the information presented in this book is applicable to developing applications for the .NET Compact Framework, but this platform is not the primary focus of this book.</p>
<p>On December 13, 2001, ECMA International (<a href="http://www.ecma-international.org/">http://www.ecma-international.org/</a>) accepted the C# programming language, portions of the CLR, and portions of the FCL as standards The standards documents that resulted from this have allowed other organizations to build ECMA-compliant versions of these technologies for other CPU architectures, as well as other operating systems. In fact, Novell produces Moonlight (<a href="http://www.mono-project.com">http://www.mono-project.com</a> /Moonlight), an open-source implementation of Silverlight (<a href="http://Silverlight.net">http://Silverlight.net</a>) that is primarily for Linux and other UNIX/X11-based operating systems. Moonlight is based on the ECMA specifications. Much of the content in this book is about these standards; therefore, many will find this book useful for working with any runtime/library implementation that adheres to the ECMA standard.</p>
<hr/>
<blockquote><b>Note </b>My editors and I have worked hard to bring you the most accurate, up-to-date, in-depth, easy-to-read, painless-to-understand, bug-free information Even with this fantastic team assembled, however, things inevitably slip through the cracks. If you find any mistakes in this book (especially bugs) or have some constructive feedback, I would greatly appreciate it if you would contact me at <a href="mailto:JeffreyR@Wintellect.com">JeffreyR@Wintellect.com</a>.</blockquote>
<hr/>
<h2>Dedication</h2>
<p>To Kristin Words cannot express how I feel about our life together I cherish our family and all our adventures. I'm filled each day with love for you.</p>
<p>To Aidan (age 6) and Grant (age 2)   You both have been an inspiration to me and have taught me to play and have fun. Watching the two of you grow up has been so rewarding and enjoyable for me. I am lucky to be able to partake in your lives. I love and appreciate you more than you could ever know.</p>
<h2>Acknowledgments</h2>
<p>I couldn't have written this book without the help and technical assistance of many people In particular, I'd like to thank my family. The amount of time and effort that goes into writing a book is hard to measure. All I know is that I could not have produced this book without the support of my wife, Kristin, and my two sons, Aidan and Grant. There were many times when we wanted to spend time together but were unable to due to book obligations. Now that the book project is completed, I really look forward to adventures we will all share together</p>
<p>For this book revision, I truly had some fantastic people helping me. Christophe Nasarre, who I've worked with on several book projects, has done just a phenomenal job of verifying my work and making sure that I'd said everything the best way it could possibly be said. He has truly had a significant impact on the quality of this book. As always, the Microsoft Press editorial team is a pleasure to work with I'd like to extend a special thank you to Ben Ryan, Valerie Woolley, and Devon Musgrave. Also, thanks to Jean Findley and Sue McClung for their editing and production support.</p>
<h2>Support for This Book</h2>
<p>Every effort has been made to ensure the accuracy of this book. As corrections or changes are collected, they will be added to a Microsoft Knowledge Base article accessible via the Microsoft Help and Support site. Microsoft Press provides support for books, including instructions for finding Knowledge Base articles, at the following Web site:</p>
<p><a href="http://www.microsoft.com/learning/support/books/">http://www.microsoft.com/learning/support/books/</a></p>
<p>If you have questions regarding the book that are not answered by visiting the site above or viewing a Knowledge Base article, send them to Microsoft Press via e-mail to <a href="mailto:mspinput@microsoft.com">mspinput@microsoft.com</a>.</p>
<p>Please note that Microsoft software product support is not offered through these addresses.</p>
<h2>We Want to Hear from You</h2>
<p>We welcome your feedback about this book Please share your comments and ideas via the following short survey:</p>
<p><a href="http://www.microsoft.com/learning/booksurvey">http://www.microsoft.com/learning/booksurvey</a></p>
<p>Your participation will help Microsoft Press create books that better meet your needs and standards</p>
<hr/>
<blockquote><b>Note </b>We hope that you will give us detailed feedback via our survey. If you have questions about our publishing program, upcoming titles, or Microsoft Press in general, we encourage you to interact with us via Twitter at <a href="http://twitter.com/MicrosoftPress">http://twitter.com/MicrosoftPress</a> For support issues, use only the e-mail address shown above.</blockquote>
<hr/>
<mbp:pagebreak/>
<a name="Chapter1"/>
<h1>Chapter 1: The CLR's Execution Model</h1>
<p><b>In this chapter:</b></p>
<a href="#b1">Compiling Source Code into Managed Modules</a><br/>
<a href="#b5">Combining Managed Modules into Assemblies</a><br/>
<a href="#b6">Loading the Common Language Runtime</a><br/>
<a href="#b9">Executing Your Assembly's Code</a><br/>
<a href="#b18">The Native Code Generator Tool: NGen.exe</a><br/>
<a href="#b20">The Framework Class Library</a><br/>
<a href="#b22">The Common Type System</a><br/>
<a href="#b25">The Common Language Specification</a><br/>
<a href="#b29">Interoperability with Unmanaged Code</a><br/>
<p>The Microsoft .NET Framework introduces many new concepts, technologies, and terms. My goal in this chapter is to give you an overview of how the .NET Framework is designed, introduce you to some of the new technologies the framework includes, and define many of the terms you'll be seeing when you start using it. I'll also take you through the process of building your source code into an application or a set of redistributable components (files) that contain types (classes, structures, etc.) and then explain how your application will execute.</p>
<a name="b1"/><h2>Compiling Source Code into Managed Modules</h2>
<p>OK, so you've decided to use the .NET Framework as your development platform. Great! Your first step is to determine what type of application or component you intend to build. Let's just assume that you've completed this minor detail; everything is designed, the specifications are written, and you're ready to start development.</p>
<p>Now you must decide which programming language to use. This task is usually difficult because different languages offer different capabilities. For example, in unmanaged C/C++, you have pretty low-level control of the system. You can manage memory exactly the way you want to, create threads easily if you need to, and so on. Microsoft Visual Basic 6, on the other hand, allows you to build UI applications very rapidly and makes it easy for you to control COM objects and databases.</p>
<p>The common language runtime (CLR) is just what its name says it is: a runtime that is usable by different and varied programming languages. The core features of the CLR (such as memory management, assembly loading, security, exception handling, and thread synchronization) are available to any and all programming languages that target it用eriod. For example, the runtime uses exceptions to report errors, so all languages that target the runtime also get errors reported via exceptions. Another example is that the runtime also allows you to create a thread, so any language that targets the runtime can create a thread.</p>
<p>In fact, at runtime, the CLR has no idea which programming language the developer used for the source code This means that you should choose whatever programming language allows you to express your intentions most easily. You can develop your code in any programming language you desire as long as the compiler you use to compile your code targets the CLR.</p>
<p>So, if what I say is true, what is the advantage of using one programming language over another? Well, I think of compilers as syntax checkers and &quot;correct code&quot; analyzers. They examine your source code, ensure that whatever you've written makes some sense, and then output code that describes your intention. Different programming languages allow you to develop using different syntax. Don't underestimate the value of this choice. For mathematical or financial applications, expressing your intentions by using APL syntax can save many days of development time when compared to expressing the same intention by using Perl syntax, for example.</p>
<p>Microsoft has created several language compilers that target the runtime: C++/CLI, C# (pronounced &quot;C sharp&quot;), Visual Basic, F# (pronounced &quot;F sharp&quot;), Iron Python, Iron Ruby, and an Intermediate Language (IL) Assembler. In addition to Microsoft, several other companies, colleges, and universities have created compilers that produce code to target the CLR. I'm aware of compilers for Ada, APL, Caml, COBOL, Eiffel, Forth, Fortran, Haskell, Lexico, LISP, LOGO, Lua, Mercury, ML, Mondrian, Oberon, Pascal, Perl, Php, Prolog, RPG, Scheme, Smalltalk, and Tcl/Tk</p>
<p>Figure 1-1 shows the process of compiling source code files. As the figure shows, you can create source code files written in any programming language that supports the CLR. Then you use the corresponding compiler to check the syntax and analyze the source code Regardless of which compiler you use, the result is a managed module. A managed module is a standard 32-bit Microsoft Windows portable executable (PE32) file or a standard 64-bit Windows portable executable (PE32+) file that requires the CLR to execute. By the way, managed assemblies always take advantage of Data Execution Prevention (DEP) and Address Space Layout Randomization (ASLR) in Windows; these two features improve the security of your whole system.</p>
<img src="3.jpg"/>
<p><b>Figure 1-1 </b>Compiling source code into managed modules Table 1-1 describes the parts of a managed module. <b>Table 1-1 </b><b>Parts of a Managed Module</b></p>
<p>Native code compilers produce code targeted to a specific CPU architecture, such as x86, x64, or IA64. All CLR-compliant compilers produce IL code instead. (I'll go into more detail about IL code later in this chapter.) IL code is sometimes referred to as managed code because the CLR manages its execution.</p>
<table border="1">
<tr>
<td>
<p>Part</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
<tr>
<td>
<p>PE32 or PE32+ header</p>
</td>
<td>
<p>The standard Windows PE file header, which is similar to the Common Object File Format (COFF) header If the header uses the PE32 format, the file can run on a 32-bit or 64-bit version of Windows. If the header uses the PE32+ format, the file requires a 64-bit version of Windows to run. This header also indicates the type of file: GUI, CUI, or DLL, and contains a timestamp indicating when the file was built. For modules that contain only IL code, the bulk of the information in the PE32(+) header is ignored For modules that contain native CPU code, this header contains information about the native CPU code.</p>
</td>
</tr>
<tr>
<td>
<p>CLR header</p>
</td>
<td>
<p>Contains the information (interpreted by the CLR and utilities) that makes this a managed module The header includes the version of the CLR required, some flags, the MethodDef metadata token of the managed module's entry point method (Main method), and the location/size of the module's metadata, resources, strong name, some flags, and other less interesting stuff</p>
</td>
</tr>
<tr>
<td>
<p>Metadata</p>
</td>
<td>
<p>Every managed module contains metadata tables There are two main types of tables: tables that describe the types and members defined in your source code and tables that describe the types and members referenced by your source code.</p>
</td>
</tr>
<tr>
<td>
<p>IL code</p>
</td>
<td>
<p>Code the compiler produced as it compiled the source code At runtime, the CLR compiles the IL into native CPU instructions.</p>
</td>
</tr>
</table>
<p>In addition to emitting IL, every compiler targeting the CLR is required to emit full metadata into every managed module In brief, metadata is a set of data tables that describe what is defined in the module, such as types and their members. In addition, metadata also has tables indicating what the managed module references, such as imported types and their members Metadata is a superset of older technologies such as COM's Type Libraries and Interface Definition Language (IDL) files. The important thing to note is that CLR metadata is far more complete. And, unlike Type Libraries and IDL, metadata is always associated with the file that contains the IL code. In fact, the metadata is always embedded in the same EXE/DLL as the code, making it impossible to separate the two. Because the compiler produces the metadata and the code at the same time and binds them into the resulting managed module, the metadata and the IL code it describes are never out of sync with one another.</p>
<p>Metadata has many uses. Here are some of them:</p>
<p>&#9632; Metadata removes the need for native C/C++ header and library files when compiling because all the information about the referenced types/members is contained in the file that has the IL that implements the type/members. Compilers can read metadata directly from managed modules.</p>
<p>&#9632; Microsoft Visual Studio uses metadata to help you write code. Its IntelliSense feature parses metadata to tell you what methods, properties, events, and fields a type offers, and in the case of a method, what parameters the method expects.</p>
<p>&#9632; The CLR's code verification process uses metadata to ensure that your code performs only &quot;type-safe&quot; operations. (I'll discuss verification shortly.)</p>
<p>&#9632; Metadata allows an object's fields to be serialized into a memory block, sent to another machine, and then deserialized, re-creating the object's state on the remote machine.</p>
<p>&#9632; Metadata allows the garbage collector to track the lifetime of objects. For any object, the garbage collector can determine the type of the object and, from the metadata, know which fields within that object refer to other objects.</p>
<p>In Chapter 2, &quot;Building, Packaging, Deploying, and Administering Applications and Types,&quot; I'll describe metadata in much more detail.</p>
<p>Microsoft's C#, Visual Basic, F#, and the IL Assembler always produce modules that contain managed code (IL) and managed data (garbage-collected data types). End users must have the CLR (presently shipping as part of the .NET Framework) installed on their machine in order to execute any modules that contain managed code and/or managed data in the same way that they must have the Microsoft Foundation Class (MFC) library or Visual Basic DLLs installed to run MFC or Visual Basic 6 applications.</p>
<p>By default, Microsoft's C++ compiler builds EXE/DLL modules that contain unmanaged (native) code and manipulate unmanaged data (native memory) at runtime. These modules don't require the CLR to execute. However, by specifying the <b>/CLR </b>command-line switch, the C++ compiler produces modules that contain managed code, and of course, the CLR must then be installed to execute this code. Of all of the Microsoft compilers mentioned, C++ is unique in that it is the only compiler that allows the developer to write both managed and unmanaged code and have it emitted into a single module. It is also the only Microsoft compiler that allows developers to define both managed and unmanaged data types in their source code. The flexibility provided by Microsoft's C++ compiler is unparalleled by other compilers because it allows developers to use their existing native C/C++ code from managed code and to start integrating the use of managed types as they see fit.</p>
<a name="b5"/><h2>Combining Managed Modules into Assemblies</h2>
<p>The CLR doesn't actually work with modules, it works with assemblies. An assembly is an abstract concept that can be difficult to grasp initially. First, an assembly is a logical grouping of one or more modules or resource files. Second, an assembly is the smallest unit of reuse, security, and versioning Depending on the choices you make with your compilers or tools, you can produce a single-file or a multifile assembly. In the CLR world, an assembly is what we would call a component.</p>
<p>In Chapter 2, I'll go over assemblies in great detail, so I don't want to spend a lot of time on them here. All I want to do now is make you aware that there is this extra conceptual notion that offers a way to treat a group of files as a single entity.</p>
<p>Figure 1-2 should help explain what assemblies are about. In this figure, some managed modules and resource (or data) files are being processed by a tool. This tool produces a single PE32(+) file that represents the logical grouping of files. What happens is that this PE32(+) file contains a block of data called the manifest. The manifest is simply another set of metadata tables. These tables describe the files that make up the assembly, the publicly exported types implemented by the files in the assembly, and the resource or data files that are associated with the assembly.</p>
<img src="4.jpg"/>
<p><b>Figure 1-2 </b>Combining managed modules into assemblies</p>
<p>By default, compilers actually do the work of turning the emitted managed module into an assembly; that is, the C# compiler emits a managed module that contains a manifest. The manifest indicates that the assembly consists of just the one file. So, for projects that have just one managed module and no resource (or data) files, the assembly will be the managed module, and you don't have any additional steps to perform during your build process. If you want to group a set of files into an assembly, you'll have to be aware of more tools (such as the assembly linker, AL.exe) and their command-line options. I'll explain these tools and options in Chapter 2.</p>
<p>An assembly allows you to decouple the logical and physical notions of a reusable, securable, versionable component. How you partition your code and resources into different files is completely up to you. For example, you could put rarely used types or resources in separate files that are part of an assembly. The separate files could be downloaded on demand from the Web as they are needed at runtime. If the files are never needed, they're never downloaded, saving disk space and reducing installation time. Assemblies allow you to break up the deployment of the files while still treating all of the files as a single collection.</p>
<p>An assembly's modules also include information about referenced assemblies (including their version numbers). This information makes an assembly self-describing. In other words, the CLR can determine the assembly's immediate dependencies in order for code in the assembly to execute. No additional information is required in the registry or in Active Directory Domain Services (AD DS). Because no additional information is needed, deploying assemblies is much easier than deploying unmanaged components.</p>
<a name="b6"/><h2>Loading the Common Language Runtime</h2>
<p>Each assembly you build can be either an executable application or a DLL containing a set of types for use by an executable application Of course, the CLR is responsible for managing the execution of code contained within these assemblies This means that the NET Framework must be installed on the host machine Microsoft has created a redistribution package that you can freely ship to install the .NET Framework on your customers' machines. Some versions of Windows ship with the .NET Framework already installed.</p>
<p>You can tell if the .NET Framework has been installed by looking for the MSCorEE.dll file in the %SystemRoot%\System32 directory. The existence of this file tells you that the .NET Framework is installed. However, several versions of the .NET Framework can be installed on a single machine simultaneously. If you want to determine exactly which versions of the .NET Framework are installed, examine the subkeys under the following registry key:</p>
<p><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NET Framework Setup\NDP</code></p>
<p>The .NET Framework SDK includes a command-line utility called CLRVer.exe that shows all of the CLR versions installed on a machine. This utility can also show which version of the CLR is being used by processes currently running on the machine by using the <b>-all </b>switch or passing the ID of the process you are interested in.</p>
<p>Before we start looking at how the CLR loads, we need to spend a moment discussing 32-bit and 64-bit versions of Windows. If your assembly files contain only type-safe managed code, you are writing code that should work on both 32-bit and 64-bit versions of Windows. No source code changes are required for your code to run on either version of Windows In fact, the resulting EXE/DLL file produced by the compiler will run on 32-bit Windows as well as the x64 and IA64 versions of 64-bit Windows! In other words, the one file will run on any machine that has a version of the .NET Framework installed on it.</p>
<p>On extremely rare occasions, developers want to write code that works only on a specific version of Windows Developers might do this when using unsafe code or when interoperating with unmanaged code that is targeted to a specific CPU architecture. To aid these developers, the C# compiler offers a <b>/platform </b>command-line switch. This switch allows you to specify whether the resulting assembly can run on x86 machines running 32-bit Windows versions only, x64 machines running 64-bit Windows only, or Intel Itanium machines running 64-bit Windows only. If you don't specify a platform, the default is <b>anycpu, </b>which indicates that the resulting assembly can run on any version of Windows. Users of Visual Studio can set a project's target platform by displaying the project's property pages, clicking the Build tab, and then selecting an option in the Platform Target list (see Figure 1-3).</p>
<img src="5.jpg"/>
<p><b>Figure 1-3 </b>Setting the platform target by using Visual Studio</p>
<p>Depending on the platform switch, the C# compiler will emit an assembly that contains either a PE32 or PE32+ header, and the compiler will also emit the desired CPU architecture (or agnostic) into the header as well. Microsoft ships two SDK command-line utilities, DumpBin.exe and CorFlags.exe, that you can use to examine the header information emitted in a managed module by the compiler.</p>
<p>When running an executable file, Windows examines this EXE file's header to determine whether the application requires a 32-bit or 64-bit address space. A file with a PE32 header can run with a 32-bit or 64-bit address space, and a file with a PE32+ header requires a 64-bit address space. Windows also checks the CPU architecture information embedded inside the header to ensure that it matches the CPU type in the computer Lastly, 64-bit versions of Windows offer a technology that allows 32-bit Windows applications to run This technology is called WoW64 (for Windows on Windows64). This technology even allows 32-bit applications with x86 native code in them to run on an Itanium machine, because the WoW64 technology can emulate the x86 instruction set; albeit with a significant performance cost.</p>
<p>Table 1-2 shows two things. First, it shows what kind of managed module you get when you specify various <b>/platform </b>command-line switches to the C# compiler. Second, it shows how that application will run on various versions of Windows.</p>
<p><b>table </b><b>1-2 </b><b>Effects of /platform on Resulting Module and at Runtime</b></p>
<table border="1">
<tr>
<td>
<p><b>/platform Switch</b></p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>s</p>
</td>
<td>
<p>s</p>
</td>
<td>
<p>s</p>
</td>
</tr>
<tr>
<td>
<p>anycpu</p>
<p>(the default)</p>
</td>
<td>
<p>PE32/agnostic</p>
</td>
<td>
<p>Runs as a 32-bit application</p>
</td>
<td>
<p>Runs as a 64-bit application</p>
</td>
<td>
<p>Runs as a 64-bit application</p>
</td>
</tr>
<tr>
<td>
<p>x86</p>
</td>
<td>
<p>PE32/x86</p>
</td>
<td>
<p>Runs as a 32-bit application</p>
</td>
<td>
<p>Runs as a WoW64 application</p>
</td>
<td>
<p>Runs as a WoW64 application</p>
</td>
</tr>
<tr>
<td>
<p>x64</p>
</td>
<td>
<p>PE32+/x64</p>
</td>
<td>
<p>Doesn't run</p>
</td>
<td>
<p>Runs as a 64-bit application</p>
</td>
<td>
<p>Doesn't run</p>
</td>
</tr>
<tr>
<td>
<p>Itanium</p>
</td>
<td>
<p>PE32+/Itanium</p>
</td>
<td>
<p>Doesn't run</p>
</td>
<td>
<p>Doesn't run</p>
</td>
<td>
<p>Runs as a 64-bit application</p>
</td>
</tr>
</table>
<p>After Windows has examined the EXE file's header to determine whether to create a 32-bit process, a 64-bit process, or a WoW64 process, Windows loads the x86, x64, or IA64 version of MSCorEE dll into the process's address space On an x86 version of Windows, the x86 version of MSCorEE.dll can be found in the <span>C:\Windows\System32</span> directory. On an x64 or IA64 version of Windows, the x86 version of MSCorEE.dll can be found in the <span>C:\Windows\SysWow64</span> directory, whereas the 64-bit version (x64 or IA64) can be found in the <span>C:\Windows\System32</span> directory (for backward compatibility reasons). Then, the process's primary thread calls a method defined inside MSCorEE.dll. This method initializes the CLR, loads the EXE assembly, and then calls its entry point method <b>(Main) </b>. At this point, the managed application is up and running <sup>1</sup></p>
<p>Your code can query <b>Environment</b>'s <b>Is64BitOperatingSystem </b>property to determine if it is running on a 64-bit version of Windows. Your code can also query <b>Environment</b>'s <b>Is64BitProcess </b>property to determine if it is running in a 64-bit address space.</p>
<hr/>
<blockquote><b>Note </b>Assemblies built by using version 1.0 or 1.1 of Microsoft's C# compiler contain a PE32 header and are CPU-architecture agnostic. However, at load time, the CLR considers these assemblies to be x86 only. For executable files, this improves the likelihood of the application actually working on a 64-bit system because the executable file will load in WoW64, giving the process an environment very similar to what it would have on a 32-bit x86 version of Windows.</blockquote>
<hr/>
<p>If an unmanaged application calls <b>LoadLibrary </b>to load a managed assembly, Windows knows to load and initialize the CLR (if not already loaded) in order to process the code contained within the assembly. Of course, in this scenario, the process is already up and running, and this may limit the usability of the assembly. For example, a managed assembly compiled with the <b>/platform:x86 </b>switch will not be able to load into a 64-bit process at all, whereas an executable file compiled with this same switch would have loaded in WoW64 on a computer running a 64-bit version of Windows.</p>
<a name="b9"/><h2>Executing Your Assembly's Code</h2>
<p>As mentioned earlier, managed assemblies contain both metadata and IL IL is a CPU-independent machine language created by Microsoft after consultation with several external commercial and academic language/compiler writers IL is a much higher-level language than most CPU machine languages IL can access and manipulate object types and has instructions to create and initialize objects, call virtual methods on objects, and manipulate array elements directly It even has instructions to throw and catch exceptions for error handling You can think of IL as an object-oriented machine language.</p>
<p>Usually, developers will program in a high-level language, such as C#, C++/CLI, or Visual Basic. The compilers for these high-level languages produce IL. However, as any other machine language, IL can be written in assembly language, and Microsoft does provide an IL Assembler, ILAsm.exe. Microsoft also provides an IL Disassembler, ILDasm.exe.</p>
<p>Keep in mind that any high-level language will most likely expose only a subset of the facilities offered by the CLR. However, the IL assembly language allows a developer to access all of the CLR's facilities. So, should your programming language of choice hide a facility the CLR offers that you really want to take advantage of, you can choose to write that portion of your code in IL assembly or perhaps another programming language that exposes the CLR feature you seek.</p>
<p>The only way for you to know what facilities the CLR offers is to read documentation specific to the CLR itself. In this book, I try to concentrate on CLR features and how they are exposed or not exposed by the C# language. I suspect that most other books and articles will present the CLR via a language perspective, and that most developers will come to believe that the CLR offers only what the developer's chosen language exposes. As long as your language allows you to accomplish what you're trying to get done, this blurred perspective isn't a bad thing.</p>
<hr/>
<blockquote><b>Important </b>I think this ability to switch programming languages easily with rich integration between languages is an awesome feature of the CLR. Unfortunately, I also believe that developers will often overlook this feature Programming languages such as C# and Visual Basic are excellent languages for performing I/O operations APL is a great language for performing advanced engineering or financial calculations. Through the CLR, you can write the I/O portions of your application in C# and then write the engineering calculations part in APL The CLR offers a level of integration between these languages that is unprecedented and really makes mixed-language programming worthy of consideration for many development projects.</blockquote>
<hr/>
<p>To execute a method, its IL must first be converted to native CPU instructions. This is the job of the CLR's JIT (just-in-time) compiler.</p>
<p>Figure 1-4 shows what happens the first time a method is called.</p>
<img src="6.jpg"/>
<p><b>Figure 1-4 </b>Calling a method for the first time</p>
<p>Just before the <b>Main </b>method executes, the CLR detects all of the types that are referenced by <b>Main</b>'s code This causes the CLR to allocate an internal data structure that is used to manage access to the referenced types In Figure 1-4, the <b>Main </b>method refers to a single type, <b>Console, </b>causing the CLR to allocate a single internal structure This internal data structure contains an entry for each method defined by the <b>Console </b>type. Each entry holds the address where the method's implementation can be found When initializing this structure, the CLR sets each entry to an internal, undocumented function contained inside the CLR itself I call this function <b>JITCompiler </b>.</p>
<p>When <b>Main </b>makes its first call to <b>WriteLine, </b>the <b>JITCompiler </b>function is called. The <b>JITCompiler </b>function is responsible for compiling a method's IL code into native CPU instructions. Because the IL is being compiled &quot;just in time,&quot; this component of the CLR is frequently referred to as a JITter or a JIT compiler.</p>
<hr/>
<blockquote><b>Note </b>If the application is running on an x86 version of Windows or in WoW64, the JIT compiler produces x86 instructions If your application is running as a 64-bit application on an x64 or Itanium version of Windows, the JIT compiler produces x64 or IA64 instructions, respectively.</blockquote>
<hr/>
<p>When called, the <b>JITCompiler </b>function knows what method is being called and what type defines this method. The <b>JITCompiler </b>function then searches the defining assembly's metadata for the called method's IL. <b>JITCompiler </b>next verifies and compiles the IL code into native CPU instructions. The native CPU instructions are saved in a dynamically allocated block of memory. Then, <b>JITCompiler </b>goes back to the entry for the called method in the type's internal data structure created by the CLR and replaces the reference that called it in the first place with the address of the block of memory containing the native CPU instructions it just compiled. Finally, the <b>JITCompiler </b>function jumps to the code in the memory block. This code is the implementation of the <b>WriteLine </b>method (the version that takes a <b>String </b>parameter). When this code returns, it returns to the code in <b>Main, </b>which continues execution as normal.</p>
<p><b>Main </b>now calls <b>WriteLine </b>a second time. This time, the code for <b>WriteLine </b>has already been verified and compiled. So the call goes directly to the block of memory, skipping the <b>JITCompiler </b>function entirely. After the <b>WriteLine </b>method executes, it returns to <b>Main. </b>Figure 1-5 shows what the process looks like when <b>WriteLine </b>is called the second time.</p>
<p><b>Figure 1-5 </b>Calling a method for the second time</p>
<p>A performance hit is incurred only the first time a method is called. All subsequent calls to the method execute at the full speed of the native code because verification and compilation to native code don't need to be performed again.</p>
<p>The JIT compiler stores the native CPU instructions in dynamic memory. This means that the compiled code is discarded when the application terminates So if you run the application again in the future or if you run two instances of the application simultaneously (in two different operating system processes), the JIT compiler will have to compile the IL to native instructions again.</p>
<p>For most applications, the performance hit incurred by JIT compiling isn't significant. Most applications tend to call the same methods over and over again These methods will take the performance hit only once while the application executes. It's also likely that more time is spent inside the method than calling the method.</p>
<img src="7.jpg"/>
<p>You should also be aware that the CLR's JIT compiler optimizes the native code just as the back end of an unmanaged C++ compiler does. Again, it may take more time to produce the optimized code, but the code will execute with much better performance than if it hadn't been optimized.</p>
<p>There are two C# compiler switches that impact code optimization: <b>/optimize </b>and <b>/debug. </b>The following table shows the impact these switches have on the quality of the IL code generated by the C# compiler and the quality of the native code generated by the JIT compiler:</p>
<table border="1">
<tr>
<td>
<p>s</p>
</td>
<td>
<p><b>C# IL Code Quality</b></p>
</td>
<td>
<p>y</p>
</td>
</tr>
<tr>
<td>
<p><b>/optimize- /debug-</b></p>
</td>
<td>
<p>Unoptimized</p>
</td>
<td>
<p>Optimized</p>
</td>
</tr>
<tr>
<td>
<p>(this is the default)</p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>/optimize- /debug(+/full/pdbonly)</b></p>
</td>
<td>
<p>Unoptimized</p>
</td>
<td>
<p>Unoptimized</p>
</td>
</tr>
<tr>
<td>
<p><b>/optimize+ /debug(-/+/full/pdbonly)</b></p>
</td>
<td>
<p>Optimized</p>
</td>
<td>
<p>Optimized</p>
</td>
</tr>
</table>
<p>With <b>/optimize-, </b>the unoptimized IL code produced by the C# compiler contains many no-operation (NOP) instructions and also branches that jump to the next line of code. These instructions are emitted to enable the edit-and-continue feature of Visual Studio while debugging and the extra instructions also make code easier to debug by allowing breakpoints to be set on control flow instructions such as <b>for, while, do, if, else, try, catch, </b>and <b>finally </b>statement blocks When producing optimized IL code, the C# compiler will remove these extraneous NOP and branch instructions, making the code harder to single-step through in a debugger as control flow will be optimized. Also, some function evaluations may not work when performed inside the debugger. However, the IL code is smaller, making the resulting EXE/DLL file smaller, and the IL tends to be easier to read for those of you (like me) who enjoy examining the IL to understand what the compiler is producing.</p>
<p>Furthermore, the compiler produces a Program Database (PDB) file only if you specify the <b>/debug(+/full/pdbonly) </b>switch. The PDB file helps the debugger find local variables and map the IL instructions to source code. The <b>/debug:full </b>switch tells the JIT compiler that you intend to debug the assembly, and the JIT compiler will track what native code came from each IL instruction. This allows you to use the just-in-time debugger feature of Visual Studio to connect a debugger to an already-running process and debug the code easily Without the <b>/debug:full </b>switch, the JIT compiler does not, by default, track the IL to native code information which makes the JIT compiler run a little faster and also uses a little less memory. If you start a process with the Visual Studio debugger, it forces the JIT compiler to track the IL to native code information (regardless of the <b>/debug </b>switch) unless you turn off the Suppress JIT Optimization On Module Load (Managed Only) option in Visual Studio.</p>
<p>When you create a new C# project in Visual Studio, the Debug configuration of the project has <b>/optimize- </b>and <b>/debug:full </b>switches, and the Release configuration has <b>/optimize+ </b>and <b>/debug:pdbonly </b>switches specified.</p>
<p>For those developers coming from an unmanaged C or C++ background, you're probably thinking about the performance ramifications of all this. After all, unmanaged code is compiled for a specific CPU platform, and, when invoked, the code can simply execute. In this managed environment, compiling the code is accomplished in two phases First, the compiler passes over the source code, doing as much work as possible in producing IL But to execute the code, the IL itself must be compiled into native CPU instructions at runtime, requiring more memory to be allocated and requiring additional CPU time to do the work.</p>
<p>Believe me, since I approached the CLR from a C/C++ background myself, I was quite skeptical and concerned about this additional overhead The truth is that this second compilation stage that occurs at runtime does hurt performance, and it does allocate dynamic memory However, Microsoft has done a lot of performance work to keep this additional overhead to a minimum.</p>
<p>If you too are skeptical, you should certainly build some applications and test the performance for yourself. In addition, you should run some nontrivial managed applications Microsoft or others have produced, and measure their performance. I think you'll be surprised at how good the performance actually is.</p>
<p>You'll probably find this hard to believe, but many people (including me) think that managed applications could actually outperform unmanaged applications. There are many reasons to believe this. For example, when the JIT compiler compiles the IL code into native code at runtime, the compiler knows more about the execution environment than an unmanaged compiler would know. Here are some ways that managed code can outperform unmanaged code:</p>
<p>&#9632; A JIT compiler can determine if the application is running on an Intel Pentium 4 CPU and produce native code that takes advantage of any special instructions offered by the Pentium 4. Usually, unmanaged applications are compiled for the lowest-common-denominator CPU and avoid using special instructions that would give the application a performance boost.</p>
<p>&#9632; A JIT compiler can determine when a certain test is always false on the machine that it is running on. For example, consider a method that contains the following code:</p>
<p><code>if (numberOfCPUs &gt; 1) {<br/>
}</code></p>
<p>This code could cause the JIT compiler to not generate any CPU instructions if the host machine has only one CPU. In this case, the native code would be fine-tuned for the host machine; the resulting code is smaller and executes faster.</p>
<p>&#9632; The CLR could profile the code's execution and recompile the IL into native code while the application runs The recompiled code could be reorganized to reduce incorrect branch predictions depending on the observed execution patterns Current versions of the CLR do not do this, but future versions might.</p>
<p>These are only a few of the reasons why you should expect future managed code to execute better than today's unmanaged code. As I said, the performance is currently quite good for most applications, and it promises to improve as time goes on.</p>
<p>If your experiments show that the CLR's JIT compiler doesn't offer your application the kind of performance it requires, you may want to take advantage of the NGen.exe tool that ships with the .NET Framework SDK. This tool compiles all of an assembly's IL code into native code and saves the resulting native code to a file on disk. At runtime, when an assembly is loaded, the CLR automatically checks to see whether a precompiled version of the assembly also exists, and if it does, the CLR loads the precompiled code so that no compilation is required at runtime. Note that NGen.exe must be conservative about the assumptions it makes regarding the actual execution environment, and for this reason, the code produced by NGen.exe will not be as highly optimized as the JIT compiler-produced code. I'll discuss NGen.exe in more detail later in this chapter.</p>
<h3>IL and Verification</h3>
<p>IL is stack-based, which means that all of its instructions push operands onto an execution stack and pop results off the stack Because IL offers no instructions to manipulate registers, it is easy for people to create new languages and compilers that produce code targeting the CLR.</p>
<p>IL instructions are also typeless For example, IL offers an <b>add </b>instruction that adds the last two operands pushed on the stack. There are no separate 32-bit and 64-bit versions of the <b>add </b>instruction When the <b>add </b>instruction executes, it determines the types of the operands on the stack and performs the appropriate operation.</p>
<p>In my opinion, the biggest benefit of IL isn't that it abstracts away the underlying CPU. The biggest benefit IL provides is application robustness and security. While compiling IL into native CPU instructions, the CLR performs a process called verification. Verification examines the high-level IL code and ensures that everything the code does is safe. For example, verification checks that every method is called with the correct number of parameters, that each parameter passed to every method is of the correct type, that every method's return value is used properly, that every method has a return statement, and so on. The managed module's metadata includes all of the method and type information used by the verification process.</p>
<p>In Windows, each process has its own virtual address space Separate address spaces are necessary because you can't trust an application's code. It is entirely possible (and unfortunately, all too common) that an application will read from or write to an invalid memory address. By placing each Windows process in a separate address space, you gain robustness and stability; one process can't adversely affect another process.</p>
<p>By verifying the managed code, however, you know that the code doesn't improperly access memory and can't adversely affect another application's code. This means that you can run multiple managed applications in a single Windows virtual address space.</p>
<p>Because Windows processes require a lot of operating system resources, having many of them can hurt performance and limit available resources Reducing the number of processes by running multiple applications in a single OS process can improve performance, require fewer resources, and be just as robust as if each application had its own process. This is another benefit of managed code as compared to unmanaged code.</p>
<p>The CLR does, in fact, offer the ability to execute multiple managed applications in a single OS process. Each managed application executes in an AppDomain. By default, every managed EXE file will run in its own separate address space that has just the one AppDomain. However, a process hosting the CLR (such as Internet Information Services [IIS] or Microsoft SQL Server) can decide to run AppDomains in a single OS process. I'll devote part of Chapter 22, &quot;CLR Hosting and AppDomains,&quot; to a discussion of AppDomains.</p>
<h3>Unsafe Code</h3>
<p>By default, Microsoft's C# compiler produces safe code. Safe code is code that is verifiably safe. However, Microsoft's C# compiler allows developers to write unsafe code. Unsafe code is allowed to work directly with memory addresses and can manipulate bytes at these addresses. This is a very powerful feature and is typically useful when interoperating with unmanaged code or when you want to improve the performance of a time-critical algorithm.</p>
<p>However, using unsafe code introduces a significant risk: unsafe code can corrupt data structures and exploit or even open up security vulnerabilities. For this reason, the C# compiler requires that all methods that contain unsafe code be marked with the <b>unsafe </b>keyword. In addition, the C# compiler requires you to compile the source code by using the <b>/unsafe </b>compiler switch.</p>
<p>When the JIT compiler attempts to compile an unsafe method, it checks to see if the assembly containing the method has been granted the <b>System.Security.Permissions.Security Permission </b>with the <b>System.Security.Permissions.SecurityPermissionFlag</b>'s <b>SkipVerification </b>flag set. If this flag is set, the JIT compiler will compile the unsafe code and allow it to execute The CLR is trusting this code and is hoping the direct address and byte manipulations do not cause any harm. If the flag is not set, the JIT compiler throws either a <b>System.InvalidProgramException </b>or a <b>System.Security.VerificationException, </b>preventing the method from executing. In fact, the whole application will probably terminate at this point, but at least no harm can be done.</p>
<hr/>
<blockquote><b>Note </b>By default, assemblies that load from the local machine or via network shares are granted full trust, meaning that they can do anything, which includes executing unsafe code. However, by default, assemblies executed via the Internet are not granted the permission to execute unsafe code If they contain unsafe code, one of the aforementioned exceptions is thrown An administrator/end user can change these defaults; however, the administrator is taking full responsibility for the code's behavior.</blockquote>
<hr/>
<p>Microsoft supplies a utility called PEVerify.exe, which examines all of an assembly's methods and notifies you of any methods that contain unsafe code. You may want to consider running PEVerify.exe on assemblies that you are referencing; this will let you know if there may be problems running your application via the intranet or Internet.</p>
<p>You should be aware that verification requires access to the metadata contained in any dependent assemblies. So when you use PEVerify to check an assembly, it must be able to locate and load all referenced assemblies. Because PEVerify uses the CLR to locate the dependent assemblies, the assemblies are located using the same binding and probing rules that would normally be used when executing the assembly. I'll discuss these binding and probing rules in Chapter 2 and Chapter 3, &quot;Shared Assemblies and Strongly Named Assemblies&quot;.</p>
<p><b>IL and Protecting Your Intellectual Property</b></p>
<p>Some people are concerned that IL doesn't offer enough intellectual property protection for their algorithms. In other words, they think that you could build a managed module and that someone else could use a tool, such as an IL Disassembler, to easily reverse engineer exactly what your application's code does.</p>
<p>Yes, it's true that IL code is higher-level than most other assembly languages, and, in general, reverse engineering IL code is relatively simple. However, when implementing server-side code (such as a Web service, Web form, or stored procedure), your assembly resides on your server. Because no one outside of your company can access the assembly, no one outside of your company can use any tool to see the IL遥our intellectual property is completely safe.</p>
<p>If you're concerned about any of the assemblies you do distribute, you can obtain an obfuscator utility from a third-party vendor. These utilities scramble the names of all of the private symbols in your assembly's metadata. It will be difficult for someone to unscramble the names and understand the purpose of each method. Note that these obfuscators can provide only a little protection because the IL must be available at some point for the CLR to JIT compile it.</p>
<p>If you don't feel that an obfuscator offers the kind of intellectual property protection you desire, you can consider implementing your more sensitive algorithms in some un-managed module that will contain native CPU instructions instead of IL and metadata. Then you can use the CLR's interoperability features (assuming that you have ample permissions) to communicate between the managed and unmanaged portions of your application Of course, this assumes that you're not worried about people reverse engineering the native CPU instructions in your unmanaged code.</p>
<a name="b18"/><h2>The Native Code Generator Tool: NGen.exe</h2>
<p>The NGen.exe tool that ships with the .NET Framework can be used to compile IL code to native code when an application is installed on a user's machine Since the code is compiled at install time, the CLR's JIT compiler does not have to compile the IL code at runtime, and this can improve the application's performance The NGen exe tool is interesting in two scenarios:</p>
<p><b>&#9632; Improving an application's startup time </b>Running NGen.exe can improve startup time because the code will already be compiled into native code so that compilation doesn't have to occur at runtime.</p>
<p><b>&#9632; Reducing an application's working set   </b>If you believe that an assembly will be loaded into multiple processes simultaneously, running NGen.exe on that assembly can reduce the applications' working set. The reason is because the NGen.exe tool compiles the IL to native code and saves the output in a separate file. This file can be memory-mapped into multiple-process address spaces simultaneously, allowing the code to be shared; not every process needs its own copy of the code.</p>
<p>When a setup program invokes NGen.exe on an application or a single assembly, all of the assemblies for that application or the one specified assembly have their IL code compiled into native code. A new assembly file containing only this native code instead of IL code is created by NGen.exe. This new file is placed in a folder under the directory with a name like <span>C:\Windows\Assembly\NativeImages_v4</span>. 0.##### 64. The directory name includes the version of the CLR and information denoting whether the native code is compiled for x86 (32-bit version of Windows), x64, or Itanium (the latter two for 64-bit versions of Windows).</p>
<p>Now, whenever the CLR loads an assembly file, the CLR looks to see if a corresponding NGen'd native file exists. If a native file cannot be found, the CLR JIT compiles the IL code as usual. However, if a corresponding native file does exist, the CLR will use the compiled code contained in the native file, and the file's methods will not have to be compiled at runtime.</p>
<p>On the surface, this sounds great! It sounds as if you get all of the benefits of managed code (garbage collection, verification, type safety, and so on) without all of the performance problems of managed code (JIT compilation). However, the reality of the situation is not as rosy as it would first seem. There are several potential problems with respect to NGen'd files:</p>
<p><b>&#9632; No intellectual property protection   </b>Many people believe that it might be possible to ship NGen'd files without shipping the files containing the original IL code, thereby keeping their intellectual property a secret. Unfortunately, this is not possible. At runtime, the CLR requires access to the assembly's metadata (for functions such as reflection and serialization); this requires that the assemblies that contain IL and metadata be shipped. In addition, if the CLR can't use the NGen'd file for some reason (described below), the CLR gracefully goes back to JIT compiling the assembly's IL code, which must be available.</p>
<p><b>&#9632; NGen'd files can get out of sync   </b>When the CLR loads an NGen'd file, it compares a number of characteristics about the previously compiled code and the current execution environment. If any of the characteristics don't match, the NGen'd file cannot be used, and the normal JIT compiler process is used instead. Here is a partial list of characteristics that must match:</p>
<p><b>&#9632; </b>CLR version: this changes with patches or service packs</p>
<p><b>&#9632; </b>CPU type: this changes if you upgrade your processor hardware</p>
<p><b>&#9632; </b>Windows OS version: this changes with a new service pack update</p>
<p><b>&#9632; </b>Assembly's identity module version ID (MVID): this changes when recompiling</p>
<p><b>&#9632; </b>Referenced assembly's version IDs: this changes when you recompile a referenced assembly</p>
<p><b>&#9632;</b>Security: this changes when you revoke permissions (such as declarative inheritance, declarative link-time, <b>SkipVerification, </b>or <b>UnmanagedCode </b>permissions), that were once granted</p>
<p>Note that it is possible to run NGen exe in update mode This tells the tool to run NGen.exe on all of the assemblies that had previously been NGen'd. Whenever an end user installs a new service pack of the .NET Framework, the service pack's installation program will run NGen.exe in update mode automatically so that NGen'd files are kept in sync with the version of the CLR installed.</p>
<p><b>&#9632; Inferior execution-time performance   </b>When compiling code, NGen can't make as many assumptions about the execution environment as the JIT compiler can. This causes NGen.exe to produce inferior code. For example, NGen won't optimize the use of certain CPU instructions; it adds indirections for static field access because the actual address of the static fields isn't known until runtime. NGen inserts code to call class constructors everywhere because it doesn't know the order in which the code will execute and if a class constructor has already been called. (See Chapter 8, &quot;Methods,&quot; for more about class constructors.) Some NGen'd applications actually perform about</p>
<p>5 percent slower when compared to their JIT-compiled counterpart. So, if you're considering using NGen.exe to improve the performance of your application, you should compare NGen'd and non-NGen'd versions to be sure that the NGen'd version doesn't actually run slower! For some applications, the reduction in working set size improves performance, so using NGen can be a net win.</p>
<p>Due to all of the issues just listed, you should be very cautious when considering the use of NGen.exe. For server-side applications, NGen.exe makes little or no sense because only the first client request experiences a performance hit; future client requests run at high speed. In addition, for most server applications, only one instance of the code is required, so there is no working set benefit. Also, note that NGen'd images cannot be shared across AppDomains, so there is no benefit to NGen'ing an assembly that will be used in a cross-AppDomain scenario (such as ASP.NET).</p>
<p>For client applications, NGen.exe might make sense to improve startup time or to reduce working set if an assembly is used by multiple applications simultaneously. Even in a case in which an assembly is not used by multiple applications, NGen'ing an assembly could improve working set. Moreover, if NGen.exe is used for all of a client application's assemblies, the CLR will not need to load the JIT compiler at all, reducing working set even further. Of course, if just one assembly isn't NGen'd or if an assembly's NGen'd file can't be used, the JIT compiler will load, and the application's working set increases.</p>
<a name="b20"/><h2>The Framework Class Library</h2>
<p>The .NET Framework includes the Framework Class Library (FCL). The FCL is a set of DLL assemblies that contain several thousand type definitions in which each type exposes some functionality Microsoft is producing additional libraries such as the Windows SideShow Managed API SDK<sup>2</sup> and the DirectX SDK. These additional libraries provide even more types, exposing even more functionality for your use. In fact, Microsoft is producing many libraries at a phenomenal rate, making it easier than ever for developers to use various Microsoft technologies.</p>
<p>Here are just some of the kinds of applications developers can create by using these assemblies:</p>
<p><b>&#9632; Web services   </b>Methods that can process messages sent over the Internet very easily using Microsoft's ASP.NET XML Web Service technology or Microsoft's Windows Communication Foundation (WCF) technology.</p>
<p><b>&#9632; Web Forms HTML-based applications (Web sites)   </b>Typically, ASP.NET Web Forms applications will make database queries and Web service calls, combine and filter the returned information, and then present that information in a browser by using a rich HTML-based user interface.</p>
<p><b>&#9632; Rich Windows GUI applications   </b>Instead of using a Web Forms page to create your application's UI, you can use the more powerful, higher-performance functionality offered by the Windows desktop via Microsoft's Windows Forms technology or Windows Presentation Foundation (WPF) technology GUI applications can take advantage of controls, menus, and mouse and keyboard events, and they can exchange information directly with the underlying operating system Windows Forms applications can also make database queries and consume Web services.</p>
<p><b>&#9632; Rich Internet Applications (RIAs)   </b>Using Microsoft's Silverlight technology, you can build rich GUI applications that are deployed via the Internet These applications can run inside or outside of a Web browser. They also run on non-Windows operating systems, and on mobile devices.</p>
<p>Incidentally, I personally was contracted by Microsoft to develop this SDK.</p>
<p><b>&#9632; Windows console applications   </b>For applications with very simple UI demands, a console application provides a quick and easy way to build an application. Compilers, utilities, and tools are typically implemented as console applications.</p>
<p><b>&#9632; Windows services  </b>Yes, it is possible to build service applications that are controllable via the Windows Service Control Manager (SCM) by using the .NET Framework.</p>
<p><b>&#9632; Database stored procedures   </b>Microsoft's SQL Server, IBM's DB2, and Oracle's database servers allow developers to write their stored procedures using the NET Framework.</p>
<p><b>&#9632; Component library  </b>The .NET Framework allows you to build stand-alone assemblies (components) containing types that can be easily incorporated into any of the previously mentioned application types.</p>
<p>Because the FCL contains literally thousands of types, a set of related types is presented to the developer within a single namespace. For example, the <b>System </b>namespace (which you should become most familiar with) contains the <b>Object </b>base type, from which all other types ultimately derive. In addition, the <b>System </b>namespace contains types for integers, characters, strings, exception handling, and console I/O as well as a bunch of utility types that convert safely between data types, format data types, generate random numbers, and perform various math functions All applications will use types from the <b>System </b>namespace.</p>
<p>To access any of the framework's features, you need to know which namespace contains the types that expose the facilities you're after. A lot of types allow you to customize their behavior; you do so by simply deriving your own type from the desired FCL type. The object-oriented nature of the platform is how the .NET Framework presents a consistent programming paradigm to software developers. Also, developers can easily create their own namespaces containing their own types. These namespaces and types merge seamlessly into the programming paradigm. Compared to Win32 programming paradigms, this new approach greatly simplifies software development.</p>
<p>Most of the namespaces in the FCL present types that can be used for any kind of application. Table 1-3 lists some of the more general namespaces and briefly describes what the types in that namespace are used for. This is a very small sampling of the namespaces available Please see the documentation that accompanies the various Microsoft SDKs to gain familiarity with the ever-growing set of namespaces that Microsoft is producing.</p>
<p><b>Table 1-3 </b><b>Some General FCL Namespaces</b></p>
<table border="1">
<tr>
<td>
<p>Namespacee</p>
</td>
<td>
<p>Description of Contents</p>
</td>
</tr>
<tr>
<td>
<p><b>System</b></p>
</td>
<td>
<p>All of the basic types used by every application</p>
</td>
</tr>
<tr>
<td>
<p><b>System.Data</b></p>
</td>
<td>
<p>Types for communicating with a database and processing data</p>
</td>
</tr>
<tr>
<td>
<p><b>System.IO</b></p>
</td>
<td>
<p>Types for doing stream I/O and walking directories and files</p>
</td>
</tr>
<tr>
<td>
<p><b>System.Net</b></p>
</td>
<td>
<p>Types that allow for low-level network communications and working with some common Internet protocols.</p>
</td>
</tr>
<tr>
<td>
<p><b>System.Runtime.InteropServices</b></p>
</td>
<td>
<p>Types that allow managed code to access unmanaged OS platform facilities such as COM components and functions in Win32 or custom DLLs</p>
</td>
</tr>
<tr>
<td>
<p><b>System.Security</b></p>
</td>
<td>
<p>Types used for protecting data and resources</p>
</td>
</tr>
<tr>
<td>
<p><b>System.Text</b></p>
</td>
<td>
<p>Types to work with text in different encodings, such as ASCII and Unicode</p>
</td>
</tr>
<tr>
<td>
<p><b>System.Threading</b></p>
</td>
<td>
<p>Types used for asynchronous operations and synchronizing access to resources</p>
</td>
</tr>
<tr>
<td>
<p><b>System.Xml</b></p>
</td>
<td>
<p>Types used for processing Extensible Markup Language (XML) schemas and data</p>
</td>
</tr>
</table>
<p>This book is about the CLR and about the general types that interact closely with the CLR. So the content of this book is applicable to all programmers writing applications or components that target the CLR. Many other good books exist that cover specific application types such as Web Services, Web Forms, Windows Forms, etc. These other books will give you an excellent start at helping you build your application. I tend to think of these application-specific books as helping you learn from the top down because they concentrate on the application type and not on the development platform. In this book, I'll offer information that will help you learn from the bottom up. After reading this book and an application-specific book, you should be able to easily and proficiently build any kind of application you desire.</p>
<a name="b22"/><h2>The Common Type System</h2>
<p>By now, it should be obvious to you that the CLR is all about types Types expose functionality to your applications and other types. Types are the mechanism by which code written in one programming language can talk to code written in a different programming language Because types are at the root of the CLR, Microsoft created a formal specification葉he Common Type System (CTS)葉hat describes how types are defined and how they behave.</p>
<hr/>
<blockquote><b>Note </b>In fact, Microsoft has been submitting the CTS as well as other parts of the .NET i        Framework, including file formats, metadata, IL, and access to the underlying platform (P/lnvoke) to ECMA for the purpose of standardization The standard is called the Common Language Infrastructure (CLI) and is the ECMA-335 specification. In addition, Microsoft has also submitted portions of the FCL, the C# programming language (ECMA-334), and the C++/CLI programming language For information about these industry standards, please go to the ECMA Web site that pertains to Technical Committee 39: <a href="http://www.ecma-international.org/">www.ecma-international.org/</a>. You can also refer to Microsoft's own Web site: <a href="http://msdn.microsoft.com/en-us/netframework/aa569283.aspx">http://msdn.microsoft.com/en-us/netframework/aa569283.aspx</a>. In addition, Microsoft has applied their Community Promise to the ECMA-334 and ECMA-335 specifications. For more information about this, see <a href="http://www.microsoft.com/interop/cp/default.mspx">http://www.microsoft.com/interop/cp/default.mspx</a>.</blockquote>
<hr/>
<p>The CTS specification states that a type can contain zero or more members. In Part II, &quot;Designing Types,&quot; I'll cover all of these members in great detail. For now, I want just to give you a brief introduction to them:</p>
<p><b>&#9632; Field </b>A data variable that is part of the object's state. Fields are identified by their name and type.</p>
<p><b>&#9632; Method   </b>A function that performs an operation on the object, often changing the object's state. Methods have a name, a signature, and modifiers. The signature specifies the number of parameters (and their sequence), the types of the parameters, whether</p>
<p>a value is returned by the method, and if so, the type of the value returned by the method.</p>
<p><b>&#9632; Property  </b>To the caller, this member looks like a field. But to the type implementer, it looks like a method (or two). Properties allow an implementer to validate input parameters and object state before accessing the value and/or calculating a value only when necessary. They also allow a user of the type to have simplified syntax. Finally, properties allow you to create read-only or write-only &quot;fields.&quot;</p>
<p><b>&#9632; Event   </b>An event allows a notification mechanism between an object and other interested objects. For example, a button could offer an event that notifies other objects when the button is clicked.</p>
<p>The CTS also specifies the rules for type visibility and access to the members of a type. For example, marking a type as public (called <b>public) </b>exports the type, making it visible and accessible to any assembly. On the other hand, marking a type as assembly (called <b>internal </b>in C#) makes the type visible and accessible to code within the same assembly only. Thus, the CTS establishes the rules by which assemblies form a boundary of visibility for a type, and the CLR enforces the visibility rules.</p>
<p>A type that is visible to a caller can further restrict the ability of the caller to access the type's members. The following list shows the valid options for controlling access to a member:</p>
<p><b>&#9632; Private   </b>The member is accessible only by other members in the same class type.</p>
<p><b>&#9632; Family </b>The member is accessible by derived types, regardless of whether they are within the same assembly. Note that many languages (such as C++ and C#) refer to family as <b>protected.</b></p>
<p><b>&#9632; Family and assembly  </b>The member is accessible by derived types, but only if the derived type is defined in the same assembly. Many languages (such as C# and Visual Basic) don't offer this access control. Of course, IL Assembly language makes it available.</p>
<p><b>&#9632; Assembly  </b>The member is accessible by any code in the same assembly. Many languages refer to assembly as <b>internal </b>.</p>
<p>&#9632; <b>Family or assembly  </b>The member is accessible by derived types in any assembly. The member is also accessible by any types in the same assembly. C# refers to family or assembly as <b>protected internal.</b></p>
<p>&#9632; <b>Public   </b>The member is accessible by any code in any assembly.</p>
<p>In addition, the CTS defines the rules governing type inheritance, virtual methods, object lifetime, and so on These rules have been designed to accommodate the semantics expressible in modern-day programming languages. In fact, you won't even need to learn the CTS rules per se because the language you choose will expose its own language syntax and type rules in the same way that you're familiar with today. And it will map the language-specific syntax into IL, the &quot;language&quot; of the CLR, when it emits the assembly during compilation.</p>
<p>When I first started working with the CLR, I soon realized that it is best to think of the language and the behavior of your code as two separate and distinct things Using C++, you can define your own types with their own members. Of course, you could have used C# or Visual Basic to define the same type with the same members. Sure, the syntax you use for defining the type is different depending on the language you choose, but the behavior of the type will be identical regardless of the language because the CLR's CTS defines the behavior of the type.</p>
<p>To help clarify this idea, let me give you an example. The CTS allows a type to derive from only one base class. So, while the C++ language supports types that can inherit from multiple base types, the CTS can't accept and operate on any such type. To help the developer, Microsoft's C++/CLI compiler reports an error if it detects that you're attempting to create managed code that includes a type deriving from multiple base types.</p>
<p>Here's another CTS rule. All types must (ultimately) inherit from a predefined type: <b>System.Object. </b>As you can see, <b>Object </b>is the name of a type defined in the <b>System </b>namespace. This <b>Object </b>is the root of all other types and therefore guarantees that every type instance has a minimum set of behaviors. Specifically, the <b>System.Object </b>type allows you to do the following:</p>
<p>&#9632; Compare two instances for equality.</p>
<p>&#9632; Obtain a hash code for the instance.</p>
<p>&#9632; Query the true type of an instance.</p>
<p>&#9632; Perform a shallow (bitwise) copy of the instance.</p>
<p>&#9632; Obtain a string representation of the instance object's current state.</p>
<a name="b25"/><h2>The Common Language Specification</h2>
<p>COM allows objects created in different languages to communicate with one another On the other hand, the CLR now integrates all languages and allows objects created in one language to be treated as equal citizens by code written in a completely different language. This integration is possible because of the CLR's standard set of types, metadata (self-describing type information), and common execution environment.</p>
<p>While this language integration is a fantastic goal, the truth of the matter is that programming languages are very different from one another For example, some languages don't treat symbols with case-sensitivity, and some don't offer unsigned integers, operator overloading, or methods to support a variable number of arguments.</p>
<p>If you intend to create types that are easily accessible from other programming languages, you need to use only features of your programming language that are guaranteed to be available in all other languages. To help you with this, Microsoft has defined a Common Language Specification (CLS) that details for compiler vendors the minimum set of features their compilers must support if these compilers are to generate types compatible with other components written by other CLS-compliant languages on top of the CLR.</p>
<p>The CLR/CTS supports a lot more features than the subset defined by the CLS, so if you don't care about interlanguage operability, you can develop very rich types limited only by the language's feature set. Specifically, the CLS defines rules that externally visible types and methods must adhere to if they are to be accessible from any CLS-compliant programming language. Note that the CLS rules don't apply to code that is accessible only within the defining assembly. Figure 1-6 summarizes the ideas expressed in this paragraph.</p>
<img src="8.jpg"/>
<p><b>Figure 1-6 </b>Languages offer a subset of the CLR/CTS</p>
<p>and a superset of the CLS (but not necessarily the same superset)</p>
<p>As Figure 1-6 shows, the CLR/CTS offers a set of features Some languages expose a large subset of the CLR/CTS. A programmer willing to write in IL assembly language, for example, is able to use all of the features the CLR/CTS offers. Most other languages, such as C#, Visual Basic, and Fortran, expose a subset of the CLR/CTS features to the programmer The CLS defines the minimum set of features that all languages must support.</p>
<p>If you're designing a type in one language, and you expect that type to be used by another language, you shouldn't take advantage of any features that are outside of the CLS in its public and protected members. Doing so would mean that your type's members might not be accessible by programmers writing code in other programming languages.</p>
<p>In the following code, a CLS-compliant type is being defined in C#. However, the type has a few non-CLS-compliant constructs causing the C# compiler to complain about the code.</p>
<p><code>using System;<br/>
// Tell compiler to check for CLS compliance [assembly: CLSCompliant(true)]<br/>
namespace SomeLibrary {<br/>
// Warnings appear because the class is public public sealed class SomeLibraryType {<br/>
// Warning: Return type of 'SomeLibrary.SomeLibraryType.Abc()' // is not CLS-compliant public UInt32 Abc() { return 0; }<br/>
// Warning: Identifier 'SomeLibrary.SomeLibraryType.abc()' // differing only in case is not CLS-compliant public void abc() { }<br/>
// No warning: this method is private private UInt32 ABC() { return 0; }<br/>
}<br/>
}</code></p>
<p>In this code, the <b>[assembly:CLSCompliant(true)] </b>attribute is applied to the assembly. This attribute tells the compiler to ensure that any publicly exposed type doesn't have any construct that would prevent the type from being accessed from any other programming language. When this code is compiled, the C# compiler emits two warnings. The first warning is reported because the method <b>Abc </b>returns an unsigned integer; some other programming languages can't manipulate unsigned integer values. The second warning is because this type exposes two public methods that differ only by case and return type: <b>Abc </b>and <b>abc </b>. Visual Basic and some other languages can't call both of these methods.</p>
<p>Interestingly, if you were to delete <b>public </b>from in front of <b>'sealed class SomeLibraryType' </b>and recompile, both warnings would go away. The reason is that the <b>SomeLibraryType </b>type would default to <b>internal </b>and would therefore no longer be exposed outside of the assembly For a complete list of CLS rules, refer to the &quot;Cross-</p>
<p>Language Interoperability&quot; section in the .NET Framework SDK documentation (<a href="http://msdn.microsoft.com/en-us/library/730flwy3.aspx">http://msdn.microsoft.com/en-us/library/730flwy3.aspx</a>).</p>
<p>Let me distill the CLS rules to something very simple. In the CLR, every member of a type is either a field (data) or a method (behavior). This means that every programming language must be able to access fields and call methods. Certain fields and certain methods are used in special and common ways. To ease programming, languages typically offer additional abstractions to make coding these common programming patterns easier. For example, languages expose concepts such as enums, arrays, properties, indexers, delegates, events, constructors, finalizers, operator overloads, conversion operators, and so on. When a compiler comes across any of these things in your source code, it must translate these constructs into fields and methods so that the CLR and any other programming language can access the construct.</p>
<p>Consider the following type definition, which contains a constructor, a finalizer, some overloaded operators, a property, an indexer, and an event. Note that the code shown is there just to make the code compile; it doesn't show the correct way to implement a type.</p>
<p><code>using System;<br/>
internal sealed class Test { // Constructor public Test() {}<br/>
// Finalizer<br/>
~Test() {}<br/>
// Operator overload<br/>
public static Boolean operator == (Test t1, Test t2) { return true;<br/>
}<br/>
public static Boolean operator != (Test t1, Test t2) { return false;<br/>
}<br/>
// An operator overload<br/>
public static Test operator + (Test t1, Test t2) { return null; }<br/>
// A property public String AProperty { get { return null; }<br/>
set { }<br/>
}<br/>
// An indexer<br/>
public String this[Int32 x] { get { return null; }<br/>
set { }<br/>
}<br/>
// An event<br/>
public event EventHandler AnEvent;<br/>
}</code></p>
<p>When the compiler compiles this code, the result is a type that has a number of fields and methods defined in it. You can easily see this by using the IL Disassembler tool (ILDasm.exe) provided with the NET Framework SDK to examine the resulting managed module, which is shown in Figure 1-7.</p>
<img src="9.jpg"/>
<p><b>Figure 1-7 </b>ILDasm showing Test type's fields and methods (obtained from metadata)</p>
<p>Table 1-4 shows how the programming language constructs got mapped to the equivalent CLR fields and methods.</p>
<p><b>Table 1-4 </b><b>Test Type's Fields and Methods (Obtained from Metadata)</b></p>
<table border="1">
<tr>
<td>
<p>r</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>t</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>Field</p>
</td>
<td>
<p>Event; the name of the field is <b>AnEvent </b>and its type is <b>System.EventHandler </b>.</p>
</td>
</tr>
<tr>
<td>
<p><b>.ctor</b></p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Constructor.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Finalizer.</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p><b>Event add accessor </b>method.</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p><b>Property get accessor </b>method.</p>
</td>
</tr>
<tr>
<td>
<p>m</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p><b>Indexer get accessor </b>method.</p>
</td>
</tr>
<tr>
<td>
<p>n</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p><b>+ </b>operator.</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p><b>== </b>operator.</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p><b>!= </b>operator.</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p><b>Event remove accessor </b>method.</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p><b>Property set accessor </b>method.</p>
</td>
</tr>
<tr>
<td>
<p>m</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p><b>Indexer set accessor </b>method.</p>
</td>
</tr>
</table>
<p>The additional nodes under the <b>Test </b>type that aren't mentioned in Table 1-4<b>.class,.custom, AnEvent, AProperty, </b>and <b>Item</b>擁dentify additional metadata about the type. These nodes don't map to fields or methods; they just offer some additional information about the type that the CLR, programming languages, or tools can get access to For example, a tool can see that the <b>Test </b>type offers an event, called <b>AnEvent, </b>which is exposed via the two methods <b>(add_AnEvent </b>and <b>remove_AnEvent) </b>.</p>
<a name="b29"/><h2>Interoperability with Unmanaged Code</h2>
<p>The .NET Framework offers a ton of advantages over other development platforms. However, very few companies can afford to redesign and re-implement all of their existing code. Microsoft realizes this and has constructed the CLR so that it offers mechanisms that allow an application to consist of both managed and unmanaged parts. Specifically, the CLR supports three interoperability scenarios:</p>
<p><b>&#9632; Managed code can call an unmanaged function in a DLL   </b>Managed code can easily call functions contained in DLLs by using a mechanism called P/Invoke (for Platform Invoke). After all, many of the types defined in the FCL internally call functions exported from Kernel32.dll, User32.dll, and so on. Many programming languages will expose a mechanism that makes it easy for managed code to call out to unmanaged functions contained in DLLs For example, a C# application can call the <b>CreateSemaphore </b>function exported from Kernel32 dll.</p>
<p><b>&#9632; Managed code can use an existing COM component (server)   </b>Many companies have already implemented a number of unmanaged COM components. Using the type library from these components, a managed assembly can be created that describes the COM component. Managed code can access the type in the managed assembly just as any other managed type. See the TlbImp.exe tool that ships with the .NET Framework SDK for more information. At times, you might not have a type library or you might want to have more control over what TlbImp.exe produces. In these cases, you can manually build a type in source code that the CLR can use to achieve the proper interoperability For example, you could use DirectX COM components from a C# application.</p>
<p><b>&#9632; Unmanaged code can use a managed type (server)   </b>A lot of existing unmanaged code requires that you supply a COM component for the code to work correctly. It's much easier to implement these components by using managed code so that you can avoid all of the code having to do with reference counting and interfaces For example, you could create an ActiveX control or a shell extension in C# See the TlbExp exe and RegAsm.exe tools that ship with the .NET Framework SDK for more information.</p>
<hr/>
<blockquote><b>Note </b>Microsoft now makes available the source code for the Type Library Importer tool and a P/Invoke Interop Assistant tool to help developers needing to interact with native code. These tools and their source code can be downloaded from <a href="http://CLRInterop.CodePlex.com/">http://CLRInterop.CodePlex.com/</a>.</blockquote>
<hr/>
<mbp:pagebreak/>
<a name="Chapter2"/>
<h1>Chapter 2: Building, Packaging, Deploying, and Administering Applications and Types</h1>
<p><b>In this chapter:</b></p>
<a href="#b32">.NET Framework Deployment Goals</a><br/>
<a href="#b43">Combining Modules to Form an Assembly</a><br/>
<a href="#b53">Assembly Version Resource Information</a><br/>
<a href="#b59">Simple Application Deployment (Privately Deployed Assemblies)</a><br/>
<a href="#b61">Simple Administrative Control (Configuration)</a><br/>
<p>Before we get into the chapters that explain how to develop programs for the Microsoft .NET Framework, let's discuss the steps required to build, package, and deploy your applications and their types. In this chapter, I'll focus on the basics of how to build assemblies that are for your application's sole use. In Chapter 3, &quot;Shared Assemblies and Strongly Named Assemblies,&quot; I'll cover the more advanced concepts you'll need to understand, including how to build and use assemblies containing types that will be shared by multiple applications. In both chapters, I'll also talk about the ways an administrator can affect the execution of an application and its types.</p>
<p>Today, applications consist of several types, which are typically created by you and Microsoft. In addition, there are many component vendors creating and selling types that other companies can use to reduce a software project's development time. If these types are developed using any language that targets the common language runtime (CLR), they can all work together seamlessly; a type written in one language can use another type as its base class without concern for the language the base type was developed in.</p>
<p>In this chapter, I'll also explain how these types are built and packaged into files for deployment. In the process, I'll take you on a brief historical tour of some of the problems that the .NET Framework is solving.</p>
<a name="b32"/><h2>.NET Framework Deployment Goals</h2>
<p>Over the years, Microsoft Windows has gotten a reputation for being unstable and complicated. This reputation, whether deserved or not, is the result of many different factors. First, all applications use dynamic-link libraries (DLLs) from Microsoft or other vendors Because an application executes code from various vendors, the developer of any one piece of code can't be 100 percent sure how someone else is going to use it. Although this kind of interaction can potentially cause all kinds of trouble, in practice, these problems don't typically arise because applications are tested and debugged before they are deployed.</p>
<p>Users, however, frequently run into problems when one company decides to update its code and ships new files to them. These new files are supposed to be backward-compatible with the previous files, but who knows for sure? In fact, when one vendor updates its code, it usually finds it impossible to retest and debug all of the already-shipped applications to ensure that the changes will have no undesirable effect.</p>
<p>I'm sure that everyone reading this book has experienced some variation of this problem: when installing a new application, you discover that it has somehow corrupted an already-installed application. This predicament is known as &quot;DLL hell.&quot; This type of instability puts fear into the hearts and minds of the typical computer user. The end result is that users have to carefully consider whether to install new software on their machines. Personally, I've decided not to try out certain applications out of fear that it might adversely affect some application I really rely on.</p>
<p>The second reason that contributed to the aforementioned reputation of Windows is installation complexities. Today, when most applications are installed, they affect all parts of the system. For example, installing an application causes files to be copied to various directories, updates registry settings, and installs shortcuts on your desktop and Start menu The problem with this is that the application isn't isolated as a single entity. You can't easily back up the application since you must copy the application's files and also the relevant parts of the registry. In addition, you can't easily move the application from one machine to another; you must run the installation program again so that all files and registry settings are set properly. Finally, you can't easily uninstall or remove the application without having this nasty feeling that some part of the application is still lurking on your machine.</p>
<p>The third reason has to do with security. When applications are installed, they come with all kinds of files, many of them written by different companies. In addition, Web applications frequently have code (like ActiveX controls) that is downloaded in such a way that users don't even realize that code is being installed on their machine Today, this code can perform any operation, including deleting files or sending e-mail. Users are right to be terrified of installing new applications because of the potential damage they can cause. To make users comfortable, security must be built into the system so that the users can explicitly allow or disallow code developed by various companies to access their system's resources.</p>
<p>The NET Framework addresses the DLL hell issue in a big way, as you'll see while reading this chapter and Chapter 3. It also goes a long way toward fixing the problem of having an application's state scattered all over a user's hard disk. For example, unlike COM, types no longer require settings in the registry Unfortunately, applications still require shortcut links As for security, the .NET Framework includes a security model called code access security. Whereas Windows security is based on a user's identity, code access security is based on permissions that host applications that loading components can control. A host application like Microsoft Silverlight can grant just a few permissions to downloaded code, while a locally installed (self-hosting) application could run with full trust (all permissions) As you'll see, the NET Framework enables users to control what gets installed and what runs, and in general, to control their machines, more than Windows ever did.</p>
<h2>Building Types into a Module</h2>
<p>In this section, I'll show you how to turn your source file, containing various types, into a file that can be deployed. Let's start by examining the following simple application:</p>
<p><code>public sealed class Program { public static void Main() {<br/>
System.Console.WriteLineC'Hi&quot;);<br/>
}<br/>
}</code></p>
<p>This application defines a type, called <b>Program </b>. This type has a single public, static method called <b>Main </b>. Inside <b>Main </b>is a reference to another type called <b>System.Console. System.Console </b>is a type implemented by Microsoft, and the Intermediate Language (IL) code that implements this type's methods is in the MSCorLib dll file. So our application defines a type and also uses another company's type.</p>
<p>To build this sample application, put the preceding code into a source code file, say, Program cs, and then execute the following command line:</p>
<p><code>csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs</code></p>
<p>This command line tells the C# compiler to emit an executable file called Program.exe <b>(/out:Program.exe) </b>. The type of file produced is a Win32 console application <b>(/t[arget]:exe) </b>.</p>
<p>When the C# compiler processes the source file, it sees that the code references the <b>System.Console </b>type's <b>WriteLine </b>method. At this point, the compiler wants to ensure that this type exists somewhere, that it has a <b>WriteLine </b>method, and that the argument being passed to this method matches the parameter the method expects Since this type is not defined in the C# source code, to make the C# compiler happy, you must give it a set of assemblies that it can use to resolve references to external types In the command line above,</p>
<p>I've included the <b>/r[eference]:MSCorLib.dll </b>switch, which tells the compiler to look for external types in the assembly identified by the MSCorLib.dll file.</p>
<p>MSCorLib.dll is a special file in that it contains all the core types: <b>Byte, Char, String, Int32, </b>and many more. In fact, these types are so frequently used that the C# compiler automatically references the MSCorLib.dll assembly. In other words, the following command line (with the <b>/r </b>switch omitted) gives the same results as the line shown earlier:</p>
<p><code>csc.exe /out:Program.exe /t:exe Program.cs</code></p>
<p>Furthermore, because the <b>/out:Program.exe </b>and the <b>/t:exe </b>command-line switches also match what the C# compiler would choose as defaults, the following command line gives the same results too:</p>
<p><code>csc.exe Program.cs</code></p>
<p>If, for some reason, you really don't want the C# compiler to reference the MSCorLib.dll assembly, you can use the <b>/nostdlib </b>switch. Microsoft uses this switch when building the MSCorLib.dll assembly itself. For example, the following command line will generate an error when CSC.exe attempts to compile the Program.cs file because the <b>System.Console </b>type is defined in MSCorLib.dll:</p>
<p><code>csc.exe /out:Program.exe /t:exe /nostdlib Program.cs</code></p>
<p>Now, let's take a closer look at the Program.exe file produced by the C# compiler. What exactly is this file? Well, for starters, it is a standard portable executable (PE) file. This means that a machine running 32-bit or 64-bit versions of Windows should be able to load this file and do something with it. Windows supports two types of applications, those with a console user interface (CUI) and those with a graphical user interface (GUI). Because I specified the <b>/t:exe </b>switch, the C# compiler produced a CUI application. You'd use the <b>/t:winexe </b>switch to cause the C# compiler to produce a GUI application.</p>
<h3>Response Files</h3>
<p>Before leaving the discussion about compiler switches, I'd like to spend a moment talking about response files. A response file is a text file that contains a set of compiler command-line switches. When you execute CSC.exe, the compiler opens response files and uses any switches that are specified in them as though the switches were passed to CSC.exe on the command line. You instruct the compiler to use a response file by specifying its name on the command line prepended by an <b>@ </b>sign. For example, you could have a response file called MyProject rsp that contains the following text:</p>
<p><code>/out:MyProject.exe /target:winexe<br/>
csc.exe @MyProject.rsp CodeFile1.cs CodeFile2.cs</code></p>
<p>This tells the C# compiler what to name the output file and what kind of target to create. As you can see, response files are very convenient because you don't have to manually express the desired command-line arguments each time you want to compile your project.</p>
<p>The C# compiler supports multiple response files. In addition to the files you explicitly specify on the command line, the compiler automatically looks for files called CSC.rsp. When you run CSC.exe, it looks in the current directory for a local CSC.rsp file遥ou should place any project-specific settings in this file. The compiler also looks in the directory containing the CSC.exe file for a global CSC.rsp file. Settings that you want applied to all of your projects should go in this file. The compiler aggregates and uses the settings in all of these response files. If you have conflicting settings in the local and global response files, the settings in the local file override the settings in the global file. Likewise, any settings explicitly passed on the command line override the settings taken from a local response file.</p>
<p>When you install the .NET Framework, it installs a default global CSC.rsp file in the %SystemRoot%\Microsoft.NET\Framework\vX.X.Xdirectory (where X.X.X is the version of the .NET Framework you have installed). The 4. 0 version of this file contains the following switches:</p>
<p><code>#.This file contains command-line options that the C#<br/>
#.command line compiler (CSC) will process as part<br/>
#.of every compilation, unless the &quot;/noconfig&quot; option<br/>
#.is specified.<br/>
#.Reference the common Framework libraries /r:Accessibility.dll /r:Microsoft.CSharp.dll /r:System.Configuration.dll /r:System.Configuration.Install.dll /r:System.Core.dll /r:System.Data.dll<br/>
/r:System.Data.DataSetExtensions.dll<br/>
/r:System.Data.Linq.dll<br/>
/r:System.Deployment.dll<br/>
/r:System.Device.dll<br/>
/r:System.DirectoryServices.dll<br/>
/r:System.dll<br/>
/r:System.Drawing.dll<br/>
/r:System.EnterpriseServices.dll<br/>
/r:System.Management.dll<br/>
/r:System.Messaging.dll<br/>
/r:System.Numerics.dll<br/>
/r:System.Runtime.Remoting.dll<br/>
/r:System.Runtime.Serialization.dll<br/>
/r:System.Runtime.Serialization.Formatters.Soap.dll<br/>
/r:System.Security.dll<br/>
/r:System.ServiceModel.dll<br/>
/r:System.ServiceProcess.dll<br/>
/r:System.Transactions.dll<br/>
/r:System.Web.Services.dll<br/>
/r:System.Windows.Forms.Dll<br/>
/r:System.Xml.dll<br/>
/r:System.Xml.Linq.dll</code></p>
<p>Because the global CSC.rsp file references all of the assemblies listed, you do not need to explicitly reference these assemblies by using the C# compiler's <b>/reference </b>switch. This response file is a big convenience for developers because it allows them to use types and namespaces defined in various Microsoft-published assemblies without having to specify a <b>/reference </b>compiler switch for each when compiling.</p>
<p>Referencing all of these assemblies could slow the compiler down a bit. But if your source code doesn't refer to a type or member defined by any of these assemblies, there is no impact to the resulting assembly file, nor to run-time execution performance.</p>
<hr/>
<blockquote><b>Note </b>When you use the <b>/reference </b>compiler switch to reference an assembly, you can specify a complete path to a particular file. However, if you do not specify a path, the compiler will search for the file in the following places (in the order listed):<br/>
&#9632; Working directory.<br/>
&#9632; The directory that contains the CSC.exe file itself. MSCorLib.dll is always obtained from this directory The path looks something like this: %SystemRoot%\Microsoft NET\Framework \v4.0.<br/>
&#9632; Any directories specified using the <b>/lib </b>compiler switch.<br/>
&#9632; Any directories specified using the <b>LIB </b>environment variable.</blockquote>
<hr/>
<p>Of course, you're welcome to add your own switches to the global CSC.rsp file if you want to make your life even easier, but this makes it more difficult to replicate the build environment on different machines: you have to remember to update the CSC.rsp the same way on each build machine. Also, you can tell the compiler to ignore both local and global CSC.rsp files by specifying the <b>/noconfig </b>command-line switch.</p>
<h2>A Brief Look at Metadata</h2>
<p>Now we know what kind of PE file we've created. But what exactly is in the Program.exe file? A managed PE file has four main parts: the PE32(+) header, the CLR header, the metadata, and the IL. The PE32(+) header is the standard information that Windows expects. The CLR header is a small block of information that is specific to modules that require the CLR (managed modules). The header includes the major and minor version number of the CLR that the module was built for: some flags, a <b>MethodDef </b>token (described later) indicating the module's entry point method if this module is a CUI or GUI executable, and an optional strong-name digital signature (discussed in Chapter 3). Finally, the header contains the size and offsets of certain metadata tables contained within the module. You can see the exact format of the CLR header by examining the <b>IMAGE_COR20_HEADER </b>defined in the CorHdr. h header file.</p>
<p>The metadata is a block of binary data that consists of several tables. There are three categories of tables: definition tables, reference tables, and manifest tables. Table 2-1 describes some of the more common definition tables that exist in a module's metadata block.</p>
<p><b>Table 2-1 </b><b>Common Definition Metadata Tables</b></p>
<table border="1">
<tr>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>ModuleDef</p>
</td>
<td>
<p>Always contains one entry that identifies the module. The entry includes the module's file name and extension (without path) and a module version ID (in the form of a GUID created by the compiler). This allows the file to be renamed while keeping a record of its original name. However, renaming a file is strongly discouraged and can prevent the CLR from locating an assembly at runtime, so don't do this.</p>
</td>
</tr>
<tr>
<td>
<p>TypeDef</p>
</td>
<td>
<p>Contains one entry for each type defined in the module. Each entry includes the type's name, base type, and flags <b>(public, private, </b>etc.) and contains indexes to the methods it owns in the MethodDef table, the fields it owns in the FieldDef table, the properties it owns in the PropertyDef table, and the events it owns in the EventDef table.</p>
</td>
</tr>
<tr>
<td>
<p>MethodDef</p>
</td>
<td>
<p>Contains one entry for each method defined in the module. Each entry includes the method's name, flags <b>(private, public, virtual, abstract, static, final </b>, etc., signature, and offset within the module where its IL code can be found Each entry can also refer to a ParamDef table entry in which more information about the method's parameters can be found.</p>
</td>
</tr>
<tr>
<td>
<p>FieldDef</p>
</td>
<td>
<p>Contains one entry for every field defined in the module. Each entry includes flags <b>(private, public, </b>etc.), type, and name.</p>
</td>
</tr>
<tr>
<td>
<p>ParamDef</p>
</td>
<td>
<p>Contains one entry for each parameter defined in the module. Each entry includes flags <b>(in, out, retval, </b>etc.), type, and name.</p>
</td>
</tr>
<tr>
<td>
<p>PropertyDef</p>
</td>
<td>
<p>Contains one entry for each property defined in the module. Each entry includes flags, type, and name.</p>
</td>
</tr>
<tr>
<td>
<p>EventDef</p>
</td>
<td>
<p>Contains one entry for each event defined in the module. Each entry includes flags and name.</p>
</td>
</tr>
</table>
<p>As the compiler compiles your source code, everything your code defines causes an entry to be created in one of the tables described in Table 2-1. Metadata table entries are also created as the compiler detects the types, fields, methods, properties, and events that the source code references. The metadata created includes a set of reference tables that keep a record of the referenced items. Table 2-2 shows some of the more common reference metadata tables.</p>
<p><b>table </b><b>2-2 </b><b>Common Reference Metadata Tables</b></p>
<table border="1">
<tr>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>AssemblyRef</p>
</td>
<td>
<p>Contains one entry for each assembly referenced by the module Each entry includes the information necessary to bind to the assembly: the assembly's name (without path and extension), version number, culture, and public key token (normally a small hash value generated from the publisher's public key, identifying the referenced assembly's publisher) Each entry also contains some flags and a hash value. This hash value was intended to be a checksum of the referenced assembly's bits The CLR completely ignores this hash value and will probably continue to do so in the future.</p>
</td>
</tr>
<tr>
<td>
<p>ModuleRef</p>
</td>
<td>
<p>Contains one entry for each PE module that implements types referenced by this module. Each entry includes the module's file name and extension (without path) This table is used to bind to types that are implemented in different modules of the calling assembly's module.</p>
</td>
</tr>
<tr>
<td>
<p>TypeRef</p>
</td>
<td>
<p>Contains one entry for each type referenced by the module Each entry includes the type's name and a reference to where the type can be found. If the type is implemented within another type, the reference will indicate a TypeRef entry. If the type is implemented in the same module, the reference will indicate a ModuleDef entry. If the type is implemented in another module within the calling assembly, the reference will indicate a ModuleRef entry. If the type is implemented in a different assembly, the reference will indicate an AssemblyRef entry.</p>
</td>
</tr>
<tr>
<td>
<p>MemberRef</p>
</td>
<td>
<p>Contains one entry for each member (fields and methods, as well as property and event methods) referenced by the module. Each entry includes the member's name and signature and points to the TypeRef entry for the type that defines the member.</p>
</td>
</tr>
</table>
<p>There are many more tables than what I listed in Tables 2-1 and 2-2, but I just wanted to give you a sense of the kind of information that the compiler emits to produce the metadata information. Earlier I mentioned that there is also a set of manifest metadata tables; I'll discuss these a little later in the chapter.</p>
<p>Various tools allow you to examine the metadata within a managed PE file. My personal favorite is ILDasm.exe, the IL Disassembler. To see the metadata tables, execute the following command line:</p>
<p><code>ILDasm Program.exe</code></p>
<p>This causes ILDasm.exe to run, loading the Program.exe assembly. To see the metadata in a nice, human-readable form, select the View/MetaInfo/Show! menu item (or press CTRL+M). This causes the following information to appear:</p>
<p><code>ScopeName : Program.exe<br/>
MVID.: {CA73FFE8-0D42-4610-A8D3-9276195C35AA}<br/>
Global functions<br/>
Global fields<br/>
Global MemberRefs<br/>
TypeDef #1 (02000002)<br/>
TypDefName: Program (02000002)<br/>
Flags        : [Public] [AutoLayout] [Class] [Sealed] [AnsiClass]<br/>
[BeforeFieldInit] (00100101) Extends     : 01000001 [TypeRef] System.Object Method #1 (06000001) [ENTRYPOINT]<br/>
MethodName:.Main (06000001)<br/>
Flags        :.[Public] [Static] [HideBySig] [ReuseSlot] (00000096)<br/>
RVA.:.0x00002050<br/>
ImplFlags :.[IL] [Managed] (00000000)<br/>
CallCnvntn:.[DEFAULT]<br/>
ReturnType:.Void<br/>
No arguments.<br/>
Method #2 (06000002)<br/>
MethodName:.ctor (06000002)<br/>
Flags        :  [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886)<br/>
RVA        : 0x0000205c<br/>
ImplFlags :  [IL] [Managed] (00000000)<br/>
CallCnvntn: [DEFAULT]<br/>
hasThis<br/>
ReturnType: Void No arguments.<br/>
TypeRef #1 (01000001)<br/>
Token: 0x01000001 ResolutionScope: 0x23000001 TypeRefName: System.Object MemberRef #1 (0a000004)<br/>
Member: (0a000004).ctor: CallCnvntn: [DEFAULT] hasThis<br/>
ReturnType: Void No arguments.<br/>
TypeRef #2 (01000002)<br/>
Token: 0x01000002<br/>
ResolutionScope: 0x23000001<br/>
TypeRefName: System.Runtime.CompilerServices.CompilationRelaxationsAttribute<br/>
MemberRef #1 (0a000001)<br/>
Member: (0a000001).ctor: CallCnvntn: [DEFAULT] hasThis<br/>
ReturnType: Void 1 Arguments<br/>
Argument #1: I4<br/>
TypeRef #3 (01000003) Token: 0x01000003<br/>
ResolutionScope: 0x23000001<br/>
TypeRefName: System.Runtime.CompilerServices.RuntimeCompatibilityAttribute<br/>
MemberRef #1 (0a000002)<br/>
Member: (0a000002).ctor: CallCnvntn: [DEFAULT] hasThis<br/>
ReturnType: Void No arguments. TypeRef #4 (01000004)<br/>
Token: 0x01000004 ResolutionScope: 0x23000001 TypeRefName: System.Console<br/>
MemberRef #1 (0a000003)<br/>
Member: (0a000003) WriteLine: CallCnvntn: [DEFAULT] ReturnType: Void 1 Arguments<br/>
Argument #1: String<br/>
Assembly<br/>
Token: 0x20000001<br/>
Name : Program<br/>
Public Key :<br/>
Hash Algorithm : 0x00008004<br/>
Version: 0.0.0.0<br/>
Major Version: 0x00000000<br/>
Minor Version: 0x00000000<br/>
Build Number: 0x00000000<br/>
Revision Number: 0x00000000<br/>
Locale: &lt;nu11&gt;<br/>
Flags : [none] (00000000)<br/>
CustomAttribute #1 (0c000001)<br/>
CustomAttribute Type: 0a000001 CustomAttributeName:<br/>
System.Runtime.CompilerServices.CompilationRelaxationsAttribute :: instance void.ctor(int32) Length: 8<br/>
Value : 01 00 08 00 00 00 00 00.&gt; &lt;<br/>
ctor args: (8)<br/>
CustomAttribute #2 (0c000002)<br/>
CustomAttribute Type: 0a000002<br/>
CustomAttributeName: System.Runtime.CompilerServices.RuntimeCompatibilityAttribute ::<br/>
instance void.ctor() Length: 30<br/>
Value : 01 00 01 00 54 02 16 57   72 61 70 4e 6f 6e 45 78 &gt;      T WrapNonEx&lt; : 63 65 70 74 69 6f 6e 54   68 72 6f 77 73 01.&gt;ceptionThrows &lt;<br/>
ctor args: ()<br/>
AssemblyRef #1 (23000001)<br/>
Token: 0x23000001<br/>
Public Key or Token: b7 7a 5c 56 19 34 e0 89<br/>
Name: mscorlib<br/>
Version: 4.0.0.0<br/>
Major Version: 0x00000004<br/>
Minor Version: 0x00000000<br/>
Build Number: 0x00000000<br/>
Revision Number: 0x00000000<br/>
Locale: &lt;nu11&gt;<br/>
HashValue Blob:<br/>
Flags: [none] (00000000)<br/>
User Strings 70000001 :  ( 2) L&quot;Hi&quot;<br/>
Coff symbol name overhead: 0</code></p>
<p>Fortunately, ILDasm processes the metadata tables and combines information where appropriate so that you don't have to parse the raw table information For example, in the dump above, you see that when ILDasm shows a TypeDef entry, the corresponding member definition information is shown with it before the first TypeRef entry is displayed.</p>
<p>You don't need to fully understand everything you see here. The important thing to remember is that Program, exe contains a TypeDef whose name is <b>Program. </b>This type identifies a public sealed class that is derived from <b>System.Object </b>(a type referenced from another assembly). The <b>Program </b>type also defines two methods: <b>Main </b>and <b>.ctor </b>(a constructor).</p>
<p><b>Main </b>is a public, static method whose code is IL (as opposed to native CPU code, such as x86). <b>Main </b>has a <b>void </b>return type and takes no arguments. The constructor method (always shown with a name of <b>.ctor) </b>is public, and its code is also IL. The constructor has a <b>void </b>return type, has no arguments, and has a <b>this </b>pointer, which refers to the object's memory that is to be constructed when the method is called.</p>
<p>I strongly encourage you to experiment with using ILDasm. It can show you a wealth of information, and the more you understand what you're seeing, the better you'll understand the CLR and its capabilities. As you'll see, I'll use ILDasm quite a bit more in this book.</p>
<p>Just for fun, let's look at some statistics about the Program, exe assembly. When you select ILDasm's View/Statistics menu item, the following information is displayed:</p>
<p><code>File size.: 3584<br/>
PE header size.: 512 (496 used).(14.29%)<br/>
PE additional info     : 1415.(39.48%) Num.of PE sections     : 3<br/>
CLR header size.: 72.( 2.01%)<br/>
CLR meta-data size.: 612.(17.08%)<br/>
CLR additional info.: 0.( 0.00%)<br/>
CLR method headers.: 2.( 0.06%)<br/>
Managed code.: 18.( 0.50%)<br/>
Data.: 2048.(57.14%)<br/>
Unaccounted.: -1095.(-30.55%)<br/>
Num.of PE sections     : 3.text     - 1024.rsrc      - 1536.reloc     - 512<br/>
CLR meta-data size.: 612<br/>
Module.-.1 (10 bytes)<br/>
TypeDef.-.2 (28 bytes).0 interfaces, 0 explicit layout<br/>
TypeRef         -.4 (24 bytes)<br/>
MethodDef        -.2 (28 bytes).0 abstract, 0 native, 2 bodies<br/>
MemberRef       -.4 (24 bytes)<br/>
ParamDef       -.2 (12 bytes)<br/>
CustomAttribute-     2 (12 bytes)<br/>
Assembly.-.1 (22 bytes)<br/>
AssemblyRef     -.1 (20 bytes)<br/>
Strings.-.184 bytes<br/>
Blobs.-.68 bytes<br/>
UserStrings     -        8 bytes<br/>
Guids.-.16 bytes<br/>
Uncategorized -.168 bytes<br/>
CLR method headers : 2<br/>
Num.of method bodies.-.2<br/>
Num.of fat headers.-.0<br/>
Num.of tiny headers.-.2<br/>
Managed code : 18 Ave method size - 9</code></p>
<p>Here you can see the size (in bytes) of the file and the size (in bytes and percentages) of the various parts that make up the file. For this very small Program.cs application, the PE header and the metadata occupy the bulk of the file's size. In fact, the IL code occupies just 18 bytes. Of course, as an application grows, it will reuse most of its types and references to other types and assemblies, causing the metadata and header information to shrink considerably as compared to the overall size of the file.</p>
<hr/>
<blockquote><b>Note </b>By the way, ll_Dasm.exe does have a bug in it that affects the file size information shown. <b>I     </b>I        In particular, you cannot trust the <b>Unaccounted </b>information.</blockquote>
<hr/>
<a name="b43"/><h2>Combining Modules to Form an Assembly</h2>
<p>The Program.exe file discussed in the previous section is more than just a PE file with metadata; it is also an assembly. An assembly is a collection of one or more files containing type definitions and resource files. One of the assembly's files is chosen to hold a manifest. The manifest is another set of metadata tables that basically contain the names of the files that are part of the assembly. They also describe the assembly's version, culture, publisher, publicly exported types, and all of the files that comprise the assembly.</p>
<p>The CLR operates on assemblies; that is, the CLR always loads the file that contains the manifest metadata tables first and then uses the manifest to get the names of the other files that are in the assembly. Here are some characteristics of assemblies that you should remember:</p>
<p>&#9632; An assembly defines the reusable types.</p>
<p>&#9632; An assembly is marked with a version number.</p>
<p>&#9632; An assembly can have security information associated with it.</p>
<p>An assembly's individual files don't have these attributes容xcept for the file that contains the manifest metadata tables.</p>
<p>To package, version, secure, and use types, you must place them in modules that are part of an assembly. In most cases, an assembly consists of a single file, as the preceding Program.exe example does. However, an assembly can also consist of multiple files: some PE files with metadata and some resource files such as.gif or.jpg files. It might help you to think of an assembly as a logical EXE or a DLL.</p>
<p>I'm sure that many of you reading this are wondering why Microsoft has introduced this new assembly concept. The reason is that an assembly allows you to decouple the logical and physical notions of reusable types. For example, an assembly can consist of several types. You could put the frequently used types in one file and the less frequently used types in another file. If your assembly is deployed by downloading it via the Internet, the file with the infrequently used types might not ever have to be downloaded to the client if the client never accesses the types For example, an independent software vendor (ISV) specializing in UI controls might choose to implement Active Accessibility types in a separate module (to satisfy Microsoft's Logo requirements). Only users who require the additional accessibility features would require this module to be downloaded.</p>
<p>You configure an application to download assembly files by specifying a <b>codeBase </b>element (discussed in Chapter 3) in the application's configuration file. The <b>codeBase </b>element identifies a URL pointing to where all of an assembly's files can be found. When attempting to load an assembly's file, the CLR obtains the <b>codeBase </b>element's URL and checks the machine's download cache to see if the file is present. If it is, the file is loaded. If the file isn't in the cache, the CLR downloads the file into the cache from the location the URL points to. If the file can't be found, the CLR throws a <b>FileNotFoundException </b>exception at runtime.</p>
<p>I've identified three reasons to use multifile assemblies:</p>
<p>&#9632; You can partition your types among separate files, allowing for files to be incrementally downloaded as described in the Internet download scenario Partitioning the types into separate files also allows for partial or piecemeal packaging and deployment for applications you purchase and install.</p>
<p>&#9632; You can add resource or data files to your assembly. For example, you could have a type that calculates some insurance information This type might require access to some actuarial tables to make its computations. Instead of embedding the actuarial tables in your source code, you could use a tool (such as the Assembly Linker, AL.exe, discussed later) so that the data file is considered to be part of the assembly. By the way, this data file can be in any format預 text file, a Microsoft Office Excel spreadsheet, a Microsoft Office Word table, or whatever you like預s long as your application knows how to parse the file's contents.</p>
<p>&#9632; You can create assemblies consisting of types implemented in different programming languages. For example, you can implement some types in C#, some types in Microsoft Visual Basic, and other types in other languages When you compile the types written with C# source code, the compiler produces a module. When you compile other types written with Visual Basic source code, the compiler produces a separate module You can then use a tool to combine all of these modules into a single assembly. To developers using the assembly, the assembly appears to contain just a bunch of types; developers won't even know that different programming languages were used. By the way, if you prefer, you can run ILDasm.exe on each of the modules to obtain an IL source code file. Then you can run ILAsm.exe and pass it all of the IL source code files. ILAsm.exe will produce a single file containing all of the types. This technique requires your source code compiler to produce IL-only code.</p>
<hr/>
<blockquote><b>Important </b>To summarize, an assembly is a unit of reuse, versioning, and security. It allows you to partition your types and resources into separate files so that you, and consumers of your assembly, get to determine which files to package together and deploy. Once the CLR loads the file containing the manifest, it can determine which of the assembly's other files contain the types and resources the application is referencing. Anyone consuming the assembly is required to know only the name of the file containing the manifest; the file partitioning is then abstracted away from the consumer and can change in the future without breaking the application's behavior.</blockquote>
<hr/>
<p>If you have multiple types that can share a single version number and security settings, it is recommended that you place all of the types in a single file rather than spread the types out over separate files, let alone separate assemblies. The reason is performance. Loading a file/assembly takes the CLR and Windows time to find the assembly, load it, and initialize it. The fewer files/assemblies loaded the better, because loading fewer assemblies helps reduce working set and also reduces fragmentation of a process's address space. Finally, nGen.exe can perform better optimizations when processing larger files.</p>
<p>To build an assembly, you must select one of your PE files to be the keeper of the manifest. Or you can create a separate PE file that contains nothing but the manifest. Table 2-3 shows the manifest metadata tables that turn a managed module into an assembly.</p>
<p><b>Table 2-3 </b><b>Manifest Metadata Tables</b></p>
<table border="1">
<tr>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>AssemblyDef</p>
</td>
<td>
<p>Contains a single entry if this module identifies an assembly. The entry includes the assembly's name (without path and extension), version (major, minor, build, and revision), culture, flags, hash algorithm, and the publisher's public key (which can be <b>null) </b>.</p>
</td>
</tr>
<tr>
<td>
<p>FileDef</p>
</td>
<td>
<p>Contains one entry for each PE and resource file that is part of the assembly (except the file containing the manifest since it appears as the single entry in the AssemblyDef table). The entry includes the file's name and extension (without path), hash value, and flags. If this assembly consists only of its own file, the FileDef table has no entries.</p>
</td>
</tr>
<tr>
<td>
<p>ManifestResourceDef</p>
</td>
<td>
<p>Contains one entry for each resource that is part of the assembly. The entry includes the resource's name, flags <b>(public </b>if visible outside the assembly and <b>private </b>otherwise), and an index into the FileDef table indicating the file that contains the resource file or stream. If the resource isn't a stand-alone file (such as.jpg or a.gif), the resource is a stream contained within a PE file. For an embedded resource, the entry also includes an offset indicating the start of the resource stream within the PE file.</p>
</td>
</tr>
<tr>
<td>
<p>ExportedTypesDef</p>
</td>
<td>
<p>Contains one entry for each public type exported from all of the assembly's PE modules The entry includes the type's name, an index into the FileDef table (indicating which of this assembly's files implements the type), and an index into the TypeDef table. Note: To save file space, types exported from the file containing the manifest are not repeated in this table because the type information is available using the metadata's TypeDef table.</p>
</td>
</tr>
</table>
<p>The existence of a manifest provides a level of indirection between consumers of the assembly and the partitioning details of the assembly and makes assemblies self-describing. Also, note that the file containing the manifest has metadata information that indicates which files are part of the assembly, but the individual files themselves do not have metadata information that specifies that they are part of the assembly.</p>
<hr/>
<blockquote><b>Note </b>The assembly file that contains the manifest also has an AssemblyRef table in it. This table contains an entry for all of the assemblies referenced by all of the assembly's files. This allows tools to open an assembly's manifest and see its set of referenced assemblies without having to open the assembly's other files. Again, the entries in the AssemblyRef table exist to make an assembly self-describing.</blockquote>
<hr/>
<p>The C# compiler produces an assembly when you specify any of the following command-line switches: <b>/t[arget]:exe, /t[arget]:winexe, </b>or <b>/t[arget]:library. </b>All of these switches cause the compiler to generate a single PE file that contains the manifest metadata tables. The resulting file is either a CUI executable, a GUI executable, or a DLL, respectively.</p>
<p>In addition to these switches, the C# compiler supports the <b>/t[arget]:module </b>switch. This switch tells the compiler to produce a PE file that doesn't contain the manifest metadata tables. The PE file produced is always a DLL PE file, and this file must be added to an assembly before the CLR can access any types within it. When you use the <b>/t:module </b>switch, the C# compiler, by default, names the output file with an extension of.netmodule.</p>
<hr/>
<blockquote><b>Important </b>Unfortunately, the Microsoft Visual Studio integrated development environment (IDE) doesn't natively support the ability for you to create multifile assemblies. If you want to create multifile assemblies, you must resort to using command-line tools.</blockquote>
<hr/>
<p>There are many ways to add a module to an assembly. If you're using the C# compiler to build a PE file with a manifest, you can use the <b>/addmodule </b>switch. To understand how to build a multifile assembly, let's assume that we have two source code files:</p>
<p>&#9632; RUT.cs, which contains rarely used types</p>
<p>&#9632; FUT.cs, which contains frequently used types</p>
<p>Let's compile the rarely used types into their own module so that users of the assembly won't need to deploy this module if they never access the rarely used types:</p>
<p><code>csc /t:module RUT.cs</code></p>
<p>This line causes the C# compiler to create a RUT.netmodule file. This file is a standard DLL PE file, but, by itself, the CLR can't load it.</p>
<p>Next let's compile the frequently used types into their own module. We'll make this module the keeper of the assembly's manifest because the types are used so often In fact, because this module will now represent the entire assembly, I'll change the name of the output file to JeffTypes.dll instead of calling it FUT.dll:</p>
<p><code>csc A&gt;ut:JeffTypes.dll /t:library /addmodule:RUT.netmodule FUT.cs</code></p>
<p>This line tells the C# compiler to compile the FUT.cs file to produce the JeffTypes.dll file. Because <b>/t:library </b>is specified, a DLL PE file containing the manifest metadata tables is emitted into the JeffTypes.dll file. The <b>/addmodule:RUT.netmodule </b>switch tells the compiler that RUT.netmodule is a file that should be considered part of the assembly. Specifically, the <b>/addmodule </b>switch tells the compiler to add the file to the FileDef manifest metadata table and to add RUT.netmodule's publicly exported types to the ExportedTypesDef manifest metadata table.</p>
<p>Once the compiler has finished all of its processing, the two files shown in Figure 2-1 are created. The module on the right contains the manifest.</p>
<p><b>Figure 2-1 </b>A multifile assembly consisting of two managed modules, one with a manifest</p>
<p>The RUT.netmodule file contains the IL code generated by compiling RUT.cs. This file also contains metadata tables that describe the types, methods, fields, properties, events, and so on that are defined by RUT.cs. The metadata tables also describe the types, methods, and so on that are referenced by RUT.cs. The JeffTypes.dll is a separate file. Like RUT.netmodule, this file includes the IL code generated by compiling FUT.cs and also includes similar definition and reference metadata tables. However, JeffTypes.dll contains the additional manifest metadata tables, making JeffTypes dll an assembly The additional manifest metadata tables describe all of the files that make up the assembly (the JeffTypes.dll file itself and the RUT.netmodule file). The manifest metadata tables also include all of the public types exported from JeffTypes.dll and RUT.netmodule.</p>
<img src="10.jpg"/>
<hr/>
<blockquote><b>Note </b>In reality, the manifest metadata tables don't actually include the types that are exported from the PE file that contains the manifest The purpose of this optimization is to reduce the number of bytes required by the manifest information in the PE file. So statements like &quot;The manifest metadata tables also include all the public types exported from JeffTypes dll and RUT.netmodule&quot; aren't 100 percent accurate. However, this statement does accurately reflect what the manifest is logically exposing.</blockquote>
<hr/>
<p>Once the JeffTypes.dll assembly is built, you can use ILDasm.exe to examine the metadata's manifest tables to verify that the assembly file does in fact have references to the RUT.netmodule file's types. Here is what the FileDef and ExportedTypesDef metadata tables look like:</p>
<p><code>File #1 (26000001)<br/>
Token: 0x26000001 Name : RUT.netmodule<br/>
HashValue Blob : e6 e6 df 62 2c a1 2c 59 97 65 0f 21 44 10 15 96 f2 7e db c2 Flags : [ContainsMetaData] (00000000)<br/>
ExportedType #1 (27000001) Token: 0x27000001<br/>
Name: ARarelyUsedType Implementation token: 0x26000001 TypeDef token: 0x02000002<br/>
Flags        : [Public] [AutoLayout] [Class] [Sealed] [AnsiClass] [BeforeFieldInit](00100101)</code></p>
<p>From this, you can see that RUT.netmodule is a file considered to be part of the assembly with the token 0x26000001. From the ExportedTypesDef table, you can see that there is a publicly exported type, <b>ARarelyUsedType. </b>The implementation token for this type is 0x26000001, which indicates that the type's IL code is contained in the RUT.netmodule file.</p>
<hr/>
<blockquote><b>Note </b>For the curious, metadata tokens are 4-byte values. The high byte indicates the type of token (0x01=TypeRef, 0x02=TypeDef, 0x23=AssemblyRef, 0x26=FileRef, 0x27=ExportedType). For the complete list, see the <b>CorTokenType </b>enumerated type in the CorHdr.h file included with the .NET Framework SDK. The three lower bytes of the token simply identify the row in the corresponding metadata table For example, the implementation token 0x26000001 refers to the first row of the FileRef table. For most tables, rows are numbered starting with 1, not 0. For the TypeDef table, rows actually start with 2.</blockquote>
<hr/>
<p>Any client code that consumes the JeffTypes dll assembly's types must be built using the <b>/r[eference]:JeffTypes.dll </b>compiler switch. This switch tells the compiler to load the JeffTypes.dll assembly and all of the files listed in its FileDef table when searching for an external type. The compiler requires all of the assembly's files to be installed and accessible. If</p>
<p>you were to delete the RUT.netmodule file, the C# compiler would produce the following error: <b>&quot;fatal error CS0009: Metadata file </b><span><b>'C:\JeffTypes.dll'</b></span><b> could not be opened-'Error importing module 'RUT.netmodule' of assembly 'C:\JeffTypes.dll'-The system cannot find the file specified'&quot;. </b>This means that to build a new assembly, all of the files from a referenced assembly must be present.</p>
<p>As the client code executes, it calls methods. When a method is called for the first time, the CLR detects the types that the method references as a parameter, a return value, or as a local variable. The CLR then attempts to load the referenced assembly's file that contains the manifest. If the type being accessed is in this file, the CLR performs its internal bookkeeping, allowing the type to be used If the manifest indicates that the referenced type is in a different file, the CLR attempts to load the necessary file, performs its internal bookkeeping, and allows the type to be accessed. The CLR loads assembly files only when a method referencing a type in an unloaded assembly is called. This means that to run an application, all of the files from a referenced assembly do not need to be present.</p>
<h3>Adding Assemblies to a Project by Using the Visual Studio IDE</h3>
<p>If you're using the Visual Studio IDE to build your project, you'll have to add any assemblies that you want to reference to your project. To do so, open Solution Explorer, right-click the project you want to add a reference to, and then select the Add Reference menu item This causes the Add Reference dialog box, shown in Figure 2-2, to appear.</p>
<p><b>Figure 2-2 </b>The Add Reference dialog box in Visual Studio</p>
<img src="11.jpg"/>
<p>To have your project reference an assembly, select the desired assembly from the list. If the assembly you want isn't in the list, click the Browse tab to navigate to the desired assembly (file containing a manifest) to add the assembly reference. The COM tab on the Add Reference dialog box allows an unmanaged COM server to be accessed from within managed source code via a managed proxy class automatically generated by Visual Studio. The Projects tab allows the current project to reference an assembly that is created by another project in the same solution. The Recent tab allows you to select an assembly that you recently added to another project.</p>
<p>To make your own assemblies appear in the .NET tab's list, add the following subkey to the registry:</p>
<p>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\AssemblyFolders\MyLibName</p>
<p>MyLibName is a unique name that you create遊isual Studio doesn't display this name. After creating the subkey, change its default string value so that it refers to a directory path (such as <span>C:\Program</span> Files\MyLibPath) containing your assembly's files. Using HKEY_LOCAL_ MACHINE adds the assemblies for all users on a machine; use HKEY_CURRENT_USER instead to add the assemblies for a specific user.</p>
<h3>Using the Assembly Linker</h3>
<p>Instead of using the C# compiler, you might want to create assemblies by using the Assembly Linker utility, AL.exe. The Assembly Linker is useful if you want to create an assembly consisting of modules built from different compilers (if your compiler doesn't support the equivalent of C#'s <b>/addmodule </b>switch) or perhaps if you just don't know your assembly packaging requirements at build time. You can also use AL.exe to build resource-only assemblies, called satellite assemblies, which are typically used for localization purposes. I'll talk about satellite assemblies later in the chapter.</p>
<p>The AL.exe utility can produce an EXE or a DLL PE file that contains only a manifest describing the types in other modules. To understand how AL.exe works, let's change the way the JeffTypes.dll assembly is built:</p>
<p><code>csc /t:module RUT.cs csc /t:module FUT.cs<br/>
al   /out:JeffTypes.dll /t:library FUT.netmodule RUT.netmodule</code></p>
<p>Figure 2-3 shows the files that result from executing these statements.</p>
<p><b>Figure 2-3 </b>A multifile assembly consisting of three managed modules, one with a manifest</p>
<p>In this example, two separate modules, RUT.netmodule and FUT.netmodule, are created. Neither module is an assembly because they don't contain manifest metadata tables. Then a third file is produced: JeffTypes.dll, which is a small DLL PE file (because of the <b>/t[arget]:library </b>switch) that contains no IL code but has manifest metadata tables indicating that RUT.netmodule and FUT.netmodule are part of the assembly. The resulting assembly consists of three files: JeffTypes.dll, RUT.netmodule, and FUT.netmodule. The Assembly Linker has no way to combine multiple files into a single file.</p>
<p>The AL.exe utility can also produce CUI and GUI PE files by using the <b>/t[arget]:exe </b>or <b>/t[arget]:winexe </b>command-line switches. But this is very unusual since it would mean that you'd have an EXE PE file with just enough IL code in it to call a method in another module. You can specify which method in a module should be used as an entry point by adding the <b>/main </b>command-line switch when invoking AL.exe. The following is an example of how to call the Assembly Linker, AL.exe, by using the <b>/main </b>command-line switch:</p>
<p><code>csc /t:module /r:JeffTypes.dll Program.cs<br/>
al /out:Program.exe /t:exe /main:Program.Main Program.netmodule</code></p>
<img src="12.jpg"/>
<p>Here the first line builds the Program, cs file into a Program, netmodule file. The second line produces a small Program, exe PE file that contains the manifest metadata tables. In addition,</p>
<p>there is a small global function named__<b>EntryPoint </b>that is emitted by AL.exe because of the <b>/main:Program.Main </b>command-line switch This function, <b>__EntryPoint, </b>contains the following IL code:</p>
<p><code>.method privatescope static void _EntryPoint$PST06000001() cil managed<br/>
{<br/>
.entrypoint<br/>
// Code size.8 (0x8)<br/>
.maxstack 8 IL_0000: tail.<br/>
IL_0002:   call           void [.module 'Program.netmodule']Program::Main() IL_0007: ret } // end of method 'Global Functions'::_EntryPoint</code></p>
<p>As you can see, this code simply calls the <b>Main </b>method contained in the <b>Program </b>type defined in the Program, netmodule file. The <b>/main </b>switch in AL.exe isn't that useful because it's unlikely that you'd ever create an assembly for an application that didn't have its entry point in the PE file that contains the manifest metadata tables. I mention the switch here only to make you aware of its existence.</p>
<p>With the code that accompanies this book, I have created a Ch02-3-BuildMultiFileLibrary.bat file that encapsulates all the steps required to build a multifile assembly. The Ch02-4-AppUsingMultiFileLibrary project in Visual Studio invokes this batch file as a prebuild command-line step. You can examine this project to see how to integrate building and referencing a multifile assembly from within Visual Studio.</p>
<h3>Adding Resource Files to an Assembly</h3>
<p>When using AL.exe to create an assembly, you can add a file as a resource to the assembly by using the <b>/embed[resource] </b>switch. This switch takes a file (any file) and embeds the file's contents into the resulting PE file. The manifest's ManifestResourceDef table is updated to reflect the existence of the resources.</p>
<p>AL.exe also supports a <b>/link[resource] </b>switch, which also takes a file containing resources. However, the <b>/link[resource] </b>switch updates the manifest's ManifestResourceDef and FileDef tables, indicating that the resource exists and identifying which of the assembly's files contains it. The resource file is not embedded into the assembly PE file; it remains separate and must be packaged and deployed with the other assembly files.</p>
<p>Like AL.exe, CSC.exe also allows you to combine resources into an assembly produced by the C# compiler The C# compiler's <b>/resource </b>switch embeds the specified resource file into the resulting assembly PE file, updating the ManifestResourceDef table. The compiler's <b>/linkresource </b>switch adds an entry to the ManifestResourceDef and the FileDef manifest tables to refer to a stand-alone resource file.</p>
<p>One last note about resources: it's possible to embed standard Win32 resources into an assembly. You can do this easily by specifying the pathname of a.res file with the <b>/win32res </b>switch when using either AL.exe or CSC.exe. In addition, you can quickly and easily embed a standard Win32 icon resource into an assembly file by specifying the pathname of the.ico file with the <b>/win32icon </b>switch when using either AL.exe or CSC.exe. Within Visual Studio, you can add resource files to your assembly by displaying your project's properties and then clicking the Application tab The typical reason an icon is embedded is so that Windows Explorer can show an icon for a managed executable file.</p>
<hr/>
<blockquote><b>Note </b>Managed assembly files also contain Win32 manifest resource information in them. By default, the C# compiler automatically produces this manifest information but you can tell it not to by using the <b>/nowin32manifest </b>switch. The default manifest produced by the C# compiler looks like this:
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;<br/>
&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt;<br/>
&lt;assemblyIdentity version=&quot;1.0.0.0&quot; name=&quot;MyApplication.app&quot; /&gt;<br/>
&lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v2&quot;&gt;<br/>
&lt;security&gt;<br/>
&lt;requestedPrivileges xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt;<br/>
&lt;requestedExecutionLevel level=&quot;asInvoker&quot; uiAccess=&quot;false&quot;/&gt;<br/>
&lt;/requestedPrivileges&gt;<br/>
&lt;/security&gt;<br/>
&lt;/trustInfo&gt;<br/>
&lt;/assembly&gt;</code></p></blockquote>
<hr/>
<a name="b53"/><h2>Assembly Version Resource Information</h2>
<p>When AL.exe or CSC.exe produces a PE file assembly, it also embeds into the PE file a standard Win32 version resource. Users can examine this resource by viewing the file's properties. Application code can also acquire and examine this information at runtime by calling <b>System.Diagnostics.FileVersionlnfo</b>'s static <b>GetVersionlnfo </b>method. Figure 2-4 shows the Details tab of the JeffTypes.dll Properties dialog box.</p>
<img src="13.jpg"/>
<p><b>Figure 2-4 </b>The Details tab of the JeffTypes.dll Properties dialog box</p>
<p>When building an assembly, you should set the version resource fields by using custom attributes that you apply at the assembly level in your source code. Here's what the code that produced the version information in Figure 2-4 looks like:</p>
<p><code>using System.Reflection;<br/>
// FileDescription version information: [assembly: AssemblyTitle(&quot;JeffTypes.dll&quot;)]<br/>
// Comments version information:<br/>
[assembly: AssemblyDescription(&quot;This assembly contains Jeff's types&quot;)]<br/>
// CompanyName version information: [assembly: AssemblyCompany(&quot;Wintellect&quot;)]<br/>
// ProductName version information:<br/>
[assembly: AssemblyProduct(&quot;Wintellect (R) Jeff's Type Library&quot;)] // LegalCopyright version information:<br/>
[assembly: AssemblyCopyright(&quot;Copyright (c) Wintellect 2010&quot;)]<br/>
// LegalTrademarks version information:<br/>
[assembly:AssemblyTrademark(&quot;JeffTypes is a registered trademark of Wintellect&quot;)]<br/>
// AssemblyVersion version information: [assembly: AssemblyVersion(&quot;3.0.0.0&quot;)]<br/>
// FILEVERSION/FileVersion version information: [assembly: AssemblyFileVersion(&quot;1.0.0.0&quot;)]<br/>
// PRODUCTVERSION/ProductVersion version information: [assembly: AssemblyInformationalVersion(&quot;2.0.0.0&quot;)]<br/>
// Set the Language field (discussed later in the &quot;Culture&quot; section) [assembly:AssemblyCulture(&quot;&quot;)]</code></p>
<hr/>
<blockquote><b>Important </b>Unfortunately, the Windows Explorer Properties dialog box is missing entries for some of the attributes. In particular, it would be great if the value of the <b>AssemblyVersion </b>attribute were shown because the CLR uses this value when loading assemblies, as we'll discuss in Chapter 3.</blockquote>
<hr/>
<p>Table 2-4 shows the version resource fields and the custom attributes that correspond to them. If you're using AL.exe to build your assembly, you can use command-line switches to set this information instead of using the custom attributes. The second column in Table 2-4 shows the AL.exe command-line switch that corresponds to each version resource field. Note that the C# compiler doesn't offer these command-line switches and that, in general, using custom attributes is the preferred way to set this information.</p>
<p><b>Table 2-4 </b><b>Version Resource Fields and Their Corresponding AL.exe Switches and Custom Attributes</b></p>
<table border="1">
<tr>
<td>
<p>e</p>
</td>
<td>
<p><b>AL.exe Switch</b></p>
</td>
<td>
<p><b>Custom Attribute/Comment</b></p>
</td>
</tr>
<tr>
<td>
<p>FILEVERSION</p>
</td>
<td>
<p><b>/fileversion</b></p>
</td>
<td>
<p><b>System.Reflection. AssemblyFileVersionAttribute.</b></p>
</td>
</tr>
<tr>
<td>
<p>PRODUCTVERSION</p>
</td>
<td>
<p><b>/productversion</b></p>
</td>
<td>
<p><b>System.Reflection.</b></p>
<p><b>AssemblylnformationalVersionAttribute </b>.</p>
</td>
</tr>
<tr>
<td>
<p>FILEFLAGSMASK</p>
</td>
<td>
<p>(none)</p>
</td>
<td>
<p>Always set to <b>VS_FFI_FILEFLAGSMASK </b>(defined in WinVer.h as <b>0x0000003F) </b>.</p>
</td>
</tr>
<tr>
<td>
<p>FILEFLAGS</p>
</td>
<td>
<p>(none)</p>
</td>
<td>
<p>Always <b>0 </b>.</p>
</td>
</tr>
<tr>
<td>
<p>FILEOS</p>
</td>
<td>
<p>(none)</p>
</td>
<td>
<p>Currently always <b>VOS_WINDOWS32.</b></p>
</td>
</tr>
<tr>
<td>
<p>FILETYPE</p>
</td>
<td>
<p><b>/target</b></p>
</td>
<td>
<p>Set to <b>VFT_APP </b>if <b>/target:exe </b>or <b>/target:winexe </b>is specified; set to <b>VFT_DLL </b>if <b>/target:library </b>is specified.</p>
</td>
</tr>
<tr>
<td>
<p>FILESUBTYPE</p>
</td>
<td>
<p>(none)</p>
</td>
<td>
<p>Always set to <b>VFT2_UNKNOWN</b>. (This field has no meaning for <b>VFT_APP </b>and <b>VFT_DLL </b>.)</p>
</td>
</tr>
<tr>
<td>
<p>AssemblyVersion</p>
</td>
<td>
<p><b>/version</b></p>
</td>
<td>
<p><b>System.Reflection.AssemblyVersionAttribute </b>.</p>
</td>
</tr>
<tr>
<td>
<p>Comments</p>
</td>
<td>
<p><b>/description</b></p>
</td>
<td>
<p><b>System.Reflection. AssemblyDescriptionAttribute </b>.</p>
</td>
</tr>
<tr>
<td>
<p>CompanyName</p>
</td>
<td>
<p><b>/company</b></p>
</td>
<td>
<p><b>System.Reflection.AssemblyCompanyAttribute </b>.</p>
</td>
</tr>
<tr>
<td>
<p>FileDescription</p>
</td>
<td>
<p><b>/title</b></p>
</td>
<td>
<p><b>System.Reflection.AssemblyTitleAttribute </b>.</p>
</td>
</tr>
</table>
<table border="1">
<tr>
<td>
<p>e</p>
</td>
<td>
<p>h</p>
</td>
<td>
<p><b>Custom Attribute/Comment</b></p>
</td>
</tr>
<tr>
<td>
<p>FileVersion</p>
</td>
<td>
<p><b>/version</b></p>
</td>
<td>
<p><b>System.Reflection. AssemblyFileVersionAttribute.</b></p>
</td>
</tr>
<tr>
<td>
<p>InternalName</p>
</td>
<td>
<p><b>/out</b></p>
</td>
<td>
<p>Set to the name of the output file specified (without the extension).</p>
</td>
</tr>
<tr>
<td>
<p>LegalCopyright</p>
</td>
<td>
<p><b>/copyright</b></p>
</td>
<td>
<p><b>System.Reflection.AssemblyCopyrightAttribute </b>.</p>
</td>
</tr>
<tr>
<td>
<p>LegalTrademarks</p>
</td>
<td>
<p><b>/trademark</b></p>
</td>
<td>
<p><b>System.Reflection.AssemblyTrademarkAttribute </b>.</p>
</td>
</tr>
<tr>
<td>
<p>OriginalFilename</p>
</td>
<td>
<p><b>/out</b></p>
</td>
<td>
<p>Set to the name of the output file (without a path).</p>
</td>
</tr>
<tr>
<td>
<p>PrivateBuild</p>
</td>
<td>
<p>(none)</p>
</td>
<td>
<p>Always blank.</p>
</td>
</tr>
<tr>
<td>
<p>ProductName</p>
</td>
<td>
<p><b>/product</b></p>
</td>
<td>
<p><b>System.Reflection.AssemblyProductAttribute </b>.</p>
</td>
</tr>
<tr>
<td>
<p>ProductVersion</p>
</td>
<td>
<p><b>/productversion</b></p>
</td>
<td>
<p><b>System.Reflection.</b></p>
<p><b>AssemblylnformationalVersionAttribute </b>.</p>
</td>
</tr>
<tr>
<td>
<p>SpecialBuild</p>
</td>
<td>
<p>(none)</p>
</td>
<td>
<p>Always blank.</p>
</td>
</tr>
</table>
<hr/>
<blockquote><b>Important </b>When you create a new C# project in Visual Studio, an AssemblyInfo.cs file is created automatically for you. This file contains all of the assembly version attributes described in this section, plus a few additional attributes that I'll cover in Chapter 3. You can simply open the AssemblyInfo.cs file and modify your assembly-specific information. Visual Studio also provides a dialog box that you can use to edit the assembly version information in this file. To see this dialog box, in Solution Explorer, double-click your project's Properties entry, and on the Application tab, click Assembly Information; you'll see a dialog box like the one shown in Figure 2-5.</blockquote>
<hr/>
<img src="14.jpg"/>
<p><b>Figure 2-5 </b>Visual Studio's Assembly Information dialog box</p>
<h3>Version Numbers</h3>
<p>In the previous section, you saw that several version numbers can be applied to an assembly All of these version numbers have the same format: each consists of four period-separated parts, as shown in Table 2-5.</p>
<p><b>Table 2-5 </b><b>Format of Version Numbers</b></p>
<table border="1">
<tr>
<td>
<p></p>
</td>
<td>
<p>Major Number</p>
</td>
<td>
<p>Minor Number</p>
</td>
<td>
<p>Build Number</p>
</td>
<td>
<p>Revision Number</p>
</td>
</tr>
<tr>
<td>
<p>Example:</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>719</p>
</td>
<td>
<p>2</p>
</td>
</tr>
</table>
<p>Table 2-5 shows an example of a version number: 2. 5.719.2. The first two numbers make up the public perception of the version. The public will think of this example as version 2.5 of the assembly. The third number, 719, indicates the build of the assembly. If your company builds its assembly every day, you should increment the build number each day as well. The last number, 2, indicates the revision of the build. If for some reason your company has to build an assembly twice in one day, maybe to resolve a hot bug that is halting other work, the revision number should be incremented.</p>
<p>Microsoft uses this version-numbering scheme, and it's highly recommended that you use this scheme as well. Future versions of the CLR will offer better support for loading new versions of an assembly and for rolling back to a previous version of an assembly if a new version actually breaks an existing application. To accomplish this versioning support, the CLR will expect that a version of an assembly that fixes one or more bugs will have the same major/minor version, and the build/revision numbers will indicate a servicing version containing the update(s). When loading an assembly, the CLR will automatically find the latest installed servicing version that matches the major/minor version of the assembly being requested.</p>
<p>You'll notice that an assembly has three version numbers associated with it. This is very unfortunate and leads to a lot of confusion Let me explain each version number's purpose and how it is expected to be used:</p>
<p>&#9632; AssemblyFileVersion   This version number is stored in the Win32 version resource. This number is for information purposes only; the CLR doesn't examine this version number in any way. Typically, you set the major and minor parts to represent the version you want the public to see. Then you increment the build and revision parts each time a build is performed. Ideally, Microsoft's tool (such as CSC.exe or AL.exe) would automatically update the build and revision numbers for you (based on the date and time when the build was performed), but unfortunately, they don't. This version number can be seen when using Windows Explorer and is typically used to identify a specific version of an assembly when troubleshooting a customer's system.</p>
<p>&#9632; AssemblylnformationalVersion   This version number is also stored in the Win32 version resource, and again, this number is for information purposes only; the CLR</p>
<p>doesn't examine or care about it in any way. This version number exists to indicate the version of the product that includes this assembly. For example, version 2. 0 of a product might contain several assemblies; one of these assemblies is marked as version 1.0 since it's a new assembly that didn't ship in version 1. 0 of the same product. Typically, you set the major and minor parts of this version number to represent the public version of your product. Then you increment the build and revision parts each time you package a complete product with all its assemblies.</p>
<p><b>&#9632;   AssemblyVersion   </b>This version number is stored in the AssemblyDef manifest metadata table. The CLR uses this version number when binding to strongly named assemblies (discussed in Chapter 3). This number is extremely important and is used to uniquely identify an assembly When starting to develop an assembly, you should set the major, minor, build, and revision numbers and shouldn't change them until you're ready to begin work on the next deployable version of your assembly. When you build an assembly, this version number of the referenced assembly is embedded in the AssemblyRef table's entry. This means that an assembly is tightly bound to a specific version of a referenced assembly</p>
<h2>Culture</h2>
<p>Like version numbers, assemblies also have a culture as part of their identity For example, I could have an assembly that is strictly for German, another assembly for Swiss German, another assembly for U.S. English, and so on. Cultures are identified via a string that contains a primary and a secondary tag (as described in RFC 1766). Table 2-6 shows some examples.</p>
<p><b>Table 2-6 </b><b>Examples of Assembly Culture Tags</b></p>
<table border="1">
<tr>
<td>
<p>g</p>
</td>
<td>
<p>g</p>
</td>
<td>
<p>e</p>
</td>
</tr>
<tr>
<td>
<p>de</p>
</td>
<td>
<p>(none)</p>
</td>
<td>
<p>German</p>
</td>
</tr>
<tr>
<td>
<p>de</p>
</td>
<td>
<p>AT</p>
</td>
<td>
<p>Austrian German</p>
</td>
</tr>
<tr>
<td>
<p>de</p>
</td>
<td>
<p>CH</p>
</td>
<td>
<p>Swiss German</p>
</td>
</tr>
<tr>
<td>
<p>en</p>
</td>
<td>
<p>(none)</p>
</td>
<td>
<p>English</p>
</td>
</tr>
<tr>
<td>
<p>en</p>
</td>
<td>
<p>GB</p>
</td>
<td>
<p>British English</p>
</td>
</tr>
<tr>
<td>
<p>en</p>
</td>
<td>
<p>US</p>
</td>
<td>
<p>U S English</p>
</td>
</tr>
</table>
<p>In general, if you create an assembly that contains code, you don't assign a culture to it. This is because code doesn't usually have any culture-specific assumptions built into it. An assembly that isn't assigned a culture is referred to as being culture neutral.</p>
<p>If you're designing an application that has some culture-specific resources to it, Microsoft highly recommends that you create one assembly that contains your code and your application's default (or fallback) resources. When building this assembly, don't specify a culture. This is the assembly that other assemblies will reference when they create and manipulate types it publicly exposes.</p>
<p>Now you can create one or more separate assemblies that contain only culture-specific resources溶o code at all. Assemblies that are marked with a culture are called satellite assemblies. For these satellite assemblies, assign a culture that accurately reflects the culture of the resources placed in the assembly. You should create one satellite assembly for each culture you intend to support.</p>
<p>You'll usually use the AL.exe tool to build a satellite assembly. You won't use a compiler because the satellite assembly should have no code contained within it. When using AL.exe, you specify the desired culture by using the <b>/c[ulture]:text </b>switch, where <b>text </b>is a string such as &quot;en-US,&quot; representing U.S. English. When you deploy a satellite assembly, you should place it in a subdirectory whose name matches the culture text. For example, if the application's base directory is <span>C:\MyApp</span>, the U.S. English satellite assembly should be placed in the <span>C:\MyApp\en-US</span> subdirectory. At runtime, you access a satellite assembly's resources by using the <b>System.Resources.ResourceManager </b>class.</p>
<p><b>I-</b></p>
<hr/>
<blockquote><b>Note </b>It is possible to create a satellite assembly that contains code, though this practice is discouraged. If you prefer, you can specify the culture by using the <b>System.Reflection. AssemblyCultureAttribute </b>custom attribute instead of using AL.exe's <b>/culture </b>switch, for example, as shown here:
<p><code>// Set assembly's culture to Swiss German [assembly:AssemblyCulture(''de-CH&quot;)]</code></p></blockquote>
<hr/>
<p>Normally, you shouldn't build an assembly that references a satellite assembly. In other words, an assembly's AssemblyRef entries should all refer to culture-neutral assemblies. If you want to access types or members contained in a satellite assembly, you should use reflection techniques as discussed in Chapter 23, &quot;Assembly Loading and Reflection.&quot;</p>
<a name="b59"/><h2>Simple Application Deployment (Privately Deployed Assemblies)</h2>
<p>Throughout this chapter, I've explained how you build modules and how you combine those modules into an assembly. At this point, I'm ready to explain how to package and deploy all of the assemblies so that users can run the application.</p>
<p>Assemblies don't dictate or require any special means of packaging. The easiest way to package a set of assemblies is simply to copy all of the files directly. For example, you could put all of the assembly files on a CD-ROM and ship it to the user with a batch file setup program that just copies the files from the CD to a directory on the user's hard drive. Because the assemblies include all of the dependent assembly references and types, the user can just run the application and the runtime will look for referenced assemblies in the application's directory. No modifications to the registry are necessary for the application to run. To uninstall the application, just delete all the files葉hat's it!</p>
<p>Of course, you can package and install the assembly files by using other mechanisms, such as.cab files (typically used for Internet download scenarios to compress files and reduce download times). You can also package the assembly files into an MSI file for use by the Windows Installer service (MSIExec.exe). Using MSI files allows assemblies to be installed on demand the first time the CLR attempts to load the assembly. This feature isn't new to MSI; it can perform the same demand-load functionality for unmanaged EXE and DLL files as well.</p>
<hr/>
<blockquote><b>Note </b>Using a batch file or some other simple &quot;installation software&quot; will get an application onto the user's machine; however, you'll need more sophisticated installation software to create shortcut links on the user's desktop and Start menu Also, you can easily back up and restore the application or move it from one machine to another, but the various shortcut links will require special handling.</blockquote>
<hr/>
<p>Of course, Visual Studio has a built-in mechanism that you can use to publish an application by displaying a project's Properties pages and clicking the Publish tab. You can use the options available on the Publish tab to cause Visual Studio to produce an MSI file and copy the resulting MSI file to a Web site, FTP server, or file path. The MSI file can also install any prerequisite components such as the .NET Framework or Microsoft SQL Server 2008 Express Edition. Finally, the application can automatically check for updates and install them on the user's machine by taking advantage of ClickOnce technology.</p>
<p>Assemblies deployed to the same directory as the application are called privately deployed assemblies because the assembly files aren't shared with any other application (unless the other application is also deployed to the same directory). Privately deployed assemblies are a big win for developers, end users, and administrators because they can simply be copied to an application's base directory, and the CLR will load them and execute the code in them. In addition, an application can be uninstalled by simply deleting the assemblies in its directory. This allows simple backup and restore as well.</p>
<p>This simple install/move/uninstall scenario is possible because each assembly has metadata indicating which referenced assembly should be loaded; no registry settings are required. In addition, the referencing assembly scopes every type. This means that an application always binds to the same type it was built and tested with; the CLR can't load a different assembly that just happens to provide a type with the same name. This is different from COM, in which types are recorded in the registry, making them available to any application running on the machine.</p>
<p>In Chapter 3, I'll discuss how to deploy shared assemblies that are accessible by multiple applications.</p>
<a name="b61"/><h2>Simple Administrative Control (Configuration)</h2>
<p>The user or the administrator can best determine some aspects of an application's execution For example, an administrator might decide to move an assembly's files on the user's hard disk or to override information contained in the assembly's manifest Other scenarios also exist related to versioning; I'll talk about some of these in Chapter 3.</p>
<p>To allow administrative control over an application, a configuration file can be placed in the application's directory. An application's publisher can create and package this file. The setup program would then install this configuration file in the application's base directory. In addition, the machine's administrator or an end user could create or modify this file. The CLR interprets the content of this file to alter its policies for locating and loading assembly files.</p>
<p>These configuration files contain Extensible Markup Language (XML) and can be associated with an application or with the machine. Using a separate file (vs.registry settings) allows the file to be easily backed up and also allows the administrator to copy the application to another machine曜ust copy the necessary files and the administrative policy is copied too.</p>
<p>In Chapter 3, we'll explore this configuration file in more detail. But I want to give you a taste of it now Let's say that the publisher of an application wants its application deployed with the JeffTypes assembly files in a different directory than the application's assembly file. The desired directory structure looks like this:</p>
<p><code>AppDir directory (contains the application's assembly files) Program.exe<br/>
Program.exe.config (discussed below)<br/>
AuxFiles subdirectory (contains JeffTypes' assembly files) JeffTypes.dll FUT.netmodule RUT.netmodule</code></p>
<p>Since the JeffTypes files are no longer in the application's base directory, the CLR won't be able to locate and load these files; running the application will cause a <b>System.IO.FileNotFoundException </b>exception to be thrown. To fix this, the publisher creates an XML configuration file and deploys it to the application's base directory. The name of this file must be the name of the application's main assembly file with a.config extension: Program.exe.config, for this example. The configuration file should look like this:</p>
<p><code>&lt;configuration&gt; &lt;runtime&gt;<br/>
&lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;<br/>
&lt;probing privatePath=&quot;AuxFiles&quot; /&gt; &lt;/assemblyBinding&gt; &lt;/runtime&gt; &lt;/configuration&gt;</code></p>
<p>Whenever the CLR attempts to locate an assembly file, it always looks in the application's directory first, and if it can't find the file there, it looks in the AuxFiles subdirectory. You can specify multiple semicolon-delimited paths for the probing element's <b>privatePath </b>attribute. Each path is considered relative to the application's base directory. You can't specify an absolute or a relative path identifying a directory that is outside of the application's base directory The idea is that an application can control its directory and its subdirectories but has no control over other directories.</p>
<p>s</p>
<p>When the CLR needs to locate an assembly, it scans several subdirectories. Here is the order in which directories are probed for a culture-neutral assembly (where <b>firstPrivatePath </b>and <b>secondPrivatePath </b>are specified via the config file's <b>privatePath </b>attribute):</p>
<p><code><span>AppDir\AsmName.dll</span><br/>
<span>AppDir\AsmName\AsmName.dll</span><br/>
<span>AppDir\firstPrivatePath\AsmName.dll</span><br/>
<span>AppDir\firstPrivatePath\AsmName\AsmName.dll</span> <b>I </b><span>AppDir\secondPrivatePath\AsmName.dll</span> <b>I </b><span>AppDir\secondPrivatePath\AsmName\AsmName.dll</span></code></p>
<p>In this example, no configuration file would be needed if the JeffTypes assembly files were deployed to a subdirectory called JeffTypes, since the CLR would automatically scan for a subdirectory whose name matches the name of the assembly being searched for.</p>
<p>If the assembly can't be found in any of the preceding subdirectories, the CLR starts all over, using an.exe extension instead of a.dll extension. If the assembly still can't be found, a <b>FileNotFoundException </b>is thrown.</p>
<p>For satellite assemblies, similar rules are followed except that the assembly is expected to be in a subdirectory, whose name matches the culture, of the application's base directory. For example, if AsmName.dll has a culture of &quot;en-US&quot; applied to it, the following directories are probed:</p>
<p><code><span>C:\AppDir\en-US\AsmName.dll</span> <b>I </b><span>C:\AppDir\en-US\AsmName\AsmName.dll</span><br/>
<span>C:\AppDir\firstPrivatePath\en-US\AsmName.dll</span> <b>I </b><span>C:\AppDir\firstPrivatePath\en-US\AsmName\AsmName.dll</span><br/>
<span>C:\AppDir\secondPrivatePath\en-US\AsmName.dll</span> <b>I </b><span>C:\AppDir\secondPrivatePath\en-US\AsmName\AsmName.dll</span></code></p>
<p>I <span>C:\AppDir\en-US\AsmName.exe</span></p>
<p><code><span>C:\AppDir\en-US\AsmName\AsmName.exe</span> <b>I </b><span>C:\AppDir\firstPrivatePath\en-US\AsmName.exe</span><br/>
<span>C:\AppDir\firstPrivatePath\en-US\AsmName\AsmName.exe</span> <b>I </b><span>C:\AppDir\secondPrivatePath\en-US\AsmName.exe</span><br/>
<span>C:\AppDir\secondPrivatePath\en-US\AsmName\AsmName.exe</span><br/>
<span>C:\AppDir\en\AsmName.dll</span> <span>C:\AppDir\en\AsmName\AsmName.dll</span> <span>C:\AppDir\firstPrivatePath\en\AsmName.dll</span> <span>C:\AppDir\firstPrivatePath\en\AsmName\AsmName.dll</span> <span>C:\AppDir\secondPrivatePath\en\AsmName.dll</span> <b>I </b><span>C:\AppDir\secondPrivatePath\en\AsmName\AsmName.dll</span><br/>
<span>C:\AppDir\en\AsmName.exe</span> <b>I </b><span>C:\AppDir\en\AsmName\AsmName.exe</span><br/>
<span>C:\AppDir\firstPrivatePath\en\AsmName.exe</span><br/>
<span>C:\AppDir\firstPrivatePath\en\AsmName\AsmName.exe</span><br/>
<span>C:\AppDir\secondPrivatePath\en\AsmName.exe</span> <b>I </b><span>C:\AppDir\secondPrivatePath\en\AsmName\AsmName.exe</span></code></p>
<p>As you can see, the CLR probes for files with either an.exe or.dll file extension. Since probing can be very time-consuming (especially when the CLR is looking for files over a network), in the XML configuration file, you can specify one or more <b>culture </b>elements to limit the probing that the CLR performs when looking for satellite assemblies.</p>
<p>The name and location of this XML configuration file is different depending on the application type:</p>
<p>&#9632; For executable applications (EXEs), the configuration file must be in the application's base directory, and it must be the name of the EXE file with &quot;.config&quot; appended to it.</p>
<p>&#9632; For Microsoft ASP.NET Web Form applications, the file must be in the Web application's virtual root directory and is always named Web.config. In addition, subdirectories can also contain their own Web.config file, and the configuration settings are inherited.</p>
<p>For example, a Web application located at <a href="http://Wintellect.com/Training">http://Wintellect.com/Training</a> would use the settings in the Web.config files contained in the virtual root directory and in its Training subdirectory.</p>
<p>As mentioned at the beginning of this section, configuration settings apply to a particular application and to the machine When you install the NET Framework, it creates a Machine.config file. There is one Machine.config file per version of the CLR you have installed on the machine.</p>
<p>The Machine.config file is located in the following directory: %SystemRoot%\Microsoft.NET\Framework\version\CONFIG</p>
<p>Of course, %SystemRoot% identifies your Windows directory (usually <span>C:\WINDOWS</span>), and version is a version number identifying a specific version of the .NET Framework (something like v4. 0. #####).</p>
<p>Settings in the Machine.config file represent default settings that affect all applications running on the machine. An administrator can create a machine-wide policy by modifying the single Machine.config file. However, administrators and users should avoid modifying this file because it contains many settings related to various things, making it much more difficult to navigate Plus, you want the application's settings to be backed up and restored, and keeping an application's settings in the application-specific configuration file enables this.</p>
<mbp:pagebreak/>
<a name="Chapter3"/>
<h1>Chapter 3: Shared Assemblies and Strongly Named Assemblies</h1>
<p><b>In this chapter:</b></p>
<a href="#b66">Two Kinds of Assemblies, Two Kinds of Deployment</a><br/>
<a href="#b67">Giving an Assembly a Strong Name</a><br/>
<a href="#b75">Building an Assembly That References a Strongly Named Assembly</a><br/>
<a href="#b76">Strongly Named Assemblies Are Tamper-Resistant</a><br/>
<a href="#b80">Privately Deploying Strongly Named Assemblies</a><br/>
<a href="#b81">How the Runtime Resolves Type References</a><br/>
<a href="#b84">Advanced Administrative Control (Configuration)</a><br/>
<p>In Chapter 2, &quot;Building, Packaging, Deploying, and Administering Applications and Types,&quot; I talked about the steps required to build, package, and deploy an assembly. I focused on what's called private deployment, in which assemblies are placed in the application's base directory (or a subdirectory thereof) for the application's sole use Deploying assemblies privately gives a company a large degree of control over the naming, versioning, and behavior of the assembly.</p>
<p>In this chapter, I'll concentrate on creating assemblies that can be accessed by multiple applications The assemblies that ship with the Microsoft NET Framework are an excellent example of globally deployed assemblies, because all managed applications use types defined by Microsoft in the .NET Framework Class Library (FCL).</p>
<p>As I mentioned in Chapter 2, Microsoft Windows has a reputation for being unstable The main reason for this reputation is the fact that applications are built and tested using code implemented by someone else. After all, when you write an application for Windows, your application is calling into code written by Microsoft developers. Also, a large number of companies make controls that application developers can incorporate into their own applications. In fact, the .NET Framework encourages this, and many control vendors have appeared over time.</p>
<p>As time marches on, Microsoft developers and control developers modify their code: they fix bugs, patch security flaws, add features, and so on. Eventually, the new code makes its way onto the user's machine. The user's applications that were previously installed and working fine are no longer using the same code that the applications were built and tested with. As a result, the applications' behavior is no longer predictable, which contributes to the instability of Windows.</p>
<p>File versioning is a very difficult problem to solve. In fact, I assert that if you take a file that is used by other code files and change just one bit in the file幼hange a 0 to a 1 or a 1 to a 0葉here's absolutely no way to guarantee that code that used the file before it was changed will now work just as well if it uses the new version of the file. One of the reasons why this statement is true is that a lot of applications exploit bugs, either knowingly or unknowingly. If a later version of a file fixes a bug, the application no longer runs as expected.</p>
<p>So here's the problem: How do you fix bugs and add features to a file and also guarantee that you don't break some application? I've given this question a lot of thought and have come to one conclusion: It's just not possible But, obviously, this answer isn't good enough Files will ship with bugs, and companies will always want to provide new features. There must be a way to distribute new files with the hope that the applications will work just fine. And if the application doesn't work fine, there has to be an easy way to restore the application to its last-known good state.</p>
<p>In this chapter, I'll explain the infrastructure that the .NET Framework has in place to deal with versioning problems. Let me warn you: What I'm about to describe is complicated. I'm going to talk about a lot of algorithms, rules, and policies that are built into the common language runtime (CLR). I'm also going to mention a lot of tools and utilities that the application developer must use. This stuff is complicated because, as I've mentioned, the versioning problem is difficult to address and to solve.</p>
<a name="b66"/><h2>Two Kinds of Assemblies, Two Kinds of Deployment</h2>
<p>The CLR supports two kinds of assemblies: weakly named assemblies and strongly named assemblies.</p>
<hr/>
<blockquote><b>Important </b>By the way, you won't find the term weakly named assembly in any of the .NET Framework documentation Why? Because I made it up In fact, the documentation has no term to identify a weakly named assembly I decided to coin the term so that I can talk about assemblies without any ambiguity as to what kind of assembly I'm referring to.</blockquote>
<hr/>
<p>Weakly named assemblies and strongly named assemblies are structurally identical葉hat is, they use the same portable executable (PE) file format, PE32(+) header, CLR header, metadata, manifest tables, and Intermediate Language (IL) that we examined in Chapter 1, &quot;The CLR's Execution Model,&quot; and Chapter 2. And you use the same tools, such as the C# compiler and AL.exe, to build both kinds of assemblies. The real difference between weakly named and strongly named assemblies is that a strongly named assembly is signed with a publisher's public/private key pair that uniquely identifies the assembly's publisher. This key pair allows the assembly to be uniquely identified, secured, and versioned, and it allows the assembly to be deployed anywhere on the user's machine or even on the Internet. This ability to uniquely identify an assembly allows the CLR to enforce certain known-to-be-safe policies when an application tries to bind to a strongly named assembly. This chapter is dedicated to explaining what strongly named assemblies are and what policies the CLR applies to them.</p>
<p>An assembly can be deployed in two ways: privately or globally. A privately deployed assembly is an assembly that is deployed in the application's base directory or one of its subdirectories. A weakly named assembly can be deployed only privately. I talked about privately deployed assemblies in Chapter 2. A globally deployed assembly is an assembly that is deployed into some well-known location that the CLR looks in when it's searching for the assembly. A strongly named assembly can be deployed privately or globally. I'll explain how to create and deploy strongly named assemblies in this chapter. Table 3-1 summarizes the kinds of assemblies and the ways that they can be deployed.</p>
<p><b>Table 3-1 </b><b>How Weakly and Strongly Named Assemblies Can Be Deployed</b></p>
<table border="1">
<tr>
<td>
<p>Kind of Assembly</p>
</td>
<td>
<p>Can Be Privately Deployed</p>
</td>
<td>
<p>Can Be Globally Deployed</p>
</td>
</tr>
<tr>
<td>
<p>Weakly named</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<p>Strongly named</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
</table>
<p>Note   It is highly recommended that you strongly name all of your assemblies In fact, it is likely that future versions of the CLR will require all assemblies to be strongly named, and the ability to create weakly named assemblies will be deprecated. Weakly named assemblies are a problem because it is possible to have several different assemblies all with the same weak name. On the other hand, giving an assembly a strong name uniquely identifies that assembly. If the CLR can uniquely identify an assembly, it can apply more policies to it related to versioning or backward compatibility. It is Microsoft's plan to endow future versions of the CLR with these policies to make versioning simpler. In fact, just eliminating the ability to make weakly named assemblies makes understanding the CLR's versioning policies simpler.</p>
<a name="b67"/><h2>Giving an Assembly a Strong Name</h2>
<p>If multiple applications are going to access an assembly, the assembly must be placed in a well-known directory, and the CLR must know to look in this directory automatically when a reference to the assembly is detected. However, we have a problem: Two (or more) companies could produce assemblies that have the same file name. Then, if both of these assemblies get copied into the same well-known directory, the last one installed wins, and all of the applications that were using the old assembly no longer function as desired. (This is exactly why DLL hell exists today in Windows, in which shared DLLs are all just copied into the System32 directory.</p>
<p>Obviously, differentiating assemblies simply by using a file name isn't good enough. The CLR needs to support some mechanism that allows assemblies to be uniquely identified. This is what the term strongly named assembly refers to. A strongly named assembly consists of four attributes that uniquely identify the assembly: a file name (without an extension), a version number, a culture identity, and a public key. Since public keys are very large numbers, we frequently use a small hash value derived from a public key. This hash value is called a public key token. The following assembly identity strings (sometimes called an assembly display name) identify four completely different assembly files:</p>
<p><code>&quot;MyTypes, Version=1.0.8123.0, Culture=neutra1, PublicKeyToken=b77a5c561934e089&quot;<br/>
&quot;MyTypes, Version=1.0.8123.0, Culture=&quot;en-US&quot;, PublicKeyToken=b77a5c561934e089&quot;<br/>
&quot;MyTypes, Version=2.0.1234.0, Culture=neutra1, PublicKeyToken=b77a5c561934e089&quot;<br/>
&quot;MyTypes, Version=1.0.8123.0, Culture=neutra1, PublicKeyToken=b03f5f7flld50a3a&quot;</code></p>
<p>The first string identifies an assembly file called MyTypes.exe or MyTypes.dll (you can't actually determine the file extension from an assembly identity string). The company producing the assembly is creating version 1. 0.8123. 0 of this assembly, and nothing in the assembly is sensitive to any one culture because <b>Culture </b>is set to <b>neutral. </b>Of course, any company could produce a MyTypes.dll (or MyTypes.exe) assembly file that is marked with a version number of 1 0 8123 0 and a neutral culture.</p>
<p>There must be a way to distinguish this company's assembly from another company's assembly that happens to have the same attributes. For several reasons, Microsoft chose to use standard public/private key cryptographic technologies instead of any other unique identification technique such as GUIDs, URLs, or URNs. Specifically, cryptographic techniques provide a way to check the integrity of the assembly's bits as they are installed on a machine, and they also allow permissions to be granted on a per-publisher basis. I'll discuss these techniques later in this chapter. So a company that wants to uniquely mark its assemblies must create a public/private key pair. Then the public key can be associated with the assembly. No two companies should have the same public/private key pair, and this distinction is what allows two companies to create assemblies that have the same name, version, and culture without causing any conflict.</p>
<hr/>
<blockquote><b>Note </b>The <b>System.Reflection.AssemblyName </b>class is a helper class that makes it easy for you to build an assembly name and to obtain the various parts of an assembly's name The class offers several public instance properties, such as <b>Culturelnfo, FullName, KeyPair, Name, </b>and <b>Version </b>. The class also offers a few public instance methods, such as <b>GetPublicKey, GetPublicKeyToken, SetPublicKey, </b>and <b>SetPublicKeyToken </b>.</blockquote>
<hr/>
<p>In Chapter 2, I showed you how to name an assembly file and how to apply an assembly version number and a culture. A weakly named assembly can have assembly version and culture attributes embedded in the manifest metadata; however, the CLR always ignores the version number and uses only the culture information when it's probing subdirectories looking for the satellite assembly. Because weakly named assemblies are always privately deployed, the CLR simply uses the name of the assembly (tacking on a.dll or an.exe extension) when searching for the assembly's file in the application's base directory or in any of the application's subdirectories specified in the Extensible Markup Language (XML) configuration file's probing element's <b>privatePath </b>XML attribute.</p>
<p>A strongly named assembly has a file name, an assembly version, and a culture. In addition, a strongly named assembly is signed with the publisher's private key.</p>
<p>The first step in creating a strongly named assembly is to obtain a key by using the Strong Name utility, SN.exe, that ships with the .NET Framework SDK and Microsoft Visual Studio. This utility offers a whole slew of features depending on the command-line switch you specify Note that all SN exe's command-line switches are case-sensitive To generate a public/private key pair, you run SN exe as follows:</p>
<p><code>SN -k MyCompany.snk</code></p>
<p>This line tells SN.exe to create a file called MyCompany.snk. This file will contain the public and private key numbers persisted in a binary format.</p>
<p>Public key numbers are very big. If you want to, after creating the file that contains the public and private key, you can use the SN.exe utility again to see the actual public key. To do this, you must execute the SN.exe utility twice. First, you invoke SN.exe with the <b>-p </b>switch to create a file that contains only the public key (MyCompany.PublicKey):</p>
<p><code>SN -p MyCompany.snk MyCompany.PublicKey</code></p>
<p>Then, you invoke SN.exe, passing it the <b>-tp </b>switch and the file that contains just the public key:</p>
<p><code>SN -tp MyCompany.PublicKey</code></p>
<p>When I execute this line, I get the following output:</p>
<p><code>Microsoft (R).NET Framework Strong Name Utility   Version 4.0.20928.1 Copyright (c) Microsoft Corporation.   All rights reserved.<br/>
Public key is<br/>
002400000480000094000000060200000024000052 53413100040000010001003f9d621b702111 850be453b92bd6a58c020eb7b804f75d67ab302047fc786ffa3797b669215afb4d814a6f294010 b233bac0b8c8098ba809855da2 56d964c0d07f16463d918d651a4846a62317328cac893626a550 69f21a12 5bc03193261176dd629eace6c90d36858de3fcb781bfc8b817936a567cad608ae672b6<br/>
1fb80eb0<br/>
Public key token is 3db32f38c8b42c9a</code></p>
<p>The SN.exe utility doesn't offer any way for you to display the private key.</p>
<p>The size of public keys makes them difficult to work with. To make things easier for the developer (and for end users too), public key tokens were created. A public key token is a 64-bit hash of the public key SN exe's <b>-tp </b>switch shows the public key token that corresponds to the complete public key at the end of its output.</p>
<p>Now that you know how to create a public/private key pair, creating a strongly named assembly is simple. When you compile your assembly, you use the <b>/keyfile:&lt;file&gt; </b>compiler switch:</p>
<p><code>csc /keyfileiMyCompany.snk Program.cs</code></p>
<p>When the C# compiler sees this switch, the compiler opens the specified file (MyCompany.snk), signs the assembly with the private key, and embeds the public key in the manifest. Note that you sign only the assembly file that contains the manifest; the assembly's other files can't be signed explicitly.</p>
<p>If you are using Visual Studio, you can create a new public/private key file by displaying the properties for your project, clicking the Signing tab, selecting the Sign The Assembly check box, and then choosing the &lt;New...&gt; option from the Choose A Strong Name Key File combo box</p>
<p>Here's what it means to sign a file: When you build a strongly named assembly, the assembly's FileDef manifest metadata table includes the list of all the files that make up the assembly. As each file's name is added to the manifest, the file's contents are hashed, and this hash value is stored along with the file's name in the FileDef table. You can override the default hash algorithm used with AL.exe's <b>/algid </b>switch or apply the assembly-level <b>System.Reflection.AssemblyAlgorithmldAttribute </b>custom attribute in one of the assembly's source code files. By default, a SHA-1 algorithm is used, and this should be sufficient for almost all applications.</p>
<p>After the PE file containing the manifest is built, the PE file's entire contents (except for any Authenticode Signature, the assembly's strong name data, and the PE header checksum) are hashed, as shown in Figure 3-1. The hash algorithm used here is always SHA-1 and can't be overridden This hash value is signed with the publisher's private key, and the resulting RSA digital signature is stored in a reserved section (not included in the hash) within the PE file. The CLR header of the PE file is updated to reflect where the digital signature is embedded within the file.</p>
<p><b>Figure 3-1 </b>Signing an assembly</p>
<p>The publisher's public key is also embedded into the AssemblyDef manifest metadata table in this PE file. The combination of the file name, the assembly version, the culture, and the public key gives this assembly a strong name, which is guaranteed to be unique. There is no way that two companies could each produce an assembly named OurLibrary with the same public/private keys unless the companies share this key pair with each other.</p>
<p>At this point, the assembly and all of its files are ready to be packaged and distributed.</p>
<p>As described in Chapter 2, when you compile your source code, the compiler detects the types and members that your code references. You must specify the referenced assemblies to the compiler For the C# compiler, you use the <b>/reference </b>compiler switch. Part of the compiler's job is to emit an AssemblyRef metadata table inside the resulting managed module. Each entry in the AssemblyRef metadata table indicates the referenced assembly's name (without path and extension), version number, culture, and public key information.</p>
<hr/>
<blockquote><b>Important </b>Because public keys are such large numbers, and a single assembly might reference many assemblies, a large percentage of the resulting file's total size would be occupied with public key information To conserve storage space, Microsoft hashes the public key and takes the last 8 bytes of the hashed value. These reduced public key values楊nown as public key tokens預re what are actually stored in an AssemblyRef table. In general, developers and end users will see public key token values much more frequently than full public key values.</blockquote>
<hr/>
<p>Note, however, that the CLR never uses public key tokens when making security or trust decisions because it is possible that several public keys could hash to a single public key token.</p>
<p>The AssemblyRef metadata information (obtained by using ILDasm.exe) for the JeffTypes.dll file that I discussed in Chapter 2 is shown here:</p>
<img src="15.jpg"/>
<p><code>AssemblyRef #1 (23000001) Token: 0x23000001<br/>
Public Key or Token: b7 7a 5c 56 19 34 e0 89<br/>
Name: mscorlib<br/>
Version: 4.0.0.0<br/>
Major Version: 0x00000004<br/>
Minor Version: 0x00000000<br/>
Build Number: 0x00000000<br/>
Revision Number: 0x00000000<br/>
Locale: &lt;nu11&gt;<br/>
HashValue Blob:<br/>
Flags: [none] (00000000)</code></p>
<p>From this, you can see that JeffTypes dll references a type that is contained in an assembly matching the following attributes:</p>
<p><code>&quot;MSCorLib, Version=4.0.0.0, Culture=neutra1, PublicKeyToken=b77a5c561934e089&quot; Unfortunately, ILDasm. exe uses the term Locale when it really should be using Culture. If you look at JeffTypes dll's AssemblyDef metadata table, you see the following: Assembly<br/>
Token: 0x20000001<br/>
Name : JeffTypes<br/>
Public Key :<br/>
Hash Algorithm : 0x00008004<br/>
Version: 3.0.0.0<br/>
Major Version: 0x00000003<br/>
Minor Version: 0x00000000<br/>
Build Number: 0x00000000<br/>
Revision Number: 0x00000000<br/>
Locale: &lt;nu11&gt;<br/>
Flags : [none] (00000000)</code></p>
<p>This is equivalent to the following:</p>
<p><code>&quot;JeffTypes, Version=3.0.0.0, Culture=neutra1, PublicKeyToken=nu11&quot;</code></p>
<p>In this line, no public key token is specified because in Chapter 2, the JeffTypes.dll assembly wasn't signed with a public/private key pair, making it a weakly named assembly. If I had used SN.exe to create a key file compiled with the <b>/keyfile </b>compiler switch, the resulting assembly would have been signed. If I had then used ILDasm.exe to explore the new assembly's metadata, the AssemblyDef entry would have bytes appearing after the Public Key field, and the assembly would be strongly named. By the way, the AssemblyDef entry always stores the full public key, not the public key token. The full public key is necessary to ensure that the file hasn't been tampered with. I'll explain the tamper resistance of strongly named assemblies later in this chapter.</p>
<h2>The Global Assembly Cache</h2>
<p>Now that you know how to create a strongly named assembly, it's time to learn how to deploy this assembly and how the CLR uses the information to locate and load the assembly.</p>
<p>If an assembly is to be accessed by multiple applications, the assembly must be placed into a well-known directory, and the CLR must know to look in this directory automatically when a reference to the assembly is detected. This well-known location is called the global assembly cache (GAC), which can usually be found in the following directory (assuming that Windows is installed in the <span>C:\Windows</span> directory):</p>
<p><code><span>C:\Windows\Assembly</span></code></p>
<p>The GAC directory is structured: It contains many subdirectories, and an algorithm is used to generate the names of these subdirectories. You should never manually copy assembly files into the GAC; instead, you should use tools to accomplish this task. These tools know the GAC's internal structure and how to generate the proper subdirectory names.</p>
<p>While developing and testing, the most common tool for installing a strongly named assembly into the GAC is GACUtil.exe. Running this tool without any command-line arguments yields the following usage:</p>
<p><code>Microsoft (R).NET Global Assembly Cache Utility.   Version 4.0.20928.1 Copyright (c) Microsoft Corporation.   All rights reserved.<br/>
Usage: Gacutil &lt;command&gt; [ &lt;options&gt; ] Commands:<br/>
/i &lt;assembly_path&gt; [ /r &lt;...&gt; ] [ /f ]<br/>
Installs an assembly to the global assembly cache.<br/>
/il &lt;assembly_path_list_file&gt; [ /r &lt;...&gt; ] [ /f ]<br/>
Installs one or more assemblies to the global assembly cache.<br/>
/u &lt;assembly_display_name&gt; [ /r &lt;...&gt; ]<br/>
Uninstalls an assembly from the global assembly cache.<br/>
/ul &lt;assembly_display_name_list_file&gt; [ /r &lt;...&gt; ]<br/>
Uninstalls one or more assemblies from the global assembly cache.<br/>
/l [ &lt;assembly_name&gt; ]<br/>
List the global assembly cache filtered by &lt;assembly_name&gt;<br/>
/1r [ &lt;assembly_name&gt; ]<br/>
List the global assembly cache with all traced references.<br/>
/cdl<br/>
Deletes the contents of the download cache<br/>
/ldl<br/>
Lists the contents of the download cache<br/>
/?<br/>
Displays a detailed help screen Options:<br/>
/r &lt;reference_scheme&gt; &lt;reference_id&gt; &lt;description&gt;<br/>
Specifies a traced reference to install (/i, /il) or uninstall (/u, /ul).<br/>
/f<br/>
Forces reinstall of an assembly. /nologo<br/>
Suppresses display of the logo banner /silent<br/>
Suppresses display of all output</code></p>
<p>As you can see, you can invoke GACUtil exe, specifying the <b>/i </b>switch to install an assembly into the GAC, and you can use GACUtil.exe's <b>/u </b>switch to uninstall an assembly from the GAC. Note that you can't ever place a weakly named assembly into the GAC. If you pass the file name of a weakly named assembly to GACUtil.exe, it displays the following error message: <b>&quot;Failure adding assembly to the cache: Attempt to install an assembly without a strong name.&quot;</b></p>
<hr/>
<blockquote><b>Note </b>By default, the GAC can be manipulated only by a user belonging to the Windows Administrators group GACUtil exe will fail to install or uninstall an assembly if the user invoking the execution of the utility isn't a member of this group.</blockquote>
<hr/>
<p>Using GACUtil.exe's <b>/i </b>switch is very convenient for developer testing. However, if you use GACUtil.exe to deploy an assembly in a production environment, it's recommended that you use GACUtil exe's <b>/r </b>switch in addition to specifying the <b>/i </b>or <b>/u </b>switch to install or uninstall the assembly. The <b>/r </b>switch integrates the assembly with the Windows install and uninstall engine. Basically, it tells the system which application requires the assembly and then ties the application and the assembly together.</p>
<hr/>
<blockquote><b>Note </b>If a strongly named assembly is packaged in a cabinet (.cab) file or is compressed in some way, the assembly's file must first be decompressed to temporary file(s) before you use GACUtil.exe to install the assembly's files into the GAC. Once the assembly's files have been installed, the temporary file(s) can be deleted.</blockquote>
<hr/>
<p>The GACUtil.exe tool doesn't ship with the end-user .NET Framework redistributable package. If your application includes some assemblies that you want deployed into the GAC, you should use the Windows Installer (MSI), because MSI is the only tool that is guaranteed to be on end-user machines and capable of installing assemblies into the GAC.</p>
<hr/>
<blockquote><b>Important </b>Globally deploying assembly files into the GAC is a form of registering the assembly, although the actual Windows registry isn't affected in any way Installing assemblies into the GAC breaks the goal of simple application installation, backup, restore, moving, and uninstall So it is recommended that you avoid global deployment and use private deployment whenever possible.</blockquote>
<hr/>
<p>What is the purpose of &quot;registering&quot; an assembly in the GAC? Well, say two companies each produce an OurLibrary assembly consisting of one file: OurLibrary.dll. Obviously, both of these files can't go in the same directory because the last one installed would overwrite the first one, surely breaking some application. When you install an assembly into the GAC, dedicated subdirectories are created under the <span>C:\Windows\Assembly</span> directory, and the assembly files are copied into one of these subdirectories.</p>
<p>Normally, no one examines the GAC's subdirectories, so the structure of the GAC shouldn't really matter to you. As long as the tools and the CLR know the structure, all is good.</p>
<a name="b75"/><h2>Building an Assembly That References a Strongly Named Assembly</h2>
<p>Whenever you build an assembly, the assembly will have references to other strongly named assemblies. This is true because <b>System.Object </b>is defined in MSCorLib.dll, which is strongly named. However, it's likely that an assembly will reference types in other strongly named assemblies published either by Microsoft, a third party, or your own organization. In Chapter 2, I showed you how to use CSC.exe's <b>/reference </b>compiler switch to specify the assembly file names you want to reference. If the file name is a full path, CSC.exe loads the specified file and uses its metadata information to build the assembly. As mentioned in Chapter 2, if you specify a file name without a path, CSC.exe attempts to find the assembly by looking in the following directories (in order of their presentation here):</p>
<p><b>1. </b>Working directory.</p>
<p><b>2. </b>The directory that contains the CSC.exe file itself. This directory also contains the CLR DLLs.</p>
<p><b>3. </b>Any directories specified using the <b>/lib </b>compiler switch.</p>
<p><b>4. </b>Any directories specified using the LIB environment variable.</p>
<p>So if you're building an assembly that references Microsoft's System.Drawing.dll, you can specify the <b>/reference:System.Drawing.dll </b>switch when invoking CSC.exe. The compiler will examine the directories shown earlier and will find the System.Drawing.dll file in the directory that contains the CSC.exe file itself, which is the same directory that contains the DLLs for the version of the CLR the compiler is tied to. Even though this is the directory where the assembly is found at compile time, this isn't the directory where the assembly will be loaded from at runtime.</p>
<p>You see, when you install the .NET Framework, two copies of Microsoft's assembly files are actually installed. One set is installed into the compiler/CLR directory, and another set is installed into a GAC subdirectory. The files in the compiler/CLR directory exist so that you can easily build your assembly, whereas the copies in the GAC exist so that they can be loaded at runtime.</p>
<p>The reason that CSC exe doesn't look in the GAC for referenced assemblies is that you'd have to know the path to the assembly file and the structure of the GAC is undocumented. Alternatively, CSC.exe could allow you to specify a still long but slightly nicer-looking string, such as &quot;System.Drawing, Version=v4. 0. 0. 0, Culture=neutral, PublicKeyToken=b03f5f7flld50a3a.&quot; Both of these solutions were deemed worse than having the assembly files installed twice on the user's hard drive.</p>
<hr/>
<blockquote><b>Note </b>When building an assembly, you may want to refer to another assembly that has an x86 as well as an x64 version of itself available. Fortunately, the GAC subdirectories can actually hold an x86 and an x64 version of the same assembly However, since the assemblies have the same file name, you cannot have different versions of these assemblies in the compiler/CLR directory. However, it shouldn't matter When you install the NET Framework on a machine, the x86, x64, or IA64 version of the assemblies are installed in the compiler/CLR directory When you build an assembly, you can reference whatever version of the files were installed because all of the versions contain identical metadata and differ only by their code. At runtime, the proper version of the assembly will be loaded from the GAC. I'll discuss how the CLR determines where to load the assembly from at runtime later in this chapter.</blockquote>
<hr/>
<a name="b76"/><h2>Strongly Named Assemblies Are Tamper-Resistant</h2>
<p>Signing an assembly with a private key ensures that the holder of the corresponding public key produced the assembly. When the assembly is installed into the GAC, the system hashes the contents of the file containing the manifest and compares the hash value with the RSA digital signature value embedded within the PE file (after unsigning it with the public key). If the values are identical, the file's contents haven't been tampered with, and you know that you have the public key that corresponds to the publisher's private key. In addition, the system hashes the contents of the assembly's other files and compares the hash values with the hash values stored in the manifest file's FileDef table. If any of the hash values don't match, at least one of the assembly's files has been tampered with, and the assembly will fail to install into the GAC.</p>
<hr/>
<blockquote><b>Important </b>This mechanism ensures only that a file's content hasn't been tampered with. The mechanism doesn't allow you to tell who the publisher is unless you're absolutely positive that the publisher produced the public key you have and you're sure that the publisher's private key was never compromised. Another way to know the identity of the publisher is if the publisher associated its identity with the assembly by using Microsoft's Authenticode technology.</blockquote>
<hr/>
<p>When an application needs to bind to an assembly, the CLR uses the referenced assembly's properties (name, version, culture, and public key) to locate the assembly in the GAC. If the referenced assembly can be found, its containing subdirectory is returned, and the file holding the manifest is loaded. Finding the assembly this way assures the caller that the assembly loaded at runtime came from the same publisher that built the assembly the code was compiled against. This assurance is possible because the public key token in the referencing assembly's AssemblyRef table corresponds to the public key in the referenced assembly's AssemblyDef table. If the referenced assembly isn't in the GAC, the CLR looks in the application's base directory and then in any of the private paths identified in the application's configuration file; then, if the application was installed using MSI, the CLR asks MSI to locate the assembly. If the assembly can't be found in any of these locations, the bind fails, and a <b>System.IO.FileNotFoundException </b>is thrown.</p>
<p>When strongly named assembly files are loaded from a location other than the GAC (via the application's base directory or via a <b>codeBase </b>element in a configuration file), the CLR compares hash values when the assembly is loaded. In other words, a hash of the file is performed every time an application executes and loads the assembly. This performance hit is a tradeoff for being certain that the assembly file's content hasn't been tampered with. When the CLR detects mismatched hash values at runtime, it throws a <b>System.IO.FileLoadException </b>.</p>
<hr/>
<blockquote><b>Note </b>When a strongly named assembly is installed in the GAC, the system ensures that the file containing the manifest hasn't been tampered with. This check occurs only once, at installation time. In addition, to improve performance, the CLR does not check if a strongly named assembly has been tampered with if the assembly is fully trusted and is being loaded into a fully trusted AppDomain On the other hand, when a strongly named assembly is loaded from a directory other than the GAC, the CLR verifies the assembly's manifest file to ensure that the file's contents have not been tampered with, causing an additional performance hit every time this file is loaded.</blockquote>
<hr/>
<h2>Delayed Signing</h2>
<p>Earlier in this chapter, I discussed how the SN.exe tool can produce public/private key pairs. This tool generates the keys by making calls into the Crypto API provided by Windows. These keys can be stored in files or other storage devices. For example, large organizations (such as Microsoft) will maintain the returned private key in a hardware device that stays locked in a vault; only a few people in the company have access to the private key. This precaution prevents the private key from being compromised and ensures the key's integrity. The public key is, well, public and freely distributed.</p>
<p>When you're ready to package your strongly named assembly, you'll have to use the secure private key to sign it. However, while developing and testing your assembly, gaining access to the secure private key can be a hassle For this reason, the NET Framework supports delayed signing, sometimes referred to as partial signing. Delayed signing allows you to build an assembly by using only your company's public key; the private key isn't necessary. Using the public key allows assemblies that reference your assembly to embed the correct public key value in their AssemblyRef metadata entries. It also allows the assembly to be placed in the GAC appropriately. If you don't sign the file with your company's private key, you lose all of the tampering protection afforded to you because the assembly's files won't be hashed, and a digital signature won't be embedded in the file. This loss of protection shouldn't be a problem, however, because you use delayed signing only while developing your own assembly, not when you're ready to package and deploy the assembly.</p>
<p>Basically, you get your company's public key value in a file and pass the file name to whatever utility you use to build the assembly (As I have shown earlier in this chapter, you can use SN.exe's <b>-p </b>switch to extract a public key from a file that contains a public/private key pair.) You must also tell the tool that you want the assembly to be delay signed, meaning that you're not supplying a private key. For the C# compiler, you do this by specifying the <b>/delaysign </b>compiler switch. In Visual Studio, you display the properties for your project, click the Signing tab, and then select the Delay Sign Only check box. If you're using AL.exe, you can specify the <b>/delay[sign] </b>command-line switch.</p>
<p>When the compiler or AL.exe detects that you're delay signing an assembly, it will emit the assembly's AssemblyDef manifest entry, which will contain the assembly's public key Again, the presence of the public key allows the assembly to be placed in the GAC. It also allows you to build other assemblies that reference this assembly; the referencing assemblies will have the correct public key in their AssemblyRef metadata table entries. When creating the resulting assembly, space is left in the resulting PE file for the RSA digital signature. (The utility can determine how much space is necessary from the size of the public key.) Note that the file's contents won't be hashed at this time either.</p>
<p>At this point, the resulting assembly doesn't have a valid signature. Attempting to install the assembly into the GAC will fail because a hash of the file's contents hasn't been done葉he file appears to have been tampered with. On every machine on which the assembly needs to be installed into the GAC, you must prevent the system from verifying the integrity of the assembly's files. To do this, you use the SN.exe utility, specifying the <b>-Vr </b>command-line switch Executing SN exe with this switch also tells the CLR to skip checking hash values for any of the assembly's files when loaded at runtime. Internally, SN's <b>-Vr </b>switch adds the assembly's identity under the following registry subkey: H KEY_LOCAL_MACH IN E\SOFTWARE <span>\Microsoft\StrongName\Verification</span>.</p>
<hr/>
<blockquote><b>Important </b>When using any utility that manipulates the registry, make sure that you run the 64-bit version of the utility on a 64-bit machine. By default, the 32-bit x86 utilities are installed in <span>C:\Program</span> Files (x86)\Microsoft SDKs\Windows\v7.0A\bin\NETFX 4.0 Tools, and the 64-bit x64 utilities are installed in C:\Program Files (x86)\Microsoft SDKs\Windows\v7 0A\bin \NETFX 4 0 Tools\x64.</blockquote>
<hr/>
<p>When you're finished developing and testing the assembly, you need to officially sign it so that you can package and deploy it. To sign the assembly, use the SN.exe utility again, this time with the <b>-R </b>switch and the name of the file that contains the actual private key. The <b>-R </b>switch causes SN.exe to hash the file's contents, sign it with the private key, and embed the RSA digital signature in the file where the space for it had previously been reserved. After this step, you can deploy the fully signed assembly. On the developing and testing machines, don't forget to turn verification of this assembly back on by using SN.exe's <b>-Vu </b>or <b>-Vx </b>command-line switch The following list summarizes the steps discussed in this section to develop your assembly by using the delayed signing technique:</p>
<p><b>1. </b>While developing an assembly, obtain a file that contains only your company's public key, and compile your assembly by using the <b>/keyfile </b>and <b>/delaysign </b>compiler switches:</p>
<p><code>csc /keyfileiMyCompany.PublicKey /delaysign MyAssembly.cs</code></p>
<p><b>2. </b>After building the assembly, execute the following line so that the CLR will trust the assembly's bytes without performing the hash and comparison This allows you to install the assembly in the GAC (if you desire). Now, you can build other assemblies that reference the assembly, and you can test the assembly Note that you have to execute the following command line only once per machine; it's not necessary to perform this step each time you build your assembly.</p>
<p><code>SN.exe -Vr MyAssembly.dll</code></p>
<p><b>3. </b>When ready to package and deploy the assembly, obtain your company's private key, and then execute the line below You can install this new version in the GAC if you desire, but don't attempt to install it in the GAC until executing step 4.</p>
<p><code>SN.exe -R MyAssembly.dll MyCompany.PrivateKey</code></p>
<p><b>4. </b>To test in real conditions, turn verification back on by executing the following command line:</p>
<p><code>SN -Vu MyAssembly.dll</code></p>
<p>At the beginning of this section, I mentioned how organizations keep their key pairs in a hardware device such as a smart card To keep these keys secure, you must make sure that the key values are never persisted in a disk file. Cryptographic service providers (CSPs) offer containers that abstract the location of these keys Microsoft, for example, uses a CSP that has a container that, when accessed, obtains the private key from a hardware device.</p>
<p>If your public/private key pair is in a CSP container, you'll have to specify different switches to the CSC.exe, AL.exe, and SN.exe programs: When compiling (CSC.exe), specify the <b>/keycontainer </b>switch instead of the <b>/keyfile </b>switch; when linking (AL.exe), specify its <b>/keyname </b>switch instead of its <b>/keyfile </b>switch; and when using the Strong Name program (SN.exe) to add a private key to a delay-signed assembly, specify the <b>-Rc </b>switch instead of the <b>-R </b>switch. SN.exe offers additional switches that allow you to perform operations with a CSP.</p>
<hr/>
<blockquote><b>Important </b>Delayed signing is also useful whenever you want to perform some other operation to an assembly before you package it. For example, you may want to run an obfuscator over your assembly. You can't obfuscate an assembly after it's been fully signed because the hash value will be incorrect. So, if you want to obfuscate an assembly file or perform any other type of post-build operation, you should use delayed signing, perform the post-build operation, and then run SN.exe with the <b>-R </b>or <b>-Rc </b>switch to complete the signing process of the assembly with all of its hashing.</blockquote>
<hr/>
<a name="b80"/><h2>Privately Deploying Strongly Named Assemblies</h2>
<p>Installing assemblies into the GAC offers several benefits. The GAC enables many applications to share assemblies, reducing physical memory usage on the whole. In addition, it's easy to deploy a new version of the assembly into the GAC and have all applications use the new version via a publisher policy (described later in this chapter). The GAC also provides side-by-side management for an assembly's different versions. However, the GAC is usually secured so that only an administrator can install an assembly into it. Also, installing into the GAC breaks the simple copy deployment story.</p>
<p>Although strongly named assemblies can be installed into the GAC, they certainly don't have to be. In fact, it's recommended that you deploy assemblies into the GAC only if the assembly is intended to be shared by many applications. If an assembly isn't intended to be shared, it should be deployed privately. Deploying privately preserves the simple copy install deployment story and better isolates the application and its assemblies. Also, the GAC isn't intended to be the new <span>C:\Windows\System32</span> dumping ground for common files. The reason is because new versions of assemblies don't overwrite each other; they are installed side by side, eating up disk space.</p>
<p>In addition to deploying a strongly named assembly in the GAC or privately, a strongly named assembly can be deployed to some arbitrary directory that a small set of applications know about For example, you might be producing three applications, all of which want to share a strongly named assembly. Upon installation, you can create three directories: one for each application and an additional directory for the assembly you want shared. When you install each application into its directory, also install an XML configuration file, and have the shared assembly's <b>codeBase </b>element indicate the path of the shared assembly. Now at runtime, the CLR will know to look in the strongly named assembly's directory for the shared assembly. For the record, this technique is rarely used and is somewhat discouraged because no single application controls when the assembly's files should be uninstalled.</p>
<hr/>
<blockquote><b>Note </b>The configuration file's <b>codeBase </b>element actually identifies a URL. This URL can refer to any directory on the user's machine or to a Web address. In the case of a Web address, the CLR will automatically download the file and store it in the user's download cache (a subdirectory under <span>C:\Users\UserName\Local</span> Settings\Application Data\Assembly, where UserName is the name of the Windows user account currently signed on). When referenced in the future, the CLR will compare the timestamp of the downloaded file with the timestamp of the file at the specified URL. If the timestamp of the file at the URL is newer, the CLR will download the new version of the file and load it. If the previously downloaded file is newer, the CLR will load this file and will not download the file again (improving performance). An example of a configuration file containing a <b>codeBase </b>element is shown later in this chapter.</blockquote>
<hr/>
<a name="b81"/><h2>How the Runtime Resolves Type References</h2>
<p>At the beginning of Chapter 2, we saw the following source code:</p>
<p><code>public sealed class Program { public static void Main() {<br/>
System.Console.Writel_ine(&quot;Hi&quot;);<br/>
}<br/>
}</code></p>
<p>This code is compiled and built into an assembly, say Program.exe. When you run this application, the CLR loads and initializes Then the CLR reads the assembly's CLR header, looking for the MethodDefToken that identifies the application's entry point method <b>(Main) </b>. From the MethodDef metadata table, the offset within the file for the method's IL code is located and JIT-compiled into native code, which includes having the code verified for type safety. The native code then starts executing. Following is the IL code for the <b>Main </b>method. To obtain this output, I ran ILDasm.exe, chose the View menu's Show Bytes menu item, and then double-clicked the <b>Main </b>method in the tree view.</p>
<p><code>.method public hidebysig static void   Main() cil managed // SIG: 00 00 01<br/>
{<br/>
.entrypoint<br/>
// Method begins at RVA 0x2050 // Code size.11 (0xb)<br/>
.maxstack 8<br/>
IL_0000:    /* 72      |  (70)000001 */<br/>
ldstr &quot;Hi&quot;<br/>
IL_0005:    /* 28      |  (0A)000003 */<br/>
call.void [mscorlib]System.Console::WriteLine(string)<br/>
IL_000a:   /* 2A     | */<br/>
ret<br/>
} // end of method Program::Main</code></p>
<p>When JIT-compiling this code, the CLR detects all references to types and members and loads their defining assemblies (if not already loaded). As you can see, the IL code above has a reference to <b>System.Console.WriteLine. </b>Specifically, the IL <b>call </b>instruction references metadata token 0A000003. This token identifies entry 3 in the MemberRef metadata table (table 0A). The CLR looks up this MemberRef entry and sees that one of its fields refers to an entry in a TypeRef table (the <b>System.Console </b>type). From the TypeRef entry, the CLR is directed to an AssemblyRef entry: &quot;mscorlib, Version=4. 0. 0. 0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;. At this point, the CLR knows which assembly it needs. Now the CLR must locate the assembly in order to load it.</p>
<p>When resolving a referenced type, the CLR can find the type in one of three places:</p>
<p>&#9632; Same file  Access to a type that is in the same file is determined at compile time (sometimes referred to as early bound). The type is loaded out of the file directly, and execution continues.</p>
<p>&#9632; Different file, same assembly  The runtime ensures that the file being referenced is, in fact, in the assembly's FileRef table of the current assembly's manifest. The runtime then looks in the directory where the assembly's manifest file was loaded. The file is loaded, its hash value is checked to ensure the file's integrity, the type's member is found, and execution continues.</p>
<p>&#9632; Different file, different assembly  When a referenced type is in a different assembly's file, the runtime loads the file that contains the referenced assembly's manifest. If this file doesn't contain the type, the appropriate file is loaded. The type's member is found, and execution continues.</p>
<hr/>
<blockquote><b>Note </b>The ModuleDef, ModuleRef, and FileDef metadata tables refer to files using the file's name and its extension. However, the AssemblyRef metadata table refers to assemblies by file name without an extension When binding to an assembly, the system automatically appends</blockquote>
<hr/>
<p>I.dll and.exe file extensions while attempting to locate the file by probing the directories as mentioned in the &quot;Simple Administrative Control (Configuration)&quot; section in Chapter 2.</p>
<p>If any errors occur while resolving a type reference庸ile can't be found, file can't be loaded, hash mismatch, and so on預n appropriate exception is thrown.</p>
<hr/>
<blockquote><b>Note </b>If you want, your code can register callback methods with <b>System.AppDomain's, AssemblyResolve, ReflectionOnlyAssemblyResolve, </b>and <b>TypeResolve </b>events. In your callback methods, you can execute code that resolves the binding problem and allows the application to continue running without throwing an exception.</blockquote>
<hr/>
<p>In the previous example, the CLR determines that <b>System.Console </b>is implemented in a different assembly than the caller. The CLR must search for the assembly and load the PE file that contains the assembly's manifest. The manifest is then scanned to determine the PE file that implements the type. If the manifest file contains the referenced type, all is well. If the type is in another of the assembly's files, the CLR loads the other file and scans its metadata to locate the type The CLR then creates its internal data structures to represent the type, and the JIT compiler completes the compilation for the <b>Main </b>method. Finally, the <b>Main </b>method can start executing.</p>
<p>Figure 3-2 illustrates how type binding occurs.</p>
<img src="16.jpg"/>
<p>Note: If any operation fails, an appropriate exception is thrown.</p>
<p><b>Figure 3-2 </b>Flowchart showing how, given IL code that refers to a method or type, the CLR uses metadata to locate the proper assembly file that defines a type</p>
<hr/>
<blockquote><b>Important </b>Strictly speaking, the example just described isn't 100 percent correct. For references to methods and types defined in an assembly that does not ship with the .NET Framework, the discussion is correct However, the NET Framework assemblies (including MSCorLib dll) are closely tied to the version of the CLR that's running. Any assembly that references .NET Framework assemblies always binds to the version that matches the CLR's version This is called unification, and Microsoft does this because they test all of the .NET Framework assemblies with a particular version of the CLR; therefore, unifying the code stack helps ensure that applications will work correctly.</blockquote>
<hr/>
<p>So in the previous example, the reference to <b>System.Console</b>'s <b>WriteLine </b>method binds to whatever version of MSCorLib dll matches the version of the CLR, regardless of what version of MSCorLib.dll is referenced in the assembly's AssemblyRef metadata table.</p>
<p>There is one more twist to this story: To the CLR, all assemblies are identified by name, version, culture, and public key. However, the GAC identifies assemblies using name, version, culture, public key, and CPU architecture. When searching the GAC for an assembly, the CLR figures out what type of process the application is currently running in: 32-bit x86 (possibly using the WoW64 technology), 64-bit x64, or 64-bit IA64. Then, when searching the GAC for an assembly, the CLR first searches for a CPU architecture-specific version of the assembly. If it does not find a matching assembly, it then searches for a CPU-agnostic version of the assembly.</p>
<p>In this section, you saw how the CLR locates an assembly when using a default policy. However, an administrator or the publisher of an assembly can override the default policy. In the next two sections, I'll describe how to alter the CLR's default binding policy.</p>
<hr/>
<blockquote><b>Note </b>The CLR supports the ability to move a type (class, structure, enum, interface, or delegate) from one assembly to another. For example, in .NET 3.5, the <b>System.TimeZonelnfo </b>class is defined in the System. Core.dll assembly. But in .NET 4.0, Microsoft moved this class to the MSCorLib.dll assembly. Normally, moving a type from one assembly to another would break applications. However, the CLR offers a <b>System.Runtime.CompilerServices. TypeForwardedToAttribute </b>attribute, which can be applied to the original assembly (such as System.Core.dll). The parameter that you pass to this attribute's constructor is of type <b>System.Type </b>and it indicates the new type (that is now defined in MSCorLib.dll) that applications should now use The CLR's binder uses this information Since the <b>TypeForwardedToAttribute</b>'s constructor takes a <b>Type, </b>the assembly containing this attribute will be dependent on the new assembly defining the type.</blockquote>
<hr/>
<p>If you take advantage of this feature, then you should also apply the <b>System.Runtime. CompilerServices.TypeForwardedFromAttribute </b>attribute to the type in the new assembly and pass to this attribute's constructor a string with the full name of the assembly that used to define the type. This attribute typically is used for tools, utilities, and serialization. Since the <b>TypeForwardedFromAttribute</b>'s constructor takes a <b>String, </b>the assembly containing this attribute is not dependent on the assembly that used to define the type.</p>
<a name="b84"/><h2>Advanced Administrative Control (Configuration)</h2>
<p>In the section &quot;Simple Administrative Control (Configuration)&quot; in Chapter 2, I gave a brief introduction to how an administrator can affect the way the CLR searches and binds to assemblies. In that section, I demonstrated how a referenced assembly's files can be moved to a subdirectory of the application's base directory and how the CLR uses the application's XML configuration file to locate the moved files.</p>
<p>Having discussed only the probing element's <b>privatePath </b>attribute in Chapter 2, I'm going to discuss the other XML configuration file elements in this section. Following is an XML configuration file:</p>
<p><code>&lt;?xm1 version=&quot;1.0&quot;?&gt; &lt;configuration&gt; &lt;runtime&gt;<br/>
&lt;assemblyBinding xmlns=''urn:schemas-microsoft-com:asm.v1&quot;&gt; &lt;probing privatePath=&quot;AuxFiles;bin\subdir&quot; /&gt;<br/>
&lt;dependentAssembly&gt;<br/>
&lt;assemblyIdentity name=&quot;JeffTypes&quot;<br/>
publicKeyToken=&quot;32ab4ba45e0a69a1&quot; culture=&quot;neutra1&quot;/&gt;<br/>
&lt;bindingRedirect<br/>
oldVersion=&quot;1.0.0.0&quot; newVersion=&quot;2.0.0.0&quot; /&gt;<br/>
&lt;codeBase version=&quot;2.0.0.0&quot;<br/>
href=&quot;<a href="http://www.Wintellect.com/JeffTypes.d11">http://www.Wintellect.com/JeffTypes.d11</a>&quot; /&gt;<br/>
&lt;/dependentAssembly&gt;<br/>
&lt;dependentAssembly&gt;<br/>
&lt;assemblyIdentity name=&quot;TypeLib&quot;<br/>
publicKeyToken=&quot;1f2e74e897abbcfe&quot; culture=&quot;neutra1&quot;/&gt;<br/>
&lt;bindingRedirect<br/>
oldVersion=&quot;3.0.0.0-3.5.0.0&quot; newVersion=&quot;4.0.0.0&quot; /&gt;<br/>
&lt;publisherPolicy apply=&quot;no&quot; /&gt;<br/>
&lt;/dependentAssembly&gt;<br/>
&lt;/assemblyBinding&gt; &lt;/runtime&gt; &lt;/configuration&gt;</code></p>
<p>This XML file gives a wealth of information to the CLR. Here's what it says:</p>
<p><b>&#9632; probing element   </b>Look in the application base directory's AuxFiles and bin\subdir subdirectories when trying to find a weakly named assembly. For strongly named assemblies, the CLR looks in the GAC or in the URL specified by the <b>CodeBase </b>element. The CLR looks in the application's private paths for a strongly named assembly only if no <b>CodeBase </b>element is specified.</p>
<p><b>&#9632; First dependentAssembly, assemblyldentity, and bindingRedirect elements</b></p>
<p>When attempting to locate version 1. 0. 0. 0 of the culture-neutral JeffTypes assembly published by the organization that controls the 32ab4ba45e0a69a1 public key token, locate version 2. 0. 0. 0 of the same assembly instead.</p>
<p><b>&#9632; codeBase element   </b>When attempting to locate version 2 0 0 0 of the culture-neutral JeffTypes assembly published by the organization that controls the 32ab4ba45e0a69a1 public key token, try to find it at the following URL: <a href="http://www.Wintellect.com/JeffTypes.dll">www.Wintellect.com/JeffTypes.dll</a>. Although I didn't mention it in Chapter 2, a <b>CodeBase </b>element can also be used with weakly named assemblies. In this case, the assembly's version number is ignored and should be omitted from the XML's <b>CodeBase </b>element. Also, the <b>CodeBase </b>URL must refer to a directory under the application's base directory.</p>
<p><b>&#9632; Second dependentAssembly, assemblyldentity, and bindingRedireCt elements</b></p>
<p>When attempting to locate version 3.0. 0. 0 through version 3.5. 0. 0 inclusive of the culture-neutral TypeLib assembly published by the organization that controls the 1f2e74e897abbcfe public key token, locate version 4. 0.0. 0 of the same assembly instead.</p>
<p><b>&#9632; publisherPoliCy element   </b>If the organization that produces the TypeLib assembly has deployed a publisher policy file (described in the next section), the CLR should ignore this file.</p>
<p>When compiling a method, the CLR determines the types and members being referenced. Using this information, the runtime determines, by looking in the referencing assembly's AssemblyRef table, the assembly that was originally referenced when the calling assembly was built. The CLR then looks up the assembly/version in the application's configuration file and applies any version number redirections; the CLR is now looking for this assembly/ version.</p>
<p>If the <b>publisherPoliCy </b>element's <b>apply </b>attribute is set to <b>yes</b>熔r if the element is omitted 葉he CLR examines the GAC for the new assembly/version and applies any version number redirections that the publisher of the assembly feels is necessary; the CLR is now looking for this assembly/version. I'll talk more about publisher policy in the next section. Finally, the CLR looks up the new assembly/version in the machine's Machine.config file and applies any version number redirections there.</p>
<p>At this point, the CLR knows the version of the assembly that it should load, and it attempts to load the assembly from the GAC. If the assembly isn't in the GAC, and if there is no <b>CodeBase </b>element, the CLR probes for the assembly as I described in Chapter 2. If the configuration file that performs the last redirection also contains a <b>CodeBase </b>element, the CLR attempts to load the assembly from the <b>CodeBase </b>element's specified URL.</p>
<p>Using these configuration files, an administrator can really control what assembly the CLR decides to load If an application is experiencing a bug, the administrator can contact the publisher of the errant assembly. The publisher can send the administrator a new assembly that the administrator can install. By default, the CLR won't load this new assembly because the already-built assemblies don't reference the new version. However, the administrator can modify the application's XML configuration file to instruct the CLR to load the new assembly.</p>
<p>If the administrator wants all applications on the machine to pick up the new assembly, the administrator can modify the machine's Machine.config file instead, and the CLR will load the new assembly whenever an application refers to the old assembly.</p>
<p>If the new assembly doesn't fix the original bug, the administrator can delete the binding redirection lines from the configuration file, and the application will behave as it did before. It's important to note that the system allows the use of an assembly that doesn't exactly match the assembly version recorded in the metadata. This extra flexibility is very handy.</p>
<h3>Publisher Policy Control</h3>
<p>In the scenario described in the previous section, the publisher of an assembly simply sent a new version of the assembly to the administrator, who installed the assembly and manually edited the application's or machine's XML configuration files. In general, when a publisher fixes a bug in an assembly, the publisher would like an easy way to package and distribute the new assembly to all of the users. But the publisher also needs a way to tell each user's CLR to use the new assembly version instead of the old assembly version. Sure, each user could modify his or her application's or machine's XML configuration file, but this is terribly inconvenient and error prone. What the publisher needs is a way to create policy information that is installed on the user's computer when the new assembly is installed. In this section, I'll show how an assembly's publisher can create this policy information.</p>
<p>Let's say that you're a publisher of an assembly and that you've just created a new version of your assembly that fixes some bugs. When you package your new assembly to send out to all of your users, you should also create an XML configuration file. This configuration file looks just like the configuration files we've been talking about. Here's an example file (called JeffTypes.config) for the JeffTypes.dll assembly:</p>
<p><code>&lt;configuration&gt; &lt;runtime&gt;<br/>
&lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt; &lt;dependentAssembly&gt;<br/>
&lt;assemblyIdentity name=&quot;JeffTypes&quot;<br/>
publicKeyToken=&quot;32ab4ba45e0a69a1&quot; culture=&quot;neutra1&quot;/&gt;<br/>
&lt;bindingRedirect<br/>
oldVersion=&quot;1.0.0.0&quot; newVersion=&quot;2.0.0.0&quot; /&gt;<br/>
&lt;codeBase version=&quot;2.0.0.0&quot;<br/>
href=&quot;<a href="http://www.Wintellect.com/JeffTypes.d11%22/">http://www.Wintellect.com/JeffTypes.d11&quot;/</a>&gt;<br/>
&lt;/dependentAssembly&gt; &lt;/assemblyBinding&gt; &lt;/runtime&gt; &lt;/configuration&gt;</code></p>
<p>Of course, publishers can set policies only for the assemblies that they themselves create. In addition, the elements shown here are the only elements that can be specified in a publisher policy configuration file; you can't specify the <b>probing </b>or <b>publisherPoliCy </b>elements, for example.</p>
<p>This configuration file tells the CLR to load version 2.0. 0. 0 of the JeffTypes assembly whenever version 1. 0.0. 0 of the assembly is referenced. Now you, the publisher, can create an assembly that contains this publisher policy configuration file. You create the publisher policy assembly by running AL.exe as follows:</p>
<p><code>AL.exe /out:Policy.1.0.JeffTypes.d11 /version:1.0.0.0 /keyfile:MyCompany.snk /1inkresource:JeffTypes.config</code></p>
<p>Let me explain the meaning of AL.exe's command-line switches:</p>
<p><b>&#9632; /out  </b>This switch tells AL.exe to create a new PE file, called Policy.1. 0 JeffTypes.dll, which contains nothing but a manifest. The name of this assembly is very important. The first part of the name, Policy, tells the CLR that this assembly contains publisher policy information. The second and third parts of the name, 1.0, tell the CLR that this publisher policy assembly is for any version of the JeffTypes assembly that has a major and minor version of 1. 0. Publisher policies apply to the major and minor version numbers of an assembly only; you can't create a publisher policy that is specific to individual builds or revisions of an assembly. The fourth part of the name, JeffTypes, indicates the name of the assembly that this publisher policy corresponds to. The fifth and last part of the name, dll, is simply the extension given to the resulting assembly file.</p>
<p><b>&#9632; /version  </b>This switch identifies the version of the publisher policy assembly; this version number has nothing to do with the JeffTypes assembly itself. You see, publisher policy assemblies can also be versioned. Today, the publisher might create a publisher policy redirecting version 1. 0. 0. 0 of JeffTypes to version 2. 0. 0.0. In the future, the publisher might want to direct version 1 0 0 0 of JeffTypes to version 2 5 0 0 The CLR uses this version number so that it knows to pick up the latest version of the publisher policy assembly.</p>
<p><b>&#9632; /keyfile  </b>This switch causes AL.exe to sign the publisher policy assembly by using the publisher's public/private key pair. This key pair must also match the key pair used for all versions of the JeffTypes assembly. After all, this is how the CLR knows that the same publisher created both the JeffTypes assembly and this publisher policy file.</p>
<p><b>&#9632; /linkresourCe  </b>This switch tells AL.exe that the XML configuration file is to be considered a separate file of the assembly. The resulting assembly consists of two files, both of which must be packaged and deployed to the users along with the new version of the JeffTypes assembly. By the way, you can't use AL.exe's <b>/embedresourCe </b>switch to embed the XML configuration file into the assembly file, making a single file assembly, because the CLR requires the XML file to be contained in its own separate file.</p>
<p>Once this publisher policy assembly is built, it can be packaged together with the new JeffTypes.dll assembly file and deployed to users. The publisher policy assembly must be installed into the GAC. Although the JeffTypes assembly can also be installed into the GAC, it doesn't have to be. It could be deployed into an application's base directory or some other directory identified by a <b>CodeBase </b>URL.</p>
<hr/>
<blockquote><b>Important </b>A publisher should create a publisher policy assembly only when deploying an update or a service pack version of an assembly. When doing a fresh install of an application, no publisher policy assemblies should be installed.</blockquote>
<hr/>
<p>I want to make one last point about publisher policy. Say that a publisher distributes a publisher policy assembly, and for some reason, the new assembly introduces more bugs than it fixes. If this happens, the administrator would like to tell the CLR to ignore the publisher policy assembly. To have the runtime do this, the administrator can edit the application's configuration file and add the following <b>publisherPoliCy </b>element:</p>
<p><code>&lt;publisherPolicy apply=&quot;no&quot;/&gt;</code></p>
<p>This element can be placed as a child element of the <b>&lt;assemblyBinding&gt; </b>element in the application's configuration file so that it applies to all assemblies, or as a child element of the <b>&lt;dependantAssembly&gt; </b>element in the application's configuration file to have it apply to a specific assembly. When the CLR processes the application's configuration file, it will see that the GAC shouldn't be examined for the publisher policy assembly. So the CLR will continue to operate using the older version of the assembly Note, however, that the CLR will still examine and apply any policy specified in the Machine.config file.</p>
<p>I-</p>
<hr/>
<blockquote><b>Important </b>A publisher policy assembly is a way for a publisher to make a statement about the compatibility of different versions of an assembly. If a new version of an assembly isn't intended to be compatible with an earlier version, the publisher shouldn't create a publisher policy assembly. In general, use a publisher policy assembly when you build a new version of your assembly that fixes a bug. You should test the new version of the assembly for backward compatibility. On the other hand, if you're adding new features to your assembly, you should consider the assembly to have no relationship to a previous version, and you shouldn't ship a publisher policy assembly In addition, there's no need to do any backward compatibility testing with such an assembly.</blockquote>
<hr/>
<mbp:pagebreak/>
<a name="Chapter4"/>
<h1>Chapter 4: Type Fundamentals</h1>
<p><b>In this chapter:</b></p>
<a href="#b91">All Types Are Derived from System.ObjeCt</a><br/>
<a href="#b97">Namespaces and Assemblies</a><br/>
<a href="#b102">How Things Relate at Runtime</a><br/>
<p>In this chapter, I will introduce information that is fundamental to working with types and the common language runtime (CLR). In particular, I'll discuss the minimum set of behaviors that you can expect every type to have I'll also describe type safety, namespaces, assemblies, and the various ways you can cast objects from one type to another. Finally, I'll conclude this chapter with an explanation of how types, objects, thread stacks, and the managed heap all relate to one another at runtime.</p>
<a name="b91"/><h2>All Types Are Derived from System.ObjeCt</h2>
<p>The runtime requires every type to ultimately be derived from the <b>System.ObjeCt </b>type. This means that the following two type definitions are identical:</p>
<p><code>// Implicitly derived from Object// Explicitly derived from Object<br/>
class Employee {.class Employee : System.Object {<br/>
} }</code></p>
<p>Because all types are ultimately derived from <b>System.ObjeCt, </b>you are guaranteed that every object of every type has a minimum set of methods. Specifically, the <b>System.ObjeCt </b>class offers the public instance methods listed in Table 4-1.</p>
<p><b>Table 4-1 </b><b>Public Methods of System.Object</b></p>
<p><code>Employee e = new Employee(&quot;ConstructorParam1&quot;);</code></p>
<p>In addition, types that derive from <b>System.Object </b>have access to the protected methods listed in Table 4-2.</p>
<p><b>Table 4-2 </b><b>Protected Methods of System.Object</b></p>
<p>The CLR requires all objects to be created using the <b>new </b>operator The following line shows how to create an <b>Employee </b>object:</p>
<table border="1">
<tr>
<td>
<p>d</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>s</p>
</td>
<td>
<p>Returns <b>true </b>if two objects have the same value For more information about this method, see the &quot;Object Equality and Identity&quot; section in Chapter 5, &quot;Primitive, Reference, and Value Types.&quot;</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Returns a hash code for this object's value A type should override this method if its objects are to be used as a key in a hash table collection The method should provide a good distribution for its objects It is unfortunate that this method is defined in <b>Object </b>because most types are never used as keys in a hash table; this method should have been defined in an interface. For more information about this method, see the &quot;Object Hash Codes&quot; section in Chapter 5.</p>
</td>
</tr>
<tr>
<td>
<p>g</p>
</td>
<td>
<p>By default, returns the full name of the type <b>(this.GetType</b><b>O</b><b>.FullName) </b>.</p>
<p>However, it is common to override this method so that it returns a <b>String </b>object containing a representation of the object's state For example, the core types, such as <b>Boolean </b>and <b>Int32, </b>override this method to return a string representation of their values It is also common to override this method for debugging purposes; you can call it and get a string showing the values of the object's fields. In fact, Microsoft Visual Studio's debugger calls this function automatically to show you a string representation of an object. Note that <b>ToString </b>is expected to be aware of the <b>CultureInfo </b>associated with the calling thread. Chapter 14, &quot;Chars, Strings, and Working with Text,&quot; discusses <b>ToString </b>in greater detail.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Returns an instance of a <b>Type</b>-derived object that identifies the type of the object used to call <b>GetType. </b>The returned <b>Type </b>object can be used with the reflection classes to obtain metadata information about the object's type. Reflection is discussed in Chapter 23, &quot;Assembly Loading and Reflection.&quot; The <b>GetType </b>method is nonvirtual, which prevents a class from overriding this method and lying about its type, violating type safety.</p>
</td>
</tr>
</table>
<table border="1">
<tr>
<td>
<p>d</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>This nonvirtual method creates a new instance of the type and sets the new object's instance fields to be identical to the <b>this </b>object's instance fields. A reference to the new instance is returned.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>This virtual method is called when the garbage collector determines that the object is garbage before the memory for the object is reclaimed Types that require cleanup when collected should override this method. I'll talk about this important method in much more detail in Chapter 21, &quot;Automatic Memory Management (Garbage Collection).&quot;</p>
</td>
</tr>
</table>
<p>Here's what the <b>new </b>operator does:</p>
<p><b>1. </b>It calculates the number of bytes required by all instance fields defined in the type and all of its base types up to and including <b>System.ObjeCt </b>(which defines no instance fields of its own). Every object on the heap requires some additional members幼alled the type object pointer and the sync block index蓉sed by the CLR to manage the object. The bytes for these additional members are added to the size of the object.</p>
<p><b>2. </b>It allocates memory for the object by allocating the number of bytes required for the specified type from the managed heap; all of these bytes are then set to zero (0).</p>
<p><b>3. </b>It initializes the object's type object pointer and sync block index members.</p>
<p><b>4. </b>The type's instance constructor is called, passing it any arguments (the string <b>&quot;ConstruCtorParaml&quot; </b>in the preceding example) specified in the call to <b>new. </b>Most compilers automatically emit code in a constructor to call a base class's constructor. Each constructor is responsible for initializing the instance fields defined by the type whose constructor is being called. Eventually, <b>System.ObjeCt</b>'s constructor is called, and this constructor method does nothing but return. You can verify this by using ILDasm.exe to load MSCorLib.dll and examine <b>System.ObjeCt</b>'s constructor method.</p>
<p>After <b>new </b>has performed all of these operations, it returns a reference (or pointer) to the newly created object. In the preceding code example, this reference is saved in the variable <b>e, </b>which is of type <b>Employee </b>.</p>
<p>By the way, the <b>new </b>operator has no complementary <b>delete </b>operator; that is, there is no way to explicitly free the memory allocated for an object. The CLR uses a garbage-collected environment (described in Chapter 21) that automatically detects when objects are no longer being used or accessed and frees the object's memory automatically.</p>
<h2>Casting Between Types</h2>
<p>One of the most important features of the CLR is type safety At runtime, the CLR always knows what type an object is You can always discover an object's exact type by calling the <b>GetType </b>method Because this method is nonvirtual, it is impossible for a type to spoof another type. For example, the <b>Employee </b>type can't override the <b>GetType </b>method and have it return a type of <b>SuperHero </b>.</p>
<p>Developers frequently find it necessary to cast an object to various types. The CLR allows you to cast an object to its type or to any of its base types Your choice of programming language dictates how to expose casting operations to the developer. For example, C# doesn't require any special syntax to cast an object to any of its base types, because casts to base types are considered safe implicit conversions. However, C# does require the developer to explicitly cast an object to any of its derived types since such a cast could fail at runtime. The following code demonstrates casting to base and derived types:</p>
<p><code>// This type is implicitly derived from System.Object. internal class Employee {<br/>
}<br/>
public sealed class Program { public static void Main() {<br/>
// No cast needed since new returns an Employee object // and Object is a base type of Employee. Object o = new Employee();<br/>
// Cast required since Employee is derived from Object. // Other languages (such as Visual Basic) might not require // this cast to compile. Employee e = (Employee) o;<br/>
}<br/>
}</code></p>
<p>This example shows what is necessary for your compiler to compile your code. Now I'll explain what happens at runtime. At runtime, the CLR checks casting operations to ensure that casts are always to the object's actual type or any of its base types. For example, the following code will compile, but at runtime, an <b>InvalidCastExCeption </b>will be thrown:</p>
<p><code>internal class Employee {<br/>
}<br/>
internal class Manager : Employee {<br/>
}<br/>
public sealed class Program { public static void Main() {<br/>
// Construct a Manager object and pass it to PromoteEmployee. // A Manager IS-A Object: PromoteEmployee runs OK. Manager m = new Manager(); PromoteEmployee(m);<br/>
// Construct a DateTime object and pass it to PromoteEmployee. // A DateTime is NOT derived from Employee. PromoteEmployee // throws a System.InvalidCastException exception. DateTime newYears = new DateTime(2010, 1, 1); PromoteEmployee(newYears);<br/>
}<br/>
public static void PromoteEmployee(Object o) {<br/>
// At this point, the compiler doesn't know exactly what // type of object o refers to. So the compiler allows the // code to compile. However, at runtime, the CLR does know // what type o refers to (each time the cast is performed) and // it checks whether the object's type is Employee or any type // that is derived from Employee.<br/>
Employee e = (Employee) o;<br/>
}<br/>
}</code></p>
<p>In the <b>Main </b>method, a <b>Manager </b>object is constructed and passed to <b>PromoteEmployee </b>. This code compiles and executes because <b>Manager </b>is ultimately derived from <b>ObjeCt, </b>which is what <b>PromoteEmployee </b>expects. Once inside <b>PromoteEmployee, </b>the CLR confirms that <b>o </b>refers to an object that is either an <b>Employee </b>or a type that is derived from <b>Employee </b>. Because <b>Manager </b>is derived from <b>Employee, </b>the CLR performs the cast and allows <b>PromoteEmployee </b>to continue executing.</p>
<p>After <b>PromoteEmployee </b>returns, <b>Main </b>constructs a <b>DateTime </b>object and passes it to <b>PromoteEmployee. </b>Again, <b>DateTime </b>is derived from <b>ObjeCt, </b>and the compiler compiles the code that calls <b>PromoteEmployee </b>with no problem. However, inside <b>PromoteEmployee, </b>the CLR checks the cast and detects that <b>o </b>refers to a <b>DateTime </b>object and is therefore not an <b>Employee </b>or any type derived from <b>Employee. </b>At this point, the CLR can't allow the cast and throws a <b>System.InvalidCastExCeption </b>.</p>
<p>If the CLR allowed the cast, there would be no type safety, and the results would be unpredictable, including the possibility of application crashes and security breaches caused by the ability of types to easily spoof other types. Type spoofing is the cause of many security breaches and compromises an application's stability and robustness. Type safety is therefore an extremely important part of the CLR.</p>
<p>By the way, the proper way to declare the <b>PromoteEmployee </b>method would be to specify an <b>Employee </b>type instead of an <b>ObjeCt </b>type as its parameter so that the compiler produces a compile-time error, saving the developer from waiting until a runtime exception occurs to discover a problem. I used <b>ObjeCt </b>so that I could demonstrate how the C# compiler and the CLR deal with casting and type-safety.</p>
<h3>Casting with the C# is and as Operators</h3>
<p>Another way to cast in the C# language is to use the <b>is </b>operator. The <b>is </b>operator checks whether an object is compatible with a given type, and the result of the evaluation is a <b>Boolean: true </b>or <b>false. </b>The <b>is </b>operator will never throw an exception. The following code demonstrates:</p>
<p><code>Object o = new Object();<br/>
Boolean bl = (o is Object);     // bl is true. Boolean b2 = (o is Employee); // b2 is false.</code></p>
<p>If the object reference is <b>null</b>, the <b>is </b>operator always returns <b>false </b>because there is no object available to check its type.</p>
<p>The <b>is </b>operator is typically used as follows:</p>
<p><code>if (o is Employee) {<br/>
Employee e = (Employee) o;<br/>
// Use e within the remainder of the 'if' statement.<br/>
}</code></p>
<p>In this code, the CLR is actually checking the object's type twice: The <b>is </b>operator first checks to see if <b>o </b>is compatible with the <b>Employee </b>type. If it is, inside the <b>if </b>statement, the CLR again verifies that <b>o </b>refers to an <b>Employee </b>when performing the cast. The CLR's type checking improves security, but it certainly comes at a performance cost, because the CLR must determine the actual type of the object referred to by the variable <b>(o), </b>and then the CLR must walk the inheritance hierarchy, checking each base type against the specified type <b>(Employee) </b>. Because this programming paradigm is quite common, C# offers a way to simplify this code and improve its performance by providing an <b>as </b>operator:</p>
<p><code>Employee e = o as Employee; if (e != null) {<br/>
// Use e within the 'if' statement.<br/>
}</code></p>
<p>In this code, the CLR checks if <b>o </b>is compatible with the <b>Employee </b>type, and if it is, <b>as </b>returns a non<b>-null </b>reference to the same object. If <b>o </b>is not compatible with the <b>Employee </b>type, the <b>as </b>operator returns <b>null. </b>Notice that the <b>as </b>operator causes the CLR to verify an object's type just once. The <b>if </b>statement simply checks whether <b>e </b>is <b>null; </b>this check can be performed faster than verifying an object's type.</p>
<p>The <b>as </b>operator works just as casting does except that the <b>as </b>operator will never throw an exception. Instead, if the object can't be cast, the result is <b>null. </b>You'll want to check to see whether the resulting reference is <b>null, </b>or attempting to use the resulting reference will cause a <b>System.NullReferenCeExCeption </b>to be thrown. The following code demonstrates:</p>
<p><code>Object o = new Object();      // Creates a new Object object<br/>
Employee e = o as Employee; // Casts o to an Employee<br/>
// The cast above fails: no exception is thrown, but e is set to null.<br/>
e.ToString();   // Accessing e throws a NullReferenceException.</code></p>
<p>To make sure you understand everything just presented, take the following quiz. Assume that these two class definitions exist:</p>
<p><code>internal class B {        // Base class<br/>
}<br/>
internal class D : B { // Derived class<br/>
}</code></p>
<p>Now examine the lines of C# code in Table 4-3. For each line, decide whether the line would compile and execute successfully (marked OK below), cause a compile-time error (CTE), or cause a run-time error (RTE).</p>
<p><b>Table 4-3 </b><b>Type-Safety Quiz</b></p>
<table border="1">
<tr>
<td>
<p>t</p>
</td>
<td>
<p>K</p>
</td>
<td>
<p>E</p>
</td>
<td>
<p>E</p>
</td>
</tr>
<tr>
<td>
<p><b>Object o1 = new Object();</b></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>Object o2 = new B();</b></p>
</td>
<td>
<p><b>3</b></p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>Object o3 = new D();</b></p>
</td>
<td>
<p><b>3</b></p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>Object o4 = o3;</b></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>B b1 = new B();</b></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>B b2 = new D();</b></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>D d1 = new D();</b></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>B b3 = new Object();</b></p>
</td>
<td>
<p></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>D d2 = new Object();</b></p>
</td>
<td>
<p></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>B b4 = d1;</b></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>D d3 = b2;</b></p>
</td>
<td>
<p></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>D d4 = (D) d1;</b></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>D d5 = (D) b2;</b></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>D d6 = (D) b1;</b></p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
<td>
<p>3</p>
</td>
</tr>
<tr>
<td>
<p><b>B b5 = (B) o1;</b></p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
<td>
<p>3</p>
</td>
</tr>
<tr>
<td>
<p><b>B b6 = (D) b2;</b></p>
</td>
<td>
<p>3</p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
</table>
<a name="b97"/><h2>Namespaces and Assemblies</h2>
<p>Namespaces allow for the logical grouping of related types, and developers typically use them to make it easier to locate a particular type. For example, the <b>System.Text </b>namespace defines a bunch of types for performing string manipulations, and the <b>System.IO </b>namespace defines a bunch of types for performing I/O operations. Here's some code that constructs a <b>System.IO.FileStream </b>object and a <b>System.Text.StringBuilder </b>object:</p>
<p><code>public sealed class Program { public static void Main() {<br/>
System.IO.FileStream fs = new System.IO.FileStream(...); System.Text.StringBuilder sb = new System.Text.StringBuilder();<br/>
}<br/>
}</code></p>
<hr/>
<blockquote><b>Note </b>C# allows a type to define conversion operator methods as discussed in the &quot;Conversion Operator Methods&quot; section of Chapter 9, &quot;Parameters.&quot; These methods are invoked only when using a cast expression; they are never invoked when using C#'s <b>as </b>or <b>is </b>operator.</blockquote>
<hr/>
<p>As you can see, the code is pretty verbose; it would be nice if there were some shorthand way to refer to the <b>FileStream </b>and <b>StringBuilder </b>types to reduce typing. Fortunately, many compilers do offer mechanisms to reduce programmer typing. The C# compiler provides this mechanism via the <b>using </b>directive. The following code is identical to the previous example:</p>
<p><code>using System.IO;      // Try prepending &quot;System.IO.&quot; using System.Text;   // Try prepending &quot;System.Text.&quot;<br/>
public sealed class Program { public static void Main() {<br/>
FileStream fs = new FileStream(...); StringBuilder sb = new StringBuilder();<br/>
}<br/>
}</code></p>
<p>To the compiler, a namespace is simply an easy way of making a type's name longer and more likely to be unique by preceding the name with some symbols separated by dots. So the compiler interprets the reference to <b>FileStream </b>in this example to mean <b>System.IO.FileStream. </b>Similarly, the compiler interprets the reference to <b>StringBuilder </b>to mean <b>System.Text.StringBuilder </b>.</p>
<p>Using the C# <b>using </b>directive is entirely optional; you're always welcome to type out the fully qualified name of a type if you prefer. The C# <b>using </b>directive instructs the compiler to try prepending different prefixes to a type name until a match is found.</p>
<hr/>
<blockquote><b>Important </b>The CLR doesn't know anything about namespaces. When you access a type, the CLR needs to know the full name of the type (which can be a really long name containing periods) and which assembly contains the definition of the type so that the runtime can load the proper assembly, find the type, and manipulate it.</blockquote>
<hr/>
<p>In the previous code example, the compiler needs to ensure that every type referenced exists and that my code is using that type in the correct way: calling methods that exist, passing the right number of arguments to these methods, ensuring that the arguments are the right type, using the method's return value correctly, and so on. If the compiler can't find a type with the specified name in the source files or in any referenced assemblies, it prepends <b>System.IO. </b>to the type name and checks if the generated name matches an existing type. If the compiler still can't find a match, it prepends <b>System.Text. </b>to the type's name. The two <b>using </b>directives shown earlier allow me to simply type <b>FileStream </b>and <b>StringBuilder </b>in my code葉he compiler automatically expands the references to <b>System.IO.FileStream </b>and <b>System.Text.StringBuilder </b>. I'm sure you can easily imagine how much typing this saves, as well as how much cleaner your code is to read.</p>
<p>When checking for a type's definition, the compiler must be told which assemblies to examine by using the <b>/referenCe </b>compiler switch as discussed in Chapter 2, &quot;Building, Packaging, Deploying, and Administering Applications and Types,&quot; and Chapter 3, &quot;Shared Assemblies and Strongly Named Assemblies.&quot; The compiler will scan all of the referenced assemblies looking for the type's definition. Once the compiler finds the proper assembly, the assembly information and the type information is emitted into the resulting managed module's metadata. To get the assembly information, you must pass the assembly that defines any referenced types to the compiler. The C# compiler, by default, automatically looks in the MSCorLib.dll assembly even if you don't explicitly tell it to. The MSCorLib.dll assembly contains the definitions of all of the core Framework Class Library (FCL) types, such as <b>ObjeCt, Int32, String, </b>and so on.</p>
<p>As you might imagine, there are some potential problems with the way that compilers treat namespaces: it's possible to have two (or more) types with the same name in different namespaces. Microsoft strongly recommends that you define unique names for types. However, in some cases, it's simply not possible. The runtime encourages the reuse of components. Your application might take advantage of a component that Microsoft created and another component that Wintellect created. These two companies might both offer a type called <b>Widget</b>柚icrosoft's <b>Widget </b>does one thing, and Wintellect's <b>Widget </b>does something entirely different. In this scenario, you had no control over the naming of the types, so you can differentiate between the two widgets by using their fully qualified names when referencing them. To reference Microsoft's <b>Widget, </b>you would use <b>MiCrosoft.Widget, </b>and to reference Wintellect's <b>Widget, </b>you would use <b>WintelleCt.Widget. </b>In the following code, the reference to <b>Widget </b>is ambiguous, so the C# compiler generates the following message: <b>&quot;error CS0l04: 'Widget' is an ambiguous referenCe&quot;:</b></p>
<p><code>using Microsoft;   // Try prepending &quot;Microsoft.&quot; using Wintellect; // Try prepending &quot;Wintellect.&quot;<br/>
public sealed class Program { public static void Main() {<br/>
Widget w = new Widget();// An ambiguous reference<br/>
}<br/>
}</code></p>
<p>To remove the ambiguity, you must explicitly tell the compiler which <b>Widget </b>you want to create:</p>
<p><code>using Microsoft;   // Try prepending &quot;Microsoft.&quot; using Wintellect; // Try prepending &quot;Wintellect.&quot;<br/>
public sealed class Program { public static void Main() {<br/>
Wintellect.Widget w = new Wintellect.WidgetO; // Not ambiguous<br/>
}<br/>
}</code></p>
<p>There's another form of the C# <b>using </b>directive that allows you to create an alias for a single type or namespace. This is handy if you have just a few types that you use from a namespace and don't want to pollute the global namespace with all of a namespace's types The following code demonstrates another way to solve the ambiguity problem shown in the preceding code:</p>
<p><code>using Microsoft;   // Try prepending &quot;Microsoft.&quot; using Wintellect; // Try prepending &quot;Wintellect.&quot;<br/>
// Define WintellectWidget symbol as an alias to Wintellect.Widget using WintellectWidget = Wintellect.Widget;<br/>
public sealed class Program { public static void Main() {<br/>
WintellectWidget w = new WintellectWidget(); // No error now<br/>
}<br/>
}</code></p>
<p>These methods of disambiguating a type are useful, but in some scenarios, you need to go further. Imagine that the Australian Boomerang Company (ABC) and the Alaskan Boat Corporation (ABC) are each creating a type, called <b>BuyProduCt, </b>which they intend to ship in their respective assemblies. It's likely that both companies would create a namespace called <b>ABC </b>that contains a type called <b>BuyProduCt. </b>Anyone who tries to develop an application that needs to buy both boomerangs and boats would be in for some trouble unless the programming language provides a way to programmatically distinguish between the assemblies, not just between the namespaces. Fortunately, the C# compiler offers a feature called extern aliases that gives you a way to work around this rarely occurring problem. Extern aliases also give you a way to access a single type from two (or more) different versions of the same assembly. For more information about extern aliases, see the C# Language Specification.</p>
<p>In your library, when you're designing types that you expect third parties to use, you should define these types in a namespace so that compilers can easily disambiguate them. In fact, to reduce the likelihood of conflict, you should use your full company name (not an acronym or abbreviation) to be your top-level namespace name. Referring to the Microsoft .NET Framework SDK documentation, you can see that Microsoft uses a namespace of &quot;Microsoft&quot; for Microsoft-specific types. (See the <b>MiCrosoft.CSharp, MiCrosoft.VisualBasiC, </b>and <b>MiCrosoft.Win32 </b>namespaces as examples.)</p>
<p>Creating a namespace is simply a matter of writing a namespace declaration into your code as follows (in C#):</p>
<p><code>namespace CompanyName {<br/>
public sealed class A {// TypeDef: CompanyName.A<br/>
}<br/>
namespace X {<br/>
public sealed class B {... }        // TypeDef: CompanyName.X.B<br/>
}<br/>
}</code></p>
<p>The comment on the right of the class definitions above indicates the real name of the type the compiler will emit into the type definition metadata table; this is the real name of the type from the CLR's perspective.</p>
<p>Some compilers don't support namespaces at all, and other compilers are free to define what &quot;namespace&quot; means to a particular language. In C#, the <b>namespaCe </b>directive simply tells the compiler to prefix each type name that appears in source code with the namespace name so that programmers can do less typing.</p>
<p>e</p>
<p>Be aware that a namespace and an assembly (the file that implements a type) aren't necessarily related. In particular, the various types belonging to a single namespace might be implemented in multiple assemblies. For example, the <b>System.IO.FileStream </b>type is implemented in the MSCorLib.dll assembly, and the <b>System.IO.FileSystemWatCher </b>type is implemented in the System.dll assembly. In fact, the .NET Framework doesn't even ship a System.IO.dll assembly.</p>
<p>A single assembly can contain types in different namespaces. For example, the <b>System.Int32 </b>and <b>System.Text.StringBuilder </b>types are both in the MSCorLib.dll assembly.</p>
<p>When you look up a type in the .NET Framework SDK documentation, the documentation will clearly indicate the namespace that the type belongs to and also the assembly that the type is implemented in. In Figure 4-1, you can clearly see (right above the Syntax section) that the <b>ResXFileRef </b>type is part of the <b>System.ResourCes </b>namespace and that the type is implemented in the System.Windows.Forms.dll assembly. To compile code that references the <b>ResXFileRef </b>type, you'd add a <b>using System.ResourCes; </b>directive to your source code, and you'd use the <b>/r:System.Windows.Forms.dll </b>compiler switch.</p>
<img src="17.jpg"/>
<p><b>Figure 4-1 </b>SDK documentation showing namespace and assembly information for a type</p>
<a name="b102"/><h2>How Things Relate at Runtime</h2>
<p>In this section, I'm going to explain the relationship at runtime between types, objects, a thread's stack, and the managed heap Furthermore, I will also explain the difference between calling static methods, instance methods, and virtual methods Let's start off with some fundamentals of computers. What I'm about to describe is not specific to the CLR at all, but I'm going to describe it so that we have a working foundation, and then I'll modify the discussion to incorporate CLR-specific information.</p>
<p>Figure 4-2 shows a single Microsoft Windows process that has the CLR loaded into it. In this process there may be many threads. When a thread is created, it is allocated a 1-MB stack. This stack space is used for passing arguments to a method and for local variables defined within a method. In Figure 4-2, the memory for one thread's stack is shown (on the right). Stacks build from high-memory addresses to low-memory addresses. In the figure, this thread has been executing some code, and its stack has some data on it already (shown as the shaded area at the top of the stack). Now, imagine that the thread has executed some code that calls the <b>Ml </b>method.</p>
<img src="18.jpg"/>
<p><b>Figure 4-2 </b>A thread's stack with the <b>Ml </b>method about to be called</p>
<p>All but the simplest of methods contain some prologue code, which initializes a method before it can start doing its work. These methods also contain epilogue code, which cleans up a method after it has performed its work so that it can return to its caller. When the <b>Ml </b>method starts to execute, its prologue code allocates memory for the local <b>name </b>variable from the thread's stack (see Figure 4-3).</p>
<img src="19.jpg"/>
<p><b>Figure 4-3 </b>Allocating <b>Ml</b>'s local variable on the thread's stack</p>
<p>Then, <b>Ml </b>calls the <b>M2 </b>method, passing in the <b>name </b>local variable as an argument. This causes the address in the <b>name </b>local variable to be pushed on the stack (see Figure 4-4). Inside the <b>M2 </b>method, the stack location will be identified using the parameter variable named <b>s </b>. (Note that some architectures pass arguments via registers to improve performance, but this distinction is not important for this discussion.) Also, when a method is called, the address indicating where the called method should return to in the calling method is pushed on the stack (also shown in Figure 4-4).</p>
<p><b>Figure 4-4 Ml </b>pushes arguments and the return address on the thread's stack when calling <b>M2.</b></p>
<p>When the <b>M2 </b>method starts to execute, its prologue code allocates memory for the local <b>length </b>and <b>tally </b>variables from the thread's stack (see Figure 4-5). Then the code inside method <b>M2 </b>executes. Eventually, <b>M2 </b>gets to its return statement, which causes the CPU's instruction pointer to be set to the return address in the stack, and <b>M2</b>'s stack frame is unwound so that it looks the way it did in Figure 4-3. At this point, <b>Ml </b>is continuing to execute its code that immediately follows the call to <b>M2, </b>and its stack frame accurately reflects the state needed by <b>Ml </b>.</p>
<img src="20.jpg"/>
<p>Eventually, <b>M1 </b>will return back to its caller by setting the CPU's instruction pointer to be set to the return address (not shown on the figures, but it would be just above the <b>name </b>argument on the stack), and <b>M1</b>'s stack frame is unwound so that it looks the way it did in Figure 4-2. At this point, the method that called <b>M1 </b>continues to execute its code that immediately follows the call to <b>M1, </b>and its stack frame accurately reflects the state needed by that method.</p>
<p><b>Figure 4-5 </b>Allocating <b>m2</b>'s local variables on the thread's stack</p>
<p>Now, let's start gearing the discussion toward the CLR. Let's say that we have these two class definitions:</p>
<p><code>internal class Employee {<br/>
public.Int32        GetYearsEmployed()     {... }<br/>
public virtual String GetProgressReport() {... } public static   Employee   Lookup(String name)   {... }<br/>
}<br/>
internal sealed class Manager : Employee {<br/>
public override String     GetProgressReport()   {... }<br/>
}</code></p>
<p>Our Windows process has started, the CLR is loaded into it, the managed heap is initialized, and a thread has been created (along with its 1 MB of stack space) This thread has already executed some code, and this code has decided to call the <b>M3 </b>method. All of this is shown in Figure 4-6. The <b>M3 </b>method contains code that demonstrates how the CLR works; this is not code that you would normally write, because it doesn't actually do anything useful.</p>
<img src="21.jpg"/>
<p><b>Figure 4-6 </b>The CLR loaded in a process, its heap initialized, and a thread's stack with the <b>M3 </b>method about to be called</p>
<p>As the just-in-time (JIT) compiler converts <b>M3</b>'s Intermediate Language (IL) code into native CPU instructions, it notices all of the types that are referred to inside <b>M3: Employee, Int32, Manager, </b>and <b>String </b>(because of <b>&quot;Joe&quot;) </b>. At this time, the CLR ensures that the assemblies that define these types are loaded. Then, using the assembly's metadata, the CLR extracts information about these types and creates some data structures to represent the types themselves. The data structures for the <b>Employee </b>and <b>Manager </b>type objects are shown in Figure 4-7 Since this thread already executed some code prior to calling <b>M3, </b>let's assume that the <b>Int32 </b>and <b>String </b>type objects have already been created (which is likely because these are commonly used types), and so I won't show them in the figure.</p>
<img src="22.jpg"/>
<p><b>Figure 4-7 </b>The <b>Employee </b>and <b>Manager </b>type objects are created just as <b>M3 </b>is being called.</p>
<p>Let's take a moment to discuss these type objects. As discussed earlier in this chapter, all objects on the heap contain two overhead members: the type object pointer and the sync block index. As you can see, the <b>Employee </b>and <b>Manager </b>type objects have both of these members. When you define a type, you can define static data fields within it. The bytes that back these static data fields are allocated within the type objects themselves. Finally, inside each type object is a method table with one entry per method defined within the type. This is the method table that was discussed in Chapter 1, &quot;The CLR's Execution Model.&quot; Since the <b>Employee </b>type defines three methods <b>(GetYearsEmployed, GetProgressReport, </b>and <b>Lookup), </b>there are three entries in <b>Employee</b>'s method table. Since the <b>Manager </b>type defines one method (an override of <b>GetProgressReport), </b>there is just one entry in <b>Manager</b>'s method table.</p>
<p>Now, after the CLR has ensured that all of the type objects required by the method are created and the code for <b>M3 </b>has been compiled, the CLR allows the thread to execute <b>M3</b>'s native code. When <b>M3</b>'s prologue code executes, memory for the local variables must be allocated from the thread's stack, as shown in Figure 4-8. By the way, the CLR automatically initializes all local variables to <b>null </b>or <b>0 </b>(zero) as part of the method's prologue code. However, the C# compiler issues a <b>&quot;Use of unassigned local variable&quot; </b>error message if you write code that attempts to read from a local variable that you have not explicitly initialized in your source code.</p>
<img src="23.jpg"/>
<p><b>Figure 4-8 </b>Allocating <b>M3</b>'s local variables on the thread's stack</p>
<p>Then, <b>M3 </b>executes its code to construct a <b>Manager </b>object. This causes an instance of the <b>Manager </b>type, a <b>Manager </b>object, to be created in the managed heap, as shown in Figure 4-9. As you can see, the <b>Manager </b>object預s do all objects揺as a type object pointer and sync block index. This object also contains the bytes necessary to hold all of the instance data fields defined by the <b>Manager </b>type, as well as any instance fields defined by any base classes of the <b>Manager </b>type (in this case, <b>Employee </b>and <b>Object). </b>Whenever a new object is created on the heap, the CLR automatically initializes the internal type object pointer member to refer to the object's corresponding type object (in this case, the <b>Manager </b>type object) Furthermore, the CLR initializes the sync block index and sets all of the object's instance fields to <b>null </b>or <b>0 </b>(zero) prior to calling the type's constructor, a method that will likely modify some of the instance data fields. The <b>new </b>operator returns the memory address of the <b>Manager </b>object, which is saved in the variable <b>e </b>(on the thread's stack).</p>
<img src="24.jpg"/>
<p><b>Figure 4-9 </b>Allocating and initializing a <b>Manager </b>object</p>
<p>The next line of code in <b>M3 </b>calls <b>Employee</b>'s static <b>Lookup </b>method. When calling a static method, the JIT compiler locates the type object that corresponds to the type that defines the static method. Then, the JIT compiler locates the entry in the type object's method table that refers to the method being called, JITs the method (if necessary), and calls the JITted code. For our discussion, let's say that <b>Employee</b>'s <b>Lookup </b>method queries a database to find Joe. Let's also say that the database indicates that Joe is a manager at the company, and therefore, internally, the <b>Lookup </b>method constructs a new <b>Manager </b>object on the heap, initializes it for Joe, and returns the address of this object The address is saved in the local variable <b>e. </b>The result of this operation is shown in Figure 4-10.</p>
<p>Note that <b>e </b>no longer refers to the first <b>Manager </b>object that was created. In fact, since no variable refers to this object, it is a prime candidate for being garbage collected in the future, which will reclaim (free) the memory used by this object.</p>
<p>The next line of code in <b>M3 </b>calls <b>Employee</b>'s nonvirtual instance <b>GetYearsEmployed </b>method. When calling a nonvirtual instance method, the JIT compiler locates the type object that corresponds to the type of the variable being used to make the call. In this case, the variable <b>e </b>is defined as an <b>Employee </b>. (If the <b>Employee </b>type didn't define the method being called, the JIT compiler walks down the class hierarchy toward <b>Object </b>looking for this method. It can do this because each type object has a field in it that refers to its base type; this information is not shown in the figures.) Then, the JIT compiler locates the entry in the type object's method table that refers to the method being called, JITs the method (if necessary), and then calls the JITted code. For our discussion, let's say that <b>Employee</b>'s <b>GetYearsEmployed </b>method returns <b>5 </b>because Joe has been employed at the company for five years. The integer is saved in the local variable <b>year </b>. The result of this operation is shown in Figure 4-11.</p>
<img src="25.jpg"/>
<p><b>Figure 4-10 </b><b>Employee</b>'s static <b>Lookup </b>method allocates and initializes a <b>Manager </b>object for Joe</p>
<p><b>Figure 4-11 </b><b>Employee</b>'s nonvirtual instance <b>GetYearsEmployed </b>method is called, returning <b>5</b></p>
<img src="26.jpg"/><img src="27.jpg"/>
<p>The next line of code in <b>M3 </b>calls <b>Employee</b>'s virtual instance <b>GetProgressReport </b>method. When calling a virtual instance method, the JIT compiler produces some additional code in the method, which will be executed each time the method is invoked. This code will first look in the variable being used to make the call and then follow the address to the calling object In this case, the variable <b>e </b>points to the <b>Manager </b>object representing &quot;Joe.&quot; Then, the code will examine the object's internal type object pointer member; this member refers to the actual type of the object. The code then locates the entry in the type object's method table that refers to the method being called, JITs the method (if necessary), and calls the JITted code. For our discussion, <b>Manager</b>'s <b>GetProgressReport </b>implementation is called because <b>e </b>refers to a <b>Manager </b>object. The result of this operation is shown in Figure 4-12.</p>
<p>Note that if <b>Employee</b>'s <b>Lookup </b>method had discovered that Joe was just an <b>Employee </b>and not a <b>Manager, Lookup </b>would have internally constructed an <b>Employee </b>object whose type object pointer member would have referred to the <b>Employee </b>type object, causing <b>Employee</b>'s implementation of <b>GetProgressReport </b>to execute instead of <b>Manager</b>'s implementation.</p>
<p><b>Figure 4-12 </b><b>Employee</b>'s virtual instance <b>GetProgressReport </b>method is called, causing <b>Manager</b>'s override of this method to execute</p>
<p>At this point, we have discussed the relationship between source code, IL, and JITted code. We have also discussed the thread's stack, arguments, local variables, and how these arguments and variables refer to objects on the managed heap. You also see how objects contain a pointer to their type object (containing the static fields and method table). We have also discussed how the JIT compiler determines how to call static methods, nonvirtual instance methods, and virtual instance methods All of this should give you great insight into how the</p>
<img src="28.jpg"/>
<p>CLR works, and this insight should help you when architecting and implementing your types, components, and applications. Before ending this chapter, I'd like to give you just a little more insight as to what is going on inside the CLR.</p>
<p>You'll notice that the <b>Employee </b>and <b>Manager </b>type objects both contain type object pointer members. This is because type objects are actually objects themselves. When the CLR creates type objects, the CLR must initialize these members. &quot;To what?&quot; you might ask. Well, when the CLR starts running in a process, it immediately creates a special type object for the <b>System.Type </b>type (defined in MSCorLib.dll). The <b>Employee </b>and <b>Manager </b>type objects are &quot;instances&quot; of this type, and therefore, their type object pointer members are initialized to refer to the <b>System.Type </b>type object, as shown in Figure 4-13.</p>
<p>Of course, the <b>System.Type </b>type object is an object itself and therefore also has a type object pointer member in it, and it is logical to ask what this member refers to It refers to itself because the <b>System.Type </b>type object is itself an &quot;instance&quot; of a type object. And now you should understand the CLR's complete type system and how it works. By the way, <b>System.ObjeCt</b>'s <b>GetType </b>method simply returns the address stored in the specified object's type object pointer member In other words, the <b>GetType </b>method returns a pointer to an object's type object, and this is how you can determine the true type of any object in the system (including type objects).</p>
<p><b>Figure 4-13 </b>The <b>Employee</b> and <b>Manager </b>type objects are instances of the <b>System.Type </b>type.</p>
<img src="29.jpg"/>
<mbp:pagebreak/>
<a name="Chapter5"/>
<h1>Chapter 5: Primitive, Reference, and Value Types</h1>
<p><b>In this chapter:</b></p>
<a href="#b113">Programming Language Primitive Types</a><br/>
<a href="#b121">Reference Types and Value Types</a><br/>
<a href="#b127">Boxing and Unboxing Value Types</a><br/>
<a href="#b146">Object Hash Codes</a><br/>
<a href="#b148">The dynamic Primitive Type</a><br/>
<p>In this chapter, I'll discuss the different kinds of types you'll run into as a Microsoft .NET Framework developer It is crucial for all developers to be familiar with the different behaviors that these types exhibit. When I was first learning the .NET Framework, I didn't fully understand the difference between primitive, reference, and value types. This lack of clarity led me to unwittingly introduce subtle bugs and performance issues into my code. By explaining the differences between the types here, I'm hoping to save you some of the headaches that I experienced while getting up to speed.</p>
<a name="b113"/><h2>Programming Language Primitive Types</h2>
<p>Certain data types are so commonly used that many compilers allow code to manipulate them using simplified syntax. For example, you could allocate an integer by using the following syntax:</p>
<p><code>System.Int32 a = new System.Int32();</code></p>
<p>But I'm sure you'd agree that declaring and initializing an integer by using this syntax is rather cumbersome. Fortunately, many compilers (including C#) allow you to use syntax similar to the following instead:</p>
<p><code>int a = 0;</code></p>
<p>This syntax certainly makes the code more readable and generates identical Intermediate Language (IL) to that which is generated when <b>System.Int32 </b>is used. Any data types the compiler directly supports are called primitive types. Primitive types map directly to types existing in the Framework Class Library (FCL). For example, in C#, an <b>int </b>maps directly to the</p>
<p><b>System.Int32 </b>type. Because of this, the following four lines of code all compile correctly and produce the exact same IL:</p>
<p><code>int.a = 0;// Most convenient syntax<br/>
System.Int32 a = 0;// Convenient syntax<br/>
int.a = new int();// Inconvenient syntax<br/>
System.Int32 a = new System.Int32();   // Most inconvenient syntax</code></p>
<p>Table 5-1 shows the FCL types that have corresponding primitives in C# For the types that are compliant with the Common Language Specification (CLS), other languages will offer similar primitive types. However, languages aren't required to offer any support for the non-CLS-compliant types.</p>
<p><b>Table 5-1 </b><b>C# Primitives with Corresponding FCL Types</b></p>
<table border="1">
<tr>
<td>
<p>Primitive Type</p>
</td>
<td>
<p>FCL Type</p>
</td>
<td>
<p><b>CLS-Compliant</b></p>
</td>
<td>
<p>Description</p>
</td>
</tr>
<tr>
<td>
<p>sbyte</p>
</td>
<td>
<p><b>System.SByte</b></p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Signed 8-bit value</p>
</td>
</tr>
<tr>
<td>
<p>byte</p>
</td>
<td>
<p><b>System.Byte</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Unsigned 8-bit value</p>
</td>
</tr>
<tr>
<td>
<p>short</p>
</td>
<td>
<p><b>System.Int16</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Signed 16-bit value</p>
</td>
</tr>
<tr>
<td>
<p>ushort</p>
</td>
<td>
<p><b>System.Uint16</b></p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Unsigned 16-bit value</p>
</td>
</tr>
<tr>
<td>
<p>int</p>
</td>
<td>
<p><b>System.Int32</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Signed 32-bit value</p>
</td>
</tr>
<tr>
<td>
<p>uint</p>
</td>
<td>
<p><b>System.Uint32</b></p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Unsigned 32-bit value</p>
</td>
</tr>
<tr>
<td>
<p>long</p>
</td>
<td>
<p><b>System.Int64</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Signed 64-bit value</p>
</td>
</tr>
<tr>
<td>
<p>ulong</p>
</td>
<td>
<p><b>System.UInt64</b></p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Unsigned 64-bit value</p>
</td>
</tr>
<tr>
<td>
<p>char</p>
</td>
<td>
<p><b>System.Char</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>16-bit Unicode character <b>(char </b>never represents an 8-bit value as it would in unmanaged C++.)</p>
</td>
</tr>
<tr>
<td>
<p>float</p>
</td>
<td>
<p><b>System.Single</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>IEEE 32-bit floating point value</p>
</td>
</tr>
<tr>
<td>
<p>double</p>
</td>
<td>
<p><b>System.Double</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>IEEE 64-bit floating point value</p>
</td>
</tr>
<tr>
<td>
<p>bool</p>
</td>
<td>
<p><b>System.Boolean</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>A <b>true/false </b>value</p>
</td>
</tr>
<tr>
<td>
<p>decimal</p>
</td>
<td>
<p><b>System.Decimal</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>A 128-bit high-precision floating-point value commonly used for financial calculations in which rounding errors can't be tolerated. Of the 128 bits, 1 bit represents the sign of the value, 96 bits represent the value itself, and 8 bits represent the power of 10 to divide the 96-bit value by (can be anywhere from 0 to 28) The remaining bits are unused.</p>
</td>
</tr>
<tr>
<td>
<p>string</p>
</td>
<td>
<p><b>System.String</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>An array of characters</p>
</td>
</tr>
<tr>
<td>
<p>object</p>
</td>
<td>
<p><b>System.Object</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Base type of all types</p>
</td>
</tr>
<tr>
<td>
<p>dynamic</p>
</td>
<td>
<p><b>System.Object</b></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>To the common language runtime (CLR), <b>dynamic </b>is identical to <b>object </b>However, the C# compiler allows <b>dynamic </b>variables to participate in dynamic dispatch using a simplified syntax. For more information, see &quot;The <b>dynamic </b>Primitive Type&quot; section at the end of this chapter.</p>
</td>
</tr>
</table>
<p>Another way to think of this is that the C# compiler automatically assumes that you have the following <b>using </b>directives (as discussed in Chapter 4, &quot;Type Fundamentals&quot;) in all of your source code files:</p>
<p><code>using sbyte   = System.SByte; using byte    = System.Byte; using short   = System.Int16; using ushort = System.UInt16; using int      = System.Int32; using uint    = System.UInt32;</code></p>
<p>The C# language specification states, &quot;As a matter of style, use of the keyword is favored over use of the complete system type name.&quot; I disagree with the language specification; I prefer to use the FCL type names and completely avoid the primitive type names. In fact, I wish that compilers didn't even offer the primitive type names and forced developers to use the FCL type names instead. Here are my reasons:</p>
<p>&#9632; I've seen a number of developers confused, not knowing whether to use <b>string </b>or <b>String </b>in their code. Because in C# <b>string </b>(a keyword) maps exactly to <b>System.String </b>(an FCL type), there is no difference and either can be used. Similarly, I've heard some developers say that <b>int </b>represents a 32-bit integer when the application is running on a 32-bit OS and that it represents a 64-bit integer when the application is running on a 64-bit OS. This statement is absolutely false: in C#, an <b>int </b>always maps to <b>System.Int32, </b>and therefore it represents a 32-bit integer regardless of the OS the code is running on If programmers would use <b>Int32 </b>in their code, then this potential confusion is also eliminated.</p>
<p>&#9632; In C#, <b>long </b>maps to <b>System.Int64, </b>but in a different programming language, <b>long </b>could map to an <b>Int16 </b>or <b>Int32. </b>In fact, C++/CLI does treat <b>long </b>as an <b>Int32. </b>Someone reading source code in one language could easily misinterpret the code's intention if he or she were used to programming in a different programming language In fact, most languages won't even treat <b>long </b>as a keyword and won't compile code that uses it.</p>
<p>&#9632; The FCL has many methods that have type names as part of their method names. For example, the <b>BinaryReader </b>type offers methods such as <b>ReadBoolean, ReadInt32, ReadSingle, </b>and so on, and the <b>System.Convert </b>type offers methods such as <b>ToBoolean, ToInt32, ToSingle, </b>and so on. Although it's legal to write the following code, the line with <b>float </b>feels very unnatural to me, and it's not obvious that the line is correct:</p>
<p><code>BinaryReader br = new BinaryReader(...);<br/>
float   val = br.ReadSingle();     // OK, but feels unnatural<br/>
Single val = br.ReadSingleO;     // OK and feels good</code></p>
<p>&#9632; Many programmers that use C# exclusively tend to forget that other programming languages can be used against the CLR, and because of this, C#-isms creep into the class library code. For example, Microsoft's FCL is almost exclusively written in C# and developers on the FCL team have now introduced methods into the library such as <b>Array</b>'s <b>GetLongLength, </b>which returns an <b>Int64 </b>value that is a <b>long </b>in C# but not in other languages (like C++/CLI). Another example is <b>System.Linq.Enumerable</b>'s <b>LongCount </b>method.</p>
<p>For all of these reasons, I'll use the FCL type names throughout this book.</p>
<p>In many programming languages, you would expect the following code to compile and execute correctly:</p>
<p><code>Int32   i = 5;     // A 32-bit value<br/>
Int64   l = i;     // Implicit cast to a 64-bit value</code></p>
<p>However, based on the casting discussion presented in Chapter 4, you wouldn't expect this code to compile. After all, <b>System.Int32 </b>and <b>System.Int64 </b>are different types, and neither one is derived from the other. Well, you'll be happy to know that the C# compiler does compile this code correctly, and it runs as expected Why? The reason is that the C# compiler has intimate knowledge of primitive types and applies its own special rules when compiling the code In other words, the compiler recognizes common programming patterns and produces the necessary IL to make the written code work as expected. Specifically, the C# compiler supports patterns related to casting, literals, and operators, as shown in the following examples.</p>
<p>First, the compiler is able to perform implicit or explicit casts between primitive types such as these:</p>
<p><code>Int32   i = 5;// Implicit cast from Int32   to Int32<br/>
Int64   l = i;// Implicit cast from Int32   to Int64<br/>
Single s = i;// Implicit cast from Int32   to Single<br/>
Byte    b = (Byte) i;   // Explicit cast from Int32   to Byte Int16   v = (Int16) s; // Explicit cast from Single to Int16</code></p>
<p>C# allows implicit casts if the conversion is &quot;safe,&quot; that is, no loss of data is possible, such as converting an <b>Int32 </b>to an <b>Int64 </b>But C# requires explicit casts if the conversion is potentially unsafe For numeric types, &quot;unsafe&quot; means that you could lose precision or magnitude as a result of the conversion For example, converting from <b>Int32 </b>to <b>Byte </b>requires an explicit cast because precision might be lost from large <b>Int32 </b>numbers; converting from <b>Single </b>to <b>Int16 </b>requires a cast because <b>Single </b>can represent numbers of a larger magnitude than <b>Int16 </b>can.</p>
<p>Be aware that different compilers can generate different code to handle these cast operations For example, when casting a <b>Single </b>with a value of 6. 8 to an <b>Int32, </b>some compilers could generate code to put a 6 in the <b>Int32, </b>and others could perform the cast by rounding the result up to 7 By the way, C# always truncates the result. For the exact rules that C# follows for casting primitive types, see the &quot;Conversions&quot; section in the C# language specification.</p>
<p>In addition to casting, primitive types can be written as literals. A literal is considered to be an instance of the type itself, and therefore, you can call instance methods by using the instance as shown here:</p>
<p><code>Console.WriteLine(123.ToStringO + 456.ToString());   // &quot;123456&quot;</code></p>
<p>Also, if you have an expression consisting of literals, the compiler is able to evaluate the expression at compile time, improving the application's performance.</p>
<p><code>Boolean found = false;      // Generated code sets found to 0 Int32 x = 100 + 20 + 3;    // Generated code sets x to 123 String s = &quot;a &quot; + &quot;bc&quot;;     // Generated code sets s to &quot;a bc&quot;</code></p>
<p>Finally, the compiler automatically knows how and in what order to interpret operators (such as <b>+</b>, <b>-</b>, <b>*</b>, <b>/</b>, <b>%</b>, <b>&amp;</b>, <b>a, </b><b>|</b>, <b>==</b>, <b>!=</b>, <b>&gt;</b>, <b>&lt;</b>, <b>&gt;=</b>, <b>&lt;=</b>, <b>&lt;&lt;</b>, <b>&gt;&gt;</b>, <b>~</b>, <b>!</b>, <b>++</b>, <b>--</b>, and so on) when used in code:</p>
<p><code>Int32 x = 100;// Assignment operator<br/>
Int32 y = x + 23;// Addition and assignment operators<br/>
Boolean lessThanFifty = (y &lt; 50);   // Less-than and assignment operators</code></p>
<h3>Checked and Unchecked Primitive Type Operations</h3>
<p>Programmers are well aware that many arithmetic operations on primitives could result in an overflow:</p>
<p><code>Byte b = 100;<br/>
b = (Byte) (b + 200);// b now contains 44 (or 2C in Hex).</code></p>
<hr/>
<blockquote><b>Important </b>When performing the arithmetic operation above, the first step requires that all operand values be expanded to 32-bit values (or 64-bit values if any operand requires more than 32 bits). So <b>b </b>and <b>200 </b>(values requiring less than 32 bits) are first converted to 32-bit values and then added together The result is a 32-bit value (300 in decimal, or 12C in hexadecimal) that must be cast to a <b>Byte </b>before the result can be stored back in the variable <b>b. </b>C# doesn't perform this cast for you implicitly, which is why the <b>Byte </b>cast on the second line of the preceding code is required.</blockquote>
<hr/>
<p>In most programming scenarios, this silent overflow is undesirable and if not detected causes the application to behave in strange and unusual ways. In some rare programming scenarios (such as calculating a hash value or a checksum), however, this overflow is not only acceptable but is also desired.</p>
<p>Different languages handle overflows in different ways. C and C++ don't consider overflows to be an error and allow the value to wrap; the application continues running. Microsoft Visual Basic, on the other hand, always considers overflows to be errors and throws an exception when it detects one.</p>
<p>The CLR offers IL instructions that allow the compiler to choose the desired behavior. The CLR has an instruction called <b>add </b>that adds two values together. The <b>add </b>instruction performs no overflow checking. The CLR also has an instruction called <b>add.ovf </b>that also adds two values together. However, <b>add.ovf </b>throws a <b>System.OverflowException </b>if an overflow occurs. In addition to these two IL instructions for the add operation, the CLR also has similar IL instructions for subtraction <b>(sub/sub.ovf), </b>multiplication <b>(mul/mul.ovf), </b>and data conversions <b>(conv/conv.ovf).</b></p>
<p>C# allows the programmer to decide how overflows should be handled. By default, overflow checking is turned off This means that the compiler generates IL code by using the versions of the add, subtract, multiply, and conversion instructions that don't include overflow checking. As a result, the code runs faster傭ut developers must be assured that overflows won't occur or that their code is designed to anticipate these overflows.</p>
<p>One way to get the C# compiler to control overflows is to use the <b>/checked+ </b>compiler switch. This switch tells the compiler to generate code that has the overflow-checking versions of the add, subtract, multiply, and conversion IL instructions. The code executes a little slower because the CLR is checking these operations to determine whether an overflow occurred. If an overflow occurs, the CLR throws an <b>Overflow/Exception </b>.</p>
<p>In addition to having overflow checking turned on or off globally, programmers can control overflow checking in specific regions of their code. C# allows this flexibility by offering <b>checked </b>and <b>unchecked </b>operators. Here's an example that uses the <b>unchecked </b>operator:</p>
<p><code>UInt32 invalid = unchecked((UInt32) (-1));   // OK</code></p>
<p>And here is an example that uses the <b>checked </b>operator:</p>
<p><code>Byte b = 100;<br/>
b = checked((Byte) (b + 200));      // OverflowException is thrown</code></p>
<p>In this example, <b>b </b>and <b>200 </b>are first converted to 32-bit values and are then added together; the result is 300. Then 300 is converted to a <b>Byte </b>due to the explicit cast; this generates the <b>Overflow/Exception </b>. If the <b>Byte </b>were cast outside the <b>checked </b>operator, the exception wouldn't occur:</p>
<p><code>b = (Byte) checked(b + 200);<br/>
// b contains 44; no OverflowException</code></p>
<p>In addition to the <b>checked </b>and <b>unchecked </b>operators, C# also offers <b>checked </b>and <b>unchecked</b></p>
<p>statements The statements cause all expressions within a block to be checked or unchecked:</p>
<p><code>checked {// Start of checked block<br/>
Byte b = 100;<br/>
b = (Byte) (b + 200);// This expression is checked for overflow.<br/>
}// End of checked block</code></p>
<p>In fact, if you use a <b>checked </b>statement block, you can now use the <b>+= </b>operator with the <b>Byte, </b>which simplifies the code a bit:</p>
<p><code>checked {// Start of checked block Byte b = 100;<br/>
b += 200;// This expression is checked for overflow.<br/>
}// End of checked block</code></p>
<hr/>
<blockquote><b>Important </b>Because the only effect that the <b>checked </b>operator and statement have is to determine which versions of the add, subtract, multiply, and data conversion IL instructions are produced, calling a method within a <b>checked </b>operator or statement has no impact on that method, as the following code demonstrates:
<p><code>checked {<br/>
// Assume SomeMethod tries to load 400 into a Byte. SomeMethod(400);<br/>
// SomeMethod might or might not throw an OverflowException.<br/>
// It would if SomeMethod were compiled with checked instructions.<br/>
}</code></p></blockquote>
<hr/>
<p>In my experience, I've seen a lot of calculations produce surprising results. Typically, this is due to invalid user input, but it can also be due to values returned from parts of the system that a programmer just doesn't expect. And so, I now recommend that programmers do the following:</p>
<p>&#9632; Use signed data types (such as <b>Int32 </b>and <b>Int64) </b>instead of unsigned numeric types (such as <b>UInt32 </b>and <b>UInt64) </b>wherever possible. This allows the compiler to detect more overflow/underflow errors. In addition, various parts of the class library (such as <b>Array</b>'s and <b>String</b>'s <b>Length </b>properties) are hard-coded to return signed values, and less casting is required as you move these values around in your code Fewer casts make source code cleaner and easier to maintain In addition, unsigned numeric types are not CLS-compliant.</p>
<p>&#9632; As you write your code, explicitly use <b>checked </b>around blocks where an unwanted overflow might occur due to invalid input data, such as processing a request with data supplied from an end user or a client machine. You might want to catch <b>Overflow/Exception </b>as well, so that your application can gracefully recover from these failures.</p>
<p>&#9632; As you write your code, explicitly use <b>unchecked </b>around blocks where an overflow is OK, such as calculating a checksum.</p>
<p>&#9632; For any code that doesn't use <b>checked </b>or <b>unchecked, </b>the assumption is that you do want an exception to occur on overflow, for example, calculating something (such as prime numbers) where the inputs are known, and overflows are bugs.</p>
<p>Now, as you develop your application, turn on the compiler's <b>/checked+ </b>switch for debug builds. Your application will run more slowly because the system will be checking for overflows on any code that you didn't explicitly mark as <b>checked </b>or <b>unchecked. </b>If an exception occurs, you'll easily detect it and be able to fix the bug in your code. For the release build of your application, use the compiler's <b>/checked</b>-switch so that the code runs faster and overflow exceptions won't be generated. To change the Checked setting in Microsoft Visual Studio, display the properties for your project, select the Build tab, click Advanced, and then select the Check For Arithmetic Overflow/underflow&quot; option, as shown in Figure 5-1.</p>
<p>If your application can tolerate the slight performance hit of always doing checked operations, then I recommend that you compile with the <b>/checked </b>command-line option even for a release build because this can prevent your application from continuing to run with corrupted data and possible security holes. For example, you might perform a multiplication to calculate an index into an array; it is much better to get an <b>Overflow/Exception </b>as opposed to accessing an incorrect array element due to the math wrapping around.</p>
<img src="30.jpg"/>
<p><b>Figure 5-1 </b>Changing the compiler's default setting for performing checked arithmetic using Visual Studio's Advanced Build Settings dialog box</p>
<hr/>
<blockquote><b>Important </b>The <b>System.Decimal </b>type is a very special type. Although many programming languages (C# and Visual Basic included) consider <b>Decimal </b>a primitive type, the CLR does not. This means that the CLR doesn't have IL instructions that know how to manipulate a <b>Decimal </b>value. If you look up the <b>Decimal </b>type in the .NET Framework SDK documentation, you'll see that it has public static methods called <b>Add, Subtract, Multiply, Divide, </b>and so on. In addition, the <b>Decimal </b>type provides operator overload methods for <b>+</b>, <b>-</b>, <b>*</b>, <b>/</b>, and so on.</blockquote>
<hr/>
<p>When you compile code that uses <b>Decimal </b>values, the compiler generates code to call <b>Decimal</b>'s members to perform the actual operation. This means that manipulating <b>Decimal </b>values is slower than manipulating CLR primitive values Also, because there are no IL instructions for manipulating <b>Decimal </b>values, the <b>checked </b>and <b>unchecked </b>operators, statements, and compiler switches have no effect. Operations on <b>Decimal </b>values always throw an <b>Overflow/Exception </b>if the operation can't be performed safely</p>
<p>Similarly, the <b>System.Numerics.BigInteger </b>type is also special in that it internally uses an array of <b>UInt32</b>s to represent an arbitrarily large integer whose value has no upper or lower bound. Therefore, operations on a <b>BigInteger </b>never result in an <b>Overflow/Exception </b>. However, a <b>BigInteger </b>operation may throw an <b>OutOfMemoryException </b>if the value gets too large and there is insufficient available memory to resize the array</p>
<a name="b121"/><h2>Reference Types and Value Types</h2>
<p>The CLR supports two kinds of types: reference types and value types. While most types in the FCL are reference types, the types that programmers use most often are value types Reference types are always allocated from the managed heap, and the C# <b>new </b>operator returns the memory address of the object葉he memory address refers to the object's bits. You need to bear in mind some performance considerations when you're working with reference types First, consider these facts:</p>
<p>&#9632; The memory must be allocated from the managed heap.</p>
<p>&#9632; Each object allocated on the heap has some additional overhead members associated with it that must be initialized.</p>
<p>&#9632; The other bytes in the object (for the fields) are always set to zero.</p>
<p>&#9632; Allocating an object from the managed heap could force a garbage collection to occur.</p>
<p>If every type were a reference type, an application's performance would suffer greatly. Imagine how poor performance would be if every time you used an <b>Int32 </b>value, a memory allocation occurred! To improve performance for simple, frequently used types, the CLR offers lightweight types called value types. Value type instances are usually allocated on a thread's stack (although they can also be embedded as a field in a reference type object). The variable representing the instance doesn't contain a pointer to an instance; the variable contains the fields of the instance itself Because the variable contains the instance's fields, a pointer doesn't have to be dereferenced to manipulate the instance's fields. Value type instances don't come under the control of the garbage collector, so their use reduces pressure in the managed heap and reduces the number of collections an application requires over its lifetime.</p>
<p>The .NET Framework SDK documentation clearly indicates which types are reference types and which are value types. When looking up a type in the documentation, any type called a class is a reference type. For example, the <b>System.Exception </b>class, the <b>System.IO.FileStream </b>class, and the <b>System.Random </b>class are all reference types On the other hand, the documentation refers to each value type as a structure or an enumeration. For example, the <b>System.Int32 </b>structure, the <b>System.Boolean </b>structure, the <b>System.Decimal </b>structure, the <b>System.TimeSpan </b>structure, the <b>System.DayOfWeek </b>enumeration, the <b>System.IO.FileAttributes </b>enumeration, and the <b>System.Drawing.FontStyle </b>enumeration are all value types.</p>
<p>If you look more closely at the documentation, you'll notice that all of the structures are immediately derived from the <b>System.ValueType </b>abstract type. <b>System.ValueType </b>is itself immediately derived from the <b>System.Object </b>type. By definition, all value types must be derived from <b>System.ValueType. </b>All enumerations are derived from the <b>System.Enum </b>abstract type, which is itself derived from <b>System.ValueType </b>The CLR and all programming languages give enumerations special treatment For more information about enumerated types, refer to Chapter 15, &quot;Enumerated Types and Bit Flags.&quot;</p>
<p>Even though you can't choose a base type when defining your own value type, a value type can implement one or more interfaces if you choose. In addition, all value types are sealed, which prevents a value type from being used as a base type for any other reference type or value type. So, for example, it's not possible to define any new types using <b>Boolean, Char, Int32, Uint64, Single, Double, Decimal, </b>and so on as base types.</p>
<hr/>
<blockquote><b>Important </b>For many developers (such as unmanaged C/C++ developers), reference types and value types will seem strange at first. In unmanaged C/C++, you declare a type, and then the code that uses the type gets to decide if an instance of the type should be allocated on the thread's stack or in the application's heap. In managed code, the developer defining the type indicates where instances of the type are allocated; the developer using the type has no control over this.</blockquote>
<hr/>
<p>The following code and Figure 5-2 demonstrate how reference types and value types differ:</p>
<p><code>// Reference type (because of 'class') class   SomeRef { public Int32 x; }<br/>
// Value type (because of 'struct') struct SomeVal { public Int32 x; }<br/>
static void ValueTypeDemo() {<br/>
SomeRef rl = new SomeRef();     // Allocated in heap SomeVal vl = new SomeVa1();     // Allocated on stack<br/>
rl.x = 5;// Pointer dereference<br/>
vl.x = 5;// Changed on stack<br/>
Console.WriteLine(rl.x);// Displays &quot;5&quot;<br/>
Console.WriteLine(vl.x);// Also displays &quot;5&quot;<br/>
// The left side of Figure 5-2 reflects the situation // after the lines above have executed.<br/>
SomeRef r2 = rl;// Copies reference (pointer) only<br/>
SomeVal v2 = vl;// Allocate on stack &amp; copies members<br/>
rl.x = 8;// Changes rl.x and r2.x<br/>
vl.x = 9;// Changes vl.x, not v2.x<br/>
Console.WriteLine(rl.x);// Displays &quot;8&quot;<br/>
Console.WriteLine(r2.x);// Displays &quot;8&quot;<br/>
Console.WriteLine(vl.x);// Displays &quot;9&quot;<br/>
Console.WriteLine(v2.x);// Displays &quot;5&quot;<br/>
// The right side of Figure 5-2 reflects the situation // after ALL of the lines above have executed.<br/>
}</code></p>
<p>In this code, the <b>SomeVal </b>type is declared using <b>struct </b>instead of the more common <b>class. </b>In C#, types declared using <b>struct </b>are value types, and types declared using <b>class </b>are reference types As you can see, the behavior of reference types and value types differs quite a bit As you use types in your code, you must be aware of whether the type is a reference type or a value type because it can greatly affect how you express your intentions in the code.</p>
<p><b>Figure 5-2 </b>Visualizing the memory as the code executes</p>
<p>In the preceding code, you saw this line:</p>
<p><code>SomeVal v1 = new SomeVal();     // Allocated on stack</code></p>
<p>The way this line is written makes it look as if a <b>SomeVal </b>instance will be allocated on the managed heap However, the C# compiler knows that <b>SomeVal </b>is a value type and produces code that allocates the <b>SomeVal </b>instance on the thread's stack. C# also ensures that all of the fields in the value type instance are zeroed.</p>
<img src="31.jpg"/>
<p>The preceding line could have been written like this instead:</p>
<p><code>SomeVal v1;     // Allocated on stack</code></p>
<p>This line also produces IL that allocates the instance on the thread's stack and zeroes the fields. The only difference is that C# &quot;thinks&quot; that the instance is initialized if you use the <b>new </b>operator The following code will make this point clear:</p>
<p><code>// These two lines compile because C# thinks that // v1's fields have been initialized to 0. SomeVal v1 = new SomeVal(); Int32 a = v1.x;<br/>
// These two lines don't compile because C# doesn't think that // v1's fields have been initialized to 0. SomeVal v1;<br/>
Int32 a = v1.x;   // error CS0170: Use of possibly unassigned field 'x'</code></p>
<p>When designing your own types, consider carefully whether to define your types as value types instead of reference types. In some situations, value types can give better performance. In particular, you should declare a type as a value type if all the following statements are true:</p>
<p>&#9632; The type acts as a primitive type. Specifically, this means that it is a fairly simple type that has no members that modify any of its instance fields. When a type offers no members that alter its fields, we say that the type is immutable. In fact, it is recommended that many value types mark all their fields as <b>readonly </b>(discussed in Chapter 7, &quot;Constants and Fields&quot;).</p>
<p>&#9632; The type doesn't need to inherit from any other type.</p>
<p>&#9632; The type won't have any other types derived from it.</p>
<p>The size of instances of your type is also a condition to take into account because by default, arguments are passed by value, which causes the fields in value type instances to be copied, hurting performance. Again, a method that returns a value type causes the fields in the instance to be copied into the memory allocated by the caller when the method returns, hurting performance So, in addition to the previous conditions, you should declare a type as a value type if one of the following statements is true:</p>
<p>&#9632; Instances of the type are small (approximately 16 bytes or less).</p>
<p>&#9632; Instances of the type are large (greater than 16 bytes) and are not passed as method parameters or returned from methods.</p>
<p>The main advantage of value types is that they're not allocated as objects in the managed heap. Of course, value types have several limitations of their own when compared to reference types. Here are some of the ways in which value types and reference types differ:</p>
<p>&#9632; Value type objects have two representations: an unboxed form and a boxed form (discussed in the next section). Reference types are always in a boxed form.</p>
<p>&#9632; Value types are derived from <b>System.ValueType </b>. This type offers the same methods as defined by <b>System.Object </b>. However, <b>System.ValueType </b>overrides the <b>Equals </b>method so that it returns <b>true </b>if the values of the two objects' fields match. In addition, <b>System.ValueType </b>overrides the <b>GetHashCode </b>method to produce a hash code value by using an algorithm that takes into account the values in the object's instance fields. Due to performance issues with this default implementation, when defining your own value types, you should override and provide explicit implementations for the <b>Equals </b>and <b>GetHashCode </b>methods. I'll cover the <b>Equals </b>and <b>GetHashCode </b>methods at the end of this chapter.</p>
<p>&#9632; Because you can't define a new value type or a new reference type by using a value type as a base class, you shouldn't introduce any new virtual methods into a value type. No methods can be abstract, and all methods are implicitly sealed (can't be overridden).</p>
<p>&#9632; Reference type variables contain the memory address of objects in the heap. By default, when a reference type variable is created, it is initialized to <b>null, </b>indicating that the reference type variable doesn't currently point to a valid object. Attempting to use a <b>null </b>reference type variable causes a <b>NullReferenceException </b>to be thrown. By contrast, value type variables always contain a value of the underlying type, and all members of the value type are initialized to 0. Since a value type variable isn't a pointer, it's not possible to generate a <b>NullReferenceException </b>when accessing a value type. The CLR does offer a special feature that adds the notion of nullability to a value type. This feature, called nullable types, is discussed in Chapter 19, &quot;Nullable Value Types.&quot;</p>
<p>&#9632; When you assign a value type variable to another value type variable, a field-by-field copy is made When you assign a reference type variable to another reference type variable, only the memory address is copied.</p>
<p>&#9632; Because of the previous point, two or more reference type variables can refer to a single object in the heap, allowing operations on one variable to affect the object referenced by the other variable On the other hand, value type variables are distinct objects, and it's not possible for operations on one value type variable to affect another.</p>
<p>&#9632; Because unboxed value types aren't allocated on the heap, the storage allocated for them is freed as soon as the method that defines an instance of the type is no longer active. This means that a value type instance doesn't receive a notification (via a <b>Finalize </b>method) when its memory is reclaimed.</p>
<hr/>
<blockquote><b>Note </b>In fact, it would be quite odd to define a value type with a <b>Finalize </b>method since the method would be called only on boxed instances. For this reason, many compilers (including C#, C++/CLI, and Visual Basic) don't allow you to define <b>Finalize </b>methods on value types. Although the CLR allows a value type to define a <b>Finalize </b>method, the CLR won't call this method when a boxed instance of the value type is garbage collected.</blockquote>
<hr/>
<p><b>How the CLR Controls the Layout of a Type's Fields</b></p>
<p>To improve performance, the CLR is capable of arranging the fields of a type any way it chooses. For example, the CLR might reorder fields in memory so that object references are grouped together and data fields are properly aligned and packed. However, when you define a type, you can tell the CLR whether it must keep the type's fields in the same order as the developer specified them or whether it can reorder them as it sees fit</p>
<p>You tell the CLR what to do by applying the <b>System.Runtime.InteropServices </b>. <b>StructLayoutAttribute </b>attribute on the class or structure you're defining. To this attribute's constructor, you can pass <b>LayoutKind.Auto </b>to have the CLR arrange the fields, <b>LayoutKind.Sequential </b>to have the CLR preserve your field layout, or <b>LayoutKind.Explicit </b>to explicitly arrange the fields in memory by using offsets. If you don't explicitly specify the <b>StructLayoutAttribute </b>on a type that you're defining, your compiler selects whatever layout it determines is best.</p>
<p>You should be aware that Microsoft's C# compiler selects <b>LayoutKind.Auto </b>for reference types (classes) and <b>LayoutKind.Sequential </b>for value types (structures). It is obvious that the C# compiler team believes that structures are commonly used when interoperating with unmanaged code, and for this to work, the fields must stay in the order defined by the programmer. However, if you're creating a value type that has nothing to do with interoperability with unmanaged code, you probably want to override the C# compiler's default. Here's an example:</p>
<p><code>using System;<br/>
using System.Runtime.InteropServices;<br/>
// Let the CLR arrange the fields to improve performance for this value type. [StructLayout(LayoutKind.Auto)] internal struct SomeValType { private readonly Byte m_b; private readonly Int16 m_x;<br/>
}</code></p>
<p>The <b>StructLayoutAttribute </b>also allows you to explicitly indicate the offset of each field by passing <b>LayoutKind.Explicit </b>to its constructor. Then you apply an instance of the <b>System.Runtime.InteropServices.FieldOffsetAttribute </b>attribute to each field passing to this attribute's constructor an <b>Int32 </b>indicating the offset (in bytes) of the field's first byte from the beginning of the instance. Explicit layout is typically used to simulate what would be a union in unmanaged C/C++ because you can have multiple fields starting at the same offset in memory. Here is an example:</p>
<p><code>using System;<br/>
using System.Runtime.InteropServices;<br/>
// The developer explicitly arranges the fields of this value type. <b>I </b>[StructLayout(LayoutKind.Explicit)] internal struct SomeValType { [FieldOffset(0)]<br/>
private readonly Byte m_b; // The m_b and m_x fields overlap each [FieldOffset(0)]<br/>
private readonly Int16 m_x; // other in instances of this type<br/>
}</code></p>
<p>It should be noted that it is illegal to define a type in which a reference type and a value type overlap. It is possible to define a type in which multiple reference types overlap at the same starting offset; however, this is unverifiable. It is legal to define a type in which multiple value types overlap; however, all of the overlapping bytes must be accessible via public fields for the type to be verifiable.</p>
<a name="b127"/><h2>Boxing and Unboxing Value Types</h2>
<p>Value types are lighter weight than reference types because they are not allocated as objects in the managed heap, not garbage collected, and not referred to by pointers. However, in many cases, you must get a reference to an instance of a value type. For example, let's say that you wanted to create an <b>ArrayList </b>object (a type defined in the <b>System.Collections </b>namespace) to hold a set of <b>Point </b>structures. The code might look like this:</p>
<p><code>// Declare a value type. struct Point {<br/>
public Int32 x, y;<br/>
}<br/>
public sealed class Program { public static void Main() {<br/>
ArrayList a = new ArrayList();<br/>
Point p;// Allocate a Point (not in the heap).<br/>
for (Int32 i = 0; i &lt; 10; i++) {<br/>
p.x = p.y = i;     // Initialize the members in the value type. a.Add(p);// Box the value type and add the<br/>
// reference to the Arraylist.<br/>
}<br/>
}<br/>
}</code></p>
<p>With each iteration of the loop, a <b>Point</b>'s value type fields are initialized. Then the <b>Point </b>is stored in the <b>ArrayList. </b>But let's think about this for a moment. What is actually being stored in the <b>ArrayList? </b>Is it the <b>Point </b>structure, the address of the <b>Point </b>structure, or something else entirely? To get the answer, you must look up <b>ArrayList</b>'s <b>Add </b>method and see what type its parameter is defined as. In this case, the <b>Add </b>method is prototyped as follows:</p>
<p><code>public virtual Int32 Add(Object value);</code></p>
<p>From this, you can plainly see that <b>Add </b>takes an <b>Object </b>as a parameter, indicating that <b>Add </b>requires a reference (or pointer) to an object on the managed heap as a parameter. But in the preceding code, I'm passing <b>p, </b>a <b>Point, </b>which is a value type. For this code to work, the <b>Point </b>value type must be converted into a true heap-managed object, and a reference to this object must be obtained.</p>
<p>It's possible to convert a value type to a reference type by using a mechanism called boxing. Internally, here's what happens when an instance of a value type is boxed:</p>
<p><b>1. </b>Memory is allocated from the managed heap. The amount of memory allocated is the size required by the value type's fields plus the two additional overhead members (the type object pointer and the sync block index) required by all objects on the managed heap.</p>
<p><b>2. </b>The value type's fields are copied to the newly allocated heap memory.</p>
<p><b>3. </b>The address of the object is returned. This address is now a reference to an object; the value type is now a reference type.</p>
<p>The C# compiler automatically produces the IL code necessary to box a value type instance, but you still need to understand what's going on internally so that you're aware of code size and performance issues.</p>
<p>In the preceding code, the C# compiler detected that I was passing a value type to a method that requires a reference type, and it automatically emitted code to box the object. So at runtime, the fields currently residing in the <b>Point </b>value type instance <b>p </b>are copied into the newly allocated <b>Point </b>object. The address of the boxed <b>Point </b>object (now a reference type) is returned and is then passed to the <b>Add </b>method. The <b>Point </b>object will remain in the heap until it is garbage collected. The <b>Point </b>value type variable <b>(p) </b>can be reused because the <b>ArrayList </b>never knows anything about it. Note that the lifetime of the boxed value type extends beyond the lifetime of the unboxed value type.</p>
<hr/>
<blockquote><b>Note </b>It should be noted that the FCL now includes a new set of generic collection classes that make the non-generic collection classes obsolete For example, you should use the <b>System.Collections.Generic.List&lt;T&gt; </b>class instead of the <b>System.Collections.ArrayList</b> class The generic collection classes offer many improvements over the non-generic equivalents For example, the API has been cleaned up and improved, and the performance of the collection classes has been greatly improved as well. But one of the biggest improvements is that the generic collection classes allow you to work with collections of value types without requiring that items in the collection be boxed/unboxed. This in itself greatly improves performance because far fewer objects will be created on the managed heap thereby reducing the number of garbage collections required by your application. Furthermore, you will get compile-time type safety, and your source code will be cleaner due to fewer casts. This will all be explained in further detail in Chapter 12, &quot;Generics.&quot;</blockquote>
<hr/>
<p>Now that you know how boxing works, let's talk about unboxing. Let's say that you want to grab the first element out of the <b>ArrayList </b>by using the following code:</p>
<p><code>Point p = (Point) a[0];</code></p>
<p>Here you're taking the reference (or pointer) contained in element 0 of the <b>ArrayList </b>and trying to put it into a <b>Point </b>value type instance, <b>p </b>. For this to work, all of the fields contained in the boxed <b>Point </b>object must be copied into the value type variable, <b>p, </b>which is on the thread's stack. The CLR accomplishes this copying in two steps. First, the address of the <b>Point </b>fields in the boxed <b>Point </b>object is obtained. This process is called unboxing. Then, the values of these fields are copied from the heap to the stack-based value type instance.</p>
<p>Unboxing is not the exact opposite of boxing. The unboxing operation is much less costly than boxing. Unboxing is really just the operation of obtaining a pointer to the raw value type (data fields) contained within an object. In effect, the pointer refers to the unboxed portion in the boxed instance So, unlike boxing, unboxing doesn't involve the copying of any bytes in memory. Having made this important clarification, it is important to note that an unboxing operation is typically followed by copying the fields.</p>
<p>Obviously, boxing and unboxing/copy operations hurt your application's performance in terms of both speed and memory, so you should be aware of when the compiler generates code to perform these operations automatically and try to write code that minimizes this code generation.</p>
<p>Internally, here's exactly what happens when a boxed value type instance is unboxed:</p>
<p><b>1. </b>If the variable containing the reference to the boxed value type instance is <b>null, </b>a <b>NullReferenceException </b>is thrown.</p>
<p><b>2. </b>If the reference doesn't refer to an object that is a boxed instance of the desired value type, an <b>InvalidCastException </b>is thrown.<sup>1</sup></p>
<p>The second item above means that the following code will not work as you might expect:</p>
<p><code>public static void Main() { Int32   x = 5;<br/>
Object o = x;// Box x; o refers to the boxed object<br/>
Int16   y = (Int16) o; // Throws an InvalidCastException<br/>
}</code></p>
<p>Logically, it makes sense to take the boxed <b>Int32 </b>that <b>o </b>refers to and cast it to an <b>Int16 </b>. However, when unboxing an object, the cast must be to the exact unboxed value type <b>Int32 </b>in this case. Here's the correct way to write this code:</p>
<p><code>public static void Main() {<br/>
Int32 x = 5;<br/>
Object o = x;// Box x; o refers to the boxed object<br/>
Int16   y = (Int16)(Int32) o; // Unbox to the correct type and cast<br/>
}</code></p>
<p>I mentioned earlier that an unboxing operation is frequently followed immediately by a field copy. Let's take a look at some C# code demonstrating that unbox and copy operations work together:</p>
<p><code>public static void Main() { Point p;<br/>
p.x = p.y = 1;<br/>
Object o = p;     // Boxes p; o refers to the boxed instance<br/>
p = (Point) o;   // Unboxes o AND copies fields from boxed // instance to stack variable<br/>
}</code></p>
<p>On the last line, the C# compiler emits an IL instruction to unbox <b>o </b>(get the address of the fields in the boxed instance) and another IL instruction to copy the fields from the heap to the stack-based variable <b>p.</b></p>
<p>Now look at this code:</p>
<p><code>public static void Main() { Point p;<br/>
p.x = p.y = 1;</code></p>
<p>The CLR also allows you to unbox a value type into a nullable version of the same value type. This is discussed in Chapter 19.</p>
<p><code>Object o = p;     // Boxes p; o refers to the boxed instance<br/>
// Change Point's x field to 2<br/>
p = (Point) o;   // Unboxes o AND copies fields from boxed<br/>
// instance to stack variable p.x = 2;// Changes the state of the stack variable<br/>
o = p;// Boxes p; o refers to a new boxed instance<br/>
}</code></p>
<p>The code at the bottom of this fragment is intended only to change <b>Point</b>'s <b>x </b>field from <b>1 </b>to <b>2. </b>To do this, an unbox operation must be performed, followed by a field copy, followed by changing the field (on the stack), followed by a boxing operation (which creates a whole new boxed instance in the managed heap) Hopefully, you see the impact that boxing and unboxing/copying operations have on your application's performance.</p>
<p>Some languages, such as C++/CLI, allow you to unbox a boxed value type without copying the fields. Unboxing returns the address of the unboxed portion of a boxed object (ignoring the object's type object pointer and sync block index overhead). You can now use this pointer to manipulate the unboxed instance's fields (which happen to be in a boxed object on the heap). For example, the previous code would be much more efficient if written in C++/ CLI, because you could change the value of <b>Point</b>'s <b>x </b>field within the already boxed <b>Point </b>instance This would avoid both allocating a new object on the heap and copying all of the fields twice!</p>
<hr/>
<blockquote><b>Important </b>If you're the least bit concerned about your application's performance, you must be aware of when the compiler produces the code that performs these operations Unfortunately, many compilers implicitly emit code to box objects, and so it is not obvious when you write code that boxing is occurring. If I am concerned about the performance of a particular algorithm, I always use a tool such as ILDasm.exe to view the IL code for my methods and see where the <b>box </b>IL instructions are.</blockquote>
<hr/>
<p>Let's look at a few more examples that demonstrate boxing and unboxing:</p>
<p><code>public static void Main(){<br/>
Int32   v = 5;// Create an unboxed value type variable.<br/>
Object o = v;// o refers to a boxed Int32 containing 5.<br/>
v = 123;// Changes the unboxed value to 123<br/>
Console.WriteLine(v + &quot;, &quot; + (Int32) o); // Displays &quot;123, 5&quot;<br/>
}</code></p>
<p>In this code, can you guess how many boxing operations occur? You might be surprised to discover that the answer is three! Let's analyze the code carefully to really understand what's going on. To help you understand, I've included the IL code generated for the <b>Main </b>method shown in the preceding code. I've commented the code so that you can easily see the individual operations.</p>
<p><code>.method public hidebysig static void   Main() cil managed<br/>
{<br/>
.entrypoint<br/>
// Code size.45 (0x2d)<br/>
.maxstack 3<br/>
.locals init (int32 V_0,<br/>
object V_l) // Load 5 into v. IL_0000: 1dc.i4.5 IL_000l: stloc.0<br/>
// Box v and store the reference pointer in o. IL_0002: ldloc.0<br/>
IL_0003:   box [mscorlib]System.Int32 IL_0008: stloc.l<br/>
// Load l23 into v. IL_0009:   1dc.i4.s l23 IL_000b: stloc.0<br/>
// Box v and leave the pointer on the stack for Concat. IL_000c: ldloc.0<br/>
IL_000d:   box [mscorlib]System.Int32<br/>
// Load the string on the stack for Concat. IL_00l2:   ldstr.&quot;, &quot;<br/>
// Unbox o: Get the pointer to the In32's field on the stack. IL_00l7: Idloc.l<br/>
IL_00l8:   unbox.any [mscorlib]System.Int32<br/>
// Box the Int32 and leave the pointer on the stack for Concat. IL_00ld:   box [mscorlib]System.Int32<br/>
// Call Concat.<br/>
IL_0022:   call.string [mscorlib]System.String::Concat(object,<br/>
object, object)<br/>
// The string returned from Concat is passed to WriteLine.<br/>
IL_0027:   call.void [mscorlib]System.Console::WriteLine(string)<br/>
// Return from Main terminating this application. IL_002c: ret } // end of method App::Main</code></p>
<p>First, an <b>Int32 </b>unboxed value type instance <b>(v) </b>is created on the stack and initialized to <b>5. </b>Then a variable <b>(o) </b>typed as <b>Object </b>is created, and is initialized to point to <b>v </b>But because reference type variables must always point to objects in the heap, C# generated the proper IL code to box and store the address of the boxed copy of <b>v </b>in <b>o </b>. Now the value <b>123 </b>is placed into the unboxed value type instance <b>v; </b>this has no effect on the boxed <b>Int32 </b>value, which keeps its value of <b>5.</b></p>
<p>Next is the call to the <b>WriteLine </b>method. <b>WriteLine </b>wants a <b>String </b>object passed to it, but there is no string object Instead, these three items are available: an unboxed <b>Int32 </b>value type instance <b>(v), </b>a <b>String </b>(which is a reference type), and a reference to a boxed <b>Int32 </b>value type instance <b>(o) </b>that is being cast to an unboxed <b>Int32. </b>These must somehow be combined to create a <b>String.</b></p>
<p>To create a <b>String, </b>the C# compiler generates code that calls the <b>String </b>object's static <b>Concat </b>method. There are several overloaded versions of the <b>Concat </b>method, all of which perform identically葉he only difference is in the number of parameters. Because a string is being created from the concatenation of three items, the compiler chooses the following version of the <b>Concat </b>method:</p>
<p><code>public static String Concat(Object arg0, Object arg1, Object arg2);</code></p>
<p>For the first parameter, <b>arg0, v </b>is passed. But <b>v </b>is an unboxed value parameter and <b>arg0 </b>is an <b>Object, </b>so <b>v </b>must be boxed and the address to the boxed <b>v </b>is passed for <b>arg0 </b>For the <b>arg1 </b>parameter, the <b>&quot;</b>,<b>&quot; </b>string is passed as a reference to a <b>String </b>object. Finally, for the <b>arg2 </b>parameter, <b>o </b>(a reference to an <b>Object) </b>is cast to an <b>Int32. </b>This requires an unboxing operation (but no copy operation), which retrieves the address of the unboxed <b>Int32 </b>contained inside the boxed <b>Int32 </b>This unboxed <b>Int32 </b>instance must be boxed again and the new boxed instance's memory address passed for <b>Concat</b>'s <b>arg2 </b>parameter.</p>
<p>The <b>Concat </b>method calls each of the specified objects' <b>ToString </b>method and concatenates each object's string representation. The <b>String </b>object returned from <b>Concat </b>is then passed to <b>WriteLine </b>to show the final result.</p>
<p>I should point out that the generated IL code is more efficient if the call to <b>WriteLine </b>is written as follows:</p>
<p><code>Console.WriteLine(v + &quot;, &quot; + o);// Displays &quot;123, 5&quot;</code></p>
<p>This line is identical to the earlier version except that I've removed the <b>(Int32) </b>cast that preceded the variable <b>o. </b>This code is more efficient because <b>o </b>is already a reference type to an <b>Object </b>and its address can simply be passed to the <b>Concat </b>method. So, removing the cast saved two operations: an unbox and a box. You can easily see this savings by rebuilding the application and examining the generated IL code:</p>
<p><code>.method public hidebysig static void   Main() cil managed<br/>
{<br/>
.entrypoint<br/>
// Code size        35 (0x23)<br/>
.maxstack 3<br/>
.locals init (int32 V_0, object V_1)<br/>
// Load 5 into v. IL_0000: 1dc.i4.5<br/>
IL_0001: stloc.0<br/>
// Box v and store the reference pointer in o. IL_0002: ldloc.0<br/>
IL_0003:   box [mscorlib]System.Int32 IL_0008: stloc.1<br/>
// Load 123 into v. IL_0009:   1dc.i4.s 123 IL_000b: stloc.0<br/>
// Box v and leave the pointer on the stack for Concat. IL_000c: ldloc.0<br/>
IL_000d:   box [mscorlib]System.Int32<br/>
// Load the string on the stack for Concat. IL_0012:   ldstr.&quot;, &quot;<br/>
// Load the address of the boxed Int32 on the stack for Concat. IL_0017: ldloc.1<br/>
// Call Concat.<br/>
IL_0018:   call.string [mscorlib]System.String::Concat(object,<br/>
object, object)<br/>
// The string returned from Concat is passed to WriteLine.<br/>
IL_001d:   call.void [mscorlib]System.Console::WriteLine(string)<br/>
// Return from Main terminating this application.<br/>
IL_0022: ret<br/>
} // end of method App::Main</code></p>
<p>A quick comparison of the IL for these two versions of the <b>Main </b>method shows that the version without the <b>(Int32) </b>cast is 10 bytes smaller than the version with the cast. The extra unbox/box steps in the first version are obviously generating more code. An even bigger concern, however, is that the extra boxing step allocates an additional object from the managed heap that must be garbage collected in the future Certainly, both versions give identical results, and the difference in speed isn't noticeable, but extra, unnecessary boxing operations occurring in a loop cause the performance and memory usage of your application to be seriously degraded.</p>
<p>You can improve the previous code even more by calling <b>WriteLine </b>like this: Console.WriteLine(v.ToString() + &quot;, &quot; + o);      // Displays &quot;123, 5&quot;</p>
<p>Now <b>ToString </b>is called on the unboxed value type instance <b>v, </b>and a <b>String </b>is returned. String objects are already reference types and can simply be passed to the <b>Concat </b>method without requiring any boxing.</p>
<p>Let's look at yet another example that demonstrates boxing and unboxing:</p>
<p><code>public static void Main() {<br/>
Int32 v = 5;// Create an unboxed value type variable.<br/>
Object o = v;// o refers to the boxed version of v.<br/>
v = 123;// Changes the unboxed value type to 123<br/>
Console.WriteLine(v);// Displays &quot;123&quot;<br/>
v = (Int32) o;// Unboxes and copies o into v<br/>
Console.WriteLine(v);// Displays &quot;5&quot;<br/>
}</code></p>
<p>How many boxing operations do you count in this code? The answer is one. The reason that there is only one boxing operation is that the <b>System.Console </b>class defines a <b>WriteLine </b>method that accepts an <b>Int32 </b>as a parameter:</p>
<p><code>public static void WriteLine(Int32 value);</code></p>
<p>In the two calls to <b>WriteLine </b>above, the variable <b>v, </b>an <b>Int32 </b>unboxed value type instance, is passed by value. Now it may be that <b>WriteLine </b>will box this <b>Int32 </b>internally, but you have no control over that The important thing is that you've done the best you could and have eliminated the boxing from your own code.</p>
<p>If you take a close look at the FCL, you'll notice many overloaded methods that differ based on their value type parameters. For example, the <b>System.Console </b>type offers several overloaded versions of the <b>WriteLine </b>method:</p>
<p><code>public static void WriteLine(Boolean); public static void WriteLine(Char); public static void WriteLine(Char[]); public static void WriteLine(Int32); public static void WriteLine(UInt32); public static void WriteLine(Int64); public static void WriteLine(UInt64); public static void WriteLine(Single); public static void WriteLine(Double); public static void WriteLine(Decimal); public static void WriteLine(Object); public static void WriteLine(String);</code></p>
<p>You'll also find a similar set of overloaded methods for <b>System.Console</b>'s <b>Write </b>method, <b>System.IO.BinaryWriter</b>'s <b>Write </b>method, <b>System.IO.TextWriter</b>'s <b>Write </b>and <b>WriteLine</b></p>
<p>methods, <b>System.Runtime.Serialization.SerializationInfo</b>'s <b>AddValue </b>method, <b>System.Text.StringBuilder</b>'s <b>Append </b>and <b>Insert </b>methods, and so on. Most of these methods offer overloaded versions for the sole purpose of reducing the number of boxing operations for the common value types.</p>
<p>If you define your own value type, these FCL classes will not have overloads of these methods that accept your value type. Furthermore, there are a bunch of value types already defined in the FCL for which overloads of these methods do not exist. If you call a method that does not have an overload for the specific value type that you are passing to it, you will always end up calling the overload that takes an <b>Object. </b>Passing a value type instance as an <b>Object </b>will cause boxing to occur, which will adversely affect performance. If you are defining your own class, you can define the methods in the class to be generic (possibly constraining the type parameters to be value types). Generics give you a way to define a method that can take any kind of value type without having to box it. Generics are discussed in Chapter 12.</p>
<p>One last point about boxing: if you know that the code that you're writing is going to cause the compiler to box a single value type repeatedly, your code will be smaller and faster if you manually box the value type. Here's an example:</p>
<p><code>using System;<br/>
public sealed class Program { public static void Main() {<br/>
Int32 v = 5;     // Create an unboxed value type variable.<br/>
#if INEFFICIENT<br/>
// When compiling the following line, v is boxed // three times, wasting time and memory. Console.WriteLine(&quot;{0}, {1}, {2}&quot;, v, v, v);<br/>
#else<br/>
// The lines below have the same result, execute<br/>
// much faster, and use less memory.<br/>
Object o = v;   // Manually box v (just once).<br/>
// No boxing occurs to compile the following line. Console.WriteLine(&quot;{0}, {1}, {2}&quot;, o, o, o);<br/>
#endif }<br/>
}</code></p>
<p>If this code is compiled with the <b>INEFFICIENT </b>symbol defined, the compiler will generate code to box <b>v </b>three times, causing three objects to be allocated from the heap! This is extremely wasteful since each object will have exactly the same contents: <b>5. </b>If the code is compiled without the <b>INEFFICIENT </b>symbol defined, <b>v </b>is boxed just once, so only one object is allocated from the heap. Then, in the call to <b>Console.WriteLine, </b>the reference to the single boxed object is passed three times. This second version executes much faster and allocates less memory from the heap.</p>
<p>In these examples, it's fairly easy to recognize when an instance of a value type requires boxing Basically, if you want a reference to an instance of a value type, the instance must be boxed. Usually this happens because you have a value type instance and you want to pass it to a method that requires a reference type. However, this situation isn't the only one in which you'll need to box an instance of a value type.</p>
<p>Recall that unboxed value types are lighter-weight types than reference types for two reasons:</p>
<p>&#9632;   They are not allocated on the managed heap.</p>
<p>&#9632;   They don't have the additional overhead members that every object on the heap has: a type object pointer and a sync block index.</p>
<p>Because unboxed value types don't have a sync block index, you can't have multiple threads synchronize their access to the instance by using the methods of the <b>System.Threading.Monitor </b>type (or by using C#'s <b>lock </b>statement).</p>
<p>Even though unboxed value types don't have a type object pointer, you can still call virtual methods (such as <b>Equals, GetHashCode, </b>or <b>ToString) </b>inherited or overridden by the type. If your value type overrides one of these virtual methods, then the CLR can invoke the method nonvirtually because value types are implicitly sealed and cannot have any types derived from them. In addition, the value type instance being used to invoke the virtual method is not boxed. However, if your override of the virtual method calls into the base type's implementation of the method, then the value type instance does get boxed when calling the base type's implementation so that a reference to a heap object get passed to the <b>this </b>pointer into the base method.</p>
<p>However, calling a nonvirtual inherited method (such as <b>GetType </b>or <b>MemberwiseClone) </b>always requires the value type to be boxed because these methods are defined by <b>System.Object, </b>so the methods expect the <b>this </b>argument to be a pointer that refers to an object on the heap.</p>
<p>In addition, casting an unboxed instance of a value type to one of the type's interfaces requires the instance to be boxed, because interface variables must always contain a reference to an object on the heap. (I'll talk about interfaces in Chapter 13, &quot;Interfaces.&quot;) The following code demonstrates:</p>
<p><code>using System;<br/>
internal struct Point : IComparable { private readonly Int32 m_x, m_y;<br/>
// Constructor to easily initialize the fields public Point(Int32 x, Int32 y) {<br/>
m_x = x;<br/>
m_y = y;<br/>
}<br/>
// Override ToString method inherited from System.ValueType public override String ToString() {<br/>
// Return the point as a string<br/>
return String.Format(&quot;({0}, {1})&quot;, m_x, m_y);<br/>
}<br/>
// Implementation of type-safe CompareTo method public Int32 CompareTo(Point other) {<br/>
// Use the Pythagorean Theorem to calculate<br/>
// which point is farther from the origin (0, 0)<br/>
return Math.Sign(Math.Sqrt(m_x * m_x + m_y * m_y)<br/>
- Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));<br/>
}<br/>
// Implementation of IComparable's CompareTo method public Int32 CompareTo(Object o) { if (GetType() != o.GetType()) {<br/>
throw new ArgumentException(&quot;o is not a Point&quot;);<br/>
}<br/>
// Call type-safe CompareTo method return CompareTo((Point) o);<br/>
}<br/>
}<br/>
public static class Program { public static void Main() {<br/>
// Create two Point instances on the stack. Point p1 = new Point(10, 10); Point p2 = new Point(20, 20);<br/>
// p1 does NOT get boxed to call ToString (a virtual method). Console.WriteLine(p1.ToString());// &quot;(10, 10)&quot;<br/>
// p DOES get boxed to call GetType (a non-virtual method). Console.WriteLine(p1.GetType());// &quot;Point&quot;<br/>
// p1 does NOT get boxed to call CompareTo.<br/>
// p2 does NOT get boxed because CompareTo(Point) is called.<br/>
Console.WriteLine(p1.CompareTo(p2));//<br/>
// p1 DOES get boxed, and the reference is placed in c. IComparable c = p1;<br/>
Console.WriteLine(c.GetType());// &quot;Point&quot;<br/>
// p1 does NOT get boxed to call CompareTo.<br/>
// Since CompareTo is not being passed a Point variable,<br/>
// CompareTo(Object) is called which requires a reference to<br/>
// a boxed Point.<br/>
// c does NOT get boxed because it already refers to a boxed Point. Console.WriteLine(p1.CompareTo(c));// &quot;0&quot;<br/>
// c does NOT get boxed because it already refers to a boxed Point. // p2 does get boxed because CompareTo(Object) is called. Console.WriteLine(c.CompareTo(p2));//<br/>
// c is unboxed, and fields are copied into p2. p2 = (Point) c;<br/>
// Proves that the fields got copied into p2. Console.WriteLine(p2.ToString());// &quot;(10, 10)&quot;<br/>
}<br/>
}</code></p>
<p>This code demonstrates several scenarios related to boxing and unboxing:</p>
<p>&#9632; Calling <b>ToString  </b>In the call to <b>ToString, p1 </b>doesn't have to be boxed. At first, you'd think that <b>p1 </b>would have to be boxed because <b>ToString </b>is a virtual method that is inherited from the base type, <b>System.ValueType. </b>Normally, to call a virtual method, the CLR needs to determine the object's type in order to locate the type's method table. Since <b>p1 </b>is an unboxed value type, there's no type object pointer. However, the just-in-time (JIT) compiler sees that <b>Point </b>overrides the <b>ToString </b>method, and it emits code that calls <b>ToString </b>directly (nonvirtually) without having to do any boxing. The compiler knows that polymorphism can't come into play here since <b>Point </b>is a value type, and no type can derive from it to provide another implementation of this virtual method. Note that if <b>Point</b>'s <b>ToString </b>method internally calls <b>base.ToString</b>O, then the value type instance would be boxed when calling <b>System.ValueType</b>'s <b>ToString </b>method.</p>
<p>&#9632; Calling <b>GetType  </b>In the call to the nonvirtual <b>GetType </b>method, <b>p1 </b>does have to be boxed. The reason is that the <b>Point </b>type inherits <b>GetType </b>from <b>System.Object. </b>So to call <b>GetType, </b>the CLR must use a pointer to a type object, which can be obtained only by boxing <b>p1 </b>.</p>
<p>&#9632; Calling <b>CompareTo </b>(first time)   In the first call to <b>CompareTo, p1 </b>doesn't have to be boxed because <b>Point </b>implements the <b>CompareTo </b>method, and the compiler can just call it directly. Note that a <b>Point </b>variable <b>(p2) </b>is being passed to <b>CompareTo, </b>and therefore the compiler calls the overload of <b>CompareTo </b>that accepts a <b>Point </b>parameter. This means that <b>p2 </b>will be passed by value to <b>CompareTo </b>and no boxing is necessary.</p>
<p>&#9632; Casting to <b>IComparable  </b>When casting <b>p1 </b>to a variable <b>(c) </b>that is of an interface type, <b>p1 </b>must be boxed because interfaces are reference types by definition. So <b>p1 </b>is boxed, and the pointer to this boxed object is stored in the variable <b>c </b>The following call to <b>GetType </b>proves that <b>c </b>does refer to a boxed <b>Point </b>on the heap.</p>
<p>&#9632; Calling<b>CompareTo </b>(second time)   In the second call to <b>CompareTo, p1 </b>doesn't have to be boxed because <b>Point </b>implements the <b>CompareTo </b>method, and the compiler can just call it directly. Note that an <b>IComparable </b>variable <b>(c) </b>is being passed to <b>CompareTo, </b>and therefore, the compiler calls the overload of <b>CompareTo </b>that accepts an <b>Object </b>parameter. This means that the argument passed must be a pointer that refers to</p>
<p>an object on the heap. Fortunately, <b>c </b>does refer to a boxed <b>Point, </b>and therefore, that memory address in <b>c </b>can be passed to <b>CompareTo, </b>and no additional boxing is necessary.</p>
<p>&#9632; Calling <b>CompareTo </b>(third time)   In the third call to <b>CompareTo, c </b>already refers to a boxed <b>Point </b>object on the heap. Since <b>c </b>is of the <b>IComparable </b>interface type, you can call only the interface's <b>CompareTo </b>method that requires an <b>Object </b>parameter. This means that the argument passed must be a pointer that refers to an object on the heap. So <b>p2 </b>is boxed, and the pointer to this boxed object is passed to <b>CompareTo.</b></p>
<p>&#9632;   Casting to <b>Point  </b>When casting <b>c </b>to a <b>Point, </b>the object on the heap referred to by <b>c </b>is unboxed, and its fields are copied from the heap to <b>p2, </b>an instance of the <b>Point </b>type residing on the stack.</p>
<p>I realize that all of this information about reference types, value types, and boxing might be overwhelming at first. However, a solid understanding of these concepts is critical to any .NET Framework developer's long-term success. Trust me: having a solid grasp of these concepts will allow you to build efficient applications faster and easier.</p>
<h3>Changing Fields in a Boxed Value Type by Using Interfaces (and Why You Shouldn't Do This)</h3>
<p>Let's have some fun and see how well you understand value types, boxing, and unboxing. Examine the following code, and see whether you can figure out what it displays on the console:</p>
<p><code>using System;<br/>
// Point is a value type. internal struct Point { private Int32 m_x, m_y;<br/>
public Point(Int32 x, Int32 y) { m_x = x; m_y = y;<br/>
}<br/>
public void Change(Int32 x, Int32 y) { m_x = x; m_y = y;<br/>
}<br/>
public override String ToString() {<br/>
return String.Format(&quot;({0}, {l})&quot;, m_x, m_y);<br/>
}<br/>
}<br/>
public sealed class Program { public static void Main() { Point p = new Point(l, l);<br/>
Console.WriteLine(p);<br/>
p.Change(2, 2); Console.WriteLine(p);<br/>
Object o = p; Console.WriteLine(o);<br/>
((Point) o).Change(3, 3); Console.WriteLine(o);<br/>
}<br/>
}</code></p>
<p>Very simply, <b>Main </b>creates an instance <b>(p) </b>of a <b>Point </b>value type on the stack and sets its <b>m_x </b>and <b>m_y </b>fields to <b>1. </b>Then, <b>p </b>is boxed before the first call to <b>WriteLine, </b>which calls <b>ToString </b>on the boxed <b>Point, </b>and <b>(1, 1) </b>is displayed as expected. Then, <b>p </b>is used to call the <b>Change </b>method, which changes the values of <b>p</b>'s <b>m_x </b>and <b>m_y </b>fields on the stack to <b>2. </b>The second call to <b>WriteLine </b>requires <b>p </b>to be boxed again and displays <b>(2, 2), </b>as expected.</p>
<p>Now, <b>p </b>is boxed a third time, and <b>o </b>refers to the boxed <b>Point </b>object. The third call to <b>WriteLine </b>again shows <b>(2, 2), </b>which is also expected. Finally, I want to call the <b>Change </b>method to update the fields in the boxed <b>Point </b>object. However, <b>Object </b>(the type of the variable <b>o) </b>doesn't know anything about the <b>Change </b>method, so I must first cast <b>o </b>to a <b>Point </b>. Casting <b>o </b>to a <b>Point </b>unboxes <b>o </b>and copies the fields in the boxed <b>Point </b>to a temporary <b>Point </b>on the thread's stack! The <b>m_x </b>and <b>m_y </b>fields of this temporary point are changed to <b>3 </b>and <b>3, </b>but the boxed <b>Point </b>isn't affected by this call to <b>Change. </b>When <b>WriteLine </b>is called the fourth time, <b>(2, 2) </b>is displayed again. Many developers do not expect this.</p>
<p>Some languages, such as C++/CLI, let you change the fields in a boxed value type, but C# does not. However, you can fool C# into allowing this by using an interface. The following code is a modified version of the previous code:</p>
<p><code>using System;<br/>
// Interface defining a Change method internal interface IChangeBoxedPoint { void Change(Int32 x, Int32 y);<br/>
}<br/>
// Point is a value type. internal struct Point : IChangeBoxedPoint { private Int32 m_x, m_y;<br/>
public Point(Int32 x, Int32 y) { m_x = x; m_y = y;<br/>
}<br/>
public void Change(Int32 x, Int32 y) { m_x = x; m_y = y;<br/>
}<br/>
public override String ToString() {<br/>
return String.Format(&quot;({0}, {l})&quot;, m_x, m_y);<br/>
}<br/>
}<br/>
public sealed class Program { public static void Main() { Point p = new Point(l, l);<br/>
Console.WriteLine(p);<br/>
p.Change(2, 2); Console.WriteLine(p);<br/>
Object o = p; Console.WriteLine(o);<br/>
((Point) o).Change(3, 3); Console.WriteLine(o);<br/>
// Boxes p, changes the boxed object and discards it ((IChangeBoxedPoint) p).Change(4, 4); Console.WriteLine(p);<br/>
// Changes the boxed object and shows it ((IChangeBoxedPoint) o).Change(5, 5); Console.WriteLine(o);<br/>
}<br/>
}</code></p>
<p>This code is almost identical to the previous version The main difference is that the <b>Change </b>method is defined by the <b>IChangeBoxedPoint </b>interface, and the <b>Point </b>type now implements this interface. Inside <b>Main, </b>the first four calls to <b>WriteLine </b>are the same and produce the same results I had before (as expected) However, I've added two more examples at the end of <b>Main </b>.</p>
<p>In the first example, the unboxed <b>Point, p, </b>is cast to an <b>IChangeBoxedPoint </b>. This cast causes the value in <b>p </b>to be boxed <b>Change </b>is called on the boxed value, which does change its <b>m_x </b>and <b>m_y </b>fields to <b>4 </b>and <b>4, </b>but after <b>Change </b>returns, the boxed object is immediately ready to be garbage collected. So the fifth call to <b>WriteLine </b>displays <b>(2, 2). </b>Many developers won't expect this result.</p>
<p>In the last example, the boxed <b>Point </b>referred to by <b>o </b>is cast to an <b>IChangeBoxedPoint. </b>No boxing is necessary here because <b>o </b>is already a boxed <b>Point. </b>Then <b>Change </b>is called, which does change the boxed <b>Point</b>'s <b>m_x </b>and <b>m_y </b>fields. The interface method <b>Change </b>has allowed me to change the fields in a boxed <b>Point </b>object! Now, when <b>WriteLine </b>is called, it displays <b>(5, 5) </b>as expected. The purpose of this whole example is to demonstrate how an interface method is able to modify the fields of a boxed value type. In C#, this isn't possible without using an interface method.</p>
<hr/>
<blockquote><b>Important </b>Earlier in this chapter, I mentioned that value types should be immutable: that is, they should not define any members that modify any of the type's instance fields. In fact, I recommended that value types have their fields marked as <b>readonly </b>so that the compiler will issue errors should you accidentally write a method that attempts to modify a field. The previous example should make it very clear to you why value types should be immutable. The unexpected behaviors shown in the previous example all occur when attempting to call a method that modifies the value type's instance fields. If after constructing a value type, you do not call any methods that modify its state, you will not get confused when all of the boxing and unboxing/ field copying occurs. If the value type is immutable, you will end up just copying the same state around, and you will not be surprised by any of the behaviors you see.</blockquote>
<hr/>
<p>A number of developers reviewed the chapters of this book. After reading through some of my code samples (such as the preceding one), these reviewers would tell me that they've sworn off value types. I must say that these little value type nuances have cost me days of debugging time, which is why I spend time pointing them out in this book I hope you'll remember some of these nuances and that you'll be prepared for them if and when they strike you and your code Certainly, you shouldn't be scared of value types They are useful, and they have their place After all, a program needs a little <b>Int32 </b>love now and then. Just keep in mind that value types and reference types have very different behaviors depending on how they're used. In fact, you should take the preceding code and declare the <b>Point </b>as a <b>class </b>instead of a <b>struct </b>to appreciate the different behavior that results. Finally, you'll be very happy to know that the core value types that ship in the FCL<b>Byte, Int32, UInt32, Int64, UInt64, Single, Double, Decimal, BigInteger, Complex, </b>all <b>enums, </b>and so on預re all immutable, so you should experience no surprising behavior when using any of these types.</p>
<h3>Object Equality and Identity</h3>
<p>Frequently, developers write code to compare objects with one another. This is particularly true when placing objects in a collection and you're writing code to sort, search, or compare items in a collection. In this section, I'll discuss object equality and identity, and I'll also discuss how to define a type that properly implements object equality.</p>
<p>The <b>System.Object </b>type offers a virtual method named <b>Equals, </b>whose purpose is to return <b>true </b>if two objects contain the same value. The implementation of <b>Object</b>'s <b>Equals </b>method looks like this:</p>
<p><code>public class Object {<br/>
public virtual Boolean Equals(Object obj) {<br/>
// If both references point to the same object, // they must have the same value. if (this == obj) return true;<br/>
// Assume that the objects do not have the same value. return false;<br/>
}<br/>
}</code></p>
<p>At first, this seems like a reasonable default implementation of <b>Equals: </b>it returns <b>true </b>if the <b>this </b>and <b>obj </b>arguments refer to the same exact object. This seems reasonable because <b>Equals </b>knows that an object must have the same value as itself. However, if the arguments refer to different objects, <b>Equals </b>can't be certain if the objects contain the same values, and therefore, <b>false </b>is returned. In other words, the default implementation of <b>Object</b>'s <b>Equals </b>method really implements identity, not value equality.</p>
<p>Unfortunately, as it turns out, <b>Object</b>'s <b>Equals </b>method is not a reasonable default, and it should have never been implemented this way. You immediately see the problem when you start thinking about class inheritance hierarchies and how to properly override <b>Equals </b>. Here is how to properly implement an <b>Equals </b>method internally:</p>
<p><b>1. </b>If the <b>obj </b>argument is <b>null, </b>return <b>false </b>because the current object identified by <b>this </b>is obviously not <b>null </b>when the nonstatic <b>Equals </b>method is called.</p>
<p><b>2. </b>If the <b>this </b>and <b>obj </b>arguments refer to the same object, return <b>true. </b>This step can improve performance when comparing objects with many fields.</p>
<p><b>3. </b>If the <b>this </b>and <b>obj </b>arguments refer to objects of different types, return <b>false. </b>Obviously, checking if a <b>String </b>object is equal to a <b>FileStream </b>object should result in a <b>false </b>result.</p>
<p><b>4. </b>For each instance field defined by the type, compare the value in the <b>this </b>object with the value in the <b>obj </b>object. If any fields are not equal, return <b>false.</b></p>
<p><b>5. </b>Call the base class's <b>Equals </b>method so it can compare any fields defined by it. If the base class's <b>Equals </b>method returns <b>false, </b>return <b>false; </b>otherwise, return <b>true </b>.</p>
<p>So Microsoft should have implemented <b>Object</b>'s <b>Equals </b>like this:</p>
<p><code>public class Object {<br/>
public virtual Boolean Equals(Object obj) {<br/>
// The given object to compare to can't be null if (obj == null) return false;<br/>
// If objects are different types, they can't be equal. if (this.GetType() != obj.GetType()) return false;<br/>
// If objects are same type, return true if all of their fields match // Since System.Object defines no fields, the fields match return true;<br/>
}<br/>
}</code></p>
<p>But, since Microsoft didn't implement <b>Equals </b>this way, the rules for how to implement <b>Equals </b>are significantly more complicated than you would think. When a type overrides <b>Equals, </b>the override should call its base class's implementation of <b>Equals </b>unless it would be calling <b>Object</b>'s implementation. This also means that since a type can override <b>Object</b>'s <b>Equals </b>method, this <b>Equals </b>method can no longer be called to test for identity. To fix this, <b>Object </b>offers a static <b>ReferenceEquals </b>method, which is implemented like this:</p>
<p><code>public class Object {<br/>
public static Boolean ReferenceEquals(Object objA, Object objB) { return (objA == objB);<br/>
}<br/>
}</code></p>
<p>You should always call <b>ReferenceEquals </b>if you want to check for identity (if two references point to the same object). You shouldn't use the C# <b>== </b>operator (unless you cast both operands to <b>Object </b>first) because one of the operands' types could overload the <b>== </b>operator, giving it semantics other than identity.</p>
<p>As you can see, the .NET Framework has a very confusing story when it comes to object equality and identity. By the way, <b>System.ValueType </b>(the base class of all value types) does override <b>Object</b>'s <b>Equals </b>method and is correctly implemented to perform a value equality check (not an identity check). Internally, <b>ValueType</b>'s <b>Equals </b>is implemented this way:</p>
<p><b>1. </b>If the <b>obj </b>argument is <b>null, </b>return <b>false.</b></p>
<p><b>2. </b>If the <b>this </b>and <b>obj </b>arguments refer to objects of different types, return <b>false.</b></p>
<p><b>3. </b>For each instance field defined by the type, compare the value in the <b>this </b>object with the value in the <b>obj </b>object by calling the field's <b>Equals </b>method. If any fields are not equal, return <b>false.</b></p>
<p><b>4. </b>Return <b>true </b>. <b>Object</b>'s <b>Equals </b>method is not called by <b>ValueType</b>'s <b>Equals </b>method.</p>
<p>Internally, <b>ValueType</b>'s <b>Equals </b>method uses reflection (covered in Chapter 23, &quot;Assembly Loading and Reflection&quot;) to accomplish step #3 above. Since the CLR's reflection mechanism is slow, when defining your own value type, you should override <b>Equals </b>and provide your own implementation to improve the performance of value equality comparisons that use instances of your type. Of course, in your own implementation, do not call <b>base.Equals </b>.</p>
<p>When defining your own type, if you decide to override <b>Equals, </b>you must ensure that it adheres to the four properties of equality:</p>
<p><b>&#9632; Equals </b>must be reflexive; that is, <b>x.Equals(x) </b>must return <b>true </b>.</p>
<p><b>&#9632; Equals </b>must be symmetric; that is, <b>x.Equals(y) </b>must return the same value as <b>y.Equals(x).</b></p>
<p><b>&#9632; Equals </b>must be transitive; that is, if <b>x.Equals(y) </b>returns <b>true </b>and <b>y.Equals(z) </b>returns <b>true, </b>then <b>x.Equals(z) </b>must also return <b>true.</b></p>
<p><b>&#9632; Equals </b>must be consistent. Provided that there are no changes in the two values being compared, <b>Equals </b>should consistently return <b>true </b>or <b>false.</b></p>
<p>If your implementation of <b>Equals </b>fails to adhere to all of these rules, your application will behave in strange and unpredictable ways.</p>
<p>When overriding the <b>Equals </b>method, there are a few more things that you'll probably want to do:</p>
<p><b>&#9632; Have the type implement the System.IEquatable&lt;T&gt; interface's Equals method</b></p>
<p>This generic interface allows you to define a type-safe <b>Equals </b>method. Usually, you'll implement the <b>Equals </b>method that takes an <b>Object </b>parameter to internally call the type-safe <b>Equals </b>method.</p>
<p><b>&#9632;</b><b>   Overload the == and !=operator methods   </b>Usually, you'll implement these operator methods to internally call the type-safe <b>Equals </b>method.</p>
<p>Furthermore, if you think that instances of your type will be compared for the purposes of sorting, you'll want your type to also implement <b>System.IComparable</b>'s <b>CompareTo </b>method and <b>System.IComparable&lt;T</b>&gt;'s type-safe <b>CompareTo </b>method. If you implement these methods, you'll also want to overload the various comparison operator methods (<b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, <b>&gt;=</b>) and implement these methods internally to call the type-safe <b>CompareTo </b>method.</p>
<a name="b146"/><h2>Object Hash Codes</h2>
<p>The designers of the FCL decided that it would be incredibly useful if any instance of any object could be placed into a hash table collection To this end, <b>System.Object </b>provides a virtual <b>GetHashCode </b>method so that an <b>Int32 </b>hash code can be obtained for any and all objects.</p>
<p>If you define a type and override the <b>Equals </b>method, you should also override the <b>GetHashCode </b>method. In fact, Microsoft's C# compiler emits a warning if you define a type that overrides <b>Equals </b>without also overriding <b>GetHashCode. </b>For example, compiling the following type yields this warning: <b>&quot;warning CS0659: 'Program' overrides Object.Equals(object o) but does not override Object.GetHashCode</b>O&quot;.</p>
<p><code>public sealed class Program {<br/>
public override Boolean Equals(Object obj) {... }<br/>
}</code></p>
<p>The reason why a type that defines <b>Equals </b>must also define <b>GetHashCode </b>is that the implementation of the <b>System.Collections.Hashtable </b>type, the <b>System.Collections. Generic.Dictionary </b>type, and some other collections require that any two objects that are equal must have the same hash code value. So if you override <b>Equals, </b>you should override <b>GetHashCode </b>to ensure that the algorithm you use for calculating equality corresponds to the algorithm you use for calculating the object's hash code.</p>
<p>Basically, when you add a key/value pair to a collection, a hash code for the key object is obtained first. This hash code indicates which &quot;bucket&quot; the key/value pair should be stored in. When the collection needs to look up a key, it gets the hash code for the specified key object. This code identifies the &quot;bucket&quot; that is now searched sequentially, looking for a stored key object that is equal to the specified key object. Using this algorithm of storing and looking up keys means that if you change a key object that is in a collection, the collection will no longer be able to find the object. If you intend to change a key object in a hash table, you should remove the original object/value pair, modify the key object, and then add the new key object/value pair back into the hash table.</p>
<p>Defining a <b>GetHashCode </b>method can be easy and straightforward. But depending on your data types and the distribution of data, it can be tricky to come up with a hashing algorithm that returns a well-distributed range of values. Here's a simple example that will probably work just fine for <b>Point </b>objects:</p>
<p><code>internal sealed class Point {<br/>
private readonly Int32 m_x, m_y; public override Int32 GetHashCode() {<br/>
return m_x a m_y;   // m_x XOR'd with m_y<br/>
}<br/>
}</code></p>
<p>When selecting an algorithm for calculating hash codes for instances of your type, try to follow these guidelines:</p>
<p>&#9632; Use an algorithm that gives a good random distribution for the best performance of the hash table.</p>
<p>&#9632; Your algorithm can also call the base type's <b>GetHashCode </b>method, including its return value. However, you don't generally want to call <b>Object</b>'s or <b>ValueType</b>'s <b>GetHashCode </b>method, because the implementation in either method doesn't lend itself to high-performance hashing algorithms.</p>
<p>&#9632; Your algorithm should use at least one instance field.</p>
<p>&#9632; Ideally, the fields you use in your algorithm should be immutable; that is, the fields should be initialized when the object is constructed, and they should never again change during the object's lifetime.</p>
<p>&#9632; Your algorithm should execute as quickly as possible.</p>
<p>&#9632; Objects with the same value should return the same code. For example, two <b>String </b>objects with the same text should return the same hash code value.</p>
<p><b>System.Object</b>'s implementation of the <b>GetHashCode </b>method doesn't know anything about its derived type and any fields that are in the type. For this reason, <b>Object</b>'s <b>GetHashCode </b>method returns a number that is guaranteed to uniquely identify the object within the AppDomain; this number is guaranteed not to change for the lifetime of the object. After the object is garbage collected, however, its unique number can be reused as the hash code for a new object.</p>
<hr/>
<blockquote><b>Note </b>If a type overrides <b>Object</b>'s <b>GetHashCode </b>method, you can no longer call it to get a unique ID for the object If you want to get a unique ID (within an AppDomain) for an object, the FCL provides a method that you can call. In the <b>System.Runtime.CompilerServices </b>namespace, see the <b>RuntimeHelpers </b>class's public, static <b>GetHashCode </b>method that takes a reference to an <b>Object </b>as an argument. <b>RuntimeHelpers' GetHashCode </b>method returns a unique ID for an object even if the object's type overrides <b>Object</b>'s <b>GetHashCode </b>method This method got its name because of its heritage, but it would have been better if Microsoft had named it something like <b>GetUniqueObjectID.</b></blockquote>
<hr/>
<p><b>System.ValueType</b>'s implementation of <b>GetHashCode </b>uses reflection (which is slow) and XORs some of the type's instance fields together. This is a naive implementation that might be good for some value types, but I still recommend that you implement <b>GetHashCode </b>yourself because you'll know exactly what it does, and your implementation will be faster than <b>ValueType</b>'s implementation.</p>
<hr/>
<blockquote><b>Important </b>If you're implementing your own hash table collection for some reason, or you're implementing any piece of code in which you'll be calling <b>GetHashCode, </b>you should never, ever persist hash code values. The reason is that hash code values are subject to change. For example, a future version of a type might use a different algorithm for calculating the object's hash code.</blockquote>
<hr/>
<p>There is a company that was not heeding this important warning. On their Web site, users could create new accounts by selecting a user name and a password. The Web site then took the password <b>String, </b>called <b>GetHashCode, </b>and persisted the hash code value in a database. When users logged back on to the Web site, they entered their password The Web site would call <b>GetHashCode </b>again and compare the hash code value with the stored value in the database. If the hash codes matched, the user would be granted access. Unfortunately, when the company upgraded to a new version of the CLR, <b>String</b>'s <b>GetHashCode </b>method had changed, and it now returned a different hash code value The end result was that no user was able to log on to the Web site anymore!</p>
<a name="b148"/><h2>The dynamic Primitive Type</h2>
<p>C# is a type-safe programming language This means that all expressions resolve into an instance of a type and the compiler will generate only code that is attempting to perform an operation that is valid for this type. The benefit of a type-safe programming language over a non-type-safe programming language is that many programmer errors are detected at compile time, helping to ensure that the code is correct before you attempt to execute it In addition, compile-time languages can typically produce smaller and faster code since they make more assumptions at compile time and bake those assumptions into the resulting IL and metadata.</p>
<p>However, there are also many occasions when a program has to act on information that it doesn't know about until it is running While you can use type-safe programming languages (like C#) to interact with this information, the syntax tends to be clumsy, especially since you tend to work a lot with strings, and performance is hampered as well If you are writing a pure C# application, then the only occasion you have for working with runtime-determined information is when you are using reflection (discussed in Chapter 23). However, many developers also use C# to communicate with components that are not implemented in C# Some of these components could be.NET-dynamic languages such as Python or Ruby, or COM objects that support the <b>IDispatch </b>interface (possibly implemented in native C or C++), or</p>
<p>HTML Document Object Model (DOM) objects (implemented using various languages and technologies) Communicating with HTML DOM objects is particularly useful when building a Microsoft Silverlight application.</p>
<p>To make it easier for developers using reflection or communicating with other components, the C# compiler offers you a way to mark an expression's type as <b>dynamic. </b>You can also put the result of an expression into a variable and you can mark a variable's type as <b>dynamic. </b>This <b>dynamic </b>expression/variable can then be used to invoke a member such as a field, a property/indexer, a method, delegate, and unary/binary/conversion operators When your code invokes a member using a dynamic expression/variable, the compiler generates special IL code that describes the desired operation This special code is referred to as the payload At runtime, the payload code determines the exact operation to execute based on the actual type of the object now referenced by the <b>dynamic </b>expression/variable.</p>
<p>Here is some code to demonstrate what I'm talking about:</p>
<p><code>Private static class DynamicDemo { public static void Main() {<br/>
for (Int32 demo = 0; demo &lt; 2; demo++) {<br/>
dynamic arg = (demo == 0) ? (dynamic) 5 : (dynamic) &quot;A&quot;;<br/>
dynamic result = Plus(arg);<br/>
M(result);<br/>
}<br/>
}<br/>
private static dynamic Plus(dynamic arg) { return arg + arg; }<br/>
private static void M(Int32 n) { Console.Writel_ine(&quot;M(Int32): &quot; + n); } private static void M(String s) { Console.Writel_ine(&quot;M(String): &quot; + s); }<br/>
}</code></p>
<p>When I execute <b>Main, </b>I get the following output:</p>
<p><code>M(Int32): 10 M(String): AA</code></p>
<p>To understand what's happening, let's start by looking at the <b>Plus </b>method. This method has declared its parameter's type as <b>dynamic, </b>and inside the method, the argument is used as the two operands to the binary <b>+ </b>operator. Since <b>arg </b>is <b>dynamic, </b>the C# compiler emits payload code that will examine the actual type of <b>arg </b>at runtime and determine what the <b>+ </b>operator should actually do.</p>
<p>The first time <b>Plus </b>is called, <b>5 </b>(an <b>Int32), </b>is passed, so <b>Plus </b>will return the value <b>10 </b>(also an <b>Int32) </b>back to its caller. This puts this result in the <b>result </b>variable (declared as a <b>dynamic </b>type). Then, the <b>M </b>method is called, passing it <b>result </b>. For the call to <b>M, </b>the compiler will emit payload code that will, at runtime, examine the actual type of the value being passed to <b>M </b>and determine which overload of the <b>M </b>method to call. When <b>result </b>contains an <b>Int32, </b>the overload of <b>M </b>that takes an <b>Int32 </b>parameter is called.</p>
<p>The second time <b>Plus </b>is called, &quot;A&quot; (a <b>String) </b>is passed, so <b>Plus </b>will return &quot;AA&quot; (the result of concatenating &quot;A&quot; with itself) back to its caller, which puts this result in the <b>result </b>variable. Then, the <b>M </b>method is called again, passing it <b>result </b>. This time, the payload code determines that the actual type being passed to <b>M </b>is a <b>String </b>and calls the overload of <b>M </b>that takes a <b>String </b>parameter.</p>
<p>When the type of a field, method parameter, method return type, or local variable, is specified as <b>dynamic, </b>the compiler converts this type to the <b>System.Object </b>type and applies an instance of <b>System.Runtime.CompilerServices.DynamicAttribute </b>to the field, parameter, or return type in metadata. If a local variable is specified as <b>dynamic, </b>then the variable's type will also be of type <b>Object, </b>but the <b>DynamicAttribute </b>is not applied to the local variable since its usage is self-contained within the method. Since <b>dynamic </b>is really the same as <b>Object, </b>you cannot write methods whose signature differs only by <b>dynamic </b>and <b>Object </b>.</p>
<p>It is also possible to use <b>dynamic </b>when specifying generic type arguments to a generic class (reference type), a structure (value type), an interface, a delegate, or a method When you do this, the compiler converts <b>dynamic </b>to <b>Object </b>and applies <b>DynamicAttribute </b>to the various pieces of metadata where it makes sense Note that the generic code that you are using has already been compiled and will consider the type to be <b>Object; </b>no dynamic dispatch will be performed because the compiler did not produce any payload code in the generic code.</p>
<p>Any expression can implicitly be cast to <b>dynamic </b>since all expressions result in a type that is derived from <b>Object </b>.<sup>2</sup> Normally, the compiler does not allow you to write code that implicitly casts an expression from <b>Object </b>to another type; you must use explicit cast syntax. However, the compiler does allow you to cast an expression from <b>dynamic </b>to another type using implicit cast syntax:</p>
<p><code>Object ol = 123;// OK: Implicit cast from Int32 to Object (boxing)<br/>
Int32 nl = o;// Error: No implicit cast from Object to Int32<br/>
Int32 n2 = (Int32) o;     // OK: Explicit cast from Object to Int32 (unboxing)<br/>
dynamic dl = 123;// OK: Implicit cast from Int32 to dynamic (boxing)<br/>
Int32 n3 = d;// OK: Implicit cast from dynamic to Int32 (unboxing)</code></p>
<p>While the compiler allows you to omit the explicit cast when casting from <b>dynamic </b>to some other type, the CLR will validate the cast at runtime to ensure that type safety is maintained If the object's type is not compatible with the cast, the CLR will throw an <b>InvalidCastException </b>exception.</p>
<p>Note that the result of evaluating a <b>dynamic </b>expression is a dynamic expression Examine this code:</p>
<p><code>dynamic d = 123;<br/>
var result = M(d);   // Note:  'var result' is the same as 'dynamic result'</code></p>
<p>And, as always, value types will be boxed.</p>
<p>Here, the compiler allows the code to compile because it doesn't know at compile time which <b>M </b>method it will call. Therefore, it also does not know what type of result <b>M </b>will return. And so, the compiler assumes that the <b>result </b>variable is of type <b>dynamic </b>itself. You can verify this by placing your mouse over <b>var </b>in the Visual Studio editor; the IntelliSense window will indicate <b>'dynamic: Represents an object whose operations will be resolved at runtime.' </b>If the <b>M </b>method invoked at runtime has a return type of <b>void, </b>no exception is thrown; instead, <b>result </b>will be assigned a value of <b>null.</b></p>
<p><b>i-</b></p>
<hr/>
<blockquote><b>Important </b>Do not confuse <b>dynamic </b>and <b>var </b>Declaring a local variable using <b>var </b>is just a syntactical shortcut that has the compiler infer the specific data type from an expression. The <b>var </b>keyword can be used only for declaring local variables inside a method while the <b>dynamic </b>keyword can be used for local variables, fields, and arguments. You cannot cast an expression to <b>var </b>but you can cast an expression to <b>dynamic </b>. You must explicitly initialize a variable declared using <b>var </b>while you do not have to initialize a variable declared with <b>dynamic </b>. For more information about C#'s <b>var, </b>see the &quot;Implicitly Typed Local Variables&quot; section in Chapter 9, &quot;Parameters. &quot;</blockquote>
<hr/>
<p>However, when converting from <b>dynamic </b>to another static type, the result's type is, of course, the static type. Similarly, when constructing a type by passing one or more <b>dynamic </b>arguments to its constructor, the result is the type of object you are constructing:</p>
<p><code>dynamic d = 123;<br/>
var x = (Int32) d;// Conversion:  'var x' is the same as 'Int32 x'<br/>
var dt = new DateTime(d);   // Construction:  'var dt' is the same as 'DateTime dt'</code></p>
<p>If a <b>dynamic </b>expression is specified as the collection in a <b>foreach </b>statement or as a resource in a <b>using </b>statement, the compiler will generate code that attempts to cast the expression to the non-generic <b>System.IEnumerable </b>interface or to the <b>System.IDisposable </b>interface, respectively. If the cast succeeds, the expression is used and the code runs just fine. If the cast fails, a <b>Microsoft.CSharp.RuntimeBinder.RuntimeBinderException </b>exception is thrown.</p>
<p>I-1</p>
<hr/>
<blockquote><b>Important </b>A <b>dynamic </b>expression is really the same type as <b>System.Object </b>. The compiler</blockquote>
<hr/>
<p>assumes that whatever operation you attempt on the expression is legal, so the compiler will not generate any warnings or errors However, exceptions will be thrown at runtime if you attempt to execute an invalid operation. In addition, Visual Studio cannot offer any IntelliSense support to help you write code against a <b>dynamic </b>expression. You cannot define an extension method</p>
<p>(discussed in Chapter 8, &quot;Methods&quot;) that extends <b>dynamic, </b>although you can define one that extends <b>Object </b>. And, you cannot pass a lambda expression or anonymous method (both discussed in Chapter 17, &quot;Delegates&quot;) as an argument to a <b>dynamic </b>method call since the compiler cannot infer the types being used.</p>
<p>Here is an example of some C# code that uses COM <b>IDispatch </b>to create a Microsoft Office Excel workbook and places a string in cell A1:</p>
<p><code>using Microsoft.Office.Interop.Excel;<br/>
public static void Main() {<br/>
Application excel = new Application(); excel.Visible = true; excel.Workbooks.Add(Type.Missing);<br/>
((Range)excel.Cells[1, 1]).Value = &quot;Text in cell A1&quot;; // Put this string in cell A1<br/>
}</code></p>
<p>Without the <b>dynamic </b>type, the value returned from <b>excel.Cells[1, 1] </b>is of type <b>Object, </b>which must be cast to the <b>Range </b>type before its <b>Value </b>property can be accessed. However, when producing a runtime callable wrapper assembly for a COM object, any use of <b>VARIANT </b>in the COM method is really converted to <b>dynamic; </b>this is called dynamification. Therefore, since <b>excel.Cells[1, 1] </b>is of type <b>dynamic, </b>you do not have to explicitly cast it to the <b>Range </b>type before its <b>Value </b>property can be accessed. Dynamification can greatly simplify code that interoperates with COM objects Here is the simpler code:</p>
<p><code>using Microsoft.Office.Interop.Excel;<br/>
public static void Main() {<br/>
Application excel = new Application(); excel.Visible = true; excel.Workbooks.Add(Type.Missing);<br/>
excel.Cells[1, 1].Value = &quot;Text in cell A1&quot;; // Put this string in cell A1<br/>
}</code></p>
<p>The code below shows how to use reflection to call a method (&quot;Contains&quot;) on a <b>String </b>target (&quot;Jeffrey Richter&quot;) passing it a <b>String </b>argument (&quot;ff&quot;) and storing the <b>Int32 </b>result in a local variable <b>(result):</b></p>
<p><code>Object target = &quot;Jeffrey Richter&quot;; Object arg = &quot;ff&quot;;<br/>
// Find a method on the target that matches the desired argument types Type[] argTypes = newType[] { arg.CetType() };<br/>
MethodInfo method = target.GetType().GetMethod(&quot;Contains&quot;, argTypes);<br/>
// Invoke the method on the target passing the desired arguments Object[] arguments = newObject[] { arg };<br/>
Boolean result = Convert.ToBoolean(method.Invoke(target, arguments));</code></p>
<p>Using C#'s <b>dynamic </b>type, this code can be rewritten with greatly improved syntax:</p>
<p><code>dynamic target = &quot;Jeffrey Richter&quot;; dynamic arg = &quot;ff&quot;;<br/>
Boolean result = target.Contains(arg);</code></p>
<p>Earlier, I mentioned that the C# compiler emits payload code that, at runtime, figures out what operation to perform based on the actual type of an object This payload code uses a class known as a runtime binder. Different programming languages define their own runtime binders that encapsulate the rules of that language The code for the C# runtime binder is in the Microsoft CSharp dll assembly, and you must reference this assembly when you build projects that use the <b>dynamic </b>keyword. This assembly is referenced in the compiler's default response file, CSC.rsp. It is the code in this assembly that knows to produce code (at runtime) that performs addition when the <b>+ </b>operator is applied to two <b>Int32 </b>objects and concatenation when applied to two <b>String </b>objects.</p>
<p>At runtime, the Microsoft.CSharp.dll assembly will have to load into the AppDomain, which hurts your application's performance and increases memory consumption. Microsoft. CSharp.dll also loads System, dll and System. Core.dll. If you are using <b>dynamic </b>to help you interoperate with COM components, then System Dynamic dll will also load And when the payload code executes, it generates dynamic code at runtime; this code will be in an in-memory assembly called &quot;Anonymously Hosted DynamicMethods Assembly.&quot; The purpose of this code is to improve the performance of dynamic dispatch in scenarios where a particular call site is making many invocations using dynamic arguments that have the same runtime type.</p>
<p>Due to all the overhead associated with C#'s built-in dynamic evaluation feature, you should consciously decide that you are getting sufficient syntax simplification from the <b>dynamic </b>feature to make it worth the extra performance hit of loading all these assemblies and the extra memory that they consume. If you have only a couple places in your program where you need <b>dynamic </b>behavior, it might be more efficient to just do it the old-fashioned way, by calling reflection methods (for managed objects) or with manual casting (for COM objects).</p>
<p>At runtime, the C# runtime binder resolves a dynamic operation according to the runtime type of the object. The binder first checks to see if the type implements the <b>IDynamicMetaObjectProvider </b>interface. If the object does implement this interface, then the interface's <b>GetMetaObject </b>method is called, which returns a <b>DynamicMetaObject-</b>derived type This type can process all of the member, method, and operator bindings for the object. Both the <b>IDynamicMetaObjectProvider </b>interface and the <b>DynamicMetaObject </b>base class are defined in the <b>System.Dynamic </b>namespace, and both are in the System. Core.dll assembly.</p>
<p>Dynamic languages, such as Python and Ruby, endow their types with <b>DynamicMetaObject-</b>derived types so that they can be accessed in a way appropriate for them when manipulated from other programming languages (like C#) Similarly, when accessing a COM component, the C# runtime binder will use a <b>DynamicMetaObject</b>-derived type that knows how to communicate with a COM component. The COM <b>DynamicMetaObject</b>-derived type is defined in the System.Dynamic.dll assembly.</p>
<p>If the type of the object being used in the dynamic expression does not implement the <b>IDynamicMetaObjectProvider </b>interface, then the C# compiler treats the object like an instance of an ordinary C#-defined type and performs operations on the object using reflection.</p>
<mbp:pagebreak/>
<a name="Chapter6"/>
<h1>Chapter 6: Type and Member Basics</h1>
<p><b>In this chapter:</b></p>
<a href="#b155">The Different Kinds of Type Members</a><br/>
<a href="#b158">Type Visibility</a><br/>
<a href="#b160">Member Accessibility</a><br/>
<a href="#b162">Static Classes</a><br/>
<a href="#b164">Partial Classes, Structures, and Interfaces</a><br/>
<a href="#b165">Components, Polymorphism, and Versioning</a><br/>
<p>In Chapters 4 and 5, I focused on types and what operations are guaranteed to exist on all instances of any type I also explained how all types fall into one of two categories: reference types and value types. In this and the subsequent chapters in this part, I'll show how to design types by using the different kinds of members that can be defined within a type. In Chapters 7 through 11, I'll discuss the various members in detail.</p>
<a name="b155"/><h2>The Different Kinds of Type Members</h2>
<p>A type can define zero or more of the following kinds of members:</p>
<p>&#9632; Constants  A constant is a symbol that identifies a never-changing data value. These symbols are typically used to make code more readable and maintainable. Constants are always associated with a type, not an instance of a type Logically, constants are always static members Discussed in Chapter 7, &quot;Constants and Fields &quot;</p>
<p>&#9632; Fields  A field represents a read-only or read/write data value. A field can be static, in which case the field is considered part of the type's state. A field can also be instance (nonstatic), in which case it's considered part of an object's state. I strongly encourage you to make fields private so that the state of the type or object can't be corrupted by code outside of the defining type. Discussed in Chapter 7</p>
<p>&#9632; Instance constructors  An instance constructor is a special method used to initialize a new object's instance fields to a good initial state. Discussed in Chapter 8, &quot;Methods.&quot;</p>
<p>&#9632; Type constructors  A type constructor is a special method used to initialize a type's static fields to a good initial state. Discussed in Chapter 8.</p>
<p>&#9632; Methods A method is a function that performs operations that change or query the state of a type (static method) or an object (instance method). Methods typically read and write to the fields of the type or object. Discussed in Chapter 8.</p>
<p>&#9632; Operator overloads  An operator overload is a method that defines how an object should be manipulated when certain operators are applied to the object Because not all programming languages support operator overloading, operator overload methods are not part of the Common Language Specification (CLS). Discussed in Chapter 8.</p>
<p>&#9632; Conversion operators  A conversion operator is a method that defines how to implicitly or explicitly cast or convert an object from one type to another type. As with operator overload methods, not all programming languages support conversion operators, so they're not part of the CLS. Discussed in Chapter 8.</p>
<p>&#9632; Properties  A property is a mechanism that allows a simple, field-like syntax for setting or querying part of the logical state of a type (static property) or object (instance property) while ensuring that the state doesn't become corrupt Properties can be parameterless (very common) or parameterful (fairly uncommon but used frequently with collection classes). Discussed in Chapter 10, &quot;Properties.&quot;</p>
<p>&#9632; Events  A static event is a mechanism that allows a type to send a notification to one or more static or instance methods. An instance (nonstatic) event is a mechanism that allows an object to send a notification to one or more static or instance methods. Events are usually raised in response to a state change occurring in the type or object offering the event. An event consists of two methods that allow static or instance methods to register and unregister interest in the event In addition to the two methods, events typically use a delegate field to maintain the set of registered methods. Discussed in Chapter 11, &quot;Events.&quot;</p>
<p>&#9632; Types  A type can define other types nested within it. This approach is typically used to break a large, complex type down into smaller building blocks to simplify the implementation.</p>
<p>Again, the purpose of this chapter isn't to describe these various members in detail but to set the stage and explain what these various members all have in common.</p>
<p>Regardless of the programming language you're using, the corresponding compiler must process your source code and produce metadata and Intermediate Language (IL) code for each kind of member in the preceding list. The format of the metadata is identical regardless of the source programming language you use, and this feature is what makes the CLR a common language runtime. The metadata is the common information that all languages produce and consume, enabling code in one programming language to seamlessly access code written in a completely different programming language.</p>
<p>This common metadata format is also used by the CLR, which determines how constants, fields, constructors, methods, properties, and events all behave at runtime. Simply stated,</p>
<p>metadata is the key to the whole Microsoft .NET Framework development platform; it enables the seamless integration of languages, types, and objects.</p>
<p>The following C# code shows a type definition that contains an example of all the possible members The code shown here will compile (with warnings), but it isn't representative of a type that you'd normally create; most of the methods do nothing of any real value. Right now, I just want to show you how the compiler translates this type and its members into metadata. Once again, I'll discuss the individual members in the next few chapters.</p>
<p><code>using System;<br/>
public sealed class SomeType {// l<br/>
// Nested class<br/>
private class SomeNestedType { }// 2<br/>
// Constant, read-only,.and static read/write field<br/>
private const      Int32.c_SomeConstant = l;//.3<br/>
private readonly String.m_SomeReadOnlyField = &quot;2&quot;;//.4<br/>
private static     Int32.s_SomeReadWriteField = 3;//.5<br/>
// Type constructor<br/>
static SomeType() { }// 6<br/>
// Instance constructors<br/>
public SomeType(Int32 x) { }// 7<br/>
public SomeType() { }// 8<br/>
// Instance and static methods<br/>
private String InstanceMethod() { return null; }// 9<br/>
public static void Main() {}// l0<br/>
// Instance property<br/>
public Int32 SomeProp {// ll<br/>
get { return 0; }// l2<br/>
set { }// l3<br/>
}<br/>
// Instance parameterful property (indexer) public Int32 this[String s] {// l4<br/>
get { return 0; }// l5<br/>
set { }// l6<br/>
}<br/>
// Instance event<br/>
public event EventHandler SomeEvent;// l7<br/>
}</code></p>
<p>If you were to compile the type just defined and examine the metadata in ILDasm.exe, you'd see the output shown in Figure 6-1.</p>
<img src="32.jpg"/>
<p><b>FIGuRE 6-1 </b>ILDasm.exe output showing metadata from preceding code</p>
<p>Notice that all the members defined in the source code cause the compiler to emit some metadata. In fact, some of the members cause the compiler to generate additional members as well as additional metadata. For example, the event member (17) causes the compiler to emit a field, two methods, and some additional metadata. I don't expect you to fully understand what you're seeing here now But as you read the next few chapters, I encourage you to look back to this example to see how the member is defined and what effect that has on the metadata produced by the compiler.</p>
<a name="b158"/><h2>Type Visibility</h2>
<p>When defining a type at file scope (versus defining a type nested within another type), you can specify the type's visibility as being either <b>public </b>or <b>internal. </b>A <b>public </b>type is visible to all code within the defining assembly as well as all code written in other assemblies. An <b>internal </b>type is visible to all code within the defining assembly, and the type is not visible to code written in other assemblies. If you do not explicitly specify either of these when you define a type, the C# compiler sets the type's visibility to <b>internal </b>(the more restrictive of the two). Here are some examples:</p>
<p><code>using System;<br/>
// The type below has public visibility and can be accessed by code // in this assembly as well as code written in other assemblies. public class ThisIsAPublicType {... }<br/>
// The type below has internal visibility and can be accessed by code // in this assembly only. internal class ThisIsAnInternalType {... }<br/>
// The type below is internal because public/internal // was not explicitly stated class ThisIsAlsoAnInternalType {... }</code></p>
<h3>Friend Assemblies</h3>
<p>Imagine the following scenario: A company has one team, TeamA, that is defining a bunch of utility types in one assembly, and they expect these types to be used by members in another team, TeamB. For various reasons such as time schedules or geographical location, or perhaps different cost centers or reporting structures, these two teams cannot build all of their types into a single assembly; instead, each team produces its own assembly file.</p>
<p>In order for TeamB's assembly to use TeamA's types, TeamA must define all of their utility types as <b>public. </b>However, this means that their types are publicly visible to any and all assemblies; developers in another company could write code that uses the public utility types, and this is not desirable. Maybe the utility types make certain assumptions that TeamB ensures when they write code that uses TeamA's types. What we'd like to have is a way for TeamA to define their types as <b>internal </b>while still allowing TeamB to access the types. The CLR and C# support this via friend assemblies. This friend assembly feature is also useful when you want to have one assembly containing code that performs unit tests against the internal types within another assembly.</p>
<p>When an assembly is built, it can indicate other assemblies it considers &quot;friends&quot; by using the <b>InternalsVisibleTo </b>attribute defined in the <b>System.Runtime.CompilerServices </b>namespace. The attribute has a string parameter that identifies the friend assembly's name and public key (the string you pass to the attribute must not include a version, culture, or processor architecture). Note that friend assemblies can access all of an assembly's <b>internal </b>types as well as these type's <b>internal </b>members. Here is an example of how an assembly can specify two other strongly named assemblies named &quot;Wintellect&quot; and &quot;Microsoft&quot; as its friend assemblies:</p>
<p><code>using System;<br/>
using System.Runtime.CompilerServices; // For InternalsVisibleTo attribute<br/>
// This assembly's internal types can be accessed by any code written // in the following two assemblies (regardless of version or culture): [assembly:InternalsVisibleTo(&quot;Wintellect, PublicKey=12345678...90abcdef&quot;)] [assembly:InternalsVisibleTo(&quot;Microsoft, PublicKey=b77a5c56...1934e089&quot;)]<br/>
internal sealed class SomeInternalType {... } internal sealed class AnotherInternalType {... }</code></p>
<p>Accessing the above assembly's <b>internal </b>types from a friend assembly is trivial. For example, here's how a friend assembly called &quot;Wintellect&quot; with a public key of &quot;12345678...90ab-cdef&quot; can access the internal type <b>SomelnternalType </b>in the assembly above:</p>
<p><code>using System;<br/>
internal sealed class Foo {<br/>
private static Object SomeMethod() {<br/>
// This &quot;Wintellect&quot; assembly accesses the other assembly's<br/>
// internal type as if it were a public type SomeInternalType sit = new SomeInternalType(); return sit;<br/>
}<br/>
}</code></p>
<p>Since the <b>internal </b>members of the types in an assembly become accessible to friend assemblies, you should think carefully about what accessibility you specify for your type's members and which assemblies you declare as your friends. Note that the C# compiler requires you to use the <b>/out:&lt;file&gt; </b>compiler switch when compiling the friend assembly (the assembly that does not contain the <b>InternalsVisibleTo </b>attribute). The switch is required because the compiler needs to know the name of the assembly being compiled in order to determine if the resulting assembly should be considered a friend assembly. You would think that the C# compiler could determine this on its own since it normally determines the output file name on its own; however, the compiler doesn't decide on an output file name until it is finished compiling the code. So requiring the <b>/out:&lt;file&gt; </b>compiler switch improves the performance of compiling significantly.</p>
<p>Also, if you are compiling a module (as opposed to an assembly) using C#'s <b>/t:module </b>switch, and this module is going to become part of a friend assembly, you need to compile the module by using the C# compiler's <b>/moduleassemblyname:&lt;string&gt; </b>switch as well. This tells the compiler what assembly the module will be a part of so the compiler can allow code in the module to access the other assembly's internal types.</p>
<hr/>
<blockquote><b>Important </b>The friend assembly feature should be used only by assemblies that ship on the same schedule and probably even ship together The reason is because the interdependency between friend assemblies is so high that shipping the friend assemblies on different schedules will most likely cause compatibility problems. If you expect the assemblies to ship on different schedules, you should try to design <b>public </b>classes that can be consumed by any assembly and limit accessibility via a LinkDemand requesting the <b>StrongNameldentityPermission.</b></blockquote>
<hr/>
<a name="b160"/><h2>Member Accessibility</h2>
<p>When defining a type's member (which includes nested types), you can specify the member's accessibility. A member's accessibility indicates which members can be legally accessed from referent code. The CLR defines the set of possible accessibility modifiers, but each programming language chooses the syntax and term it wants developers to use when applying the accessibility to a member. For example, the CLR uses the term Assembly to indicate that a member is accessible to any code within the same assembly, whereas the C# term for this is <b>internal.</b></p>
<p>Table 6-1 shows the six accessibility modifiers that can be applied to a member. The rows of the table are in order from most restrictive (Private) to least restrictive (Public).</p>
<p><b>Table 6-1 </b><b>Member Accessibility</b></p>
<table border="1">
<tr>
<td>
<p>m</p>
</td>
<td>
<p><b>C# Term</b></p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>Private</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>The member is accessible only by methods in the defining type or any nested type.</p>
</td>
</tr>
<tr>
<td>
<p>Family</p>
</td>
<td>
<p>d</p>
</td>
<td>
<p>The member is accessible only by methods in the defining type, any nested type, or one of its derived types without regard to assembly.</p>
</td>
</tr>
<tr>
<td>
<p>Family and Assembly</p>
</td>
<td>
<p>(not supported)</p>
</td>
<td>
<p>The member is accessible only by methods in the defining type, any nested type, or by any derived types defined in the same assembly.</p>
</td>
</tr>
<tr>
<td>
<p>Assembly</p>
</td>
<td>
<p>l</p>
</td>
<td>
<p>The member is accessible only by methods in the defining assembly.</p>
</td>
</tr>
<tr>
<td>
<p>Family or Assembly</p>
</td>
<td>
<p>l</p>
</td>
<td>
<p>The member is accessible by any nested type, any derived type (regardless of assembly), or any methods in the defining assembly.</p>
</td>
</tr>
<tr>
<td>
<p>Public</p>
</td>
<td>
<p>c</p>
</td>
<td>
<p>The member is accessible to all methods in any assembly.</p>
</td>
</tr>
</table>
<p>Of course, for any member to be accessible, it must be defined in a type that is visible. For example, if AssemblyA defines an <b>internal </b>type with a <b>public </b>method, code in AssemblyB cannot call the <b>public </b>method because the <b>internal </b>type is not visible to AssemblyB.</p>
<p>When compiling code, the language compiler is responsible for checking that the code is referencing types and members correctly. If the code references some type or member incorrectly, the compiler has the responsibility of emitting the appropriate error message. In addition, the just-in-time (JIT) compiler also ensures that references to fields and methods are legal when compiling IL code into native CPU instructions at runtime. For example, if the JIT compiler detects code that is improperly attempting to access a private field or method, the JIT compiler throws a <b>FieldAccessException </b>or a <b>MethodAccessException, </b>respectively.</p>
<p>Verifying the IL code ensures that a referenced member's accessibility is properly honored at runtime, even if a language compiler ignored checking the accessibility. Another, more likely, possibility is that the language compiler compiled code that accessed a <b>public </b>member in another type (in another assembly); but at runtime, a different version of the assembly is loaded, and in this new version, the <b>public </b>member has changed and is now <b>protected </b>or <b>private.</b></p>
<p>In C#, if you do not explicitly declare a member's accessibility, the compiler usually (but not always) defaults to selecting <b>private </b>(the most restrictive of them all). The CLR requires that all members of an interface type be public. The C# compiler knows this and forbids the programmer from explicitly specifying accessibility on interface members; the compiler just makes all the members <b>public </b>for you.</p>
<p>More Info See the &quot;Declared Accessibility&quot; section in the C# Language Specification for</p>
<p>the complete set of C# rules about what accessibilities can be applied to types and members and what default accessibilities C# selects based on the context in which the declaration takes place.</p>
<p>Furthermore, you'll notice the CLR offers an accessibility called Family and Assembly. However, C# doesn't expose this in the language. The C# team felt that this accessibility was for the most part useless and decided not to incorporate it into the C# language.</p>
<p>When a derived type is overriding a member defined in its base type, the C# compiler requires that the original member and the overriding member have the same accessibility That is, if the member in the base class is <b>protected, </b>the overriding member in the derived class must also be <b>protected. </b>However, this is a C# restriction, not a CLR restriction. When deriving from a base class, the CLR allows a member's accessibility to become less restrictive but not more restrictive. For example, a class can override a <b>protected </b>method defined in its base class and make the overridden method <b>public </b>(more accessible). However, a class cannot override a <b>protected </b>method defined in its base class and make the overridden method <b>private </b>(less accessible). The reason a class cannot make a base class method more restricted is because a user of the derived class could always cast to the base type and gain access to the base class's method. If the CLR allowed the derived type's method to be less accessible, it would be making a claim that was not enforceable.</p>
<a name="b162"/><h2>Static Classes</h2>
<p>There are certain classes that are never intended to be instantiated, such as <b>Console, Math, Environment, </b>and <b>ThreadPool. </b>These classes have only <b>static </b>members and, in fact, the classes exist simply as a way to group a set of related members together. For example, the <b>Math </b>class defines a bunch of methods that do math-related operations. C# allows you to define non-instantiable classes by using the C# <b>static </b>keyword. This keyword can be applied only to classes, not structures (value types) because the CLR always allows value types to be instantiated and there is no way to stop or prevent this.</p>
<p>The compiler enforces many restrictions on a <b>static </b>class:</p>
<p>&#9632; The class must be derived directly from <b>System.Object </b>because deriving from any other base class makes no sense since inheritance applies only to objects, and you cannot create an instance of a <b>static </b>class.</p>
<p>&#9632; The class must not implement any interfaces since interface methods are callable only when using an instance of a class.</p>
<p>&#9632; The class must define only <b>static </b>members (fields, methods, properties, and events). Any instance members cause the compiler to generate an error.</p>
<p>&#9632; The class cannot be used as a field, method parameter, or local variable because all of these would indicate a variable that refers to an instance, and this is not allowed. If the compiler detects any of these uses, the compiler issues an error.</p>
<p>Here is an example of a <b>static </b>class that defines some <b>static </b>members; this code compiles (with a warning) but the class doesn't do anything interesting:</p>
<p><code>using System;<br/>
public static class AStaticClass {<br/>
public static void AStaticMethod() { }<br/>
public static String AStaticProperty { get { return s_AStaticField; } set { s_AStaticField = value; }<br/>
}<br/>
private static String s_AStaticField;<br/>
public static event EventHandler AStaticEvent;<br/>
}</code></p>
<p>If you compile the code above into a library (DLL) assembly and look at the result by using ILDasm.exe, you'll see what is shown in Figure 6-2. As you can see in Figure 6-2, defining a class by using the <b>static </b>keyword causes the C# compiler to make the class both <b>abstract </b>and <b>sealed. </b>Furthermore, the compiler will not emit an instance constructor method into the type. Notice that there is no instance constructor <b>(.ctor) </b>method shown in Figure 6-2.</p>
<img src="33.jpg"/>
<p><b>Figure 6-2 </b>ILDasm.exe showing the class as abstract sealed in metadata</p>
<a name="b164"/><h2>Partial Classes, Structures, and Interfaces</h2>
<p>In this section, I discuss partial classes, structures, and interfaces It should be noted that this feature is offered entirely by the C# compiler (some other compilers also offer this feature); the CLR knows nothing about partial classes, structures, and interfaces</p>
<p>The partial keyword tells the C# compiler that the source code for a single class, structure, or interface definition may span one or more source code files. There are three main reasons why you might want to split the source code for a type across multiple files:</p>
<p>&#9632; Source control   Suppose a type's definition consists of a lot of source code, and a programmer checks it out of source control to make changes. No other programmer will be able to modify the type at the same time without doing a merge later. Using the partial keyword allows you to split the code for the type across multiple source code files, each of which can be checked out individually so that multiple programmers can edit the type at the same time.</p>
<p>&#9632; Splitting a class or structure into distinct logical units within a single file   I sometimes create a single type that provides multiple features so that the type can provide a complete solution. To simplify my implementation, I will sometimes declare the same partial type repeatedly within a single source code file. Then, in each part of the partial type, I implement one feature with all its fields, methods, properties, events, and so on. This allows me to easily see all the members that provide a single feature grouped together, which simplifies my coding. Also, I can easily comment out a part of the partial type to remove a whole feature from the class and replace it with another implementation (via a new part of the partial type).</p>
<p>&#9632; Code spitters   In Microsoft Visual Studio, when you create a new Windows Forms or Web Forms project, some source code files are created automatically as part of the project. These source code files contain templates that give you a head start at building these kinds of projects When you use the Visual Studio designers and drag and drop controls onto the Windows form or Web form, Visual Studio writes source code for you automatically and spits this code into the source code files. This really improves your productivity. Historically, the generated code was emitted into the same source code file that you were working on. The problem with this is that you might edit the generated code accidentally and cause the designers to stop functioning correctly. Starting with Visual Studio 2005, when you create a new Windows form, Web form, user control, and so on, Visual Studio creates two source code files: one for your code and the other for the code generated by the designer. Since the designer code is in a separate file, you'll be far less likely to accidentally edit it.</p>
<p>The partial keyword is applied to the types in all files. When the files are compiled together, the compiler combines the code to produce one type that is in the resulting exe or dll assembly file (or.netmodule module file). As I stated in the beginning of this section, the partial types feature is completely implemented by the C# compiler; the CLR knows nothing about partial types at all. This is why all of the source code files for the type must use the same programming language, and they must all be compiled together as a single compilation unit.</p>
<a name="b165"/><h2>Components, Polymorphism, and Versioning</h2>
<p>Object-oriented programming (OOP) has been around for many, many years. When it was first used in the late 1970s/early 1980s, applications were much smaller in size and all the code to make the application run was written by one company. Sure, there were operating systems back then and applications did make use of what they could out of those operating systems, but the operating systems offered very few features compared with the operating systems of today.</p>
<p>Today, software is much more complex and users demand that applications offer rich features such as GUIs, menu items, mouse input, tablet input, printer output, networking, and so on. For this reason, our operating systems and development platforms have grown substantially over recent years. Furthermore, it is no longer feasible or even cost effective for application developers to write all of the code necessary for their application to work the way users expect. Today, applications consist of code produced by many different companies. This code is stitched together using an object-oriented paradigm.</p>
<p>Component Software Programming (CSP) is OOP brought to this level. Here are some attributes of a component:</p>
<p>&#9632; A component (an assembly in.NET) has the feeling of being &quot;published.&quot;</p>
<p>&#9632; A component has an identity (a name, version, culture, and public key).</p>
<p>&#9632; A component forever maintains its identity (the code in an assembly is never statically linked into another assembly;.NET always uses dynamic linking).</p>
<p>&#9632; A component clearly indicates the components it depends upon (reference metadata tables).</p>
<p>&#9632; A component should document its classes and members. C# offers this by allowing in-source Extensible Markup Language (XML) documentation along with the compiler's <b>/doc </b>command-line switch.</p>
<p>&#9632; A component must specify the security permissions it requires. The CLR's code access security (CAS) facilities enable this.</p>
<p>&#9632; A component publishes an interface (object model) that won't change for any servicings. A servicing is a new version of a component whose intention is to be backward compatible with the original version of the component Typically, a servicing version includes bug fixes, security patches, and possibly some small feature enhancements. But a servicing cannot require any new dependencies or any additional security permissions.</p>
<p>As indicated by the last bullet, a big part of CSP has to do with versioning Components will change over time and components will ship on different time schedules. Versioning introduces a whole new level of complexity for CSP that didn't exist with OOP, with which all code was written, tested, and shipped as a single unit by a single company. In this section, I'm going to focus on component versioning.</p>
<p>In.NET, a version number consists of four parts: a major part, a minor part, a build part, and a revision part. For example, an assembly whose version number is 1.2.3.4 has a major part of 1, a minor part of 2, a build part of 3, and a revision part of 4. The major/minor parts are typically used to represent a consistent and stable feature set for an assembly and the build/ revision parts are typically used to represent a servicing of this assembly's feature set.</p>
<p>Let's say that a company ships an assembly with version 2.7. 0. 0. If the company later wants to fix a bug in this component, they would produce a new assembly in which only the build/ revision parts of the version are changed, something like version 2. 7.1.34. This indicates that the assembly is a servicing whose intention is to be backward compatible with the original component (version 2. 7 0.0).</p>
<p>On the other hand, if the company wants to make a new version of the assembly that has significant changes to it and is therefore not intended to be backward compatible with the original assembly, the company is really creating a new component and the new assembly should be given a version number in which the major/minor parts are different from the existing component (version 3. 0. 0.0, for example).</p>
<hr/>
<blockquote><b>Note </b>I have just described how you should think of version numbers. Unfortunately, the CLR <b>i        </b>doesn't treat version numbers this way. Today, the CLR treats a version number as an opaque value, and if an assembly depends on version 1.2.3.4 of another assembly, the CLR tries to load version 1 2 3 4 only (unless a binding redirection is in place)</blockquote>
<hr/>
<p>Now that we've looked at how we use version numbers to update a component's identity to reflect a new version, let's take a look at some of the features offered by the CLR and programming languages (such as C#) that allow developers to write code that is resilient to changes that may be occurring in components that they are using.</p>
<p>Versioning issues come into play when a type defined in a component (assembly) is used as the base class for a type in another component (assembly) Obviously, if the base class versions (changes) underneath the derived class, the behavior of the derived class changes as well, probably in a way that causes the class to behave improperly. This is particularly true in polymorphism scenarios in which a derived type overrides virtual methods defined by a base</p>
<p>C# offers five keywords that you can apply to types and/or type members that impact component versioning. These keywords map directly to features supported in the CLR to support component versioning. Table 6-2 contains the C# keywords related to component versioning and indicates how each keyword affects a type or type member definition.</p>
<p><b>Table 6-2 </b><b>C# Keywords and How They Affect Component Versioning</b></p>
<table border="1">
<tr>
<td>
<p><b>C# Keyword</b></p>
</td>
<td>
<p>e</p>
</td>
<td>
<p><b>Method/Property/Event</b></p>
</td>
<td>
<p><b>Constant/Field</b></p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>Indicates that no instances of the type can be constructed</p>
</td>
<td>
<p>Indicates that the derived type must override and implement this member before instances of the derived type can be constructed</p>
</td>
<td>
<p>(not allowed)</p>
</td>
</tr>
<tr>
<td>
<p>l</p>
</td>
<td>
<p>(not allowed)</p>
</td>
<td>
<p>Indicates that this member can be overridden by a derived type</p>
</td>
<td>
<p>(not allowed)</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>(not allowed)</p>
</td>
<td>
<p>Indicates that the derived type is overriding the base type's member</p>
</td>
<td>
<p>(not allowed)</p>
</td>
</tr>
<tr>
<td>
<p>d</p>
</td>
<td>
<p>Indicates that the type cannot be used as a base type</p>
</td>
<td>
<p>Indicates that the member cannot be overridden by a derived type This keyword can be applied only to a method that is overriding a virtual method.</p>
</td>
<td>
<p>(not allowed)</p>
</td>
</tr>
</table>
<p><b>new.</b>When applied to a nested type, method, property, event, constant, or field, indicates that the member has no relationship to a similar member that may exist in the base class</p>
<p>I will demonstrate the value and use of all these keywords in the upcoming section titled &quot;Dealing with Virtual Methods When Versioning Types.&quot; But before we get to a versioning scenario, let's focus on how the CLR actually calls virtual methods.</p>
<h3>How the CLR Calls Virtual Methods, Properties, and Events</h3>
<p>In this section, I will be focusing on methods, but this discussion is relevant to virtual properties and virtual events as well. Properties and events are actually implemented as methods; this will be shown in their corresponding chapters.</p>
<p>Methods represent code that performs some operation on the type (static methods) or an instance of the type (nonstatic methods). All methods have a name, a signature, and a return value (that may be <b>void) </b>. The CLR allows a type to define multiple methods with the same name as long as each method has a different set of parameters or a different return value. So it's possible to define two methods with the same name and same parameters as long as the methods have a different return type. However, except for IL assembly language, I'm not aware of any language that takes advantage of this &quot;feature&quot;; most languages (including C#) require that methods differ by parameters and ignore a method's return type when determining uniqueness. (C# actually relaxes this restriction when defining conversion operator methods; see Chapter 8 for details.</p>
<p>The <b>Employee </b>class shown below defines three different kinds of methods:</p>
<p><code>internal class Employee {<br/>
// A nonvirtual instance method<br/>
public.Int32      GetYearsEmployed() { &#9632;&#9632;&#9632; }<br/>
// A virtual method (virtual implies instance) public virtual String     GetProgressReport() {... }<br/>
// A static method<br/>
public static   Employee Lookup(String name) {... }<br/>
}</code></p>
<p>When the compiler compiles this code, the compiler emits three entries in the resulting assembly's method definition table. Each entry has flags set indicating if the method is instance, virtual, or static.</p>
<p>When code is written to call any of these methods, the compiler emitting the calling code examines the method definition's flags to determine how to emit the proper IL code so that the call is made correctly The CLR offers two IL instructions for calling a method:</p>
<p>&#9632; The <b>call </b>IL instruction can be used to call static, instance, and virtual methods. When the <b>call </b>instruction is used to call a static method, you must specify the type that defines the method that the CLR should call. When the <b>call </b>instruction is used to call an instance or virtual method, you must specify a variable that refers to an object. The <b>call </b>instruction assumes that this variable is not <b>null. </b>In other words, the type of the variable itself indicates which type defines the method that the CLR should call. If the variable's type doesn't define the method, base types are checked for a matching method. The <b>call </b>instruction is frequently used to call a virtual method nonvirtually</p>
<p>&#9632; The <b>callvirt </b>IL instruction can be used to call instance and virtual methods, not static methods. When the <b>callvirt </b>instruction is used to call an instance or virtual method, you must specify a variable that refers to an object. When the <b>callvirt </b>IL instruction is used to call a nonvirtual instance method, the type of the variable indicates which type defines the method that the CLR should call. When the <b>callvirt </b>IL instruction is used to call a virtual instance method, the CLR discovers the actual type of the object being used to make the call and then calls the method polymorphically In order to determine the type, the variable being used to make the call must not be <b>null. </b>In other words, when compiling this call, the JIT compiler generates code that verifies that the variable's value is not <b>null. </b>If it is <b>null, </b>the <b>callvirt </b>instruction causes the CLR to throw a <b>NullReferenceException. </b>This additional check means that the <b>callvirt </b>IL instruction executes slightly more slowly than the <b>call </b>instruction. Note that this <b>null </b>check is performed even when the <b>callvirt </b>instruction is used to call a nonvirtual instance method.</p>
So now, let's put this together to see how C# uses these different IL instructions:
<p><code>using System;<br/>
public sealed class Program { public static void Main() {<br/>
Console.WriteLineO; // Call a static method<br/>
Object o = new Object();<br/>
o.GetHashCode(); // Call a virtual instance method o.GetType();        // Call a nonvirtual instance method<br/>
}<br/>
}</code></p>
<p>If you were to compile the code above and look at the resulting IL, you'd see the following:</p>
<p><code>.method public hidebysig static void Main() cil managed {.entrypoint<br/>
// Code size 26 (0xla).maxstack 1<br/>
.locals init (object V_0)<br/>
IL_0000: call void System.Console::WriteLine() IL_0005: newobj instance void System.Object::.ctor() IL_000a: stloc.0 IL_000b: ldloc.0<br/>
IL_000c: callvirt instance int32 System.Object::GetHashCode() IL_0011: pop IL_0012: ldloc.0<br/>
IL_0013: callvirt instance class System.Type System.Object::GetType() IL_0018: pop IL_0019: ret } // end of method Program::Main</code></p>
<p>Notice that the C# compiler uses the <b>call </b>IL instruction to call <b>Console</b>'s <b>WriteLine </b>method. This is expected because <b>WriteLine </b>is a static method. Next, notice that the <b>callvirt </b>IL instruction is used to call <b>GetHashCode. </b>This is also expected, since <b>GetHashCode </b>is a virtual method. Finally, notice that the C# compiler also uses the <b>callvirt </b>IL instruction to call the <b>GetType </b>method. This is surprising since <b>GetType </b>is not a virtual method. However, this works because while JIT-compiling this code, the CLR will know that <b>GetType </b>is not a virtual method, and so the JIT-compiled code will simply call <b>GetType </b>nonvirtually.</p>
<p>Of course, the question is, why didn't the C# compiler simply emit the <b>call </b>instruction instead? The answer is because the C# team decided that the JIT compiler should generate code to verify that the object being used to make the call is not <b>null. </b>This means that calls to nonvirtual instance methods are a little slower than they could be. It also means that the C# code shown below will cause a <b>NullReferenceException </b>to be thrown. In some other programming languages, the intention of the code shown below would run just fine:</p>
<p><code>using System;<br/>
public sealed class Program {<br/>
public Int32 GetFive() { return 5; } public static void Main() { Program p = null;<br/>
Int32 x = p.GetFive(); // In C#, NullReferenceException is thrown<br/>
}<br/>
}</code></p>
<p>Theoretically, the code above is fine. Sure, the variable <b>p </b>is <b>null, </b>but when calling a nonvirtual method <b>(GetFive), </b>the CLR needs to know just the data type of <b>p, </b>which is <b>Program. </b>If <b>GetFive </b>did get called, the value of the <b>this </b>argument would be <b>null. </b>Since the argument is not used inside the <b>GetFive </b>method, no <b>NullReferenceException </b>would be thrown However, because the C# compiler emits a <b>callvirt </b>instruction instead of a <b>call </b>instruction, the code above will end up throwing the <b>NullReferenceException.</b></p>
<hr/>
<blockquote><b>Important </b>If you define a method as nonvirtual, you should never change the method to virtual in the future The reason is because some compilers will call the nonvirtual method by using the <b>call </b>instruction instead of the <b>callvirt </b>instruction. If the method changes from nonvirtual to virtual and the referencing code is not recompiled, the virtual method will be called nonvirtually, causing the application to produce unpredictable behavior. If the referencing code is written in C#, this is not a problem, since C# calls all instance methods by using <b>callvirt. </b>But this could be a problem if the referencing code was written using a different programming language.</blockquote>
<hr/>
<p>Sometimes, the compiler will use a <b>call </b>instruction to call a virtual method instead of using a <b>callvirt </b>instruction. At first, this may seem surprising, but the code below demonstrates why it is sometimes required:</p>
<p><code>internal class SomeClass {<br/>
// ToString is a virtual method defined in the base class: Object. public override String ToString() {<br/>
// Compiler uses the 'call' IL instruction to call // Object's ToString method nonvirtually.<br/>
// If the compiler were to use 'callvirt' instead of 'call', this // method would call itself recursively until the stack overflowed. return base.ToString();<br/>
}<br/>
}</code></p>
<p>When calling <b>base.ToString </b>(a virtual method), the C# compiler emits a <b>call </b>instruction to ensure that the <b>ToString </b>method in the base type is called nonvirtually. This is required because if <b>ToString </b>were called virtually, the call would execute recursively until the thread's stack overflowed, which obviously is not desired.</p>
<p>Compilers tend to use the <b>call </b>instruction when calling methods defined by a value type since value types are sealed This implies that there can be no polymorphism even for their virtual methods, which causes the performance of the call to be faster In addition, the nature of a value type instance guarantees it can never be <b>null, </b>so a <b>NullReferenceException </b>will never be thrown Finally, if you were to call a value type's virtual method virtually, the CLR would need to have a reference to the value type's type object in order to refer to the method table within it This requires boxing the value type Boxing puts more pressure on the heap, forcing more frequent garbage collections and hurting performance.</p>
<p>Regardless of whether <b>call </b>or <b>callvirt </b>is used to call an instance or virtual method, these methods always receive a hidden <b>this </b>argument as the method's first parameter The <b>this </b>argument refers to the object being operated on.</p>
<p>When designing a type, you should try to minimize the number of virtual methods you define. First, calling a virtual method is slower than calling a nonvirtual method. Second, virtual methods cannot be inlined by the JIT compiler, which further hurts performance. Third, virtual methods make versioning of components more brittle, as described in the next section. Fourth, when defining a base type, it is common to offer a set of convenience overloaded methods. If you want these methods to be polymorphic, the best thing to do is to make the most complex method virtual and leave all of the convenience overloaded methods nonvirtual. By the way, following this guideline will also improve the ability to version a component without adversely affecting the derived types. Here is an example:</p>
<p><code>public class Set {<br/>
private Int32 m_length = 0;<br/>
// This convenience overload is not virtual public Int32 Find(Object value) { return Find(value, 0, m_length);<br/>
}<br/>
// This convenience overload is not virtual<br/>
public Int32 Find(Object value, Int32 startIndex) {<br/>
return Find(value, startIndex, m_length - startIndex);<br/>
}<br/>
// The most feature-rich method is virtual and can be overridden public virtual Int32 Find(Object value, Int32 startIndex, Int32 endIndex) { // Actual implementation that can be overridden goes here...<br/>
}<br/>
// Other methods go here<br/>
}</code></p>
<h3>Using Type Visibility and Member Accessibility Intelligently</h3>
<p>With the .NET Framework, applications are composed of types defined in multiple assemblies produced by various companies This means that the developer has little control over the components he or she is using and the types defined within those components. The developer typically doesn't have access to the source code (and probably doesn't even know what programming language was used to create the component), and components tend to version with different schedules. Furthermore, due to polymorphism and protected members, a base class developer must trust the code written by the derived class developer. And, of course, the developer of a derived class must trust the code that he is inheriting from a base class These are just some of the issues that you need to really think about when designing components and types.</p>
<p>In this section, I'd like to say just a few words about how to design a type with these issues in mind. Specifically, I'm going to focus on the proper way to set type visibility and member accessibility so that you'll be most successful.</p>
<p>First, when defining a new type, compilers should make the class sealed by default so that the class cannot be used as a base class. Instead, many compilers, including C#, default to unsealed classes and allow the programmer to explicitly mark a class as sealed by using the sealed keyword. Obviously, it is too late now, but I think that today's compilers have chosen the wrong default and it would be nice if this could change with future compilers There are three reasons why a sealed class is better than an unsealed class:</p>
<p>&#9632; Versioning   When a class is originally sealed, it can change to unsealed in the future without breaking compatibility However, once a class is unsealed, you can never change it to sealed in the future as this would break all derived classes In addition, if the unsealed class defines any unsealed virtual methods, ordering of the virtual method calls must be maintained with new versions or there is the potential of breaking derived types in the future.</p>
<p>&#9632; Performance   As discussed in the previous section, calling a virtual method doesn't perform as well as calling a nonvirtual method because the CLR must look up the type of the object at runtime in order to determine which type defines the method to call. However, if the JIT compiler sees a call to a virtual method using a sealed type, the JIT compiler can produce more efficient code by calling the method nonvirtually. It can do this because it knows there can't possibly be a derived class if the class is sealed. For example, in the code below, the JIT compiler can call the virtual ToString method nonvirtually:</p>
<p><code>using System;<br/>
public sealed class Point { private Int32 m_x, m_y;<br/>
public Point(Int32 x, Int32 y) { m_x = x; m_y = y; }<br/>
public override String ToString() {<br/>
return String.Format(&quot;({0}, {1})&quot;, m_x, m_y);<br/>
}<br/>
public static void Main() { Point p = new Point(3, 4);<br/>
// The C# compiler emits the callvirt instruction here but the // JIT compiler will optimize this call and produce code that // calls ToString nonvirtually because p's type is Point, // which is a sealed class Console.WriteLine(p.ToStringO);<br/>
}<br/>
}</code></p>
<p>&#9632;   Security and predictability  A class must protect its own state and not allow itself to ever become corrupted When a class is unsealed, a derived class can access and manipulate the base class's state if any data fields or methods that internally manipulate fields are accessible and not private. In addition, a virtual method can be overridden by a derived class, and the derived class can decide whether to call the base class's implementation. By making a method, property, or event virtual, the base class is giving up some control over its behavior and its state. Unless carefully thought out, this can cause the object to behave unpredictably, and it opens up potential security holes.</p>
<p>The problem with a sealed class is that it can be a big inconvenience to users of the type Occasionally, developers want to create a class derived from an existing type in order to attach some additional fields or state information for their application's own use. In fact, they may even want to define some helper or convenience methods on the derived type to manipulate these additional fields. Since sealed classes restrict this ability, I made a proposal to the CLR team that they introduce a new class modifier called <b>closed.</b></p>
<p>A closed class can be used as a base class, but its behavior is closed and not subject to interference by a derived class Basically, a closed base class would prohibit a derived class from accessing any of the base class's non-public members. This would allow the base class to change with the knowledge that it will not impact a derived class. Ideally, compilers would change the default access modifier for types to <b>closed </b>because this would be the safest choice without being too restrictive. It is too early to know if this idea will make its way into the CLR and programming languages. However, I am very hopeful it will someday.</p>
<p>By the way, you could almost accomplish today what <b>closed </b>is designed to do; it's just that it is very inconvenient. Basically, when you implement your class, make sure you seal all the virtual methods you inherit (including the methods defined by <b>System.Object) </b>. Also, don't define any methods that may become a versioning burden in the future such as protected or virtual methods. Here is an example:</p>
<p><code>public class SimulatedClosedClass : Object {<br/>
public sealed override Boolean Equals(Object obj) { return base.Equals(obj);<br/>
}<br/>
public sealed override Int32 GetHashCode() { return base.GetHashCode();<br/>
}<br/>
public sealed override String ToString() { return base.ToString();<br/>
}<br/>
// Unfortunately, C# won't let you seal the Finalize method<br/>
// Define additional public or private members here... // Do not define any protected or virtual members<br/>
}</code></p>
<p>Unfortunately, the compilers and the CLR do not support closed types today Here are the guidelines I follow when I define my own classes:</p>
<p>&#9632; When defining a class, I always explicitly make it <b>sealed </b>unless I truly intend for the class to be a base class that allows specialization by derived classes. As stated earlier, this is the opposite of what C# and many other compilers default to today. I also default to making the class <b>internal </b>unless I want the class to be publicly exposed outside of my assembly. Fortunately, if you do not explicitly indicate a type's visibility, the C# compiler defaults to internal. If I really feel that it is important to define a class that others can derive but I do not want to allow specialization, I will simulate creating a closed class by using the above technique of sealing the virtual methods that my class inherits.</p>
<p>&#9632; Inside the class, I always define my data fields as <b>private </b>and I never waver on this. Fortunately, C# does default to making fields <b>private. </b>I'd actually prefer it if C# mandated that all fields be private and that you could not make fields <b>protected, internal, public, </b>and so on. Exposing state is the easiest way to get into problems, have your object behave unpredictably, and open potential security holes. This is true even if you just declare some fields as <b>internal. </b>Even within a single assembly, it is too hard to track all code that references a field, especially if several developers are writing code that gets compiled into the same assembly.</p>
<p>&#9632; Inside the class, I always define my methods, properties, and events as <b>private </b>and nonvirtual Fortunately, C# defaults to this as well Certainly, I'll make a method, property, or event <b>public </b>to expose some functionality from the type. I try to avoid making any of these members <b>protected </b>or <b>internal, </b>as this would be exposing my type to some potential vulnerability. However, I would sooner make a member <b>protected </b>or <b>internal </b>than I would make a member <b>virtual </b>because a virtual member gives up a lot of control and really relies on the proper behavior of the derived class.</p>
<p>&#9632; There is an old OOP adage that goes like this: when things get too complicated, make more types When an implementation of some algorithm starts to get complicated,</p>
<p>I define helper types that encapsulate discrete pieces of functionality. If I'm defining these helper types for use by a single uber-type, I'll define the helper types nested within the uber-type. This allows for scoping and also allows the code in the nested, helper type to reference the private members defined in the uber-type. However, there is a design guideline rule, enforced by the Code Analysis tool (FxCopCmd.exe) in Visual Studio, which indicates that publicly exposed nested types should be defined at file or assembly scope and not be defined within another type. This rule exists because some developers find the syntax for referencing nested types cumbersome. I appreciate this rule, and I never define public nested types.</p>
<h3>Dealing with Virtual Methods When Versioning Types</h3>
<p>As was stated earlier, in a Component Software Programming environment, versioning is a very important issue. I talked about some of these versioning issues in Chapter 3, &quot;Shared Assemblies and Strongly Named Assemblies,&quot; when I explained strongly named assemblies and discussed how an administrator can ensure that an application binds to the assemblies that it was built and tested with However, other versioning issues cause source code compatibility problems. For example, you must be very careful when adding or modifying members of a type if that type is used as a base type. Let's look at some examples.</p>
<p>CompanyA has designed the following type, <b>Phone:</b></p>
<p><code>namespace CompanyA { public class Phone { public void Dial() {<br/>
Console.WriteLine(&quot;Phone.Dial&quot;); // Do work to dial the phone here.<br/>
}<br/>
}<br/>
}</code></p>
<p>Now imagine that CompanyB defines another type, <b>BetterPhone, </b>which uses CompanyA's <b>Phone </b>type as its base:</p>
<p><code>namespace CompanyB {<br/>
public class BetterPhone : CompanyA.Phone { public void Dial() {<br/>
Console.WriteLine(&quot;BetterPhone.Dial&quot;);<br/>
EstablishConnection();<br/>
base.Dial();<br/>
}<br/>
protected virtual void EstablishConnection() {<br/>
Console.WriteLine(&quot;BetterPhone.EstablishConnection&quot;); // Do work to establish the connection.<br/>
}<br/>
}<br/>
}</code></p>
<p>When CompanyB attempts to compile its code, the C# compiler issues the following message: <b>&quot;warning CS0108:  'CompanyB.BetterPhone.Dial</b>O' <b>hides inherited member 'CompanyA.Phone.Dial</b>O'. <b>Use the new keyword if hiding was intended.&quot;</b></p>
<p>This warning is notifying the developer that <b>BetterPhone </b>is defining a <b>Dial </b>method, which will hide the <b>Dial </b>method defined in <b>Phone. </b>This new method could change the semantic meaning of <b>Dial </b>(as defined by CompanyA when it originally created the <b>Dial </b>method).</p>
<p>It's a very nice feature of the compiler to warn you of this potential semantic mismatch The compiler also tells you how to remove the warning by adding the <b>new </b>keyword before the definition of <b>Dial </b>in the <b>BetterPhone </b>class. Here's the fixed <b>BetterPhone </b>class:</p>
<p><code>namespace CompanyB {<br/>
public class BetterPhone : CompanyA.Phone {<br/>
// This Dial method has nothing to do with Phone's Dial method. public new void Dial() {<br/>
Console.WriteLine(&quot;BetterPhone.Dial&quot;);<br/>
EstablishConnection();<br/>
base.Dial();<br/>
}<br/>
protected virtual void EstablishConnection() {<br/>
Console.WriteLine(&quot;BetterPhone.EstablishConnection&quot;); // Do work to establish the connection.<br/>
}<br/>
}<br/>
}</code></p>
<p>At this point, CompanyB can use <b>BetterPhone.Dial </b>in its application. Here's some sample code that CompanyB might write:</p>
<p><code>public sealed class Program { public static void Main() {<br/>
CompanyB.BetterPhone phone = new CompanyB.BetterPhoneC); phone.Dial();<br/>
}<br/>
}</code></p>
<p>When this code runs, the following output is displayed:</p>
<p><code>BetterPhone.Dial<br/>
BetterPhone.EstablishConnection<br/>
Phone.Dial</code></p>
<p>This output shows that CompanyB is getting the behavior it desires The call to <b>Dial </b>is calling the new <b>Dial </b>method defined by <b>BetterPhone, </b>which calls the virtual <b>EstablishConnection </b>method and then calls the <b>Phone </b>base type's <b>Dial </b>method.</p>
<p>Now let's imagine that several companies have decided to use CompanyA's <b>Phone </b>type Let's further imagine that these other companies have decided that the ability to establish a connection in the <b>Dial </b>method is a really useful feature. This feedback is given to CompanyA, which now revises its <b>Phone </b>class:</p>
<p>namespace CompanyA { public class Phone { public void Dia1() {</p>
<p><code>Console.WriteLineC'Phone.Dial&quot;);<br/>
EstablishConnection();<br/>
// Do work to dial the phone here.<br/>
}<br/>
protected virtual void EstablishConnection() { Console.WriteLine(&quot;Phone.EstablishConnection&quot;); // Do work to establish the connection.<br/>
}<br/>
}<br/>
}</code></p>
<p>Now when CompanyB compiles its <b>BetterPhone </b>type (derived from this new version of CompanyA's <b>Phone), </b>the compiler issues this message: <b>&quot;warning CS0114: 'CompanyB.BetterPhone.EstablishConnection</b>O' <b>hides inherited member 'CompanyA.Phone.EstablishConnection</b>O'. <b>To make the current member override that implementation, add the override keyword. Otherwise, add the new keyword.&quot;</b></p>
<p>The compiler is alerting you to the fact that both <b>Phone </b>and <b>BetterPhone </b>offer an <b>EstablishConnection </b>method and that the semantics of both might not be identical; simply recompiling <b>BetterPhone </b>can no longer give the same behavior as it did when using the first version of the <b>Phone </b>type.</p>
<p>If CompanyB decides that the <b>EstablishConnection </b>methods are not semantically identical in both types, CompanyB can tell the compiler that the <b>Dial </b>and <b>EstablishConnection </b>method defined in <b>BetterPhone </b>is the correct method to use and that it has no relationship with the <b>EstablishConnection </b>method defined in the <b>Phone </b>base type. CompanyB informs the compiler of this by adding the <b>new </b>keyword to the <b>EstablishConnection </b>method:</p>
<p><code>namespace CompanyB {<br/>
public class BetterPhone : CompanyA.Phone {<br/>
// Keep 'new' to mark this method as having no // relationship to the base type's Dial method. public new void Dia1() {<br/>
Console.WriteLineC'BetterPhone.Dial&quot;);<br/>
EstablishConnection();<br/>
base.DialO;<br/>
}<br/>
// Add 'new' to mark this method as having no<br/>
// relationship to the base type's EstablishConnection method.<br/>
protected new virtual void EstablishConnection() {<br/>
Console.WriteLineC'BetterPhone.EstablishConnection&quot;);<br/>
// Do work to establish the connection.<br/>
}<br/>
}<br/>
}</code></p>
<p>In this code, the <b>new </b>keyword tells the compiler to emit metadata, making it clear to the CLR that <b>BetterPhone</b>'s <b>EstablishConnection </b>method is intended to be treated as a new function that is introduced by the <b>BetterPhone </b>type. The CLR will know that there is no relationship between <b>Phone</b>'s and <b>BetterPhone</b>'s methods.</p>
<p>When the same application code (in the <b>Main </b>method) executes, the output is as follows:</p>
<p><code>BetterPhone.Dial<br/>
BetterPhone.EstablishConnection<br/>
Phone.Dial<br/>
Phone.EstablishConnection</code></p>
<p>This output shows that <b>Main</b>'s call to <b>Dial </b>calls the new <b>Dial </b>method defined by <b>BetterPhone.Dial, </b>which in turn calls the virtual <b>EstablishConnection </b>method that is also defined by <b>BetterPhone. </b>When <b>BetterPhone</b>'s <b>EstablishConnection </b>method returns, <b>Phone</b>'s <b>Dial </b>method is called. <b>Phone</b>'s <b>Dial </b>method calls <b>EstablishConnection, </b>but because <b>BetterPhone</b>'s <b>EstablishConnection </b>is marked with <b>new, BetterPhone</b>'s <b>EstablishConnection </b>method isn't considered an override of <b>Phone</b>'s virtual <b>EstablishConnection </b>method. As a result, <b>Phone</b>'s <b>Dial </b>method calls <b>Phone</b>'s <b>EstablishConnection </b>method葉his is the expected behavior.</p>
<hr/>
<blockquote><b>Note </b>If the compiler treated methods as overrides by default (as a native C++ compiler does), the developer of <b>BetterPhone </b>couldn't use the method names <b>Dial </b>and <b>EstablishConnection. </b>This would most likely cause a ripple effect of changes throughout the entire source code base, breaking source and binary compatibility. This type of pervasive change is undesirable, especially in any moderate-to-large project. However, if changing the method name causes only moderate updates in the source code, you should change the name of the methods so the two different meanings of <b>Dial </b>and <b>EstablishConnection </b>don't confuse other developers.</blockquote>
<hr/>
<p>Alternatively, CompanyB could have gotten the new version of CompanyA's <b>Phone </b>type and decided that <b>Phone</b>'s semantics of <b>Dial </b>and <b>EstablishConnection </b>are exactly what it's been looking for. In this case, CompanyB would modify its <b>BetterPhone </b>type by removing its <b>Dial </b>method entirely. In addition, because CompanyB now wants to tell the compiler that <b>BetterPhone</b>'s <b>EstablishConnection </b>method is related to <b>Phone</b>'s <b>EstablishConnection </b>method, the <b>new </b>keyword must be removed. Simply removing the <b>new </b>keyword isn't enough, though, because now the compiler can't tell exactly what the intention is of <b>BetterPhone</b>'s <b>EstablishConnection </b>method. To express his intent exactly, the CompanyB developer must also change <b>BetterPhone</b>'s <b>EstablishConnection </b>method from <b>virtual </b>to <b>override. </b>The following code shows the new version of <b>BetterPhone:</b></p>
<p><code>namespace CompanyB {<br/>
public class BetterPhone : CompanyA.Phone {<br/>
// Delete the Dial method (inherit Dial from base).<br/>
// Remove 'new' and change 'virtual' to 'override' to // mark this method as having a relationship to the base // type's EstablishConnection method. protected override void EstablishConnection() {<br/>
Console.WriteLine(&quot;BetterPhone.EstablishConnection&quot;);<br/>
// Do work to establish the connection.<br/>
}<br/>
}<br/>
}</code></p>
<p>Now when the same application code (in the <b>Main </b>method) executes, the output is as follows:</p>
<p><code>Phone.Dial<br/>
BetterPhone.EstablishConnection</code></p>
<p>This output shows that <b>Main</b>'s call to <b>Dial </b>calls the <b>Dial </b>method defined by <b>Phone </b>and inherited by <b>BetterPhone. </b>Then when <b>Phone</b>'s <b>Dial </b>method calls the virtual <b>EstablishConnection </b>method, <b>BetterPhone</b>'s <b>EstablishConnection </b>method is called because it overrides the virtual <b>EstablishConnection </b>method defined by <b>Phone.</b></p>
<mbp:pagebreak/>
<a name="Chapter7"/>
<h1>Chapter 7: Constants and Fields</h1>
<p><b>In this chapter:</b></p>
<a href="#b181">Constants</a><br/>
<a href="#b183">Fields</a><br/>
<p>In this chapter, I'll show you how to add data members to a type. Specifically, we'll look at constants and fields.</p>
<a name="b181"/><h2>Constants</h2>
<p>A constant is a symbol that has a never-changing value. When defining a constant symbol, its value must be determinable at compile time The compiler then saves the constant's value in the assembly's metadata. This means that you can define a constant only for types that your compiler considers primitive types. In C#, the following types are primitives and can be used to define constants: <b>Boolean, Char, Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal, </b>and <b>String. </b>However, C# also allows you to define a constant variable of a non-primitive type if you set the value to <b>null:</b></p>
<p><code>using System;<br/>
public sealed class SomeType {<br/>
// SomeType is not a primitive type but C# does allow // a constant variable of this type to be set to 'null'. public const SomeType Empty = null;<br/>
}</code></p>
<p>Because a constant value never changes, constants are always considered to be part of the defining type. In other words, constants are always considered to be static members, not instance members. Defining a constant causes the creation of metadata.</p>
<p>When code refers to a constant symbol, compilers look up the symbol in the metadata of the assembly that defines the constant, extract the constant's value, and embed the value in the emitted Intermediate Language (IL) code. Because a constant's value is embedded directly in code, constants don't require any memory to be allocated for them at runtime. In addition, you can't get the address of a constant and you can't pass a constant by reference These constraints also mean that constants don't have a good cross-assembly versioning story, so you should use them only when you know that the value of a symbol will never change.</p>
<p>(Defining <b>MaxInt16 </b>as <b>32767 </b>is a good example.) Let me demonstrate exactly what I mean. First, take the following code and compile it into a DLL assembly:</p>
<p><code>using System;<br/>
public sealed class SomeLibraryType {<br/>
// NOTE: C# doesn't allow you to specify static for constants // because constants are always implicitly static. public const Int32 MaxEntrieslnList = 50;<br/>
}</code></p>
<p>Then use the following code to build an application assembly: using System;</p>
<p><code>public sealed class Program { public static void Main() {<br/>
Console.WriteLine(&quot;Max entries supported in list: &quot; + SomeLibraryType.MaxEntrieslnList);<br/>
}<br/>
}</code></p>
<p>You'll notice that this application code references the <b>MaxEntriesInList </b>constant defined in the <b>SomeLibraryType </b>class. When the compiler builds the application code, it sees that <b>MaxEntriesInList </b>is a constant literal with a value of <b>50 </b>and embeds the <b>Int32 </b>value of <b>50 </b>right inside the application's IL code, as you can see in the IL code shown below In fact, after building the application assembly, the DLL assembly isn't even loaded at runtime and can be deleted from the disk.</p>
<p><code>.method public hidebysig static void   Main() cil managed<br/>
{<br/>
.entrypoint<br/>
// Code size.2 5 (0x19)<br/>
.maxstack 8 IL_0000: nop<br/>
<u>IL_0001:   ldstr</u>_<u>&quot;Max entries supported in list: &quot;</u></code></p>
<p><u>f </u><u>IL_0006:   ldc.i4.s     50 </u><u>I </u>IL_0008:   box [mscorlib]System.Int32</p>
<p><code>IL_000d:   call.string [mscorlib]System.String::Concat(object, object)<br/>
IL_0012:   call.void [mscorlib]System.Console::WriteLine(string)<br/>
IL_0017: nop IL_0018: ret } // end of method Program::Main</code></p>
<p>This example should make the versioning problem obvious to you If the developer changes the <b>MaxEntriesInList </b>constant to <b>1000 </b>and only rebuilds the DLL assembly, the application assembly is not affected. For the application to pick up the new value, it will have to be recompiled as well. You can't use constants if you need to have a value in one assembly picked up by another assembly at runtime (instead of compile time). Instead, you can use <b>readonly </b>fields, which I'll discuss next.</p>
<a name="b183"/><h2>Fields</h2>
<p>A field is a data member that holds an instance of a value type or a reference to a reference type. Table 7-1 shows the modifiers that can be applied to a field.</p>
<p><b>Table 7-1 </b><b>Field Modifiers</b></p>
<table border="1">
<tr>
<td>
<p>m</p>
</td>
<td>
<p><b>C# Term</b></p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>Static</p>
</td>
<td>
<p>c</p>
</td>
<td>
<p>The field is part of the type's state, as opposed to being part of an object's state.</p>
</td>
</tr>
<tr>
<td>
<p>Instance</p>
</td>
<td>
<p>(default)</p>
</td>
<td>
<p>The field is associated with an instance of the type, not the type itself</p>
</td>
</tr>
<tr>
<td>
<p>InitOnly</p>
</td>
<td>
<p>y</p>
</td>
<td>
<p>The field can be written to only by code contained in a constructor method.</p>
</td>
</tr>
<tr>
<td>
<p>Volatile</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>Code that accessed the field is not subject to some thread-unsafe optimizations that may be performed by the compiler, the CLR, or by hardware. Only the following types can be marked <b>volatile: </b>all reference types, <b>Single, Boolean, Byte, SByte, Int16, UInt16, Int32, UInt32, Char, </b>and all enumerated types with an underlying type of <b>Byte, SByte, Int16, UInt16, Int32, </b>or <b>UInt32. </b>Volatile fields are discussed in Chapter 28, &quot;Primitive Thread Synchronization Constructs &quot;</p>
</td>
</tr>
</table>
<p>As Table 7-1 shows, the common language runtime (CLR) supports both type (static) and instance (nonstatic) fields. For type fields, the dynamic memory required to hold the field's data is allocated inside the type object, which is created when the type is loaded into an AppDomain (see Chapter 22, &quot;CLR Hosting and AppDomains&quot;), which typically happens the first time any method that references the type is just-in-time (JIT)-compiled. For instance fields, the dynamic memory to hold the field is allocated when an instance of the type is constructed.</p>
<p>Because fields are stored in dynamic memory, their value can be obtained at runtime only. Fields also solve the versioning problem that exists with constants. In addition, a field can be of any data type, so you don't have to restrict yourself to your compiler's built-in primitive types (as you do for constants).</p>
<p>The CLR supports <b>readonly </b>fields and <b>read/write </b>fields. Most fields are <b>read/write </b>fields, meaning the field's value might change multiple times as the code executes. However, <b>readonly </b>fields can be written to only within a constructor method (which is called only once, when an object is first created). Compilers and verification ensure that <b>readonly </b>fields are not written to by any method other than a constructor. Note that reflection can be used to modify a <b>readonly </b>field.</p>
<p>Let's take the example from the &quot;Constants&quot; section and fix the versioning problem by using a static <b>readonly </b>field. Here's the new version of the DLL assembly's code:</p>
<p><code>using System;<br/>
public sealed class SomeLibraryType {<br/>
// The static is required to associate the field with the type. public static readonly Int32 MaxEntriesInList = 50;<br/>
}</code></p>
<p>This is the only change you have to make; the application code doesn't have to change at all, although you must rebuild it to see the new behavior. Now when the application's <b>Main </b>method runs, the CLR will load the DLL assembly (so this assembly is now required at run time) and grab the value of the <b>MaxEntriesInList </b>field out of the dynamic memory allocated for it. Of course, the value will be <b>50.</b></p>
<p>Let's say that the developer of the DLL assembly changes the <b>50 </b>to <b>1000 </b>and rebuilds the assembly. When the application code is re-executed, it will automatically pick up the new value: <b>1000. </b>In this case, the application code doesn't have to be rebuilt擁t just works (although its performance is adversely affected). A caveat: this scenario assumes that the new version of the DLL assembly is not strongly named and the versioning policy of the application is such that the CLR loads this new version.</p>
<p>The following example shows how to define a <b>readonly </b>static field that is associated with the type itself, as well as <b>read/write </b>static fields and <b>readonly </b>and <b>read/write </b>instance fields, as shown here:</p>
<p><code>public sealed class SomeType {<br/>
// This is a static read-only field; its value is calculated and // stored in memory when this class is initialized at run time. public static readonly Random s_random = new Random();<br/>
// This is a static read/write field. private static Int32 s_numberOfWrites = 0;<br/>
// This is an instance read-only field. public readonly String Pathname = &quot;Untitled&quot;;<br/>
// This is an instance read/write field. private System.IO.FileStream m_fs;<br/>
public SomeType(String pathname) {<br/>
// This line changes a read-only field.<br/>
// This is OK because the code is in a constructor.<br/>
this.Pathname = pathname;<br/>
}<br/>
public String DoSomething() {<br/>
// This line reads and writes to the static read/write field. s_numberOfWrites = s_numberOfWrites + l;<br/>
// This line reads the read-only instance field. return Pathname;<br/>
}<br/>
}</code></p>
<p>In this code, many of the fields are initialized inline. C# allows you to use this convenient inline initialization syntax to initialize a class's constants and <b>read/write </b>and <b>readonly </b>fields. As you'll see in Chapter 8, &quot;Methods,&quot; C# treats initializing a field inline as shorthand syntax for initializing the field in a constructor. Also, in C#, there are some performance issues to consider when initializing fields by using inline syntax versus assignment syntax in a constructor. These performance issues are discussed in Chapter 8 as well.</p>
<hr/>
<blockquote><b>Important </b>When a field is of a reference type and the field is marked as readonly, it is the reference that is immutable, not the object that the field refers to. The following code demonstrates:</blockquote>
<hr/>
<p><code>public sealed class AType {<br/>
// InvalidChars must always refer to the same array object<br/>
public static readonly Char[] InvalidChars = new Char[] { 'A',  'B',  'C' };<br/>
}<br/>
public sealed class AnotherType { public static void M() {<br/>
// The lines below are legal, compile, and successfully // change the characters in the InvalidChars array AType.InvalidChars[0] = 'X'; AType.InvalidChars[l] = 'Y'; AType.InvalidChars[2] = 'Z';<br/>
// The line below is illegal and will not compile because // what InvalidChars refers to cannot be changed AType.InvalidChars = new Char[] { 'X',  'Y',  'Z' };<br/>
}<br/>
}</code></p>
<mbp:pagebreak/>
<a name="Chapter8"/>
<h1>Chapter 8: Methods</h1>
<p><b>In this chapter:</b></p>
<a href="#b187">Instance Constructors and Classes (Reference Types)</a><br/>
<a href="#b191">Instance Constructors and Structures (Value Types)</a><br/>
<a href="#b194">Type Constructors</a><br/>
<a href="#b200">Operator Overload Methods</a><br/>
<a href="#b204">Conversion Operator Methods</a><br/>
<a href="#b207">Extension Methods</a><br/>
<a href="#b213">Partial Methods</a><br/>
<p>This chapter focuses on the various kinds of methods that you'll run into, including instance constructors and type constructors, as well as how to define methods to overload operators and type conversions (for implicit and explicit casting). We'll also talk about extension methods, which allow you to logically add your own instance methods to already existing types, and partial methods, which allow you to spread a type's implementation into multiple parts.</p>
<a name="b187"/><h2>Instance Constructors and Classes (Reference Types)</h2>
<p>Constructors are special methods that allow an instance of a type to be initialized to a good state. Constructor methods are always called <b>.ctor </b>(for constructor) in a method definition metadata table. When creating an instance of a reference type, memory is allocated for the instance's data fields, the object's overhead fields (type object pointer and sync block index) are initialized, and then the type's instance constructor is called to set the initial state of the object.</p>
<p>When constructing a reference type object, the memory allocated for the object is always zeroed out before the type's instance constructor is called. Any fields that the constructor doesn't explicitly overwrite are guaranteed to have a value of <b>0 </b>or <b>null.</b></p>
<p>Unlike other methods, instance constructors are never inherited. That is, a class has only the instance constructors that the class itself defines. Since instance constructors are never inherited, you cannot apply the following modifiers to an instance constructor: <b>virtual, new, override, sealed, </b>or <b>abstract </b>. If you define a class that does not explicitly define any constructors, the C# compiler defines a default (parameterless) constructor for you whose implementation simply calls the base class's parameterless constructor.</p>
<p>For example, if you define the following class:</p>
<p><code>public class SomeType {<br/>
}</code></p>
<p>it is as though you wrote the code like this:</p>
<p><code>public class SomeType {<br/>
public SomeType() : base() { }<br/>
}</code></p>
<p>If the class is <b>abstract, </b>the compiler-produced default constructor has <b>protected </b>accessibility; otherwise, the constructor is given <b>public </b>accessibility. If the base class doesn't offer a parameterless constructor, the derived class must explicitly call a base class constructor or the compiler will issue an error. If the class is <b>static (sealed </b>and <b>abstract), </b>the compiler will not emit a default constructor at all into the class definition.</p>
<p>A type can define several instance constructors. Each constructor must have a different signature, and each can have different accessibility. For verifiable code, a class's instance constructor must call its base class's constructor before accessing any of the inherited fields of the base class The C# compiler will generate a call to the default base class's constructor automatically if the derived class's constructor does not explicitly invoke one of the base class's constructors. Ultimately, <b>System.Object</b>'s public, parameterless constructor gets called. This constructor does nothing擁t simply returns. This is because <b>System.Object </b>defines no instance data fields, and therefore its constructor has nothing to do.</p>
<p>In a few situations, an instance of a type can be created without an instance constructor being called. In particular, calling <b>Object</b>'s <b>MemberwiseClone </b>method allocates memory, initializes the object's overhead fields, and then copies the source object's bytes to the new object. Also, a constructor is usually not called when deserializing an object with the runtime serializer. The deserialization code allocates memory for the object without calling a constructor using the <b>System.Runtime.Serialization.FormatterServices </b>type's <b>GetUninitializedObject </b>or <b>GetSafeUninitializedObject </b>methods (as discussed in Chapter 24, &quot;Runtime Serialization&quot;).</p>
<hr/>
<blockquote><b>Important </b>You should not call any virtual methods within a constructor that can affect the object being constructed. The reason is if the virtual method is overridden in the type being instantiated, the derived type's implementation of the overridden method will execute, but all of the fields in the hierarchy have not been fully initialized. Calling a virtual method would therefore result in unpredictable behavior.</blockquote>
<hr/>
<p>C# offers a simple syntax that allows the initialization of fields defined within a reference type when an instance of the type is constructed:</p>
<p><code>internal sealed class SomeType { private Int32 m_x = 5;<br/>
}</code></p>
<p>When a <b>SomeType </b>object is constructed, its <b>m_x </b>field will be initialized to <b>5. </b>How does this happen? Well, if you examine the Intermediate Language (IL) for <b>SomeType</b>'s constructor method (also called <b>.ctor), </b>you'll see the code shown here:</p>
<p><code>.method public hidebysig specialname rtspecialname instance void  .ctor() cil managed<br/>
{<br/>
// Code size.l4 (0xe)<br/>
.maxstack 8 IL_0000: ldarg.0 IL_000l: ldc.i4.5<br/>
IL_0002:   stfld       int32 SomeType::m_x IL_0007: ldarg.0<br/>
IL_0008:   call.instance void [mscorlib]System.Object::.ctor()<br/>
IL_000d: ret } // end of method SomeType::.ctor</code></p>
<p>In this code, you see that <b>SomeType</b>'s constructor contains code to store a <b>5 </b>into <b>m_x </b>and then calls the base class's constructor In other words, the C# compiler allows the convenient syntax that lets you initialize the instance fields inline and translates this to code in the constructor method to perform the initialization. This means that you should be aware of code explosion, as illustrated by the following class definition:</p>
<p><code>internal sealed class SomeType { private Int32   m_x = 5; private String m_s = &quot;Hi there&quot;; private Double m_d = 3.14159; private Byte m_b;<br/>
// Here are some constructors.<br/>
public SomeType(){... }<br/>
public SomeType(Int32 x)   {... }<br/>
public SomeType(String s) {.m_d = 10; }<br/>
}</code></p>
<p>When the compiler generates code for the three constructor methods, the beginning of each method includes the code to initialize <b>m_x, m_s, </b>and <b>m_d </b>After this initialization code, the compiler inserts a call to the base class's constructor, and then the compiler appends to the method the code that appears in the constructor methods For example, the code generated for the constructor that takes a <b>String </b>parameter includes the code to initialize <b>m_x, m_s, </b>and <b>m_d, </b>call the base class's <b>(Object</b>'s) constructor, and then overwrite <b>m_d </b>with the value <b>10. </b>Note that <b>m_b </b>is guaranteed to be initialized to <b>0 </b>even though no code exists to explicitly initialize it.</p>
<hr/>
<blockquote><b>Note </b>The compiler initializes any fields using the convenient syntax before calling a base class's constructor to maintain the impression that these fields always have a value as the source code appearance dictates The potential problem occurs when a base class's constructor invokes a virtual method that calls back into a method defined by the derived class. If this happens, the fields initialized using the convenient syntax have been initialized before the virtual method is called.</blockquote>
<hr/>
<p>Because there are three constructors in the preceding class, the compiler generates the code to initialize <b>m_x, m_s, </b>and <b>m_d </b>three times熔nce per constructor If you have several initialized instance fields and a lot of overloaded constructor methods, you should consider defining the fields without the initialization, creating a single constructor that performs the common initialization, and having each constructor explicitly call the common initialization constructor. This approach will reduce the size of the generated code. Here is an example using C#'s ability to explicitly have a constructor call another constructor by using the <b>this </b>keyword:</p>
<p><code>internal sealed class SomeType {<br/>
// Do not explicitly initialize the fields here private Int32 m_x; private String m_s; private Double m_d; private Byte m_b;<br/>
// This constructor sets all fields to their default. // All of the other constructors explicitly invoke this constructor. public SomeType() { m_x = 5;<br/>
m_s = &quot;Hi there&quot;; m_d = 3.l4l59; m_b = 0xff;<br/>
}<br/>
// This constructor sets all fields to their default, then changes m_x. public SomeType(Int32 x) : this() { m_x = x;<br/>
}<br/>
// This constructor sets all fields to their default, then changes m_s. public SomeType(String s) : this() {<br/>
m_s = s;<br/>
}<br/>
// This constructor sets all fields to their default, then changes m_x &amp; m_s. public SomeType(Int32 x, String s) : this() {<br/>
m_x = x;<br/>
m_s = s;<br/>
}<br/>
}</code></p>
<a name="b191"/><h2>Instance Constructors and Structures (Value Types)</h2>
<p>Value type <b>(struct) </b>constructors work quite differently from reference type <b>(class) </b>constructors. The common language runtime (CLR) always allows the creation of value type instances, and there is no way to prevent a value type from being instantiated For this reason, value types don't actually even need to have a constructor defined within them, and the C# compiler doesn't emit default parameterless constructors for value types. Examine the following code:</p>
<p><code>internal struct Point { public Int32 m_x, m_y;<br/>
}<br/>
internal sealed class Rectangle {<br/>
public Point m_topLeft, m_bottomRight;<br/>
}</code></p>
<p>To construct a <b>Rectangle, </b>the <b>new </b>operator must be used, and a constructor must be specified. In this case, the default constructor automatically generated by the C# compiler is called. When memory is allocated for the <b>Rectangle, </b>the memory includes the two instances of the <b>Point </b>value type. For performance reasons, the CLR doesn't attempt to call a constructor for each value type field contained within the reference type. But as I mentioned earlier, the fields of the value types are initialized to <b>0/null.</b></p>
<p>The CLR does allow you to define constructors on value types. The only way that these constructors will execute is if you write code to explicitly call one of them, as in <b>Rectangle</b>'s constructor, shown here:</p>
<p><code>internal struct Point { public Int32 m_x, m_y;<br/>
public Point(Int32 x, Int32 y) { m_x = x; m_y = y;<br/>
}<br/>
}<br/>
internal sealed class Rectangle {<br/>
public Point m_topLeft, m_bottomRight;<br/>
public Rectangle() {<br/>
// In C#, new on a value type calls the constructor to // initialize the value type's fields. m_topLeft        = new Point(1, 2); m_bottomRight = new Point(100, 200);<br/>
}<br/>
}</code></p>
<p>A value type's instance constructor is executed only when explicitly called. So if <b>Rectangle</b>'s constructor didn't initialize its <b>m_topLeft </b>and <b>m_bottomRight </b>fields by using the <b>new </b>operator to call <b>Point</b>'s constructor, the <b>m_x </b>and <b>m_y </b>fields in both <b>Point </b>fields would be <b>0 </b>.</p>
<p>In the <b>Point </b>value type defined earlier, no default parameterless constructor is defined. However, let's rewrite that code as follows:</p>
<p><code>internal struct Point { public Int32 m_x, m_y;<br/>
public Point() {<br/>
m_x = m_y = 5;<br/>
}<br/>
}<br/>
internal sealed class Rectangle {<br/>
public Point m_topLeft, m_bottomRight;<br/>
public Rectangle() { }<br/>
}</code></p>
<p>Now when a new <b>Rectangle </b>is constructed, what do you think the <b>m_x </b>and <b>m_y </b>fields in the two <b>Point </b>fields, <b>m_topLeft </b>and <b>m_bottomRight, </b>would be initialized to: <b>0 </b>or <b>5? </b>(Hint: This is a trick question.</p>
<p>Many developers (especially those with a C++ background) would expect the C# compiler to emit code in <b>Rectangle</b>'s constructor that automatically calls <b>Point</b>'s default parameterless constructor for the <b>Rectangle</b>'s two fields. However, to improve the runtime performance of the application, the C# compiler doesn't automatically emit this code. In fact, many compilers will never emit code to call a value type's default constructor automatically, even if the value type offers a parameterless constructor To have a value type's parameterless constructor execute, the developer must add explicit code to call a value type's constructor.</p>
<p>Based on the information in the preceding paragraph, you should expect the <b>m_x </b>and <b>m_y </b>fields in <b>Rectangle</b>'s two <b>Point </b>fields to be initialized to <b>0 </b>in the code shown earlier because there are no explicit calls to <b>Point</b>'s constructor anywhere in the code.</p>
<p>However, I did say that my original question was a trick question. The trick part is that C# doesn't allow a value type to define a parameterless constructor. So the previous code won't actually compile. The C# compiler produces the following message when attempting to compile that code: <b>&quot;error CS0568: Structs cannot contain explicit parameterless constructors.&quot;</b></p>
<p>C# purposely disallows value types from defining parameterless constructors to remove any confusion a developer might have about when that constructor gets called If the constructor can't be defined, the compiler can never generate code to call it automatically. Without a parameterless constructor, a value type's fields are always initialized to <b>0/null.</b></p>
<hr/>
<blockquote><b>Note </b>Strictly speaking, value type fields are guaranteed to be <b>0/null </b>when the value type is a field nested within a reference type. However, stack-based value type fields are not guaranteed to be <b>0/null</b>. For verifiability, any stack-based value type field must be written to prior to being read. If code could read a value type's field prior to writing to the field, a security breach is possible. C# and other compilers that produce verifiable code ensure that all stack-based value types have their fields zeroed out or at least written to before being read so that a verification exception won't be thrown at run time For the most part, this means that you can assume that your value types have their fields initialized to <b>0, </b>and you can completely ignore everything in this note.</blockquote>
<hr/>
<p>Keep in mind that although C# doesn't allow value types with parameterless constructors, the CLR does. So if the unobvious behavior described earlier doesn't bother you, you can use another programming language (such as IL assembly language) to define your value type with a parameterless constructor.</p>
<p>Because C# doesn't allow value types with parameterless constructors, compiling the following type produces the following message: <b>&quot;error CS0573:  'SomeValType.m_x': cannot have instance field initializers in structs.&quot;</b></p>
<p><code>internal struct SomeValType {<br/>
// You cannot do inline instance field initialization in a value type private Int32 m_x = 5;<br/>
}</code></p>
<p>In addition, because verifiable code requires that every field of a value type be written to prior to any field being read, any constructors that you do have for a value type must initialize all of the type's fields. The following type defines a constructor for the value type but fails to initialize all of the fields:</p>
<p><code>internal struct SomeValType { private Int32 m_x, m_y;<br/>
// C# allows value types to have constructors that take parameters. public SomeValType(Int32 x) { m_x = x;<br/>
// Notice that m_y is not initialized here.<br/>
}<br/>
}</code></p>
<p>When compiling this type, the C# compiler produces the following message: <b>&quot;error CS0171: Field 'SomeValType.m_y' must be fully assigned before control leaves the constructor.&quot; </b>To fix the problem, assign a value (usually <b>0) </b>to <b>y </b>in the constructor.</p>
<p>As an alternative way to initialize all the fields of a value type, you can actually do this:</p>
<p><code>// C# allows value types to have constructors that take parameters. public SomeValType(Int32 x) {<br/>
// Looks strange but compiles fine and initializes all fields to 0/null<br/>
this = new SomeValType();<br/>
m_x = x; // Overwrite m_x's 0 with x<br/>
// Notice that m_y was initialized to 0.<br/>
}</code></p>
<p>In a value type's constructor, <b>this </b>represents an instance of the value type itself and you can actually assign to it the result of <b>new</b>ing up an instance of the value type, which really just zeroes out all the fields. In a reference type's constructor, <b>this </b>is considered read-only and so you cannot assign to it at all.</p>
<a name="b194"/><h2>Type Constructors</h2>
<p>In addition to instance constructors, the CLR also supports type constructors (also known as static constructors, class constructors, or type initializers). A type constructor can be applied to interfaces (although C# doesn't allow this), reference types, and value types. Just as instance constructors are used to set the initial state of an instance of a type, type constructors are used to set the initial state of a type. By default, types don't have a type constructor defined within them. If a type has a type constructor, it can have no more than one. In addition, type constructors never have parameters. In C#, here's how to define a reference type and a value type that have type constructors:</p>
<p><code>internal sealed class SomeRefType { static SomeRefTypeO {<br/>
// This executes the first time a SomeRefType is accessed.<br/>
}<br/>
}<br/>
internal struct SomeValType {<br/>
// C# does allow value types to define parameterless type constructors. static SomeValType() {<br/>
// This executes the first time a SomeValType is accessed.<br/>
}<br/>
}</code></p>
<p>You'll notice that you define type constructors just as you would parameterless instance constructors, except that you must mark them as <b>static </b>Also, type constructors should always be private; C# makes them <b>private </b>for you automatically. In fact, if you explicitly mark a type constructor as <b>private </b>(or anything else) in your source code, the C# compiler issues the following error: <b>&quot;error CS0515:  'SomeValType.SomeValType</b>O': <b>access modifiers are not allowed on static constructors.&quot; </b>Type constructors should be private to prevent any developer-written code from calling them; the CLR is always capable of calling a type constructor.</p>
<hr/>
<blockquote><b>Important </b>While you can define a type constructor within a value type, you should never actually do this because there are times when the CLR will not call a value type's static type constructor. Here is an example:</blockquote>
<hr/>
<p><code>internal struct SomeValType { static SomeValType() {<br/>
Console.WriteLine(&quot;This never gets displayed&quot;);<br/>
}<br/>
public Int32 m_x;<br/>
}<br/>
public sealed class Program { public static void Main() {<br/>
SomeValType[] a = new SomeValType[l0]; a[0].m_x = l23;<br/>
Console.WriteLine(a[0].m_x);     // Displays l23<br/>
}<br/>
}</code></p>
<p>The calling of a type constructor is a tricky thing. When the just-in-time (JIT) compiler is compiling a method, it sees what types are referenced in the code. If any of the types define a type constructor, the JIT compiler checks if the type's type constructor has already been executed for this AppDomain. If the constructor has never executed, the JIT compiler emits a call to the type constructor into the native code that the JIT compiler is emitting. If the type constructor for the type has already executed, the JIT compiler does not emit the call since it knows that the type is already initialized. (For an example of this, see the &quot;Type Constructor Performance&quot; section later in this chapter.)</p>
<p>Now, after the method has been JIT-compiled, the thread starts to execute it and will eventually get to the code that calls the type constructor. In fact, it is possible that multiple threads will be executing the same method concurrently. The CLR wants to ensure that a type's constructor executes only once per AppDomain. To guarantee this, when a type constructor is called, the calling thread acquires a mutually exclusive thread synchronization lock. So if multiple threads attempt to simultaneously call a type's static constructor, only one thread will acquire the lock and the other threads will block. The first thread will execute the code in the static constructor. After the first thread leaves the constructor, the waiting threads will wake up and will see that the constructor's code has already been executed. These threads will not execute the code again; they will simply return from the constructor method. In addition, if any of these methods ever get called again, the CLR knows that the type constructor has already executed and will ensure that the constructor is not called again.</p>
<hr/>
<blockquote><b>Note </b>Since the CLR guarantees that a type constructor executes only once per AppDomain and is thread-safe, a type constructor is a great place to initialize any singleton objects required by the type.</blockquote>
<hr/>
<p>Within a single thread, there is a potential problem that can occur if two type constructors contain code that reference each other For example, ClassA has a type constructor containing code that references ClassB, and ClassB has a type constructor containing code that references ClassA In this situation, the CLR still guarantees that each type constructor's code executes only once; however, it cannot guarantee that ClassA's type constructor code has run to completion before executing ClassB's type constructor. You should certainly try to avoid writing code that sets up this scenario. In fact, since the CLR is responsible for calling type constructors, you should always avoid writing any code that requires type constructors to be called in a specific order.</p>
<p>Finally, if a type constructor throws an unhandled exception, the CLR considers the type to be unusable. Attempting to access any fields or methods of the type will cause a <b>System.TypeInitializationException </b>to be thrown.</p>
<p>The code in a type constructor has access only to a type's static fields, and its usual purpose is to initialize those fields. As it does with instance fields, C# offers a simple syntax that allows you to initialize a type's static fields:</p>
<p><code>internal sealed class SomeType { private static Int32 s_x = 5;<br/>
}</code></p>
<hr/>
<blockquote><b>Note </b>While C# doesn't allow a value type to use inline field initialization syntax for instance fields, it does allow you to use it for static fields. In other words, if you change the <b>SomeType </b>type above from a <b>class </b>to a <b>struct, </b>the code will compile and work as expected.</blockquote>
<hr/>
<p>When this code is built, the compiler automatically generates a type constructor for <b>SomeType. </b>It's as if the source code had originally been written as follows:</p>
<p><code>internal sealed class SomeType { private static Int32 s_x; static SomeType() { s_x = 5; }<br/>
}</code></p>
<p>Using ILDasm.exe, it's easy to verify what the compiler actually produced by examining the IL for the type constructor. Type constructor methods are always called <b>.cctor </b>(for class constructor) in a method definition metadata table.</p>
<p>In the code below, you see that the <b>.cctor </b>method is <b>private </b>and <b>static </b>. In addition, notice that the code in the method does in fact load a <b>5 </b>into the static field <b>s_x </b>.</p>
<p><code>.method private hidebysig specialname rtspecialname static void  .cctor() cil managed<br/>
{<br/>
// Code size.7 (0x7)<br/>
.maxstack 8 IL_0000: ldc.i4.5<br/>
IL_0001:   stsfld        int32 SomeType::s_x IL_0006: ret } // end of method SomeType::.cctor</code></p>
<p>Type constructors shouldn't call a base type's type constructor. Such a call isn't necessary because none of a type's static fields is shared or inherited from its base type.</p>
<hr/>
<blockquote><b>Note </b>Some languages, such as Java, expect that accessing a type causes its type constructor and all of its base type's type constructors to be called. In addition, interfaces implemented by the types must also have their type constructors called. The CLR doesn't offer this behavior. However, the CLR does offer compilers and developers the ability to provide this behavior via the <b>RunClassConstructor </b>method offered by the <b>System.Runtime.CompilerServices.RuntimeHelpers </b>type. Any language that requires this behavior would have its compiler emit code into a type's type constructor that calls this method for all base types When using the <b>RunClassConstructor </b>method to call a type constructor, the CLR knows if the type constructor has executed previously and, if it has, the CLR won't call it again.</blockquote>
<hr/>
<p>Finally, assume that you have this code:</p>
<p><code>internal sealed class SomeType { private static Int32 s_x = 5;<br/>
static SomeType() { s_x = 10;<br/>
}<br/>
}</code></p>
<p>In this case, the C# compiler generates a single type constructor method This constructor first initializes <b>s_x </b>to <b>5 </b>and then initializes <b>s_x </b>to <b>10. </b>In other words, when the C# compiler generates IL code for the type constructor, it first emits the code required to initialize the static fields followed by the explicit code contained in your type constructor method.</p>
<p>I-[-</p>
<hr/>
<blockquote><b>Important </b>Developers occasionally ask me if there's a way to get some code to execute when a type is unloaded. You should first know that types are unloaded only when the AppDomain unloads. When the AppDomain unloads, the object that identifies the type becomes unreachable, and the garbage collector reclaims the type object's memory. This behavior leads many developers to believe that they could add a static <b>Finalize </b>method to the type, which will automatically get called when the type is unloaded Unfortunately, the CLR doesn't support static <b>Finalize </b>methods All is not lost, however If you want some code to execute when an AppDomain unloads, you can register a callback method with the <b>System.AppDomain </b>type's <b>DomainUnload </b>event.</blockquote>
<hr/>
<h3>Type Constructor Performance</h3>
<p>In the previous section, I mentioned that calling a type constructor is a tricky thing. And I explained some of the trickiness about it: the JIT compiler has to decide whether to emit the code to call it, and the CLR ensures that calls to it are thread-safe. As it turns out, this is the just the beginning of the tricky stuff. There is more about this that is performance-related.</p>
<p>As discussed already, when compiling a method, the JIT compiler determines whether it must emit a call to execute a type constructor into the method. If the JIT compiler decides to emit the call, it must decide where it should emit the call There are two possibilities here:</p>
<p>&#9632; The JIT compiler can emit the call immediately before code that would create the first instance of the type or immediately before code that accesses a noninherited field or member of the class. This is called precise semantics because the CLR will call the type constructor at precisely the right time.</p>
<p>&#9632; The JIT compiler can emit the call sometime before code first accesses a static field or a static or instance method, or invokes an instance constructor. This is called before-field-init semantics because the CLR guarantees only that the static constructor will run some time before the member is accessed; it could run much earlier.</p>
<p>The before-field-init semantics is preferred since it gives the CLR a lot of freedom as to when it can call the type constructor, and the CLR takes advantage of this whenever possible to produce code that executes faster For example, the CLR might pick different times to call the type constructor based on whether the type is loaded in an AppDomain or loaded domain-neutral or whether the code is being JIT-compiled or NGen'd.</p>
<p>By default, language compilers choose which of these semantics makes the most sense for the type you're defining and informs the CLR of this choice by setting the <b>beforefieldinit </b>flag in the row of the type definition metadata table. In this section, I'll focus on what the C# compiler does and how this impacts performance. Let's start by examining the following code:</p>
<p><code>using System;<br/>
using System.Diagnostics;<br/>
///////////////////////////////////////////////////////////////////////////////<br/>
// Since this class doesn't explicitly define a type constructor, // C# marks the type definition with BeforeFieldInit in the metadata. internal sealed class BeforeFieldInit { public static Int32 s_x = 123;<br/>
}<br/>
// Since this class does explicitly define a type constructor, // C# doesn't mark the type definition with BeforeFieldInit in the metadata. internal sealed class Precise { public static Int32 s_x;<br/>
static Precise() { s_x = l23; }<br/>
}<br/>
///////////////////////////////////////////////////////////////////////////////<br/>
public sealed class Program { public static void Main() {<br/>
const Int32 iterations = l000 * l000 * l000;<br/>
PerfTestl(iterations);<br/>
PerfTest2(iterations);<br/>
}<br/>
// When this method is JIT compiled, the type constructors for // the BeforeFieldInit and Precise classes HAVE NOT executed yet // and therefore, calls to these constructors are embedded in // this method's code, making it run slower private static void PerfTestl(Int32 iterations) { Stopwatch sw = Stopwatch.StartNew(); for (Int32 x = 0; x &lt; iterations; x++) {<br/>
// The JIT compiler hoists the code to call BeforeFieldInit's // type constructor so that it executes before the loop starts BeforeFieldInit.s_x = l;<br/>
}<br/>
Console.WriteLine(&quot;PerfTestl: {0} BeforeFieldInit&quot;, sw.Elapsed);<br/>
sw = Stopwatch.StartNew();<br/>
for (Int32 x = 0; x &lt; iterations; x++) {<br/>
// The JIT compiler emits the code to call Precise's // type constructor here so that it checks whether it // has to call the constructor with each loop iteration Precise.s_x = l;<br/>
}<br/>
Console.WriteLine(&quot;PerfTestl: {0} Precise&quot;, sw.Elapsed);<br/>
}<br/>
// When this method is JIT compiled, the type constructors for<br/>
// the BeforeFieldInit and Precise classes HAVE executed<br/>
// and therefore, calls to these constructors are NOT embedded<br/>
// in this method's code, making it run faster<br/>
private static void PerfTest2(Int32 iterations) {<br/>
Stopwatch sw = Stopwatch.StartNew();<br/>
for (Int32 x = 0; x &lt; iterations; x++) { BeforeFieldInit.s_x = l;<br/>
}<br/>
Console.WriteLine(&quot;PerfTest2: {0} BeforeFieldInit&quot;, sw.Elapsed);<br/>
sw = Stopwatch.StartNew(); for (Int32 x = 0; x &lt; iterations; x++) { Precise.s_x = l;<br/>
}<br/>
Console.WriteLine(&quot;PerfTest2: {0} Precise&quot;, sw.Elapsed);<br/>
}<br/>
}<br/>
////////////////////////////// End of File ////////////////////////////////////</code></p>
<p>When I build and run the code above, I get the following output:</p>
<p><code>PerfTest1: 00:00:01.9619358 BeforeFieldInit PerfTest1: 00:00:06.2374912 Precise PerfTest2: 00:00:03.1576608 BeforeFieldInit PerfTest2: 00:00:03.1557822 Precise</code></p>
<p>When the C# compiler sees a class with static fields that use inline initialization (the <b>BeforeFieldInit </b>class), the compiler emits the class's type definition table entry with the <b>BeforeFieldInit </b>metadata flag. When the C# compiler sees a class with an explicit type constructor (the <b>Precise </b>class), the compiler emits the class's type definition table entry without the <b>BeforeFieldInit </b>metadata flag. The rationale behind this is as follows: initialization of static fields needs to be done before the fields are accessed, whereas an explicit type constructor can contain arbitrary code that can have observable side effects; this code may need to run at a precise time.</p>
<p>As you can see from the output, this decision comes with a huge performance impact. When <b>PerfTest1 </b>runs, the top loop executes in about 1. 96 seconds versus the bottom loop, which took about 6. 24 seconds to run葉he bottom loop took about 3 times longer to execute. When <b>PerfTest2 </b>runs, the times are much closer in value because the JIT compiler knew that the types' constructors were already called, and therefore the native code doesn't contain any calls to the type constructor methods.</p>
<p>It would be nice if C# gave programmers the ability to set the <b>BeforeFieldInit </b>flag explicitly in their source code instead of the compiler making this decision based on whether a type constructor is created implicitly or explicitly This way, developers would have more direct control over the performance and semantics of their code.</p>
<a name="b200"/><h2>Operator Overload Methods</h2>
<p>Some programming languages allow a type to define how operators should manipulate instances of the type. For example, a lot of types (such as <b>System.String, System.Decimal, </b>and <b>System.DateTime) </b>overload the equality (<b>==</b>) and inequality (<b>!=</b>) operators. The CLR doesn't know anything about operator overloading because it doesn't even know what an operator is. Your programming language defines what each operator symbol means and what code should be generated when these special symbols appear.</p>
<p>For example, in C#, applying the <b>+ </b>symbol to primitive numbers causes the compiler to generate code that adds the two numbers together. When the <b>+ </b>symbol is applied to <b>String </b>objects, the C# compiler generates code that concatenates the two strings together. For inequality, C# uses the <b>!= </b>symbol, while Microsoft Visual Basic uses the <b>&lt;&gt; </b>symbol. Finally, the <b>a </b>symbol means exclusive OR (XOR) in C#, but it means exponent in Visual Basic.</p>
<p>Although the CLR doesn't know anything about operators, it does specify how languages should expose operator overloads so that they can be readily consumed by code written in a different programming language. Each programming language gets to decide for itself whether it will support operator overloads, and if it does, the syntax for expressing and using them. As far as the CLR is concerned, operator overloads are simply methods.</p>
<p>Your choice of programming language determines whether or not you get the support of operator overloading and what the syntax looks like When you compile your source code, the compiler produces a method that identifies the behavior of the operator. The CLR specification mandates that operator overload methods be <b>public </b>and <b>static </b>methods. In addition, C# (and many other languages) requires that at least one of the operator method's parameters must be the same as the type that the operator method is defined within. The reason for this restriction is that it enables the C# compiler to search for a possible operator method to bind to in a reasonable amount of time.</p>
<p>Here is an example of an operator overload method defined in a C# class definition:</p>
<p><code>public sealed class Complex {<br/>
public static Complex operator+(Complex c1, Complex c2) {... }<br/>
}</code></p>
<p>The compiler emits a metadata method definition entry for a method called <b>op_Addition; </b>the method definition entry also has the <b>specialname </b>flag set, indicating that this is a &quot;special&quot; method. When language compilers (including the C# compiler) see a <b>+ </b>operator specified in source code, they look to see if one of the operand's types defines a <b>specialname </b>method called <b>op_Addition </b>whose parameters are compatible with the operand's types. If this method exists, the compiler emits code to call this method. If no such method exists, a compilation error occurs.</p>
<p>Tables 8-1 and 8-2 show the set of unary and binary operators that C# supports being overloaded, their symbols, and the corresponding Common Language Specification (CLS) method name that the compiler emits. I'll explain the tables' third columns in the next section.</p>
<p><b>Table 8-1 </b><b>C# unary Operators and Their CLS-Compliant Method Names</b></p>
<table border="1">
<tr>
<td>
<p><b>C# Operator Symbol</b></p>
</td>
<td>
<p>e</p>
</td>
<td>
<p><b>Suggested CLS-Compliant Method Name</b></p>
</td>
</tr>
<tr>
<td>
<p><b>+</b></p>
</td>
<td>
<p>s</p>
</td>
<td>
<p>s</p>
</td>
</tr>
<tr>
<td>
<p><b>-</b></p>
</td>
<td>
<p>n</p>
</td>
<td>
<p>e</p>
</td>
</tr>
<tr>
<td>
<p><b>!</b></p>
</td>
<td>
<p>t</p>
</td>
<td>
<p>t</p>
</td>
</tr>
<tr>
<td>
<p><b>~</b></p>
</td>
<td>
<p>t</p>
</td>
<td>
<p>t</p>
</td>
</tr>
<tr>
<td>
<p><b>++</b></p>
</td>
<td>
<p>t</p>
</td>
<td>
<p>t</p>
</td>
</tr>
<tr>
<td>
<p></p>
</td>
<td>
<p>t</p>
</td>
<td>
<p>t</p>
</td>
</tr>
<tr>
<td>
<p><b>(none)</b></p>
</td>
<td>
<p>e</p>
</td>
<td>
<p><b>IsTrue { get; }</b></p>
</td>
</tr>
<tr>
<td>
<p><b>(none)</b></p>
</td>
<td>
<p>e</p>
</td>
<td>
<p><b>IsFalse { get; }</b></p>
</td>
</tr>
</table>
<p><b>Table 8-2 </b><b>C# Binary Operators and Their CLS-Compliant Method Names</b></p>
<table border="1">
<tr>
<td>
<p><b>C# Operator Symbol</b></p>
</td>
<td>
<p>e</p>
</td>
<td>
<p><b>Suggested CLS-Compliant Method Name</b></p>
</td>
</tr>
<tr>
<td>
<p><b>+</b></p>
</td>
<td>
<p>n</p>
</td>
<td>
<p>d</p>
</td>
</tr>
<tr>
<td>
<p><b>-</b></p>
</td>
<td>
<p>n</p>
</td>
<td>
<p>t</p>
</td>
</tr>
<tr>
<td>
<p></p>
</td>
<td>
<p>y</p>
</td>
<td>
<p>y</p>
</td>
</tr>
<tr>
<td>
<p><b>/</b></p>
</td>
<td>
<p>n</p>
</td>
<td>
<p>e</p>
</td>
</tr>
<tr>
<td>
<p><b>%</b></p>
</td>
<td>
<p>s</p>
</td>
<td>
<p>d</p>
</td>
</tr>
<tr>
<td>
<p><b>&amp;</b></p>
</td>
<td>
<p>d</p>
</td>
<td>
<p>d</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>r</p>
</td>
<td>
<p>r</p>
</td>
</tr>
<tr>
<td>
<p><b>A</b></p>
</td>
<td>
<p>r</p>
</td>
<td>
<p>r</p>
</td>
</tr>
<tr>
<td>
<p><b>&lt;&lt;</b></p>
</td>
<td>
<p>t</p>
</td>
<td>
<p>t</p>
</td>
</tr>
<tr>
<td>
<p><b>&gt;&gt;</b></p>
</td>
<td>
<p>t</p>
</td>
<td>
<p>t</p>
</td>
</tr>
<tr>
<td>
<p><b>==</b></p>
</td>
<td>
<p>y</p>
</td>
<td>
<p>s</p>
</td>
</tr>
<tr>
<td>
<p><b>! =</b></p>
</td>
<td>
<p>y</p>
</td>
<td>
<p>e</p>
</td>
</tr>
<tr>
<td>
<p><b>&lt;</b></p>
</td>
<td>
<p>n</p>
</td>
<td>
<p>e</p>
</td>
</tr>
<tr>
<td>
<p><b>&gt;</b></p>
</td>
<td>
<p>n</p>
</td>
<td>
<p>e</p>
</td>
</tr>
<tr>
<td>
<p><b>&lt;=</b></p>
</td>
<td>
<p>l</p>
</td>
<td>
<p>e</p>
</td>
</tr>
<tr>
<td>
<p><b>&gt;=</b></p>
</td>
<td>
<p>l</p>
</td>
<td>
<p>e</p>
</td>
</tr>
</table>
<p>The CLR specification defines many additional operators that can be overloaded, but C# does not support these additional operators. Therefore, they are not in mainstream use, so I will not list them here. If you are interested in the complete list, please see the ECMA specifications (www.ecma-international.org/publications/standards/Ecma-335.htm) for the Common Language Infrastructure (CLI), Partition I, Concepts and Architecture, Sections 10. 3.1 (unary operators) and 10.3.2 (binary operators).</p>
<hr/>
<blockquote><b>Note </b>If you examine the core numeric types <b>(Int32, Int64, UInt32, </b>and so on) in the</blockquote>
<hr/>
<p>Framework Class Library (FCL), you'll see that they don't define any operator overload methods. The reason they don't is that compilers look specifically for operations on these primitive types and emit IL instructions that directly manipulate instances of these types. If the types were to offer methods and if compilers were to emit code to call these methods, a run-time performance cost would be associated with the method call. Plus, the method would ultimately have to execute some IL instructions to perform the expected operation anyway This is the reason why the core FCL types don't define any operator overload methods. Here's what this means to you: If the programming language you're using doesn't support one of the core FCL types, you won't be able to perform any operations on instances of that type.</p>
<h3>Operators and Programming Language Interoperability</h3>
<p>Operator overloading can be a very useful tool, allowing developers to express their thoughts with succinct code However, not all programming languages support operator overloading. When using a language that doesn't support operator overloading, the language will not know how to interpret the <b>+ </b>operator (unless the type is a primitive in that language), and the compiler will emit an error When using languages that do not support operator overloading, the language should allow you to call the desired <b>op_* </b>method directly (such as <b>op_Addition) </b>.</p>
<p>If you are using a language that doesn't support + operator overloading to be defined in a type, obviously, this type could still offer an <b>op_Addition </b>method. From C#, you might expect that you could call this <b>op_Addition </b>method by using the <b>+ </b>operator, but you cannot. When the C# compiler detects the + operator, it looks for an <b>op_Addition </b>method that has the <b>specialname </b>metadata flag associated with it so that the compiler knows for sure that the <b>op_Addition </b>method is intended to be an operator overload method. Because the <b>op_Addition </b>method is produced by a language that doesn't support operator overloads, the method won't have the <b>specialname </b>flag associated with it, and the C# compiler will produce a compilation error Of course, code in any language can explicitly call a method that just happens to be named <b>op_Addition, </b>but the compilers won't translate a usage of the <b>+ </b>symbol to call this method.</p>
<p><b>Jeff's Opinion About Microsoft's Operator Method Name Rules</b></p>
<p>I'm sure that all of these rules about when you can and can't call an operator overload method seem very confusing and overly complicated. If compilers that supported operator overloading just didn't emit the <b>specialname </b>metadata flag, the rules would be a lot simpler, and programmers would have an easier time working with types that offer operator overload methods Languages that support operator overloading would support the operator symbol syntax, and all languages would support calling the various <b>op_ </b>methods explicitly. I can't come up with any reason why Microsoft made this so difficult, and I hope that they'll loosen these rules in future versions of their compilers.</p>
<p>For a type that defines operator overload methods, Microsoft recommends that the type also define friendlier public static methods that call the operator overload methods internally. For example, a public-friendly named method called <b>Add </b>should be defined by a type that overloads the <b>op_Addition </b>method. The third column in Tables 8-1 and 8-2 lists the recommended friendly name for each operator. So the <b>Complex </b>type shown earlier should be defined this way:</p>
<p><code>public sealed class Complex {<br/>
public static Complex operator+(Complex cl, Complex c2) {... } public static Complex Add(Complex cl, Complex c2) { return(cl + c2); }<br/>
}</code></p>
<p>Certainly, code written in any programming language can call any of the friendly operator methods, such as <b>Add </b>. Microsoft's guideline that types offer these friendly method names complicates the story even more. I feel that this additional complication is unnecessary, and that calling these friendly named methods would cause an additional performance hit unless the JIT compiler is able to inline the code in the friendly named method. Inlining the code would cause the JIT compiler to optimize the code, removing the additional method call and boosting runtime performance.</p>
<hr/>
<blockquote><b>Note </b>For an example of a type that overloads operators and uses the friendly method names as per Microsoft's design guidelines, see the <b>System.Decimal </b>class in the FCL.</blockquote>
<hr/>
<a name="b204"/><h2>Conversion Operator Methods</h2>
<p>Occasionally, you need to convert an object from one type to an object of a different type For example, I'm sure you've had to convert a <b>Byte </b>to an <b>Int32 </b>at some point in your life. When the source type and the target type are a compiler's primitive types, the compiler knows how to emit the necessary code to convert the object.</p>
<p>If the source type or target type is not a primitive, the compiler emits code that has the CLR perform the conversion (cast). In this case, the CLR just checks if the source object's type is the same type as the target type (or derived from the target type) However, it is sometimes natural to want to convert an object of one type to a completely different type. For example, the <b>System.Xml.Linq.XElement </b>class allows you to convert an Extensible Markup Language (XML) element to a <b>Boolean, (U)Int32, (U)Int64, Single, Double, Decimal, String, DateTime, DateTimeOffset, TimeSpan, Guid, </b>or the nullable equivalent of any of these types (except <b>String) </b>. You could also imagine that the FCL included a <b>Rational </b>data type and that it might be convenient to convert an <b>Int32 </b>object or a <b>Single </b>object to a <b>Rational </b>object. Moreover, it also might be nice to convert a <b>Rational </b>object to an <b>Int32 </b>or a <b>Single </b>object.</p>
<p>To make these conversions, the <b>Rational </b>type should define public constructors that take a single parameter: an instance of the type that you're converting from. You should also define public instance <b>ToXxx </b>methods that take no parameters (just like the very popular <b>ToString </b>method). Each method will convert an instance of the defining type to the <b>Xxx </b>type. Here's how to correctly define conversion constructors and methods for a <b>Rational </b>type:</p>
<p><code>public sealed class Rational {<br/>
// Constructs a Rational from an Int32 public Rational(Int32 num) {... }<br/>
// Constructs a Rational from a Single public Rational(Single num) {... }<br/>
// Convert a Rational to an Int32<br/>
public Int32 ToInt32() {... }<br/>
// Convert a Rational to a Single public Single ToSingle() {... }<br/>
}</code></p>
<p>By invoking these constructors and methods, a developer using any programming language can convert an <b>Int32 </b>or a <b>Single </b>object to a <b>Rational </b>object and convert a <b>Rational </b>object to an <b>Int32 </b>or a <b>Single </b>object. The ability to do these conversions can be quite handy, and when designing a type, you should seriously consider what conversion constructors and methods make sense for your type.</p>
<p>In the previous section, I discussed how some programming languages offer operator overloading. Well, some programming languages (such as C#) also offer conversion operator overloading. Conversion operators are methods that convert an object from one type to another type. You define a conversion operator method by using special syntax. The CLR specification mandates that conversion overload methods be <b>public </b>and <b>static </b>methods. In addition, C# (and many other languages) requires that either the parameter or the return type must be the same as the type that the conversion method is defined within. The reason for this restriction is that it enables the C# compiler to search for a possible operator method to bind to in a reasonable amount of time. The following code adds four conversion operator methods to the <b>Rational </b>type:</p>
<p><code>public sealed class Rational {<br/>
// Constructs a Rational from an Int32 public Rational(Int32 num) {... }<br/>
// Constructs a Rational from a Single public Rational(Single num) {... }<br/>
// Convert a Rational to an Int32<br/>
public Int32 ToInt32() {... }<br/>
// Convert a Rational to a Single public Single ToSingle() {... }<br/>
// Implicitly constructs and returns a Rational from an Int32 public static implicit operator Rational(Int32 num) { return new Rational(num);<br/>
}<br/>
// Implicitly constructs and returns a Rational from a Single public static implicit operator Rational(Single num) { return new Rational(num);<br/>
}<br/>
// Explicitly returns an Int32 from a Rational public static explicit operator Int32(Rational r) { return r.ToInt32();<br/>
}<br/>
// Explicitly returns a Single from a Rational public static explicit operator Single(Rational r) { return r.ToSingle();<br/>
}<br/>
}</code></p>
<p>For conversion operator methods, you must indicate whether a compiler can emit code to call a conversion operator method implicitly or whether the source code must explicitly indicate when the compiler is to emit code to call a conversion operator method In C#, you use the <b>implicit </b>keyword to indicate to the compiler that an explicit cast doesn't have to appear in the source code in order to emit code that calls the method. The <b>explicit </b>keyword allows the compiler to call the method only when an explicit cast exists in the source code.</p>
<p>After the <b>implicit </b>or <b>explicit </b>keyword, you tell the compiler that the method is a conversion operator by specifying the <b>operator </b>keyword After the <b>operator </b>keyword, you specify the type that an object is being cast to; in the parentheses, you specify the type that an object is being cast from.</p>
<p>Defining the conversion operators in the preceding <b>Rational </b>type allows you to write code like this (in C#):</p>
<p><code>public sealed class Program { public static void Main() {<br/>
Rational r1 = 5;// Implicit cast from Int32   to Rational<br/>
Rational r2 = 2.5F;// Implicit cast from Single to Rational<br/>
Int32   x = (Int32)   r1;   // Explicit cast from Rational to Int32 Single s = (Single) r2;   // Explicit cast from Rational to Single<br/>
}<br/>
}</code></p>
<p>Under the covers, the C# compiler detects the casts (type conversions) in the code and internally generates IL code that calls the conversion operator methods defined by the <b>Rational </b>type. But what are the names of these methods? Well, compiling the <b>Rational </b>type and examining its metadata shows that the compiler produces one method for each conversion operator defined. For the <b>Rational </b>type, the metadata for the four conversion operator methods looks like this:</p>
<p><code>public static Rational op_Implicit(Int32 num) public static Rational op_Implicit(Single num) public static Int32      op_Explicit(Rational r) public static Single    op_Explicit(Rational r)</code></p>
<p>As you can see, methods that convert an object from one type to another are always named <b>op_Implicit </b>or <b>op_Explicit </b>. You should define an implicit conversion operator only when precision or magnitude isn't lost during a conversion, such as when converting an <b>Int32 </b>to a <b>Rational. </b>However, you should define an explicit conversion operator if precision or magnitude is lost during the conversion, as when converting a <b>Rational </b>object to an <b>Int32. </b>If an explicit conversion fails, you should indicate this by having your explicit conversion operator method throw an <b>OverflowException </b>or an <b>InvalidOperationException </b>.</p>
<hr/>
<blockquote><b>Note </b>The two <b>op_Explicit </b>methods take the same parameter, a <b>Rational. </b>However, the methods differ by their return value, an <b>Int32 </b>and a <b>Single. </b>This is an example of two methods that differ only by their return type. The CLR fully supports the ability for a type to define multiple methods that differ only by return type. However, very few languages expose this ability. As you're probably aware, C++, C#, Visual Basic, and Java are all examples of languages that don't support the definition of multiple methods that differ only by their return type. A few languages (such as IL assembly language) allow the developer to explicitly select which of these methods to call. Of course, IL assembly language programmers shouldn't take advantage of this ability because the methods they define can't be callable from other programming languages. Even though C# doesn't expose this ability to the C# programmer, the compiler does take advantage of this ability internally when a type defines conversion operator methods.</blockquote>
<hr/>
<p>C# has full support for conversion operators. When it detects code where you're using an object of one type and an object of a different type is expected, the compiler searches for an implicit conversion operator method capable of performing the conversion and generates code to call that method. If an implicit conversion operator method exists, the compiler emits a call to it in the resulting IL code. If the compiler sees source code that is explicitly casting an object from one type to another type, the compiler searches for an implicit or explicit conversion operator method. If one exists, the compiler emits the call to the method. If the compiler can't find an appropriate conversion operator method, it issues an error and doesn't compile the code.</p>
<hr/>
<blockquote><b>Note </b>C# generates code to invoke explicit conversion operators when using a cast expression; <b>I     </b>I        they are never invoked when using C#'s <b>as </b>or <b>is </b>operators.</blockquote>
<hr/>
<p>_</p>
<p>To really understand operator overload methods and conversion operator methods, I strongly encourage you to examine the <b>System.Decimal </b>type as a role model. <b>Decimal </b>defines several constructors that allow you to convert objects from various types to a <b>Decimal. </b>It also offers several <b>ToXxx </b>methods that let you convert a <b>Decimal </b>object to another type. Finally, the type defines several conversion operators and operator overload methods as well.</p>
<a name="b207"/><h2>Extension Methods</h2>
<p>The best way to understand C#'s extension methods feature is by way of an example. In the <b>&quot;StringBuilder </b>Members&quot; section in Chapter 14, &quot;Chars, Strings, and Working with Text,&quot; I mention how the <b>StringBuilder </b>class offers fewer methods than the <b>String </b>class for manipulating a string and how strange this is, considering that the <b>StringBuilder </b>class is the preferred way of manipulating a string because it is mutable. So, let's say that you would like to define some of these missing methods yourself to operate on a <b>StringBuilder </b>. For example, you might want to define your own <b>IndexOf </b>method as follows:</p>
<p><code>public static class StringBuilderExtensions {<br/>
public static Int32 IndexOf(StringBuilder sb, Char value) { for (Int32 index = 0; index &lt; sb.Length; index++)<br/>
if (sb[index] == value) return index; return -l;<br/>
}<br/>
}</code></p>
<p>Now that you have defined this method, you can use it as the following code demonstrates: StringBuilder sb = new StringBuilder(&quot;Hello. My name is Jeff.&quot;);     // The initial string</p>
<p><code>// Change period to exclamation and get # characters in lst sentence (5). Int32 index = StringBuilderExtensions.IndexOf(sb.Replace('.',  'I'), 'I');</code></p>
<p>This code works just fine, but is it not ideal from a programmer's perspective. The first problem is that a programmer who wants to get the index of a character within a <b>StringBuilder </b>must know that the <b>StringBuilderExtensions </b>class even exists. The second problem is that the code does not reflect the order of operations that are being performed on the <b>StringBuilder </b>object, making the code difficult to write, read, and maintain. The programmer wants to call <b>Replace </b>first and then call <b>IndexOf; </b>but when you read the last line of code from left to right, <b>IndexOf </b>appears first on the line and <b>Replace </b>appears second. Of course, you could alleviate this problem and make the code's behavior more understandable by rewriting it like this:</p>
<p><code>// First, change period to exclamation mark sb.Replace('.', 'I');<br/>
// Now, get # characters in lst sentence (5)<br/>
Int32 index = StringBuilderExtensions.IndexOf(sb, 'I');</code></p>
<p>However, a third problem exists with both versions of this code that affects understanding the code's behavior The use of <b>StringBuilderExtensions </b>is overpowering and detracts a programmer's mind from the operation that is being performed: <b>IndexOf </b>If the <b>StringBuilder </b>class had defined its own <b>IndexOf </b>method, then we could rewrite the code above as follows:</p>
<p><code>// Change period to exclamation and get # characters in lst sentence (5). Int32 index = sb.Replace('.', 'I').IndexOf('I');</code></p>
<p>Wow, look how great this is in terms of code maintainability! In the <b>StringBuilder </b>object, we're going to replace a period with an exclamation mark and then find the index of the exclamation mark.</p>
<p>Now, I can explain what C#'s extension methods feature does. It allows you to define a static method that you can invoke using instance method syntax. Or, in other words, we can now define our own <b>IndexOf </b>method and the three problems mentioned above go away. To turn the <b>IndexOf </b>method into an extension method, we simply add the <b>this </b>keyword before the first argument:</p>
<p><code>public static class StringBuilderExtensions {<br/>
public static Int32 IndexOf<b>(this </b>StringBuilder sb, Char value) { for (Int32 index = 0; index &lt; sb.Length; index++)<br/>
if (sb[index] == value) return index; return -1;<br/>
}<br/>
}</code></p>
<p>Now, when the compiler sees code like this: Int32 index = sb.IndexOf('X');</p>
<p>the compiler first checks if the <b>StringBuilder </b>class or any of its base classes offers an instance method called <b>IndexOf </b>that takes a single <b>Char </b>parameter. If an existing instance method exists, then the compiler produces IL code to call it If no matching instance method exists, then the compiler will look at any static classes that define static methods called <b>IndexOf </b>that take as their first parameter a type matching the type of the expression being used to invoke the method. This type must also be marked with the <b>this </b>keyword. In this example, the expression is <b>sb, </b>which is of the <b>StringBuilder </b>type. In this case, the compiler is looking specifically for an <b>IndexOf </b>method that takes two parameters: a <b>StringBuilder </b>(marked with the <b>this </b>keyword) and a <b>Char </b>. The compiler will find our <b>IndexOf </b>method and produce IL code that calls our static method.</p>
<p>OK耀o this now explains how the compiler improves the last two problems related to code understandability that I mentioned earlier. However, I haven't yet addressed the first problem: how does a programmer know that an <b>IndexOf </b>method even exists that can operate on a <b>StringBuilder </b>object? The answer to this question is found in Microsoft Visual Studio's Intellisense feature In the editor, when you type a period, Visual Studio's IntelliSense window opens to show you the list of instance methods that are available Well, that IntelliSense window also shows you any extension methods that exist for the type of expression you have to the left of the period. Figure 8-1 shows Visual Studio's IntelliSense window; the icon for an extension method has a down arrow next to it, and the tooltip next to the method indicates that the method is really an extension method. This is truly awesome because it is now easy to define your own methods to operate on various types of objects and have other programmers discover your methods naturally when using objects of these types.</p>
<img src="34.jpg"/>
<p><b>Figure 8-1 </b>Visual Studio's IntelliSense window, showing extension methods</p>
<h3>Rules and Guidelines</h3>
<p>There are some additional rules and guidelines that you should know about extension methods:</p>
<p>&#9632; C# supports extension methods only; it does not offer extension properties, extension events, extension operators, and so on.</p>
<p>&#9632; Extension methods (methods with <b>this </b>before their first argument) must be declared in non-generic, static classes However, there is no restriction on the name of the class; you can call it whatever you want Of course, an extension method must have at least one parameter, and only the first parameter can be marked with the <b>this </b>keyword.</p>
<p>&#9632; The C# compiler looks only for extension methods defined in static classes that are themselves defined at the file scope. In other words, if you define the static class nested within another class, the C# compiler will emit the following message: <b>&quot;error CS1109: Extension method must be defined in a top-level static class; StringBuilderExtensions is a nested class.&quot;</b></p>
<p>&#9632; Since the static classes can have any name you want, it takes the C# compiler time to find extension methods as it must look at all the file-scope static classes and scan their static methods for a match To improve performance and also to avoid considering an extension method that you may not want, the C# compiler requires that you &quot;import&quot; extension methods. For example, if someone has defined a <b>StringBuilderExtensions </b>class in a <b>Wintellect </b>namespace, then a programmer who wants to have access to this class's extension methods must put a <b>using Wintellect; </b>directive at the top of his or her source code file.</p>
<p>&#9632; It is possible that multiple static classes could define the same extension method. If the compiler detects that two or more extension methods exist, then the compiler issues the following message: <b>&quot;error CS0121: The call is ambiguous between the following methods or properties: 'StringBuilderExtensions. IndexOf(string, char)' and 'AnotherStringBuilderExtensions. IndexOf(string, char)'.&quot; </b>To fix this error, you must modify your source code. Specifically, you cannot use the instance method syntax to call this static method anymore; instead you must now use the static method syntax where you explicitly indicate the name of the static class to explicitly tell the compiler which method you want to invoke.</p>
<p>&#9632; You should use this feature sparingly, as not all programmers are familiar with it For example, when you extend a type with an extension method, you are actually extending derived types with this method as well. Therefore, you should not define an extension method whose first parameter is <b>System.Object, </b>as this method will be callable for all expression types and this will really pollute Visual Studio's IntelliSense window.</p>
<p>&#9632; There is a potential versioning problem that exists with extension methods. If, in the future, Microsoft adds an <b>IndexOf </b>instance method to their <b>StringBuilder </b>class with the same prototype as my code is attempting to call, then when I recompile my code, the compiler will bind to Microsoft's <b>IndexOf </b>instance method instead of my static <b>IndexOf </b>method. Because of this, my program will experience different behavior. This versioning problem is another reason why this feature should be used sparingly.</p>
<h3>Extending Various Types with Extension Methods</h3>
<p>In this chapter, I demonstrated how to define an extension method for a class, <b>StringBuilder. </b>I'd like to point out that since an extension method is really the invocation of a static method, the CLR does not emit code ensuring that the value of the expression used to invoke the method is not <b>null:</b></p>
<p><code>// sb is null StringBuilder sb = null;<br/>
// Calling extension method: NullReferenceException will NOT be thrown when calling IndexOf<br/>
// NullReferenceException will be thrown inside IndexOf's for loop<br/>
sb.IndexOf('X');<br/>
// Calling instance method: NullReferenceException WILL be thrown when calling Replace sb.Replace('.', 'I');</code></p>
<p>I'd also like to point out that you can define extension methods for interface types as the following code shows:</p>
<p><code>public static void ShowItems&lt;T&gt;(this IEnumerable&lt;T&gt; collection) { foreach (var item in collection) Console.WriteLine(item);<br/>
}</code></p>
<p>The extension method above can now be invoked using any expression that results in a type that implements the <b>IEnumerable&lt;T&gt; </b>interface:</p>
<p><code>public static void Main() {<br/>
// Shows each Char on a separate line in the console &quot;Grant&quot;.ShowItems();<br/>
// Shows each String on a separate line in the console new[] { &quot;Jeff&quot;, &quot;Kristin&quot; }.ShowItems();<br/>
// Shows each Int32 value on a separate line in the console new List&lt;Int32&gt;() { l, 2, 3 }.ShowItems();<br/>
}</code></p>
<hr/>
<blockquote><b>Important </b>Extension methods are the cornerstone of Microsoft's Language Integrated Query (LINQ) technology. For a great example of a class that offers many extension methods, see the static <b>System.Linq.Enumerable </b>class and all its static extension methods in the Microsoft .NET Framework SDK documentation. Every extension method in this class extends either the <b>IEnumerable </b>or <b>IEnumerable&lt;T&gt; </b>interface.</blockquote>
<hr/>
<p>You can define extension methods for delegate types, too. For an example of this, turn to page 278 in Chapter 11, &quot;Events.&quot; You can also add extension methods to enumerated types. I show an example of this in the &quot;Adding Methods to Enumerated Types&quot; section in Chapter 15, &quot;Enumerated Types and Bit Flags.&quot;</p>
<p>And last but not least, I want to point out that the C# compiler allows you to create a delegate (see Chapter 17, &quot;Delegates,&quot; for more information) that refers to an extension method over an object:</p>
<p><code>public static void Main () {<br/>
// Create an Action delegate that refers to the static ShowItems extension method // and has the first argument initialized to reference the &quot;Jeff&quot; string. Action a = &quot;Jeff'.ShowItems;<br/>
// Invoke the delegate which calls ShowItems passing it a reference to the &quot;Jeff&quot; string. a();<br/>
}</code></p>
<p>In the code above, the C# compiler generates IL code to construct an <b>Action </b>delegate. When creating a delegate, the constructor is passed the method that should be called and is also passed a reference to an object that should be passed to the method's hidden <b>this </b>parameter Normally, when you create a delegate that refers to a static method, the object reference is <b>null </b>since static methods don't have a <b>this </b>parameter. However, in this example, the C# compiler generated some special code that creates a delegate that refers to a static method <b>(ShowItems) </b>and the target object of the static method is the reference to the &quot;Jeff&quot; string Later, when the delegate is invoked, the CLR will call the static method and will pass to it the reference to the &quot;Jeff&quot; string. This is a little hacky, but it works great and it feels natural so long as you don't think about what is happening internally.</p>
<h3>The Extension Attribute</h3>
<p>It would be best if this concept of extension methods was not C#-specific. Specifically, we want programmers to define a set of extension methods in some programming language and for people in other programming languages to take advantage of them For this to work, the compiler of choice must support searching static types and methods for potentially matching extension methods. And compilers need to do this quickly so that compilation time is kept to a minimum.</p>
<p>In C#, when you mark a static method's first parameter with the <b>this </b>keyword, the compiler internally applies a custom attribute to the method and this attribute is persisted in the resulting file's metadata. The attribute is defined in the System. Core.dll assembly, and it looks like this:</p>
<p><code>// Defined in the System.Runtime.CompilerServices namespace<br/>
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class | AttributeTargets. Assembly)]<br/>
public sealed class ExtensionAttribute : Attribute {<br/>
}</code></p>
<p>In addition, this attribute is applied to the metadata for any static class that contains at least one extension method. And this attribute is also applied to the metadata for any assembly that contains at least one static class that contains an extension method So now, when compiling code that invokes an instance method that doesn't exist, the compiler can quickly scan all the referenced assemblies to know which ones contain extension methods. Then it can scan only these assemblies for static classes that contain extension methods, and it can scan just the extension methods for potential matches to compile the code as quickly as possible.</p>
<hr/>
<blockquote><b>Note </b>The <b>ExtensionAttribute </b>class is defined in the System.Core.dll assembly. This means that the resulting assembly produced by the compiler will have a reference to System Core dll embedded in it even if I do not use any types from System Core dll and do not even reference System Core dll when compiling my code However, this is not too bad a problem because the <b>ExtensionAttribute </b>is used only at compile time; at runtime, System. Core.dll will not have to be loaded unless the application consumes something else in this assembly.</blockquote>
<hr/>
<a name="b213"/><h2>Partial Methods</h2>
<p>Imagine that you use a tool that produces a C# source code file containing a type definition. The tool knows that there are potential places within the code it produces where you might want to customize the type's behavior. Normally, customization would be done by having the tool-produced code invoke virtual methods The tool-produced code would also have to contain definitions for these virtual methods, and the way these methods would be implemented is to do nothing and simply return. Now, if you want to customize the behavior of the class, you'd define your own class, derive it from the base class, and then override any virtual methods implementing it so that it has the behavior you desire. Here is an example:</p>
<p><code>// Tool-produced code in some source code file: internal class Base { private String m_name;<br/>
// Called before changing the m_name field<br/>
protected virtual void OnNameChanging(String value) {<br/>
}<br/>
public String Name {<br/>
get { return m_name; } set {<br/>
OnNameChanging(value.Tollpper<b>O);   </b>// Inform class of potential change m_name = value;// Change the field<br/>
}<br/>
}<br/>
}<br/>
// Developer-produced code in some other source code file: internal class Derived : Base {<br/>
protected override void OnNameChanging(string value) { if (String.IsNullOrEmpty(value))<br/>
throw new ArgumentNullException(&quot;value&quot;);<br/>
}<br/>
}</code></p>
<p>Unfortunately, there are two problems with the code above:</p>
<p>&#9632; The type must be a class that is not sealed You cannot use this technique for sealed classes or for value types (because value types are implicitly sealed). In addition, you cannot use this technique for static methods since they cannot be overridden.</p>
<p>&#9632; There are efficiency problems here. A type is being defined just to override a method; this wastes a small amount of system resources. And, even if you do not want to override the behavior of <b>OnNameChanging, </b>the base class code still invokes a virtual method which simply does nothing but return. Also, <b>ToUpper </b>is called whether <b>OnNameChanging </b>accesses the argument passed to it or not.</p>
<p>C#'s partial methods feature allows you the option of overriding the behavior or a type while fixing the aforementioned problems. The code below uses partial methods to accomplish the same semantic as the previous code:</p>
<p><code>// Tool-produced code in some source code file: internal sealed partial class Base { private String m_name;<br/>
// This defining-partial-method-declaration is called before changing the m_name field partial void OnNameChanging(String value);<br/>
public String Name {<br/>
get { return m_name; } set {<br/>
OnNameChanging(value.TollpperO);   // Inform class of potential change m_name = value;// Change the field<br/>
}<br/>
}<br/>
}<br/>
// Developer-produced code in some other source code file: internal sealed partial class Base {<br/>
// This implementing-partial-method-declaration is called before m_name is changed partial void OnNameChanging(String value) { if (String.IsNullOrEmpty(value))<br/>
throw new ArgumentNullException(&quot;value&quot;);<br/>
}<br/>
}</code></p>
<p>There are several things to notice about this new version of the code:</p>
<p>&#9632; The class is now sealed (although it doesn't have to be). In fact, the class could be a static class or even a value type.</p>
<p>&#9632; The tool-produced code and the developer-produced code are really two partial definitions that ultimately make up one type definition. For more information about partial types, see the &quot;Partial Classes, Structures, and Interfaces&quot; section in Chapter 6, &quot;Type and Member Basics.&quot;</p>
<p>&#9632; The tool-produced code defined a partial method declaration. This method is marked with the <b>partial </b>token and it has no body.</p>
<p>&#9632; The developer-produced code implemented the partial method declaration This method is also marked with the <b>partial </b>token and it has a body.</p>
<p>Now, when you compile this code, you see the same effect as the original code I showed you Again, the big benefit here is that you can rerun the tool and produce new code in a new source code file, but your code remains in a separate file and is unaffected. And, this technique works for sealed classes, static classes, and value types.</p>
<hr/>
<blockquote><b>Note </b>In Visual Studio's editor, if you type in <b>partial </b>and press the spacebar, the IntelliSense window shows you all the enclosing type's defined partial method declarations that do not yet have matching implementing partial method declarations. You can then easily select a partial method from the IntelliSense window and Visual Studio will produce the method prototype for you automatically. This is a very nice feature that enhances productivity.</blockquote>
<hr/>
<p>But, there is another big improvement we get with partial methods. Let's say that you do not need to modify the behavior of the tool-produced type. In this case, you do not supply your source code file at all. If you just compile the tool-produced code by itself, the compiler produces IL code and metadata as if the tool-produced code looked like this:</p>
<p><code>// Logical equivalent of tool-produced code if there is no // implementing partial method declaration: internal sealed class Base { private String m_name;<br/>
public String Name {<br/>
get { return m_name; } set {<br/>
m_name = value;// Change the field<br/>
}<br/>
}<br/>
}</code></p>
<p>That is, if there is no implementing partial method declaration, the compiler will not emit any metadata representing the partial method In addition, the compiler will not emit any IL instructions to call the partial method And the compiler will not emit code that evaluates any arguments that would have been passed to the partial method. In this example, the compiler will not emit code to call the <b>ToUpper </b>method. The result is that there is less metadata/IL, and the runtime performance is awesome!</p>
<hr/>
<blockquote><b>Note </b>Partial methods work similarly to the <b>System.Diagnostics.ConditionalAttribute</b></blockquote>
<hr/>
<p>attribute. However, partial methods work within a single type only while the <b>ConditionalAttribute </b>can be used to optionally invoke methods defined in another type.</p>
<h3>Rules and Guidelines</h3>
<p>There are some additional rules and guidelines that you should know about partial methods:</p>
<p>&#9632; They can only be declared within a partial class or struct.</p>
<p>&#9632; Partial methods must always have a return type of <b>void, </b>and they cannot have any parameters marked with the <b>out </b>modifier. These restrictions are in place because at runtime, the method may not exist and so you can't initialize a variable to what the method might return because the method might not exist. Similarly, you can't have an</p>
<p><b>out </b>parameter because the method would have to initialize it and the method might not exist. A partial method may have <b>ref </b>parameters, may be generic, may be instance or static, and may be marked as <b>unsafe.</b></p>
<p>&#9632; Of course, the defining partial method declaration and the implementing partial method declaration must have identical signatures. If both have custom attributes applied to them, then the compiler combines both methods' attributes together Any attributes applied to a parameter are also combined.</p>
<p>&#9632; If there is no implementing partial method declaration, then you cannot have any code that attempts to create a delegate that refers to the partial method Again, the reason is that the method doesn't exist at runtime The compiler produces this message: <b>&quot;error CS0762: Cannot create delegate from method 'Base.OnNameChanging(string)' because it is a partial method without an implementing declaration&quot;.</b></p>
<p>&#9632; Partial methods are always considered to be private methods. However, the C# compiler forbids you from putting the <b>private </b>keyword before the partial method declaration.</p>
<mbp:pagebreak/>
<a name="Chapter9"/>
<h1>Chapter 9: Parameters</h1>
<p><b>In this chapter:</b></p>
<a href="#b219">Optional and Named Parameters</a><br/>
<a href="#b223">Implicitly Typed Local Variables</a><br/>
<a href="#b225">Passing Parameters by Reference to a Method</a><br/>
<a href="#b231">Passing a Variable Number of Arguments to a Method</a><br/>
<a href="#b233">Parameter and Return Type Guidelines</a><br/>
<a href="#b235">Const-ness</a><br/>
<p>This chapter focuses on the various ways of passing parameters to a method, including how to optionally specify parameters, specify parameters by name, and pass parameters by reference, as well as how to define methods that accept a variable number of arguments.</p>
<a name="b219"/><h2>Optional and Named Parameters</h2>
<p>When designing a method's parameters, you can assign default values to some of or all the parameters. Then, code that calls these methods can optionally not specify some of the arguments, thereby accepting the default values. In addition, when you call a method, you can specify arguments by using the name of their parameters. Here is some code that demonstrates using both optional and named parameters:</p>
<p><code>public static class Program { private static Int32 s_n = 0;<br/>
private static void M(Int32 x = 9, String s = &quot;A&quot;,<br/>
DateTimedt = default(DateTime), Guidguid = new Guid()) {<br/>
Console.WriteLine(&quot;x={0}, s={1}, dt={2}, guid={3}&quot;, x, s, dt, guid);<br/>
}<br/>
public static void Main() {<br/>
// 1. Same as: M(9, &quot;A&quot;, default(DateTime), new Guid()); M();<br/>
// 2. Same as: M(8, &quot;X&quot;, default(DateTime), new Guid()); M(8, &quot;X&quot;);<br/>
// 3. Same as: M(5, &quot;A&quot;, DateTime.Now, Guid.NewGuidO); M(5, guid: Guid.NewGuidO, dt: DateTime.Now);<br/>
// 4. Same as: M(0, &quot;l&quot;, default(DateTime), new Guid()); M(s_n++, s_n++.ToString());<br/>
// 5. Same as: String tl = &quot;2&quot;; Int32 t2 = 3;<br/>
//.M(t2, tl, default(DateTime), new Guid());<br/>
M(s: (s_n++).ToString(), x: s_n++);<br/>
}<br/>
}</code></p>
<p>When I run this program, I get the following output:</p>
<p><code>x=9, s=A, dt=l/l/000l l2:00:00 AM, guid=00000000-0000-0000-0000-000000000000 x=8, s=X, dt=l/l/000l l2:00:00 AM, guid=00000000-0000-0000-0000-000000000000 x=5, s=A, dt=7/2/2009 l0:l4:25 PM, guid=d24a59da-6009-4aae-9295-839l558ll309 x=0, s=l, dt=l/l/000l l2:00:00 AM, guid=00000000-0000-0000-0000-000000000000 x=3, s=2, dt=l/l/000l l2:00:00 AM, guid=00000000-0000-0000-0000-000000000000</code></p>
<p>As you can see, whenever arguments are left out at the call site, the C# compiler embeds the parameter's default value. The third and fifth calls to <b>M </b>use C#'s named parameter feature. In the two calls, I'm explicitly passing a value for <b>x </b>and I'm indicating that I want to pass an argument for the parameters named <b>guid </b>and <b>dt </b>.</p>
<p>When you pass arguments to a method, the compiler evaluates the arguments from left to right In the fourth call to <b>M, </b>the value in <b>s_n (0) </b>is passed for <b>x, </b>then <b>s_n </b>is incremented, and <b>s_n (1) </b>is passed as a string for <b>s </b>and then <b>s_n </b>is incremented again to <b>2 </b>When you pass arguments by using named parameters, the compiler still evaluates the arguments from left to right. In the fifth call to <b>M, </b>the value in <b>s_n (2) </b>is converted to a string and saved in a temporary variable <b>(t1) </b>that the compiler creates Next, <b>s_n </b>is incremented to <b>3 </b>and this value is saved in another temporary variable <b>(t2) </b>created by the compiler, and then <b>s_n </b>is incremented again to <b>4 </b>. Ultimately, <b>M </b>is invoked, passing it <b>t2, t1, </b>a default <b>DateTime, </b>and a new <b>Guid </b>.</p>
<h3>Rules and Guidelines</h3>
<p>There are some additional rules and guidelines that you should know about when defining a method that specifies default values for some of its parameters:</p>
<p>&#9632; You can specify default values for the parameters of methods, constructor methods, and parameterful properties (C# indexers). You can also specify default values for parameters that are part of a delegate definition. Then, when invoking a variable of this delegate type, you can omit the arguments and accept the default values.</p>
<p>&#9632; Parameters with default values must come after any parameters that do not have default values. That is, once you define a parameter as having a default value, then all parameters to the right of it must also have default values. For example, in the definition of my <b>M </b>method, I would get a compiler error if I removed the default value <b>(&quot;A&quot;) </b>for</p>
<p><b>s </b>. There is one exception to this rule: a <b>params </b>array parameter (discussed later in this chapter) must come after all parameters (including those that have default values), and the array cannot have a default value itself</p>
<p>&#9632; Default values must be constant values known at compile time. This means that you can set default values for parameters of types that C# considers to be primitive types, as shown in Table 5-1 in Chapter 5, &quot;Primitive, Reference, and Value Types.&quot; This also includes enumerated types, and any reference type can be set to <b>null. </b>For a parameter of an arbitrary value type, you can set the default value to be an instance of the value type, with all its fields containing zeroes. You can use the <b>default </b>keyword or the <b>new </b>keyword to express this; both syntaxes produce identical Intermediate Language (IL) code. Examples of both syntaxes are used by my <b>M </b>method for setting the default value for the <b>dt </b>parameter and <b>guid </b>parameter, respectively.</p>
<p>&#9632; Be careful not to rename parameter variables because any callers who are passing arguments by parameter name will have to modify their code. For example, in the declaration of my <b>M </b>method, if I rename the <b>dt </b>variable to <b>dateTime, </b>then my third call to <b>M </b>in the earlier code will cause the compiler to produce the following message: <b>&quot;error CS1739: The best overload for 'M' does not have a parameter named 'dt'.</b>&quot;</p>
<p>&#9632; Be aware that changing a parameter's default value is potentially dangerous if the method is called from outside the module. A call site embeds the default value into its call. If you later change the parameter's default value and do not recompile the code containing the call site, then it will call your method passing the old default value You might want to consider using a default value of <b>0/null </b>as a sentinel to indicate default behavior; this allows you to change your default without having to recompile all the code with call sites. Here is an example:</p>
<p><code>// Don't do this:<br/>
private static String MakePath(String filename = &quot;Untitled&quot;) { return String.Format(@&quot;C:\{0}.txt&quot;, filename);<br/>
}<br/>
// Do this instead:<br/>
private static String MakePath(String filename = null) {<br/>
// I am using the null-coalescing operator (??) here; see Chapter 19 return String.Format(@&quot;C:\{0}.txt&quot;, filename ?? &quot;Untitled&quot;);<br/>
}</code></p>
<p>&#9632; You cannot set default values for parameters marked with either the <b>ref </b>or <b>out </b>keywords because there is no way to pass a meaningful default value for these parameters.</p>
<p>There are some additional rules and guidelines that you should know about when calling a method using optional or named parameters:</p>
<p>&#9632; Arguments can be passed in any order; however, named arguments must always appear at the end of the argument list.</p>
<p>&#9632; You can pass arguments by name to parameters that do not have default values, but all required arguments must be passed (by position or by name) for the compiler to compile the code.</p>
<p>&#9632; C# doesn't allow you to omit arguments between commas, as in <b>M(1,.DateTime.Now), </b>because this could lead to unreadable comma-counting code. Pass arguments by way of their parameter name if you want to omit some arguments for parameters with default values.</p>
<p>&#9632; To pass an argument by parameter name that requires <b>ref/out, </b>use syntax like this: // Method declaration:</p>
<p><code>private static void M(ref Int32 x) {... }<br/>
// Method invocation: Int32 a = 5; M(x: ref a);</code></p>
<hr/>
<blockquote><b>Note </b>C#'s optional and named parameter features are really convenient when writing C# code that interoperates with the COM object model in Microsoft Office. And, when calling a COM component, C# also allows you to omit <b>ref/out </b>when passing an argument by reference to simplify the coding even more When not calling a COM component, C# requires that the <b>out/ref </b>keyword be applied to the argument.</blockquote>
<hr/>
<p>s</p>
<p>It would be best if this concept of default and optional arguments was not C#-specific. Specifically, we want programmers to define a method indicating which parameters are optional and what their default value should be in some programming language and then give programmers working in other programming languages the ability to call them. For this to work, the compiler of choice must allow the caller to omit some arguments and have a way of determining what those arguments' default values should be.</p>
<p>In C#, when you give a parameter a default value, the compiler internally applies the <b>System.Runtime.InteropServices.OptionalAttribute </b>custom attribute to the parameter, and this attribute is persisted in the resulting file's metadata. In addition, the compiler applies <b>System.Runtime.InteropServices.DefaultParameterValueAttribute </b>to the parameter and persists this attribute in the resulting file's metadata. Then, <b>DefaultParameterValueAttribute</b>'s constructor is passed the constant value that you specified in your source code.</p>
<p>Now, when a compiler sees that you have code calling a method that is missing some arguments, the compiler can ensure that you've omitted optional arguments, grab their default values out of metadata, and embed the values in the call for you automatically.</p>
<a name="b223"/><h2>Implicitly Typed Local Variables</h2>
<p>C# supports the ability to infer the type of a method's local variable from the type of expression that is used to initialize it Here is some sample code demonstrating the use of this feature:</p>
<p><code>private static void ImplicitlyTypedLocalVariables() { var name = &quot;Jeff&quot;;<br/>
ShowVariableType(name);      // Displays: System.String<br/>
// var n = null;// Error<br/>
var x = (Exception)null;     // OK, but not much value<br/>
ShowVariableType(x);// Displays: System.Exception<br/>
var numbers = new Int32[] { 1, 2, 3, 4 }; ShowVariableType(numbers); // Displays: System.Int32[]<br/>
// Less typing for complex types<br/>
var collection = new Dictionary&lt;String, Single&gt;() { { &quot;.NET&quot;, 4.0f } };<br/>
// Displays: System.Collections.Generic.Dictionary'2[System.String,System.Single] ShowVariableType(collection);<br/>
foreach (var item in collection) {<br/>
// Displays: System.Collections.Generic.KeyValuePair~2[System.String,System.Single] ShowVariableType(item);<br/>
}<br/>
}<br/>
private static void ShowVariableType&lt;T&gt;(T t) { Console.WriteLine(typeofCO);<br/>
}</code></p>
<p>The first line of code inside the <b>ImplicitlyTypedLocalVariables </b>method is introducing a new local variable using the C# <b>var </b>token To determine the type of the <b>name </b>variable, the compiler looks at the type of the expression on the right side of the assignment operator (<b>=</b>). Since <b>&quot;Jeff&quot; </b>is a string, the compiler infers that <b>name</b>'s type must be <b>String. </b>To prove that the compiler is inferring the type correctly, I wrote the <b>ShowVariableType </b>method This generic method infers the type of its argument, and then it shows the type that it inferred on the console I added what <b>ShowVariableType </b>displayed as comments inside the <b>ImplicitlyTypedLocalVariables </b>method for easy reading.</p>
<p>The second assignment (commented out) inside the <b>ImplicitlyTypedLocalVariables </b>method would produce a compiler error <b>(&quot;error CS0815: Cannot assign &lt;null&gt; to an implicitly-typed local variable&quot;) </b>because <b>null </b>is implicitly castable to any reference type or nullable value type; therefore, the compiler cannot infer a distinct type for it However, on the third assignment, I show that it is possible to initialize an implicitly typed local variable with <b>null </b>if you explicitly specify a type <b>(Exception, </b>in my example) While this is possible, it is not that useful because you could also write <b>Exception x = null; </b>to get the same result.</p>
<p>In the fourth assignment, you see some real value of using C#'s implicitly typed local variable feature. Without this feature, you'd have to specify <b>Dictionary&lt;String, Single&gt; </b>on both sides of the assignment operator. Not only is this a lot of typing, but if you ever decide to change the collection type or any of the generic parameter types, then you would have to modify your code on both sides of the assignment operator, too.</p>
<p>In the <b>foreach </b>loop, I also use <b>var </b>to have the compiler automatically infer the type of the elements inside the collection This demonstrates that it is possible and quite useful to use <b>var </b>with <b>foreach, using, </b>and <b>for </b>statements. It can also be useful when experimenting with code. For example, you initialize an implicitly typed local variable from the return type of a method, and as you develop your method, you might decide to change its return type If you do this, the compiler will automatically figure out that the return type has changed and automatically change the type of the variable! This is great, but of course, other code in the method that uses that variable may no longer compile if the code accesses members using the variable assuming that it was the old type.</p>
<p>In Microsoft Visual Studio, you can hold the mouse cursor over <b>var </b>in your source code and the editor will display a tooltip showing you the type that the compiler infers from the expression. C#'s implicitly typed local variable feature must be used when working with anonymous types within a method; see Chapter 10, &quot;Properties,&quot; for more details.</p>
<p>You cannot declare a method's parameter type using <b>var </b>The reason for this should be obvious to you since the compiler would have to infer the parameter's type from the argument being passed at a callsite and there could be no call sites or many call sites. In addition, you cannot declare a type's field using <b>var </b>. There are many reasons why C# has this restriction. One reason is that fields can be accessed by several methods and the C# team feels that this contract (the type of the variable) should be stated explicitly Another reason is that allowing this would permit an anonymous type (discussed in Chapter 10) to leak outside of a single method.</p>
<hr/>
<blockquote><b>Important </b>Do not confuse <b>dynamic </b>and <b>var </b>. Declaring a local variable using <b>var </b>is just a syntactical shortcut that has the compiler infer the specific data type from an expression. The <b>var </b>keyword can be used only for declaring local variables inside a method while the <b>dynamic </b>keyword can be used for local variables, fields, and arguments. You cannot cast an expression to <b>var, </b>but you can cast an expression to <b>dynamic </b>. You must explicitly initialize a variable declared using <b>var </b>while you do not have to initialize a variable declared with <b>dynamic </b>. For more information about C#'s <b>dynamic </b>type, see the &quot;The dynamic Primitive Type&quot; section in Chapter 5.</blockquote>
<hr/>
<a name="b225"/><h2>Passing Parameters by Reference to a Method</h2>
<p>By default, the common language runtime (CLR) assumes that all method parameters are passed by value When reference type objects are passed, the reference (or pointer) to the object is passed (by value) to the method. This means that the method can modify the object and the caller will see the change. For value type instances, a copy of the instance is passed to the method. This means that the method gets its own private copy of the value type and the instance in the caller isn't affected.</p>
<hr/>
<blockquote><b>Important </b>In a method, you must know whether each parameter passed is a reference type or a value type because the code you write to manipulate the parameter could be markedly different.</blockquote>
<hr/>
<p>The CLR allows you to pass parameters by reference instead of by value. In C#, you do this by using the <b>out </b>and <b>ref </b>keywords. Both keywords tell the C# compiler to emit metadata indicating that this designated parameter is passed by reference, and the compiler uses this to generate code to pass the address of the parameter rather than the parameter itself</p>
<p>From the CLR's perspective, <b>out </b>and <b>ref </b>are identical葉hat is, the same IL is produced regardless of which keyword you use, and the metadata is also identical except for 1 bit, which is used to record whether you specified <b>out </b>or <b>ref </b>when declaring the method. However, the C# compiler treats the two keywords differently, and the difference has to do with which method is responsible for initializing the object being referred to If a method's parameter is marked with <b>out, </b>the caller isn't expected to have initialized the object prior to calling the method The called method can't read from the value, and the called method must write to the value before returning If a method's parameter is marked with <b>ref, </b>the caller must initialize the parameter's value prior to calling the method The called method can read from the value and/or write to the value.</p>
<p>Reference and value types behave very differently with <b>out </b>and <b>ref </b>Let's look at using <b>out </b>and <b>ref </b>with value types first:</p>
<p><code>public sealed class Program { public static void Main() {<br/>
Int32 x;// x is uninitialized<br/>
GetVal(out x);// x doesn't have to be initialized.<br/>
Console.WriteLine(x);   // Displays &quot;10&quot;<br/>
}<br/>
private static void GetVal(out Int32 v) { v = 10;   // This method must initialize v.<br/>
}<br/>
}</code></p>
<p>In this code, <b>x </b>is declared in <b>Main</b>'s stack frame. The address of <b>x </b>is then passed to <b>GetVal. GetVal</b>'s <b>v </b>is a pointer to the <b>Int32 </b>value in <b>Main</b>'s stack frame. Inside <b>GetVal,</b></p>
<p>the <b>Int32 </b>that <b>v </b>points to is changed to <b>10. </b>When <b>GetVal </b>returns, <b>Main</b>'s <b>x </b>has a value of <b>10, </b>and 10 is displayed on the console. Using <b>out </b>with large value types is efficient because it prevents instances of the value type's fields from being copied when making method calls.</p>
<p>Now let's look at an example that uses <b>ref </b>instead of <b>out:</b></p>
<p><code>public sealed class Program { public static void Main() {<br/>
Int32 x = 5;// x is initialized<br/>
AddVal(ref x);// x must be initialized.<br/>
Console.WriteLine(x); // Displays &quot;l5&quot;<br/>
}<br/>
private static void AddVal(ref Int32 v) {<br/>
v += l0;   // This method can use the initialized value in v.<br/>
}<br/>
}</code></p>
<p>In this code, <b>x </b>is also declared in <b>Main</b>'s stack frame and is initialized to <b>5. </b>The address of <b>x </b>is then passed to <b>AddVal. AddVal</b>'s <b>v </b>is a pointer to the <b>Int32 </b>value in <b>Main</b>'s stack frame. Inside <b>AddVal </b>, the <b>Int32 </b>that <b>v </b>points to is required to have a value already So, <b>AddVal </b>can use the initial value in any expression it desires <b>AddVal </b>can also change the value, and the new value will be &quot;returned&quot; to the caller. In this example, <b>AddVal </b>adds <b>10 </b>to the initial value. When <b>AddVal </b>returns, <b>Main</b>'s <b>x </b>will contain <b>15, </b>which is what gets displayed in the console.</p>
<p>To summarize, from an IL or a CLR perspective, <b>out </b>and <b>ref </b>do exactly the same thing: they both cause a pointer to the instance to be passed The difference is that the compiler helps ensure that your code is correct The following code that attempts to pass an uninitialized value to a method expecting a <b>ref </b>parameter produces the following message: <b>&quot;error CS0165: Use of unassigned local variable 'x'.&quot;</b></p>
<p><code>public sealed class Program { public static void Main() {<br/>
Int32 x;// x is not initialized.<br/>
// The following line fails to compile, producing<br/>
// error CS0l65: Use of unassigned local variable 'x'.<br/>
AddVal(ref x);<br/>
Console.WriteLine(x);<br/>
}<br/>
private static void AddVal(ref Int32 v) {<br/>
v += l0;   // This method can use the initialized value in v.<br/>
}<br/>
}</code></p>
<hr/>
<blockquote><b>Important </b>I'm frequently asked why C# requires that a call to a method must specify out or ref. After all, the compiler knows whether the method being called requires out or ref and should be able to compile the code correctly It turns out that the compiler can indeed do the right thing automatically However, the designers of the C# language felt that the caller should explicitly state its intention This way at the call site, it's obvious that the method being called is expected to change the value of the variable being passed.</blockquote>
<hr/>
<p>In addition, the CLR allows you to overload methods based on their use of <b>out </b>and <b>ref </b>parameters. For example, in C#, the following code is legal and compiles just fine:</p>
<p><code>public sealed class Point {<br/>
static void Add(Point p) {... } static void Add(ref Point p) {... }<br/>
}</code></p>
<p>It's not legal to overload methods that differ only by <b>out </b>and <b>ref </b>because the metadata representation of the method's signature for the methods would be identical. So I couldn't also define the following method in the preceding <b>Point </b>type:</p>
<p><code>static void Add(out Point p) {... }</code></p>
<p>If you attempt to include the last <b>Add </b>method in the <b>Point </b>type, the C# compiler issues this message: <b>&quot;error CS0663: 'Add' cannot define overloaded methods that differ only on ref and out.&quot;</b></p>
<p>Using <b>out </b>and <b>ref </b>with value types gives you the same behavior that you already get when passing reference types by value With value types, <b>out </b>and <b>ref </b>allow a method to manipulate a single value type instance. The caller must allocate the memory for the instance, and the callee manipulates that memory. With reference types, the caller allocates memory for a pointer to a reference object, and the callee manipulates this pointer. Because of this behavior, using <b>out </b>and <b>ref </b>with reference types is useful only when the method is going to &quot;return&quot; a reference to an object that it knows about The following code demonstrates:</p>
<p><code>using System; using System.IO;<br/>
public sealed class Program { public static void Main() {<br/>
FileStream fs;     // fs is uninitialized<br/>
// Open the first file to be processed. StartProcessingFiles(out fs);<br/>
// Continue while there are more files to process. for (; fs != null; ContinueProcessingFiles(ref fs)) {<br/>
// Process a file. fs.Read(...);<br/>
}<br/>
}<br/>
private static void StartProcessingFiles(out FileStream fs) {<br/>
fs = new FileStream(...);     // fs must be initialized in this method<br/>
}<br/>
private static void ContinueProcessingFiles(ref FileStream fs) { fs.Close();   // Close the last file worked on.<br/>
// Open the next file, or if no more files, &quot;return&quot; null. if (noMoreFilesToProcess) fs = null; else fs = new FileStream (...);<br/>
}<br/>
}</code></p>
<p>As you can see, the big difference with this code is that the methods that have <b>out </b>or <b>ref </b>reference type parameters are constructing an object, and the pointer to the new object is returned to the caller You'll also notice that the <b>ContinueProcessingFiles </b>method can manipulate the object being passed into it before returning a new object This is possible because the parameter is marked with the <b>ref </b>keyword. You can simplify the preceding code a bit, as shown here:</p>
<p><code>using System; using System.IO;<br/>
public sealed class Program { public static void Main() {<br/>
FileStream fs = null;     // Initialized to null (required)<br/>
// Open the first file to be processed. ProcessFiles(ref fs);<br/>
// Continue while there are more files to process. for (; fs != null; ProcessFiles(ref fs)) {<br/>
// Process a file. fs.Read(...);<br/>
}<br/>
}<br/>
private static void ProcessFiles(ref FileStream fs) { // Close the previous file if one was open.<br/>
if (fs != null) fs.Close();   // Close the last file worked on.<br/>
// Open the next file, or if no more files, &quot;return&quot; null. if (noMoreFilesToProcess) fs = null; else fs = new FileStream (...);<br/>
}<br/>
}</code></p>
<p>Here's another example that demonstrates how to use the <b>ref </b>keyword to implement a method that swaps two reference types:</p>
<p><code>public static void Swap(ref Object a, ref Object b) { Object t = b; b = a; a = t;<br/>
}</code></p>
<p>To swap references to two <b>String </b>objects, you'd probably think that you could write code like this:</p>
<p><code>public static void SomeMethod() { String s1 = &quot;Jeffrey&quot;; String s2 = &quot;Richter&quot;;<br/>
Swap(ref s1, ref s2);<br/>
Console.WriteLine(s1); // Displays &quot;Richter&quot; Console.WriteLine(s2);   // Displays &quot;Jeffrey&quot;<br/>
}</code></p>
<p>However, this code won't compile. The problem is that variables passed by reference to a method must be of the same type as declared in the method signature In other words, <b>Swap </b>expects two <b>Object </b>references, not two <b>String </b>references. To swap the two <b>String </b>references, you must do this:</p>
<p><code>public static void SomeMethod() { String s1 = &quot;Jeffrey&quot;; String s2 = &quot;Richter&quot;;<br/>
// Variables that are passed by reference // must match what the method expects. Object o1 = s1, o2 = s2; Swap(ref o1, ref o2);<br/>
// Now cast the objects back to strings. s1 = (String) o1; s2 = (String) o2;<br/>
Console.WriteLine(s1); // Displays &quot;Richter&quot; Console.WriteLine(s2);   // Displays &quot;Jeffrey&quot;<br/>
}</code></p>
<p>This version of <b>SomeMethod </b>does compile and execute as expected The reason why the parameters passed must match the parameters expected by the method is to ensure that type safety is preserved. The following code, which thankfully won't compile, shows how type safety could be compromised.</p>
<p><code>internal sealed class SomeType { public Int32 m_val;<br/>
}<br/>
public sealed class Program { public static void Main() { SomeType st;<br/>
// The following line generates error CSl503: Argument 'l': // cannot convert from 'ref SomeType' to 'ref object'. GetAnObject(out st);<br/>
Console.WriteLine(st.m_val);<br/>
}<br/>
private static void GetAnObject(out Object o) { o = new StringCX', l00);<br/>
}<br/>
}</code></p>
<p>In this code, <b>Main </b>clearly expects <b>GetAnObject </b>to return a <b>SomeType </b>object. However, because <b>GetAnObject</b>'s signature indicates a reference to an <b>Object, GetAnObject </b>is free to initialize <b>o </b>to an object of any type. In this example, when <b>GetAnObject </b>returned to <b>Main, st </b>would refer to a <b>String, </b>which is clearly not a <b>SomeType </b>object, and the call to <b>Console.WriteLine </b>would certainly fail. Fortunately, the C# compiler won't compile the preceding code because <b>st </b>is a reference to <b>SomeType, </b>but <b>GetAnObject </b>requires a reference to an <b>Object </b>.</p>
<p>You can use generics to fix these methods so that they work as you'd expect. Here is how to fix the <b>Swap </b>method shown earlier:</p>
<p><code>public static void Swap&lt;T&gt;(ref T a, ref T b) { T t = b; b = a; a = t;<br/>
}</code></p>
<p>And now, with <b>Swap </b>rewritten as above, the following code (identical to that shown before) will compile and run perfectly:</p>
<p><code>public static void SomeMethod() { String sl = &quot;Jeffrey&quot;; String s2 = &quot;Richter&quot;;<br/>
Swap(ref sl, ref s2);<br/>
Console.WriteLine(sl); // Displays &quot;Richter&quot; Console.WriteLine(s2);   // Displays &quot;Jeffrey&quot;<br/>
}</code></p>
<p>For some other examples that use generics to solve this problem, see <b>System.Threading</b>'s <b>Interlocked </b>class with its <b>CompareExchange </b>and <b>Exchange </b>methods.</p>
<a name="b231"/><h2>Passing a Variable Number of Arguments to a Method</h2>
<p>It's sometimes convenient for the developer to define a method that can accept a variable number of arguments. For example, the <b>System.String </b>type offers methods allowing an arbitrary number of strings to be concatenated together and methods allowing the caller to specify a set of strings that are to be formatted together.</p>
<p>To declare a method that accepts a variable number of arguments, you declare the method as follows:</p>
<p><code>static Int32 Add(params Int32[] values) {<br/>
// NOTE: it is possible to pass the 'values' // array to other methods if you want to.<br/>
Int32 sum = 0;<br/>
if (values != null) {<br/>
for (Int32 x = 0; x &lt; values.Length; x++) sum += values[x];<br/>
}<br/>
return sum;<br/>
}</code></p>
<p>Everything in this method should look very familiar to you except for the <b>params </b>keyword that is applied to the last parameter of the method signature Ignoring the <b>params </b>keyword for the moment, it's obvious that this method accepts an array of <b>Int32 </b>values and iterates over the array, adding up all of the values. The resulting <b>sum </b>is returned to the caller.</p>
<p>Obviously, code can call this method as follows:</p>
<p><code>public static void Main() { // Displays &quot;15&quot;<br/>
Console.WriteLine(Add(new Int32[] { 1, 2, 3, 4, 5 }.);<br/>
}</code></p>
<p>It's clear that the array can easily be initialized with an arbitrary number of elements and then passed off to <b>Add </b>for processing Although the preceding code would compile and work correctly, it is a little ugly. As developers, we would certainly prefer to have written the call to <b>Add </b>as follows:</p>
<p><code>public static void Main() { // Displays &quot;15&quot;<br/>
Console.WriteLine(Add(1, 2, 3, 4, 5));<br/>
}</code></p>
<p>You'll be happy to know that we can do this because of the <b>params </b>keyword. The <b>params </b>keyword tells the compiler to apply an instance of the <b>System.ParamArrayAttribute </b>custom attribute to the parameter.</p>
<p>When the C# compiler detects a call to a method, the compiler checks all of the methods with the specified name, where no parameter has the <b>ParamArray </b>attribute applied. If a method exists that can accept the call, the compiler generates the code necessary to call the method. However, if the compiler can't find a match, it looks for methods that have a <b>ParamArray </b>attribute to see whether the call can be satisfied. If the compiler finds a match, it emits code that constructs an array and populates its elements before emitting the code that calls the selected method.</p>
<p>In the previous example, no <b>Add </b>method is defined that takes five <b>Int32</b>-compatible arguments; however, the compiler sees that the source code has a call to <b>Add </b>that is being passed a list of <b>Int32 </b>values and that there is an <b>Add </b>method whose array-of<b>-Int32 </b>parameter is marked with the <b>ParamArray </b>attribute. So the compiler considers this a match and generates code that coerces the parameters into an <b>Int32 </b>array and then calls the <b>Add </b>method. The end result is that you can write the code, easily passing a bunch of parameters to <b>Add, </b>but the compiler generates code as though you'd written the first version that explicitly constructs and initializes the array.</p>
<p>Only the last parameter to a method can be marked with the <b>params </b>keyword <b>(ParamArrayAttribute). </b>This parameter must also identify a single-dimension array of any type. It's legal to pass <b>null </b>or a reference to an array of <b>0 </b>entries as the last parameter to the method. The following call to <b>Add </b>compiles fine, runs fine, and produces a resulting sum of <b>0 </b>(as expected):</p>
<p><code>public static void Main() {<br/>
// Both of these lines display &quot;0&quot;<br/>
Console.WriteLine(Add());        // passes new Int32[0] to Add<br/>
Console.WriteLine(Add(null)); // passes null to Add: more efficient (no array allocated)<br/>
}</code></p>
<p>So far, all of the examples have shown how to write a method that takes an arbitrary number of <b>Int32 </b>parameters. How would you write a method that takes an arbitrary number of parameters where the parameters could be any type? The answer is very simple: just modify the method's prototype so that it takes an <b>Object[] </b>instead of an <b>Int32[]. </b>Here's a method that displays the <b>Type </b>of every object passed to it:</p>
<p><code>public sealed class Program { public static void Main() {<br/>
DisplayTypes(new Object(), new Random(), &quot;Jeff&quot;, 5);<br/>
}<br/>
private static void DisplayTypes(params Object[] objects) { if (objects != null) {<br/>
foreach (Object o in objects)<br/>
Console.WriteLine(o.GetType());<br/>
}<br/>
}<br/>
}</code></p>
<p>Running this code yields the following output:</p>
<p><code>System.Object System.Random System.String System.Int32</code></p>
<hr/>
<blockquote><b>Important </b>Be aware that calling a method that takes a variable number of arguments incurs an additional performance hit unless you explicitly pass <b>null</b>. After all, an array object must be allocated on the heap, the array's elements must be initialized, and the array's memory must ultimately be garbage collected To help reduce the performance hit associated with this, you may want to consider defining a few overloaded methods that do not use the <b>params </b>keyword. For some examples, look at the <b>System.String </b>class's <b>Concat </b>method, which has the following overloads:</blockquote>
<hr/>
<p><code>public sealed class String : Object, ... { public static string Concat(object arg0); public static string Concat(object arg0, object argl); public static string Concat(object arg0, object argl, object arg2); public static string Concat(params object[] args);<br/>
public static string Concat(string str0, string strl);<br/>
public static string Concat(string str0, string strl, string str2);<br/>
public static string Concat(string str0, string strl, string str2, string str3);<br/>
public static string Concat(params string[] values);<br/>
}</code></p>
<p>As you can see, the <b>Concat </b>method defines several overloads that do not use the <b>params </b>keyword These versions of the <b>Concat </b>method are the most frequently called overloads, and these overloads exist in order to improve performance for the most common scenarios The overloads that use the <b>params </b>keyword are there for the less common scenarios; these scenarios will suffer a performance hit, but fortunately, they are rare.</p>
<a name="b233"/><h2>Parameter and Return Type Guidelines</h2>
<p>When declaring a method's parameter types, you should specify the weakest type possible, preferring interfaces over base classes For example, if you are writing a method that manipulates a collection of items, it would be best to declare the method's parameter by using an interface such as <b>IEnumerable&lt;T&gt; </b>rather than using a strong data type such as <b>List&lt;T&gt; </b>or even a stronger interface type such as <b>ICollection&lt;T&gt; </b>or <b>IList&lt;T&gt;:</b></p>
<p><code>// Desired: This method uses a weak parameter type<br/>
public void ManipulateItems&lt;T&gt;(IEnumerable&lt;T&gt; collection) {... }<br/>
// Undesired: This method uses a strong parameter type public void ManipulateItems&lt;T&gt;(List&lt;T&gt; collection) {... }</code></p>
<p>The reason, of course, is that someone can call the first method passing in an array object, a <b>List&lt;T&gt; </b>object, a <b>String </b>object, and so on預ny object whose type implements <b>IEnumerable&lt;T&gt; </b>. The second method allows only <b>List&lt;T&gt; </b>objects to be passed in; it will not accept an array or a <b>String </b>object. Obviously, the first method is better because it is much more flexible and can be used in a much wider range of scenarios.</p>
<p>Naturally, if you are writing a method that requires a list (not just any enumerable object), then you should declare the parameter type as an <b>IList&lt;T&gt;. </b>You should still avoid declaring the parameter type as <b>List&lt;T&gt; </b>. Using <b>IList&lt;T&gt; </b>allows the caller to pass arrays and any other objects whose type implements <b>IList&lt;T&gt;</b></p>
<p>Note that my examples talked about collections, which are designed using an interface architecture If we were talking about classes designed using a base class architecture, the concept still applies So, for example, if I were implementing a method that processed bytes from a stream, we'd have this:</p>
<p><code>// Desired: This method uses a weak parameter type public void ProcessBytes(Stream someStream) {... }<br/>
// Undesired: This method uses a strong parameter type public void ProcessBytes(FileStream fileStream) {... }</code></p>
<p>The first method can process bytes from any kind of stream: a <b>FileStream, </b>a <b>NetworkStream, </b>a <b>MemoryStream, </b>and so on The second method can operate only on a <b>FileStream, </b>making it far more limited.</p>
<p>On the flip side, it is usually best to declare a method's return type by using the strongest type possible (trying not to commit yourself to a specific type). For example, it is better to declare a method that returns a <b>FileStream </b>object as opposed to returning a <b>Stream </b>object:</p>
<p><code>// Desired: This method uses a strong return type public FileStream OpenFile() {... }<br/>
// Undesired: This method uses a weak return type public Stream OpenFile() {... }</code></p>
<p>Here, the first method is preferred because it allows the method's caller the option of treating the returned object as either a <b>FileStream </b>object or as a <b>Stream </b>object. Meanwhile, the second method requires that the caller treat the returned object as a <b>Stream </b>object Basically, it is best to let the caller have as much flexibility as possible when calling a method, allowing the method to be used in the widest range of scenarios.</p>
<p>Sometimes you want to retain the ability to change the internal implementation of a method without affecting the callers. In the example just shown, the <b>OpenFile </b>method is unlikely to ever change its internal implementation to return anything other than a <b>FileStream </b>object (or an object whose type is derived from <b>FileStream). </b>However, if you have a method that returns a <b>List&lt;String&gt; </b>object, you might very well want to change the internal implementation of this method in the future so that it would instead return a <b>String[]. </b>In the cases in which you want to leave yourself some flexibility to change what your method returns, choose a weaker return type For example:</p>
<p><code>// Flexible: This method uses a weaker return type public IList&lt;String&gt; GetStringCollection() {... }<br/>
// Inflexible: This method uses a stronger return type public List&lt;String&gt; GetStringCollection() {... }</code></p>
<p>In this example, even though the <b>GetStringCollection </b>method uses a <b>List&lt;String&gt; </b>object internally and returns it, it is better to prototype the method as returning an <b>IList&lt;String&gt; </b>instead. In the future, the <b>GetStringCollection </b>method could change its internal collection to use a <b>String[], </b>and callers of the method won't be required to change any of their source code. In fact, they won't even have to recompile their code. Notice in this example that I'm using the strongest of the weakest types. For instance, I'm not using an <b>IEnumerable&lt;String&gt; </b>or even <b>ICollection&lt;String&gt; </b>.</p>
<a name="b235"/><h2>Const-ness</h2>
<p>In some languages, such as unmanaged C++, it is possible to declare methods or parameters as a constant that forbids the code in an instance method from changing any of the object's fields or prevents the code from modifying any of the objects passed into the method. The CLR does not provide for this, and many programmers have been lamenting this missing feature. Since the CLR doesn't offer this feature, no language (including C#) can offer this feature.</p>
<p>First, you should note that in unmanaged C++, marking an instance method or parameter as <b>const </b>ensured only that the programmer could not write normal code that would modify the object or parameter. Inside the method, it was always possible to write code that could mutate the object/parameter by either casting away the <b>const</b>-ness or by getting the address of the object/argument and then writing to the address. In a sense, unmanaged C++ lied to programmers, making them believe that their constant objects/arguments couldn't be written to even though they could.</p>
<p>When designing a type's implementation, the developer can just avoid writing code that manipulates the object/arguments. For example, strings are immutable because the <b>String </b>class doesn't offer any methods that can change a string object.</p>
<p>Also, it would be very difficult for Microsoft to endow the CLR with the ability to verify that a constant object/argument isn't being mutated. The CLR would have to verify at each write that the write was not occurring to a constant object, and this would hurt performance significantly. Of course, a detected violation would result in the CLR throwing an exception. Furthermore, constant support adds a lot of complexity for developers. For example, if a type is immutable, all derived types would have to respect this. In addition, an immutable type would probably have to consist of fields that are also of immutable types.</p>
<p>These are just some of the reasons why the CLR does not support constant objects/arguments.</p>
<mbp:pagebreak/>
<a name="Chapter10"/>
<h1>Chapter 10: Properties</h1>
<p><b>In this chapter:</b></p>
<a href="#b257">The Performance of Calling Property Accessor Methods</a><br/>
<a href="#b258">Property Accessor Accessibility</a><br/>
<a href="#b258_">Generic Property Accessor Methods</a><br/>
<p>In this chapter, I'll talk about properties. Properties allow source code to call a method by using a simplified syntax. The common language runtime (CLR) offers two kinds of properties: parameterless properties, which are simply called properties, and parameterful properties, which are called different names by different programming languages. For example, C# calls parameterful properties indexers, and Microsoft Visual Basic calls them default properties. I'll also talk about initializing properties using object and collection initializers as well as ways to package a bunch of properties together using C#'s anonymous types and the <b>System.Tuple </b>type.</p>
<h2>Parameterless Properties</h2>
<p>Many types define state information that can be retrieved or altered. Frequently, this state information is implemented as field members of the type. For example, here's a type definition that contains two fields:</p>
<p><code>public sealed class Employee {<br/>
public String Name; // The employee's name public Int32   Age;   // The employee's age<br/>
}</code></p>
<p>If you were to create an instance of this type, you could easily get or set any of this state information with code similar to the following:</p>
<p><code>Employee e = new Employee();<br/>
e.Name = &quot;Jeffrey Richter&quot;;   // Set the employee's Name. e.Age   = 45;// Set the employee's Age.<br/>
Console.WriteLine(e.Name);     // Displays &quot;Jeffrey Richter&quot;</code></p>
<p>Querying and setting an object's state information in the way I just demonstrated is very common. However, I would argue that the preceding code should never be implemented as shown. One of the hallmarks of object-oriented design and programming is data encapsulation. Data encapsulation means that your type's fields should never be publicly exposed because it's too easy to write code that improperly uses the fields, corrupting the object's state. For example, a developer could easily corrupt an <b>Employee </b>object with code like this:</p>
<p><code>e.Age = -5; // How could someone be -5 years old?</code></p>
<p>There are additional reasons for encapsulating access to a type's data field. For example, you might want access to a field to execute some side effect, cache some value, or lazily create some internal object. You might also want access to the field to be thread-safe. Or perhaps the field is a logical field whose value isn't represented by bytes in memory but whose value is instead calculated using some algorithm.</p>
<p>For any of these reasons, when designing a type, I strongly suggest that all of your fields be <b>private </b>. Then, to allow a user of your type to get or set state information, you expose methods for that specific purpose. Methods that wrap access to a field are typically called accessor methods. These accessor methods can optionally perform sanity checking and ensure that the object's state is never corrupted. For example, I'd rewrite the previous class as follows:</p>
<p><code>public sealed class Employee {<br/>
private String m_Name; // Field is now private private Int32   m_Age;        // Field is now private<br/>
public String GetName() { return(m_Name);<br/>
}<br/>
public void SetName(String value) { m_Name = value;<br/>
}<br/>
public Int32 GetAge() { return(m_Age);<br/>
}<br/>
public void SetAge(Int32 value) { if (value &lt; 0)<br/>
throw new ArgumentOutOfRangeException(&quot;value&quot;, value.ToString(), &quot;The value must be greater than or equal to 0&quot;); m_Age = value;<br/>
}<br/>
}</code></p>
<p>Although this is a simple example, you should still be able to see the enormous benefit you get from encapsulating the data fields. You should also be able to see how easy it is to make read-only or write-only properties: just don't implement one of the accessor methods. Alternatively, you could allow only derived types to modify the value by marking the <b>SetXxx </b>method as <b>protected </b>.</p>
<p>Encapsulating the data as shown earlier has two disadvantages. First, you have to write more code because you now have to implement additional methods Second, users of the type must now call methods rather than simply refer to a single field name.</p>
<p><code>e.SetName(&quot;Jeffrey Richter&quot;);// updates the employee's name<br/>
String EmployeeName = e.GetName(); // retrieves the employee's name e.SetAge(4l);// Updates the employee's age<br/>
e.SetAge(-5);// Throws ArgumentOutOfRangeException<br/>
Int32 EmployeeAge = e.GetAge();      // retrieves the employee's age</code></p>
<p>Personally, I think these disadvantages are quite minor. Nevertheless, programming languages and the CLR offer a mechanism called properties that alleviates the first disadvantage a little and removes the second disadvantage entirely.</p>
<p>The class shown here uses properties and is functionally identical to the class shown earlier:</p>
<p><code>public sealed class Employee { private String m_Name; private Int32 m_Age;<br/>
public String Name {<br/>
get { return(m_Name); }<br/>
set { m_Name = value; } // The 'value' keyword always identifies the new value.<br/>
}<br/>
public Int32 Age {<br/>
get { return(m_Age); } set {<br/>
if (value &lt; 0)      // The 'value' keyword always identifies the new value. throw new ArgumentOutOfRangeException(&quot;value&quot;, value.ToString(), &quot;The value must be greater than or equal to 0&quot;); m_Age = value;<br/>
}<br/>
}<br/>
}</code></p>
<p>As you can see, properties complicate the definition of the type slightly, but the fact that they allow you to write your code as follows more than compensates for the extra work:</p>
<p><code>e.Name = &quot;Jeffrey Richter&quot;;     // &quot;sets&quot; the employee name<br/>
String EmployeeName = e.Name; // &quot;gets&quot; the employee's name<br/>
e.Age = 4l;// &quot;sets&quot; the employee's age<br/>
e.Age = -5;// Throws ArgumentOutOfRangeException<br/>
Int32 EmployeeAge = e.Age;      // &quot;gets&quot; the employee's age</code></p>
<p>You can think of properties as smart fields: fields with additional logic behind them. The CLR supports static, instance, abstract, and virtual properties In addition, properties can be marked with any accessibility modifier (discussed in Chapter 6, &quot;Type and Member Basics&quot;) and defined within an interface (discussed in Chapter 13, &quot;Interfaces&quot;).</p>
<p>Each property has a name and a type (which can't be <b>void) </b>. It isn't possible to overload properties (that is, have two properties with the same name if their types are different).</p>
<p>When you define a property, you typically specify both a <b>get </b>and a <b>set </b>method. However, you can leave out the <b>set </b>method to define a read-only property or leave out the <b>get </b>method to define a write-only property.</p>
<p>It's also quite common for the property's <b>get/set </b>methods to manipulate a private field defined within the type. This field is commonly referred to as the backing field. The <b>get </b>and <b>set </b>methods don't have to access a backing field, however. For example, the <b>System.Threading.Thread </b>type offers a <b>Priority </b>property that communicates directly with the operating system; the <b>Thread </b>object doesn't maintain a field for a thread's priority. Another example of properties without backing fields are those read-only properties calculated at runtime庸or example, the length of a zero-terminated array or the area of a rectangle when you have its height and width.</p>
<p>When you define a property, depending on its definition, the compiler will emit either two or three of the following items into the resulting managed assembly:</p>
<p>&#9632; A method representing the property's <b>get </b>accessor method. This is emitted only if you define a <b>get </b>accessor method for the property.</p>
<p>&#9632; A method representing the property's <b>set </b>accessor method. This is emitted only if you define a <b>set </b>accessor method for the property.</p>
<p>&#9632; A property definition in the managed assembly's metadata. This is always emitted.</p>
<p>Refer back to the <b>Employee </b>type shown earlier. As the compiler compiles this type, it comes across the <b>Name </b>and <b>Age </b>properties Because both properties have <b>get </b>and <b>set </b>accessor methods, the compiler emits four method definitions into the <b>Employee </b>type. It's as though the original source were written as follows:</p>
<p><code>public sealed class Employee { private String m_Name; private Int32 m_Age;<br/>
public String get_Name(){ return m_Name;<br/>
}<br/>
public void     set_Name(String value) {<br/>
m_Name = value; // The argument 'value' always identifies the new value.<br/>
}<br/>
public Int32 get_Age() { return m_Age;<br/>
}<br/>
public void   set_Age(Int32 value) {<br/>
if (value &lt; 0)// The 'value' always identifies the new value.<br/>
throw new ArgumentOutOfRangeException(&quot;value&quot;, value.ToString(), &quot;The value must be greater than or equal to 0&quot;); m_Age = value;<br/>
}<br/>
}</code></p>
<p>The compiler automatically generates names for these methods by prepending <b>get_ </b>or <b>set_ </b>to the property name specified by the developer.</p>
<p>C# has built-in support for properties. When the C# compiler sees code that's trying to get or set a property, the compiler actually emits a call to one of these methods. If you're using a programming language that doesn't directly support properties, you can still access properties by calling the desired accessor method. The effect is exactly the same; it's just that the source code doesn't look as pretty.</p>
<p>In addition to emitting the accessor methods, compilers also emit a property definition entry into the managed assembly's metadata for each property defined in the source code. This entry contains some flags and the type of the property, and it refers to the <b>get </b>and <b>set </b>accessor methods. This information exists simply to draw an association between the abstract concept of a &quot;property&quot; and its accessor methods. Compilers and other tools can use this metadata, which can be obtained by using the <b>System.Reflection.PropertyInfo </b>class. The CLR doesn't use this metadata information and requires only the accessor methods at runtime.</p>
<h3>Automatically Implemented Properties</h3>
<p>If you are creating a property to simply encapsulate a backing field, then C# offers a simplified syntax known as automatically implemented properties (AIPs), as shown here for the <b>Name </b>property:</p>
<p><code>public sealed class Employee {<br/>
// This property is an automatically implemented property public String Name { get; set; }<br/>
private Int32 m_Age;<br/>
public Int32 Age {<br/>
get { return(m_Age); } set {<br/>
if (value &lt; 0)      // The 'value' keyword always identifies the new value. throw new ArgumentOutOfRangeException(&quot;value&quot;, value.ToString(), &quot;The value must be greater than or equal to 0&quot;); m_Age = value;<br/>
}<br/>
}<br/>
}</code></p>
<p>When you declare a property and do not provide an implementation for the <b>get/set </b>methods, then the C# compiler will automatically declare for you a private field. In this example, the field will be of type <b>String, </b>the type of the property. And, the compiler will automatically implement the <b>get_Name </b>and <b>set_Name </b>methods for you to return the value in the field and to set the field's value, respectively.</p>
<p>You might wonder what the value of doing this is, as opposed to just declaring a <b>public String </b>field called <b>Name. </b>Well, there is a big difference. Using the AIP syntax means that you have created a property. Any code that accesses this property is actually calling <b>get </b>and <b>set </b>methods. If you decide later to implement the <b>get </b>and/or <b>set </b>method yourself instead of accepting the compiler's default implementation, then any code that accesses the property will not have to be recompiled. However, if you declared <b>Name </b>as a field and then you later change it to a property, then all code that accessed the field will have to be recompiled so that it now accesses the property methods.</p>
<p>&#9632; Personally, I do not like the compiler's AIP feature, so I usually avoid it for the following reason: The syntax for a field declaration can include initialization so that you are declaring and initializing the field in one line of code. However, there is no convenient syntax to set an AIP to an initial value. Therefore, you must explicitly initialize each AIP in each constructor method.</p>
<p>&#9632; The runtime serialization engines persist the name of the field in a serialized stream. The name of the backing field for an AIP is determined by the compiler, and it could actually change the name of this backing field every time you recompile your code, negating the ability to deserialize instances of any types that contain an AIP. Do not use the AIP feature with any type you intend to serialize or deserialize.</p>
<p>&#9632; When debugging, you cannot put a breakpoint on an AIP <b>get </b>or <b>set </b>method, so you cannot easily detect when an application is getting or setting this property. You can set breakpoints on manually implemented properties, which can be quite handy when tracking down bugs.</p>
<p>You should also know that when you use AIPs, the property must be readable and writable; that is, the compiler must produce both <b>get </b>and <b>set </b>methods This makes sense because a write-only field is not useful without the ability to read its value; likewise, a read-only field would always have its default value. In addition, since you do not know the name of the compiler-generated backing field, your code must always access the property by using the property name. And, if you decide you want to explicitly implement one of the accessor methods, then you must explicitly implement both accessor methods and you are not using the AIP feature anymore. For a single property, the AIP feature is an all-or-nothing deal.</p>
<h3>Defining Properties Intelligently</h3>
<p>Personally, I don't like properties and I wish that they were not supported in the Microsoft .NET Framework and its programming languages. The reason is that properties look like fields, but they are methods. This has been known to cause a phenomenal amount of confusion. When a programmer sees code that appears to be accessing a field, there are many assumptions that the programmer makes that may not be true for a property. For example,</p>
<p>&#9632; A property may be read-only or write-only; field access is always readable and writable. If you define a property, it is best to offer both <b>get </b>and <b>set </b>accessor methods.</p>
<p>&#9632; A property method may throw an exception; field access never throws an exception.</p>
<p>&#9632; A property cannot be passed as an <b>out </b>or <b>ref </b>parameter to a method; a field can. For example, the following code will not compile:</p>
<p><code>using System;<br/>
public sealed class SomeType { private static String Name { get { return null; } set {}<br/>
}<br/>
static void MethodWithOutParam(out String n) { n = null; }<br/>
public static void Main() {<br/>
// For the line of code below, the C# compiler emits the following: // error CS0206: A property or indexer may not // be passed as an out or ref parameter MethodWithOutParam(out Name);<br/>
}<br/>
}</code></p>
<p>&#9632; A property method can take a long time to execute; field access always completes immediately. A common reason to use properties is to perform thread synchronization, which can stop the thread forever, and therefore, a property should not be used if thread synchronization is required In that situation, a method is preferred Also, if your class can be accessed remotely (for example, your class is derived from <b>System.MarshalByRefObject), </b>calling the property method will be very slow, and therefore, a method is preferred to a property. In my opinion, classes derived from <b>MarshalByRefObject </b>should never use properties.</p>
<p>&#9632; If called multiple times in a row, a property method may return a different value each time; a field returns the same value each time. The <b>System.DateTime </b>class has a readonly <b>Now </b>property that returns the current date and time. Each time you query this property, it will return a different value. This is a mistake, and Microsoft wishes that they could fix the class by making <b>Now </b>a method instead of a property. <b>Environment</b>'s <b>TickCount </b>property is another example of this mistake.</p>
<p>&#9632; A property method may cause observable side effects; field access never does. In other words, a user of a type should be able to set various properties defined by a type in any order he or she chooses without noticing any different behavior in the type.</p>
<p>&#9632; A property method may require additional memory or return a reference to something that is not actually part of the object's state, so modifying the returned object has no effect on the original object; querying a field always returns a reference to an object that is guaranteed to be part of the original object's state Working with a property that returns a copy can be very confusing to developers, and this characteristic is frequently not documented.</p>
<p>It has come to my attention that people use properties far more often than they should. If you examine this list of differences between properties and fields, you'll see that there are very few circumstances in which defining a property is actually useful and will not cause confusion for developers. The only thing that properties buy you is some simplified syntax; there is no performance benefit compared to calling a non-property method, and understandability of the code is reduced. If I had been involved in the design of the .NET Framework and compilers, I would have not offered properties at all; instead, I would have programmers actually implement <b>GetXxx </b>and <b>SetXxx </b>methods as desired. Then, if compilers wanted to offer some special, simplified syntax for calling these methods, so be it. But I'd want the compiler to use syntax that is different from field access syntax so that programmers really understand what they are doing預 method call.</p>
<p>r</p>
<p>Microsoft Visual Studio allows you to enter an object's property in the debugger's watch window. When you do this, every time you hit a breakpoint, the debugger calls into the property's <b>get </b>accessor method and displays the returned value. This can be quite helpful in tracking down bugs, but it can also cause bugs to occur and hurt your debugging performance. For example, let's say that you have created a <b>FileStream </b>for a file on a network share and then you add <b>FileStream</b>'s <b>Length </b>property to the debugger's watch window. Now, every time you hit a breakpoint, the debugger will call <b>Length</b>'s <b>get </b>accessor method, which internally makes a network request to the server to get the current length of the file!</p>
<p>Similarly, if your property's <b>get </b>accessor method has a side effect, then this side effect will execute every time you hit a breakpoint. For example, let's say that your property's <b>get </b>accessor method increments a counter every time it is called; this counter will now be incremented every time you hit a breakpoint, too. Because of these potential problems, Visual Studio allows you to turn off property evaluation for properties shown in watch windows. To turn property evaluation off in Visual Studio, select Tools, Options, Debugging, and General and in the list box in Figure 10-1, and clear the Enable Property Evaluation And Other Implicit Function Calls option. Note that even with this item cleared, you can add the property to the watch window and manually force Visual Studio to evaluate it by clicking the force evaluation circle in the watch window's Value column.</p>
<h3>Object and Collection Initializers</h3>
<p>It is very common to construct an object and then set some of the object's public properties (or fields). To simplify this common programming pattern, the C# language supports a special object initialization syntax. Here is an example:</p>
<p><code>Employee e = new Employee() { Name = &quot;Jeff&quot;, Age = 45 };</code></p>
<p>With this one statement, I am constructing an <b>Employee </b>object, calling its parameterless constructor, and then setting its public <b>Name </b>property to <b>&quot;Jeff&quot; </b>and its public <b>Age </b>property to <b>45. </b>In fact, the code above is identical to this, which you could verify by examining the Intermediate Language (IL) for both of these code fragments:</p>
<p><code>Employee e = new Employee(); e.Name = &quot;Jeff&quot;; e.Age = 45;</code></p>
<p>The real benefit of the object initializer syntax is that it allows you to code in an expression context (as opposed to a statement context), permitting composability of functions, which in turn increases code readability For example, I can now write this:</p>
<p><code>String s = new Employee() { Name = &quot;Jeff&quot;, Age = 45 }.ToString().ToUpper();</code></p>
<p>So now, in one statement, I have constructed an <b>Employee </b>object, called its constructor, initialized two public properties, and then, using the resulting expression, called <b>ToString </b>on it followed by calling <b>ToUpper </b>. For more about composability of functions, see the &quot;Extension Methods&quot; section in Chapter 8, &quot;Methods.&quot;</p>
<img src="35.jpg"/>
<p><b>Figure 10-1 </b>Visual Studio's General Debugger settings</p>
<p>As a small side note, C# also lets you omit the parentheses before the open brace if you want to call a parameterless constructor. The line below produces the same IL as the line above:</p>
<p><code>String s = new Employee { Name = &quot;Jeff&quot;, Age = 45 }.ToString().ToUpper();</code></p>
<p>If a property's type implements the <b>IEnumerable </b>or <b>IEnumerable&lt;T&gt; </b>interface, then the property is considered to be a collection, and initializing a collection is an additive operation as opposed to a replacement operation For example, suppose I have the following class definition:</p>
<p><code>public sealed class Classroom {<br/>
private List&lt;String&gt; m_students = new List&lt;String&gt;(); public List&lt;String&gt; Students { get { return m_students; } }<br/>
public Classroom() {}<br/>
}</code></p>
<p>I can now have code that constructs a <b>Classroom </b>object and initializes the <b>Students </b>collection as follows:</p>
<p><code>public static void M() {<br/>
Classroom classroom = new Classroom {<br/>
Students = { &quot;Jeff&quot;, &quot;Kristin&quot;, &quot;Aidan&quot;, &quot;Grant&quot; }<br/>
};<br/>
// Show the 4 students in the classroom foreach (var student in classroom.Students) Console.WriteLine(student);<br/>
}</code></p>
<p>When compiling this code, the compiler sees that the <b>Students </b>property is of type <b>List&lt;String&gt; </b>and that this type implements the <b>IEnumerable&lt;String&gt; </b>interface. Now, the compiler assumes that the <b>List&lt;String&gt; </b>type offers a method called <b>Add </b>(because most collection classes actually offer an <b>Add </b>method that adds items to the collection). The compiler then generates code to call the collection's <b>Add </b>method So, the code shown above is converted by the compiler into this:</p>
<p><code>public static void M() {<br/>
Classroom classroom = new Classroom();<br/>
classroom.Students.Add(&quot;Jeff&quot;);<br/>
classroom.Students.Add(&quot;Kristin&quot;);<br/>
classroom.Students.Add(&quot;Aidan&quot;);<br/>
classroom.Students.Add(&quot;Grant&quot;);<br/>
// Show the 4 students in the classroom foreach (var student in classroom.Students) Console.WriteLine(student);<br/>
}</code></p>
<p>If the property's type implements <b>IEnumerable </b>or <b>IEnumerable&lt;T&gt; </b>but the type doesn't offer an <b>Add </b>method, then the compiler does not let you use the collection initialize syntax to add items to the collection; instead, the compiler issues something like the following message: <b>&quot;error CS0117: 'System.Collections.Generic.IEnumerable&lt;string&gt;' does not contain a definition for 'Add'.&quot;</b></p>
<p>Some collection's <b>Add </b>methods take multiple arguments For example, <b>Dictionary</b>'s <b>Add </b>method:</p>
<p><code>public void Add(TKey key, TValue value);</code></p>
<p>You can pass multiple arguments to an <b>Add </b>method by using nested braces in a collection initializer, as follows:</p>
<p><code>var table = new Dictionary&lt;String, Int32&gt; {<br/>
{ &quot;Jeffrey&quot;, 1 }, { &quot;Kristin&quot;, 2 }, { &quot;Aidan&quot;, 3 }, { &quot;Grant&quot;, 4 }<br/>
};</code></p>
<p>The line above is identical to:</p>
<p><code>var table = new Dictionary&lt;String, Int32&gt;(); table.AddC'Jeffrey&quot;, 1); table.Add(&quot;Kristin&quot;, 2); table.AddC'Aidan&quot;, 3); table.AddC'Grant&quot;, 4);</code></p>
<h3>Anonymous Types</h3>
<p>C#'s anonymous type feature allows you to automatically declare an immutable tuple type using a very simple and succinct syntax. A tuple type<sup>1</sup> is a type that contains a collection of properties that are usually related to each other in some way. In the top line of the code below, I am defining a class with two properties <b>(Name </b>of type <b>String, </b>and <b>Year </b>of type <b>Int32), </b>constructing an instance of this type, and setting its <b>Name </b>property to <b>&quot;Jeff&quot; </b>and its <b>Year </b>property to <b>1964</b>.</p>
<p><code>// Define a type, construct an instance of it, &amp; initialize its properties var ol = new { Name = &quot;Jeff&quot;, Year = 1964 };<br/>
// Display the properties on the console:<br/>
Console.WriteLine(&quot;Name={0}, Year={1}&quot;, ol.Name, ol.Year);// Displays: Name=Jeff, Year=1964</code></p>
<p>This top line of code creates an anonymous type because I did not specify a type name after the <b>new </b>keyword, so the compiler will create a type name for me automatically and not tell me what it is (which is why it is called an anonymous type) The line of code uses the object initializer syntax discussed in the previous section to declare the properties and also to initialize these properties Also, since I (the developer) do not know the name of the type at compile time, I do not know what type to declare the variable <b>o1 </b>as. However, this is not a problem, as I can use C#'s implicitly typed local variable feature <b>(var), </b>as discussed in</p>
<p>The term originated as an abstraction of the sequence: single, double, triple, quadruple, quintuple, n-tuple.</p>
<p>Chapter 9, &quot;Parameters,&quot; to have the compiler infer the type from the expression on the right of the assignment operator (<b>=</b>).</p>
<p>Now, let's focus on what the compiler is actually doing. When you write a line of code like this:</p>
<p><code>var o = new { property1 = expression1.....propertyN = expressionN };</code></p>
<p>the compiler infers the type of each expression, creates private fields of these inferred types, creates public read-only properties for each of the fields, and creates a constructor that accepts all these expressions. The constructor's code initializes the private read-only fields from the expression results passed in to it. In addition, the compiler overrides <b>Object</b>'s <b>Equals, GetHashCode, </b>and <b>ToString </b>methods and generates code inside all these methods. In effect, the class that the compiler generates looks like this:</p>
<p><code>[CompilerGenerated]<br/>
internal sealed class &lt;&gt;f_AnonymousType0&lt;...&gt;: Object {<br/>
private readonly t1 f1;<br/>
public   t1 p1 { get { return f1; } }<br/>
private readonly tn fn;<br/>
public   tn pn { get { return fn; } }<br/>
public &lt;&gt;f_AnonymousType0&lt;...&gt;(t1 a1.....tn an) {<br/>
f1 = a1;.fn = an; // Set all fields<br/>
}<br/>
public override Boolean Equals(Object value) {<br/>
// Return false if any fields don't match; else true<br/>
}<br/>
public override Int32 GetHashCode() {<br/>
// Returns a hash code generated from each fields' hash code<br/>
}<br/>
public override String ToString() {<br/>
// Return comma-separated set of property name = value pairs<br/>
}<br/>
}</code></p>
<p>The compiler generates <b>Equals </b>and <b>GetHashCode </b>methods so that instances of the anonymous type can be placed in a hash table collection. The properties are readonly as opposed to read/write to help prevent the object's hashcode from changing. Changing the hashcode for an object used as a key in a hashtable can prevent the object from being found. The compiler generates the <b>ToString </b>method to help with debugging. In the Visual Studio debugger, you can place the mouse cursor over a variable that refers to an instance of an anonymous type, and Visual Studio will invoke the <b>ToString </b>method and show the resulting string in a datatip window. By the way, Visual Studio's IntelliSense will suggest the property names as you write code in the editor預 very nice feature.</p>
<p>The compiler supports two additional syntaxes for declaring a property inside an anonymous type where it can infer the property names and types from variables:</p>
<p><code>String Name = &quot;Grant&quot;; DateTime dt = DateTime.Now;<br/>
// Anonymous type with two properties<br/>
//   l. String Name property set to Grant<br/>
//   2. Int32 Year property set to the year inside the dt<br/>
var o2 = new { Name, dt.Year };</code></p>
<p>In this example, the compiler determines that the first property should be called <b>Name </b>. Since <b>Name </b>is the name of a local variable, the compiler sets the type of the property to be the same type as the local variable: <b>String. </b>For the second property, the compiler uses the name of the field/property: <b>Year </b>. <b>Year </b>is an <b>Int32 </b>property of the <b>DateTime </b>class and therefore the <b>Year </b>property in the anonymous type will also be an <b>Int32 </b>Now, when the compiler constructs an instance of this anonymous type, it will set the instance's <b>Name </b>property to the same value that is in the <b>Name </b>local variable so the <b>Name </b>property will refer to the same <b>&quot;Grant&quot; </b>string. The compiler will set the instance's <b>Year </b>property to the same value that is returned from <b>dt</b>'s <b>Year </b>property.</p>
<p>The compiler is very intelligent about defining anonymous types. If the compiler sees that you are defining multiple anonymous types in your source code that have the identical structure, the compiler will create just one definition for the anonymous type and create multiple instances of that type. By &quot;same structure,&quot; I mean that the anonymous types have the same type and name for each property and that these properties are specified in the same order. In the code examples above, the type of variable <b>o1 </b>and the type of variable <b>o2 </b>will be the same type because the two lines of code are defining an anonymous type with a <b>Name/String </b>property and a <b>Year/Int32 </b>property, and <b>Name </b>comes before <b>Year.</b></p>
<p>Since the two variables are of the same type, we get to do some cool things, such as checking if the two objects contain equal values and assigning a reference to one object into the other's variable, as follows:</p>
<p><code>// One type allows equality and assignment operations. Console.WriteLine(&quot;Objects are equal: &quot; + ol.Equals(o2)); ol = o2;   // Assignment</code></p>
<p>Also, because of this type identity, we can create an implicitly typed array (discussed in the &quot;Initializing Array Elements&quot; section in Chapter 16, &quot;Arrays&quot;) of anonymous types:</p>
<p><code>// This works because all of the objects are of the same anonymous type var people = new[] {<br/>
ol,   // From earlier in this.section<br/>
new { Name = &quot;Kristin&quot;, Year.= l970 },<br/>
new { Name = &quot;Aidan&quot;, Year =.2003 },<br/>
new { Name = &quot;Grant&quot;, Year =.2008 }<br/>
};<br/>
// This shows how to walk through the array of anonymous types (var is required) foreach (var person in people)<br/>
Console.WriteLine(&quot;Person={0}, Year={l}&quot;, person.Name, person.Year);</code></p>
<p>Anonymous types are most commonly used with the Language Integrated Query (LINQ) technology, where you perform a query that results in a collection of objects that are all of the same anonymous type Then, you process the objects in the resulting collection All this takes place in the same method. Here is an example that returns all the files in my document directory that have been modified within the past seven days:</p>
<p><code>String myDocuments = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments); var query =<br/>
from pathname in Directory.GetFiles(myDocuments) let LastWriteTime = File.GetLastWriteTime(pathname) where LastWriteTime &gt; (DateTime.Now - TimeSpan.FromDays(7)) orderby LastWriteTime<br/>
select new { Path = pathname, LastWriteTime };// Set of anonymous type objects<br/>
foreach (var file in query)<br/>
Console.WriteLine(&quot;LastWriteTime={0}, Path={l}&quot;, file.LastWriteTime, file.Path);</code></p>
<p>Instances of anonymous types are not supposed to leak outside of a method A method cannot be prototyped as accepting a parameter of an anonymous type because there is no way to specify the anonymous type Similarly, a method cannot indicate that it returns a reference to an anonymous type. While it is possible to treat an instance of an anonymous type as an <b>Object </b>(since all anonymous types are derived from <b>Object), </b>there is no way to cast a variable of type <b>Object </b>back into an anonymous type because you don't know the name of the anonymous type at compile time. If you want to pass a tuple around, then you should consider using the <b>System.Tuple </b>type discussed in the next section.</p>
<p><b>The System.Tuple Type</b></p>
<p>In the <b>System </b>namespace, Microsoft has defined several generic <b>Tuple </b>types (all derived from <b>Object) </b>that differ by arity (the number of generic parameters). Here is what the simplest and most complex ones essentially look like:</p>
<p><code>// This is the simplest: [Serializable] public class Tuple&lt;Tl&gt; { private Tl m_Iteml;<br/>
public Tuple(Tl iteml) { m_Iteml = iteml; } public Tl Iteml { get { return m_Iteml; } }<br/>
}<br/>
// This is the most complex: [Serializable]<br/>
public class Tuple&lt;Tl, T2, T3, T4, T5, T6, T7, TRest&gt; {<br/>
private Tl m_Iteml; private T2 m_Item2; private T3 m_Item3; private T4 m_Item4; private T5 m_Item5; private T6 m_Item6; private T7 m_Item7; private TRestm_Rest;<br/>
public Tuple(Tl iteml, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7,<br/>
TRest t) {<br/>
m_Iteml = iteml; m_Item2 = item2; m_Item3 = item3; m_Item4 = item4; m_Item5 = item5; m_Item6 = item6; m_Item7 = item7; m_Rest = rest;<br/>
}<br/>
public Tl Iteml { get { return m_Iteml; } } public T2 Item2 { get { return m_Item2; } } public T3 Item3 { get { return m_Item3; } } public T4 Item4 { get { return m_Item4; } } public T5 Item5 { get { return m_Item5; } } public T6 Item6 { get { return m_Item6; } } public T7 Item7 { get { return m_Item7; } } public TRest Rest { get { return m_Rest; } }</code></p>
<p>Like anonymous types, once a <b>Tuple </b>is created, it is immutable (all properties are read-only). I don't show it here, but the <b>Tuple </b>classes also offer <b>CompareTo, Equals, GetHashCode, </b>and <b>ToString </b>methods, as well as a <b>Size </b>property. In addition, all the <b>Tuple </b>types implement the <b>IStructuralEquatable, IStructuralComparable, </b>and <b>IComparable </b>interfaces so that you can compare two <b>Tuple </b>objects with each other to see how their fields compare with each other. Refer to the SDK documentation to learn more about these methods and interfaces.</p>
<p>Here is an example of a method that uses a <b>Tuple </b>type to return two pieces of information back to a caller:</p>
<p><code>// Returns minimum in Iteml &amp; maximum in Item2<br/>
private static Tuple&lt;Int32, Int32&gt;MinMax(Int32 a, Int32 b) {<br/>
return new Tuple&lt;Int32, Int32&gt;(Math.Min(a, b), Math.Max(a, b));<br/>
}<br/>
// This shows how to call the method and how to use the returned Tuple private static void TupleTypes() { varminmax = MinMax(6, 2);<br/>
Console.WriteLine(&quot;Min={0}, Max={l}&quot;, minmax.Iteml, minmax.Item2); // Min=2, Max=6<br/>
}</code></p>
<p>Of course, it is very important that the producer and consumer of the <b>Tuple </b>have a clear understanding of what is being returned in the <b>Item# </b>properties With anonymous types, the properties are given actual names based on the source code that defines the anonymous type. With <b>Tuple </b>types, the properties are assigned their <b>Item# </b>names by Microsoft and you cannot change this at all. Unfortunately, these names have no real meaning or significance, so it is up to the producer and consumer to assign meanings to them This also reduces code readability and maintainability so you should add comments to your code explaining what the producer/consumer understanding is.</p>
<p>The compiler can only infer generic types when calling a generic method, not when you are calling a constructor. For this reason, the <b>System </b>namespace also includes a non-generic, static <b>Tuple </b>class containing a bunch of static <b>Create </b>methods which can infer generic types from arguments. This class acts as a factory for creating <b>Tuple </b>objects, and it exists simply to simplify your code. Here is a rewrite of the <b>MinMax </b>method shown earlier using the static <b>Tuple </b>class:</p>
<p><code>// Returns minimum in Iteml &amp; maximum in Item2<br/>
private static Tuple&lt;Int32, Int32&gt;MinMax(Int32 a, Int32 b) {<br/>
return Tuple.Create(Math.Min(a, b), Math.Max(a, b));       // Simpler syntax<br/>
}</code></p>
<p>If you want to create a <b>Tuple </b>with more than eight elements in it, then you would pass another <b>Tuple </b>for the <b>Rest </b>parameter as follows:</p>
<p><code>var t = Tuple.Create(0, l, 2, 3, 4, 5, 6, Tuple.Create(7, 8));<br/>
Console.WriteLine(&quot;{0}, {l}, {2}, {3}, {4}, {5}, {6}, {7}, {8}&quot;, t.Iteml, t.Item2, t.Item3, t.Item4, t.Item5, t.Item6, t.Item7, t.Rest.Iteml.Iteml, t.Rest.Iteml.Item2);</code></p>
<hr/>
<blockquote><b>Note </b>In addition to anonymous types and the <b>Tuple </b>types, you might want to take a look</blockquote>
<hr/>
<p>at the <b>System.Dynamic.ExpandoObject </b>class (defined in the System.Core.dll assembly). When you use this class with C#'s <b>dynamic </b>type (discussed in Chapter 5, &quot;Primitive, Reference, and Value Types&quot;), you have another way of grouping a set of properties (key/value pairs) together The result is not compile-time type-safe, but the syntax looks nice (although you get no IntelliSense support), and you can pass <b>ExpandoObject </b>objects between C# and dynamic languages like Python Here's some sample code that uses an <b>ExpandoObject:</b></p>
<p><code>dynamic e = new System.Dynamic.ExpandoObject();<br/>
e.x = 6;// Add an Int32 'x' property whose value is 6<br/>
e.y = &quot;Jeff&quot;;// Add a String 'y' property whose value is &quot;Jeff&quot;<br/>
e.z = null;    // Add an Object 'z' property whose value is null<br/>
// See all the properties and their values: foreach (var v in (IDictionary&lt;String, Object&gt;)e)<br/>
Console.WriteLine(&quot;Key={0}, V={l}&quot;, v.Key, v.Value);<br/>
// Remove the 'x' property and its value var d = (IDictionary&lt;String, Object&gt;)e; d.Remove(&quot;x&quot;);</code></p>
<h2>Parameterful Properties</h2>
<p>In the previous section, the <b>get </b>accessor methods for the properties accepted no parameters For this reason, I called these properties parameterless properties. These properties are easy to understand because they have the feel of accessing a field. In addition to these field-like properties, programming languages also support what I call parameterful properties, whose <b>get </b>accessor methods accept one or more parameters and whose <b>set </b>accessor methods accept two or more parameters. Different programming languages expose parameterful properties in different ways Also, languages use different terms to refer to parameterful properties: C# calls them indexers and Visual Basic calls them default properties. In this section, I'll focus on how C# exposes its indexers by using parameterful properties.</p>
<p>In C#, parameterful properties (indexers) are exposed using an array-like syntax In other words, you can think of an indexer as a way for the C# developer to overload the <b>[] </b>operator. Here's an example of a <b>BitArray </b>class that allows array-like syntax to index into the set of bits maintained by an instance of the class:</p>
<p><code>using System;<br/>
public sealed class BitArray {<br/>
// Private array of bytes that hold the bits private Byte[] m_byteArray; private Int32 m_numBits;<br/>
// Constructor that allocates the byte array and sets all bits to 0 public BitArray(Int32 numBits) {<br/>
// Validate arguments first.<br/>
if (numBits &lt;= 0)<br/>
throw new ArgumentOutOfRangeException(&quot;numBits must be &gt; 0&quot;);<br/>
// Save the number of bits. m_numBits = numBits;<br/>
// Allocate the bytes for the bit array. m_byteArray = new Byte[(numBits + 7) / 8];<br/>
}<br/>
// This is the indexer (parameterful property). public Boolean this[Int32 bitPos] {<br/>
// This is the indexer's get accessor method.<br/>
get {<br/>
// Validate arguments first<br/>
if ((bitPos &lt; 0) || (bitPos &gt;= m_numBits))<br/>
throw new ArgumentOutOfRangeException(&quot;bitPos&quot;);<br/>
// Return the state of the indexed bit.<br/>
return (m_byteArray[bitPos / 8] &amp; (l &lt;&lt; (bitPos % 8))) != 0;<br/>
}<br/>
// This is the indexer's set accessor method. set {<br/>
if ((bitPos &lt; 0) || (bitPos &gt;= m_numBits))<br/>
throw new ArgumentOutOfRangeException(&quot;bitPos&quot;, bitPos.ToStringO); if (value) {<br/>
// Turn the indexed bit on.<br/>
m_byteArray[bitPos / 8] = (Byte)<br/>
(m_byteArray[bitPos / 8]  | (l &lt;&lt; (bitPos % 8)));<br/>
} else {<br/>
// Turn the indexed bit off. m_byteArray[bitPos / 8] = (Byte)<br/>
(m_byteArray[bitPos / 8] &amp; ~(l &lt;&lt; (bitPos % 8)));<br/>
}<br/>
}<br/>
}<br/>
}</code></p>
<p>Using the <b>BitArray </b>class's indexer is incredibly simple:</p>
<p><code>// Allocate a BitArray that can hold 14 bits. BitArray ba = new BitArray(14);<br/>
// Turn all the even-numbered bits on by calling the set accessor. for (Int32 x = 0; x &lt; 14; x++) { ba[x] = (x % 2 == 0);<br/>
}<br/>
// Show the state of all the bits by calling the get accessor. for (Int32 x = 0; x &lt; 14; x++) {<br/>
Console.WriteLine(&quot;Bit &quot; + x + &quot; is &quot; + (ba[x] ? &quot;On&quot; : &quot;Off&quot;));<br/>
}</code></p>
<p>In the <b>BitArray </b>example, the indexer takes one <b>Int32 </b>parameter, <b>bitPos </b>. All indexers must have at least one parameter, but they can have more. These parameters (as well as the return type) can be of any data type (except <b>void) </b>. An example of an indexer that has more than one parameter can be found in the <b>System.Drawing.Imaging.ColorMatrix </b>class, which ships in the System.Drawing, dll assembly.</p>
<p>It's quite common to create an indexer to look up values in an associative array. In fact, the <b>System.Collections.Generic.Dictionary </b>type offers an indexer that takes a key and returns the value associated with the key Unlike parameterless properties, a type can offer multiple, overloaded indexers as long as their signatures differ.</p>
<p>Like a parameterless property's <b>set </b>accessor method, an indexer's <b>set </b>accessor method also contains a hidden parameter, called <b>value </b>in C# This parameter indicates the new value desired for the &quot;indexed element.&quot;</p>
<p>The CLR doesn't differentiate parameterless properties and parameterful properties; to the CLR, each is simply a pair of methods and a piece of metadata defined within a type. As mentioned earlier, different programming languages require different syntax to create and use parameterful properties. The fact that C# requires <b>this[...] </b>as the syntax for expressing an indexer was purely a choice made by the C# team. What this choice means is that C# allows indexers to be defined only on instances of objects. C# doesn't offer syntax allowing a developer to define a static indexer property, although the CLR does support static parameterful properties.</p>
<p>Because the CLR treats parameterful properties just as it does parameterless properties, the compiler will emit either two or three of the following items into the resulting managed assembly:</p>
<p>&#9632; A method representing the parameterful property's <b>get </b>accessor method. This is emitted only if you define a <b>get </b>accessor method for the property.</p>
<p>&#9632; A method representing the parameterful property's <b>set </b>accessor method This is emitted only if you define a <b>set </b>accessor method for the property.</p>
<p>&#9632;   A property definition in the managed assembly's metadata, which is always emitted. There's no special parameterful property metadata definition table because, to the CLR, parameterful properties are just properties.</p>
<p>For the <b>BitArray </b>class shown earlier, the compiler compiles the indexer as though the original source code were written as follows:</p>
<p><code>public sealed class BitArray {<br/>
// This is the indexer's get accessor method. public Boolean get_Item(Int32 bitPos) { /*... */ }<br/>
// This is the indexer's set accessor method.<br/>
public void      set_Item(Int32 bitPos, Boolean value)   { /*... */ }<br/>
}</code></p>
<p>The compiler automatically generates names for these methods by prepending <b>get_ </b>and <b>set_ </b>to the indexer name. Because the C# syntax for an indexer doesn't allow the developer to specify an indexer name, the C# compiler team had to choose a default name to use for the accessor methods; they chose <b>Item. </b>Therefore, the method names emitted by the compiler are <b>get_Item </b>and <b>set_Item </b>.</p>
<p>When examining the .NET Framework Reference documentation, you can tell if a type offers an indexer by looking for a property named <b>Item. </b>For example, the <b>System.Collections.Generic.List </b>type offers a public instance property named <b>Item; </b>this property is <b>List</b>'s indexer.</p>
<p>When you program in C#, you never see the name of <b>Item, </b>so you don't normally care that the compiler has chosen this name for you. However, if you're designing an indexer for a type that code written in other programming languages will be accessing, you might want to change the default name, <b>Item, </b>given to your indexer's <b>get </b>and <b>set </b>accessor methods. C# allows you to rename these methods by applying the <b>System.Runtime.CompilerServices.IndexerNameAttribute </b>custom attribute to the indexer The following code demonstrates how to do this:</p>
<p><code>using System;<br/>
using System.Runtime.CompilerServices;<br/>
public sealed class BitArray {<br/>
[IndexerName(&quot;Bit&quot;)]<br/>
public Boolean this[Int32 bitPos] {<br/>
// At least one accessor method is defined here<br/>
}<br/>
}</code></p>
<p>Now the compiler will emit methods called <b>get_Bit </b>and <b>set_Bit </b>instead of <b>get_Item </b>and <b>set_Item. </b>When compiling, the C# compiler sees the <b>IndexerName </b>attribute, and this tells the compiler how to name the methods and the property metadata; the attribute itself is not emitted into the assembly's metadata. <sup>2</sup></p>
<p>Here's some Visual Basic code that demonstrates how to access this C# indexer:</p>
<p><code>' Construct an instance of the BitArray type. Dim ba as New BitArray(10)<br/>
' Visual Basic uses () instead of [] to specify array elements. Console.WriteLine(ba(2)).' Displays True or False<br/>
' Visual Basic also allows you to access the indexer by its name. Console.WriteLine(ba.Bit(2))     ' Displays same as previous line</code></p>
<p>In C#, a single type can define multiple indexers as long as the indexers all take different parameter sets In other programming languages, the <b>IndexerName </b>attribute allows you to define multiple indexers with the same signature because each can have a different name. The reason C# won't allow you to do this is because its syntax doesn't refer to the indexer by name; the compiler wouldn't know which indexer you were referring to. Attempting to compile the following C# source code causes the compiler to generate the following message: <b>&quot;error C0111: Type 'SomeType' already defines a member called 'this' with the same parameter types.&quot;</b></p>
<p><code>using System;<br/>
using System.Runtime.CompilerServices;<br/>
public sealed class SomeType {<br/>
// Define a get_Item accessor method. public Int32 this[Boolean b] { get { return 0; }<br/>
}<br/>
// Define a get_Jeff accessor method. [IndexerName(&quot;Jeff&quot;)] public String this[Boolean b] { get { return null; }<br/>
}<br/>
}</code></p>
<p>You can clearly see that C# thinks of indexers as a way to overload the <b>[] </b>operator, and this operator can't be used to disambiguate parameterful properties with different method names and identical parameter sets.</p>
<p>By the way, the <b>System.String </b>type is an example of a type that changed the name of its indexer. The name of <b>String</b>'s indexer is <b>Chars </b>instead of <b>Item </b>. This read-only property allows you to get an individual character within a string For programming languages that don't use <b>[] </b>operator syntax to access this property, <b>Chars </b>was decided to be a more meaningful name.</p>
<p>For this reason, the <b>IndexerNameAttribute </b>class is not part of the ECMA standardization of the CLI and the C# language.</p>
<p>y</p>
<p>C#'s limitations with respect to indexers brings up the following two questions:</p>
<p>&#9632; What if a type is defined in a programming language that does allow the developer to define several parameterful properties?</p>
<p>&#9632; How can this type be consumed from C#?</p>
<p>The answer to both questions is that a type must select one of the parameterful property names to be the default property by applying an instance of <b>System.Reflection.DefaultMemberAttribute </b>to the class itself For the record, <b>DefaultMemberAttribute </b>can be applied to a class, a structure, or an interface. In C#, when you compile a type that defines a parameterful property, the compiler automatically applies an instance of <b>DefaultMember </b>attribute to the defining type and takes it into account when you use the <b>IndexerName </b>attribute This attribute's constructor specifies the name that is to be used for the type's default parameterful property.</p>
<p>So, in C#, if you define a type that has a parameterful property and you don't specify the <b>IndexerName </b>attribute, the defining type will have a <b>DefaultMember </b>attribute indicating <b>Item. </b>If you apply the <b>IndexerName </b>attribute to a parameterful property, the defining type will have a <b>DefaultMember </b>attribute indicating the string name specified in the <b>IndexerName </b>attribute. Remember, C# won't compile the code if it contains parameterful properties with different names.</p>
<p>For a language that supports several parameterful properties, one of the property method names must be selected and identified by the type's <b>DefaultMember </b>attribute. This is the only parameterful property that C# will be able to access.</p>
<p>When the C# compiler sees code that is trying to get or set an indexer, the compiler actually emits a call to one of these methods. Some programming languages might not support parameterful properties. To access a parameterful property from one of these languages, you must call the desired accessor method explicitly To the CLR, there's no difference between parameterless properties and parameterful properties, so you use the same <b>System.Reflection.PropertyInfo </b>class to find the association between a parameterful property and its accessor methods.</p>
<a name="b257"/><h2>The Performance of Calling Property Accessor Methods</h2>
<p>For simple <b>get </b>and <b>set </b>accessor methods, the just-in-time (JIT) compiler inlines the code so that there's no runtime performance hit as a result of using properties rather than fields. Inlining is when the code for a method (or accessor method, in this case) is compiled directly in the method that is making the call This removes the overhead associated with making a</p>
<p>call at runtime at the expense of making the compiled method's code bigger. Because property accessor methods typically contain very little code, inlining them can make the native code smaller and can make it execute faster.</p>
<p>Note that the JIT compiler does not inline property methods when debugging code because inlined code is harder to debug This means that the performance of accessing a property can be fast in a release build and slow in a debug build. Field access is fast in both debug and release builds.</p>
<a name="b258"/><h2>Property Accessor Accessibility</h2>
<p>Occasionally, when designing a type, it is desired to have one accessibility for a <b>get </b>accessor method and a different accessibility for a <b>set </b>accessor method. The most common scenario is to have a public <b>get </b>accessor and a protected <b>set </b>accessor:</p>
<p><code>public class SomeType { private String m_name; public String Name {<br/>
get { return m_name; }<br/>
protected set {m_name = value; }<br/>
}<br/>
}</code></p>
<p>As you can see from the code above, the <b>Name </b>property is itself declared as a <b>public </b>property, and this means that the <b>get </b>accessor method will be public and therefore callable by all code. However, notice that the <b>set </b>accessor is declared as <b>protected </b>and will be callable only from code defined within <b>SomeType </b>or from code in a class that is derived from <b>SomeType </b>.</p>
<p>When defining a property with accessor methods that have different accessibilities, C# syntax requires that the property itself must be declared with the least-restrictive accessibility and that more restrictive accessibility be applied to just one of the accessor methods. In the example above, the property is <b>public, </b>and the <b>set </b>accessor is <b>protected </b>(more restrictive than <b>public) </b>.</p>
<a name="b258_"/><h2>Generic Property Accessor Methods</h2>
<p>Since properties are really just methods, and because C# and the CLR allow methods to be generic, sometimes people want to define properties that introduce their own generic type parameters (as opposed to using the enclosing type's generic type parameter). However, C# does not allow this. The main reason why properties cannot introduce their own generic type parameters is because they don't make sense conceptually. A property is supposed to represent a characteristic of an object that can be queried or set Introducing a generic type parameter would mean that the behavior of the querying/setting could be changed, but conceptually, a property is not supposed to have behavior. If you want your object to expose some behavior揚eneric or not妖efine a method, not a property.</p>
<mbp:pagebreak/>
<a name="Chapter11"/>
<h1>Chapter 11: Events</h1>
<p><b>In this chapter:</b></p>
<a href="#b260">Designing a Type That Exposes an Event</a><br/>
<a href="#b266">How the Compiler Implements an Event</a><br/>
<a href="#b269">Designing a Type That Listens for an Event</a><br/>
<a href="#b271">Explicitly Implementing an Event</a><br/>
<p>In this chapter, I'll talk about the last kind of member a type can define: events. A type that defines an event member allows the type (or instances of the type) to notify other objects that something special has happened For example, the <b>Button </b>class offers an event called <b>Click </b>When a <b>Button </b>object is clicked, one or more objects in an application may want to receive notification about this event in order to perform some action. Events are type members that allow this interaction. Specifically, defining an event member means that a type is offering the following capabilities:</p>
<p>&#9632; A method can register its interest in the event.</p>
<p>&#9632; A method can unregister its interest in the event.</p>
<p>&#9632; Registered methods will be notified when the event occurs.</p>
<p>Types can offer this functionality when defining an event because they maintain a list of the registered methods. When the event occurs, the type notifies all of the registered methods in the collection.</p>
<p>The common language runtime's (CLR's) event model is based on delegates. A delegate is a type-safe way to invoke a callback method. Callback methods are the means by which objects receive the notifications they subscribed to. In this chapter, I'll be using delegates, but I won't fully explain all their details until Chapter 17, &quot;Delegates.&quot;</p>
<p>To help you fully understand the way events work within the CLR, I'll start with a scenario in which events are useful. Suppose you want to design an e-mail application. When an e-mail message arrives, the user might like the message to be forwarded to a fax machine or a pager In architecting this application, let's say that you'll first design a type, called <b>MailManager, </b>that receives the incoming e-mail messages. <b>MailManager </b>will expose an event called <b>NewMail. </b>Other types (such as <b>Fax </b>and <b>Pager) </b>may register interest in this event. When <b>MailManager </b>receives a new e-mail message, it will raise the event, causing the message to be distributed to each of the registered objects Each object can process the message in any way it desires.</p>
<p>When the application initializes, let's instantiate just one <b>MailManager </b>instance葉he application can then instantiate any number of <b>Fax </b>and <b>Pager </b>types. Figure 11-1 shows how the application initializes and what happens when a new e-mail message arrives.</p>
<img src="36.jpg"/>
<p><b>FIGURE 11-1 </b>Architecting an application to use events</p>
<p>Here's how the application illustrated in Figure 11-1 works: The application initializes by constructing an instance of <b>MailManager </b>. <b>MailManager </b>offers a <b>NewMail </b>event. When the <b>Fax </b>and <b>Pager </b>objects are constructed, they register an instance method with <b>MailManager</b>'s <b>NewMail </b>event so that <b>MailManager </b>knows to notify the <b>Fax </b>and <b>Pager </b>objects when new e-mail messages arrive. Now, when <b>MailManager </b>receives a new e-mail message (sometime in the future), it will raise the <b>NewMail </b>event, giving all of the registered methods an opportunity to process the new message in any way they want.</p>
<a name="b260"/><h2>Designing a Type That Exposes an Event</h2>
<p>There are many steps a developer must take in order to define a type that exposes one or more event members. In this section, I'll walk through each of the necessary steps. The <b>MailManager </b>sample application (which can be downloaded from <a href="http://wintellect.com">http://wintellect.com</a>) shows all of the source code for the <b>MailManager </b>type, the <b>Fax </b>type, and the <b>Pager </b>type. You'll notice that the <b>Pager </b>type is practically identical to the <b>Fax </b>type.</p>
<h3>Step #1: Define a type that will hold any additional information that should be sent to receivers of the event notification</h3>
<p>When an event is raised, the object raising the event may want to pass some additional information to the objects receiving the event notification. This additional information needs to be encapsulated into its own class, which typically contains a bunch of private fields along with some read-only public properties to expose these fields. By convention, classes that hold event information to be passed to the event handler should be derived from <b>System.EventArgs, </b>and the name of the class should be suffixed with <b>EventArgs </b>. In this example, the <b>NewMailEventArgs </b>class has fields identifying who sent the message <b>(m_from), </b>who is receiving the message <b>(m_to), </b>and the subject of the message <b>(m_subject).</b></p>
<p><code>// Step #1: Define a type that will hold any additional information that // should be sent to receivers of the event notification internal class NewMailEventArgs : EventArgs {<br/>
private readonly String m_from, m_to, m_subject;<br/>
public NewMailEventArgs(String from, String to,.String subject) { m_from = from; m_to = to; m_subject = subject;<br/>
}<br/>
public String From      { get { return m_from;.} }<br/>
public String To{ get { return m_to;.} }<br/>
public String Subject { get { return m_subject;.} }<br/>
}</code></p>
<hr/>
<blockquote><b>Note </b>The <b>EventArgs </b>class is defined in the Microsoft .NET Framework Class Library (FCL) and is implemented like this:</blockquote>
<hr/>
<p><code>[ComVisible(true), Serializable] public class EventArgs {<br/>
public static readonly EventArgs Empty = new EventArgs();<br/>
public EventArgs() { }<br/>
}</code></p>
<p>As you can see, this type is nothing to write home about It simply serves as a base type from which other types can derive. Many events don't have any additional information to pass on. For example, when a <b>Button </b>notifies its registered receivers that it has been clicked, just invoking the callback method is enough information. When you're defining an event that doesn't have any additional data to pass on, just use <b>EventArgs.Empty </b>rather than constructing a new <b>EventArgs </b>object.</p>
<h3>Step #2: Define the event member</h3>
<p>An event member is defined using the C# keyword <b>event </b>. Each event member is given accessibility (which is almost always <b>public </b>so that other code can access the event member), a type of delegate indicating the prototype of the method(s) that will be called, and a name (which can be any valid identifier). Here is what the event member in our <b>MailManager </b>class looks like:</p>
<p><code>internal class MailManager {<br/>
// Step #2: Define the event member<br/>
public event EventHandler&lt;NewMailEventArgs&gt; NewMail;<br/>
}</code></p>
<p><b>NewMail </b>is the name of this event The type of the event member is <b>EventHandler&lt;NewMailEventArgs&gt;, </b>which means that all receivers of the event notification must supply a callback method whose prototype matches that of the <b>EventHandler&lt;NewMailEventArgs&gt; </b>delegate type. Since the generic <b>System.EventHandler</b></p>
<p>delegate is defined as follows:</p>
<p><code>public delegate void EventHandler&lt;TEventArgs&gt;(Object sender, TEventArgs e) where TEventArgs: EventArgs;</code></p>
<p>the method prototypes must look like this:</p>
<p><code>void MethodName(Object sender, NewMailEventArgs e);</code></p>
<p><b>I-</b></p>
<hr/>
<blockquote><b>Note </b>A lot of people wonder why the event pattern requires the <b>sender </b>parameter to always be of type <b>Object </b>. After all, since the <b>MailManager </b>will be the only type raising an event with a <b>NewMailEventArgs </b>object, it makes more sense for the callback method to be prototyped like</blockquote>
<hr/>
<p>this:</p>
<p><code>void MethodName(MailManager sender, NewMailEventArgs e);</code></p>
<p>The pattern requires the <b>sender </b>parameter to be of type <b>Object </b>mostly because of inheritance. What if <b>MailManager </b>were used as a base class for <b>SmtpMailManager? </b>In this case, the callback method should have the <b>sender </b>parameter prototyped as <b>SmtpMailManager </b>instead of <b>MailManager, </b>but this can't happen because <b>SmtpMailManager </b>just inherited the <b>NewMail </b>event So the code that was expecting <b>SmtpMailManager </b>to raise the event must still have to cast the <b>sender </b>argument to <b>SmtpMailManager </b>. In other words, the cast is still required, so the <b>sender </b>parameter might as well be typed as <b>Object </b>.</p>
<p>The next reason for typing the <b>sender </b>parameter as <b>Object </b>is just flexibility. It allows the delegate to be used by multiple types that offer an event that passes a <b>NewMailEventArgs </b>object. For example, a <b>PopMailManager </b>class could use the delegate even if this class were not derived from <b>MailManager </b>.</p>
<p>The event pattern also requires that the delegate definition and the callback method name the <b>EventArgs</b>-derived parameter <b>e. </b>The only reason for this is to add additional consistency to the pattern, making it easier for developers to learn and implement the pattern Tools that spit out source code (such as Microsoft Visual Studio) also know to call the parameter <b>e </b>.</p>
<p>Finally, the event pattern requires all event handlers to have a return type of <b>void. </b>This is necessary because raising an event might call several callback methods, and there is no way to get the return values from all of them. Having a return type of <b>void </b>doesn't allow the callbacks to return a value. Unfortunately, there are some event handlers in the FCL, such as <b>ResolveEventHandler, </b>that did not follow Microsoft's own prescribed pattern because it returns an object of type <b>Assembly.</b></p>
<h3>Step #3: Define a method responsible for raising the event to notify registered objects that the event has occurred</h3>
<p>By convention, the class should define a protected, virtual method that is called by code internally within the class and its derived classes when the event is to be raised. This method takes one parameter, a <b>NewMailEventArgs </b>object, which includes the information passed to the objects receiving the notification. The default implementation of this method simply checks if any objects have registered interest in the event and, if so, the event will be raised, thereby notifying the registered methods that the event has occurred Here is what the method in our <b>MailManager </b>class looks like:</p>
<p><code>internal class MailManager {<br/>
// Step #3: Define a method responsible for raising the event<br/>
// to notify registered objects that the event has occurred<br/>
// If this class is sealed, make this method private and nonvirtual<br/>
protected virtual void OnNewMail(NewMailEventArgs e) {<br/>
// Copy a reference to the delegate field now into a temporary field for thread safety EventHandler&lt;EventArgs&gt; temp =<br/>
Interlocked.CompareExchange(ref NewMail, null, null);<br/>
// If any methods registered interest with our event, notify them if (temp != null) temp(this, e);<br/>
}<br/>
}</code></p>
<p><b>Raising an Event in a Thread-Safe Way</b></p>
<p>When the .NET Framework first shipped, the recommended way for developers to raise an event was by using code similar to this:</p>
<p><code>// Version 1<br/>
protected virtual void OnNewMail(NewMailEventArgs e) { if (NewMail  != null) NewMail(this, e);<br/>
}</code></p>
<p>The problem with the <b>OnNewMail </b>method is that the thread could see that <b>NewMail </b>is not <b>null, </b>and then, just before invoking <b>NewMail, </b>another thread could remove a delegate from the chain making <b>NewMail null, </b>resulting in a <b>NullReferenceException </b>being thrown. To fix this race condition, many developers write the <b>OnNewMail </b>method as follows:</p>
<p><code>// Version 2<br/>
protected void OnNewMail(NewMailEventArgs e) { <b>I        </b>EventHandler&lt;NewMailEventArgs&gt; temp = NewMail; <b>I        </b>if (temp != null) temp(this, e);<br/>
}</code></p>
<p>The thinking here is that a reference to <b>NewMail </b>is copied into a temporary variable, <b>temp, </b>which refers to the chain of delegates at the moment the assignment is performed Now, this method compares <b>temp </b>and <b>null </b>and invokes <b>temp, </b>so it doesn't matter if another thread changes <b>NewMail </b>after the assignment to <b>temp </b>. Remember that delegates are immutable and this is why this technique works in theory. However, what a lot of developers don't realize is that this code could be optimized by the compiler to remove the local <b>temp </b>variable entirely. If this happens, this version of the code is identical to the first version, so a <b>NullReferenceException </b>is still possible.</p>
<p>To really fix this code, you should rewrite <b>OnNewMail </b>like this:</p>
<p><code>// Version 3<br/>
protected void OnNewMail(NewMailEventArgs e) {<br/>
EventHandler&lt;NewMailEventArgs&gt; temp = Thread.VolatileRead(ref NewMail); <b>I        </b>if (temp != null) temp(this, e);<br/>
}</code></p>
<p>The call to <b>VolatileRead </b>forces <b>NewMail </b>to be read at the point of the call and the reference really has to be copied to the <b>temp </b>variable now. Then, <b>temp </b>will be invoked only if it is not <b>null. </b>Unfortunately, it is impossible to write the code as shown because there isn't a generic overload of the <b>VolatileRead </b>method. However, there is a generic overload of <b>Interlocked.CompareExchange, </b>which you can use:</p>
<p><code>// Version 4<br/>
protected void OnNewMail(NewMailEventArgs e) { EventHandler&lt;NewMailEventArgs&gt; temp = <b>I.</b>Interlocked.CompareExchange(ref NewMail, null, null);<br/>
if (temp != null) temp(this, e);<br/>
<sup>}</sup></code></p>
<p>Here, <b>CompareExchange </b>changes the <b>NewMail </b>reference to <b>null </b>if it is <b>null </b>and does not alter <b>NewMail </b>if it is not <b>null. </b>In other words, <b>CompareExchange </b>doesn't change the value in <b>NewMail </b>at all, but it does return the value inside <b>NewMail </b>in an atomic, thread-safe way. See Chapter 28, &quot;Primitive Thread Synchronization Constructs,&quot; for more information about the <b>Thread.VolatileRead </b>and <b>Interlocked </b>. <b>CompareExchange </b>methods.</p>
<p>While the fourth version of this code is the best, technically correct version, you can actually use the second version because the just-in-time (JIT) compiler is aware of this pattern and it knows not to optimize away the local <b>temp </b>variable. Specifically, all of Microsoft's JIT compilers respect the invariant of not introducing new reads to heap memory and therefore, caching a reference in a local variable ensures that the heap reference is accessed only once. This is not documented and, in theory, it could change, which is why you should use the fourth version. But in reality, Microsoft's JIT compiler would never embrace a change that would break this pattern because too many applications would break. <sup>1</sup> In addition, events are mostly used in single-threaded scenarios (Windows Forms, Windows Presentation Foundation, and Microsoft Silverlight) and so thread safety is not an issue anyway.</p>
<p>It is very important to note that due to this thread race condition, it is also possible that a method will be invoked after it has been removed from the event's delegate chain.</p>
<p>As a convenience, you could define an extension method (as discussed in Chapter 8, &quot;Methods&quot;) that encapsulates this thread-safety logic. Define the extension method like this:</p>
<p><code>public static class EventArgExtensions {<br/>
public static void Raise&lt;TEventArgs&gt;(this TEventArgs e,<br/>
Object sender, ref EventHandler&lt;TEventArgs&gt; eventDelegate) where TEventArgs : EventArgs {<br/>
// Copy a reference to the delegate field now into a temporary field for thread safety EventHandler&lt;TEventArgs&gt; temp =<br/>
Interlocked.CompareExchange(ref eventDelegate, null, null);<br/>
// If any methods registered interest with our event, notify them if (temp != null) temp(sender, e);<br/>
}<br/>
}</code></p>
<p>And now, we can rewrite the <b>OnNewMail </b>method as follows:</p>
<p><code>protected virtual void OnNewMail(NewMailEventArgs e) { e.Raise(this, ref m_NewMail);<br/>
}</code></p>
<p>This was actually told to me by a member of Microsoft's JIT compiler team.</p>
<p>A class that uses <b>MailManager </b>as a base type is free to override the <b>OnNewMail </b>method. This capability gives the derived class control over the raising of the event. The derived class can handle the new e-mail message in any way it sees fit. Usually, a derived type calls the base type's <b>OnNewMail </b>method so that the registered method(s) receive the notification. However, the derived class might decide to disallow the event from being forwarded.</p>
<h3>Step #4: Define a method that translates the input into the desired event</h3>
<p>Your class must have some method that takes some input and translates it into the raising of the event. In my <b>MailManager </b>example, the <b>SimulateNewMail </b>method is called to indicate that a new e-mail message has arrived into <b>MailManager:</b></p>
<p><code>internal class MailManager {<br/>
// Step #4: Define a method that translates the // input into the desired event<br/>
public void SimulateNewMail(String from, String to, String subject) {<br/>
// Construct an object to hold the information we wish // to pass to the receivers of our notification NewMailEventArgs e = new NewMailEventArgs(from, to, subject);<br/>
// Call our virtual method notifying our object that the event // occurred. If no type overrides this method, our object will // notify all the objects that registered interest in the event OnNewMail(e);<br/>
}<br/>
}</code></p>
<p><b>SimulateNewMail </b>accepts information about the message and constructs a <b>NewMailEventArgs </b>object, passing the message information to its constructor <b>MailManager</b>'s own virtual <b>OnNewMail </b>method is then called to formally notify the <b>MailManager </b>object of the new e-mail message Usually, this causes the event to be raised, notifying all of the registered methods (As mentioned before, a class using <b>MailManager </b>as a base class can override this behavior.</p>
<a name="b266"/><h2>How the Compiler Implements an Event</h2>
<p>Now that you know how to define a class that offers an event member, let's take a closer look at what an event really is and how it works. In the <b>MailManager </b>class, we have a line of code that defines the event member itself:</p>
<p><code>public event EventHandler&lt;NewMailEventArgs&gt; NewMail;</code></p>
<p>When the C# compiler compiles the line above, it translates this single line of source code into the following three constructs:</p>
<p><code>// 1. A PRIVATE delegate field that is initialized to null private EventHandler&lt;NewMailEventArgs&gt; NewMail = null;<br/>
// 2. A PUBLIC add_Xxx method (where Xxx is the Event name)<br/>
// Allows methods to register interest in the event.<br/>
public void add_NewMail(EventHandler&lt;NewMailEventArgs&gt; value) {<br/>
// The loop and the call to CompareExchange is all just a fancy way<br/>
// of adding a delegate to the event in a thread-safe way<br/>
EventHandler&lt;NewMailEventArgs&gt;prevHandler;<br/>
EventHandler&lt;NewMailEventArgs&gt; newMail = this.NewMail;<br/>
do {<br/>
prevHandler = newMail;<br/>
EventHandler&lt;NewMailEventArgs&gt;newHandler =<br/>
(EventHandler&lt;NewMailEventArgs&gt;) Delegate.Combine(prevHandler, value); newMail = Interlocked.CompareExchange&lt;EventHandler&lt;NewMailEventArgs&gt;&gt;(<br/>
ref this.NewMail, newHandler, prevHandler); } while (newMail  != prevHandler);<br/>
}<br/>
// 3. A PUBLIC remove_Xxx method (where Xxx is the Event name)<br/>
// Allows methods to unregister interest in the event.<br/>
public void remove_NewMail(EventHandler&lt;NewMailEventArgs&gt; value) {<br/>
// The loop and the call to CompareExchange is all just a fancy way<br/>
// of removing a delegate from the event in a thread-safe way<br/>
EventHandler&lt;NewMailEventArgs&gt; prevHandler;<br/>
EventHandler&lt;NewMailEventArgs&gt; newMail = this.NewMail;<br/>
do {<br/>
prevHandler = newMail;<br/>
EventHandler&lt;NewMailEventArgs&gt; newHandler =<br/>
(EventHandler&lt;NewMailEventArgs&gt;) Delegate.Remove(prevHandler, value); newMail = Interlocked.CompareExchange&lt;EventHandler&lt;NewMailEventArgs&gt;&gt;(<br/>
ref this.NewMail, newHandler, prevHandler); } while (newMail  != prevHandler);<br/>
}</code></p>
<p>The first construct is simply a field of the appropriate delegate type. This field is a reference to the head of a list of delegates that will be notified when this event occurs. This field is initialized to <b>null, </b>meaning that no listeners have registered interest in the event. When a method registers interest in the event, this field refers to an instance of the <b>EventHandler&lt;NewMailEventArgs&gt; </b>delegate, which may refer to additional <b>EventHandler&lt;NewMailEventArgs&gt; </b>delegates. When a listener registers interest in an event, the listener is simply adding an instance of the delegate type to the list. Obviously, unregis-tering means removing the delegate from the list.</p>
<p>You'll notice that the delegate field, <b>NewMail </b>in this example, is always <b>private </b>even though the original line of source code defines the event as <b>public </b>. The reason for making the delegate field <b>private </b>is to prevent code outside the defining class from manipulating it improperly. If the field were <b>public, </b>any code could alter the value in the field and potentially wipe out all of the delegates that have registered interest in the event.</p>
<p>The second construct the C# compiler generates is a method that allows other objects to register their interest in the event. The C# compiler automatically names this function by prepending <b>add_ </b>to the event's name <b>(NewMail) </b>. The C# compiler automatically generates the code that is inside this method. The code always calls <b>System.Delegate</b>'s static <b>Combine </b>method, which adds the instance of a delegate to the list of delegates and returns the new head of the list, which gets saved back in the field.</p>
<p>The third construct the C# compiler generates is a method that allows an object to unreg-ister its interest in the event. Again, the C# compiler automatically names this function by prepending <b>remove_ </b>to the event's name <b>(NewMail) </b>. The code inside this method always calls <b>Delegate</b>'s static <b>Remove </b>method, which removes the instance of a delegate from the list of delegates and returns the new head of the list, which gets saved back in the field.</p>
<p><b>Warning </b>If you attempt to remove a method that was never added, then <b>Delegate</b>'s <b>Remove </b>method internally does nothing. That is, you get no exception or warning of any type; the event's collection of methods remains unchanged.</p>
<p>I-</p>
<hr/>
<blockquote><b>Note </b>The <b>add </b>and <b>remove </b>methods use a well-known pattern to update a value in a thread-safe way. This pattern is discussed in the &quot;The Interlocked Anything Pattern&quot; section of Chapter 28.&quot; <b>I____</b></blockquote>
<hr/>
<p>In this example, the <b>add </b>and <b>remove </b>methods are <b>public. </b>The reason they are <b>public </b>is that the original line of source code declared the event to be <b>public </b>. If the event had been declared <b>protected, </b>the <b>add </b>and <b>remove </b>methods generated by the compiler would also have been declared <b>protected. </b>So, when you define an event in a type, the accessibility of the event determines what code can register and unregister interest in the event, but only the type itself can ever access the delegate field directly. Event members can also be declared as <b>static </b>or <b>virtual, </b>in which case the <b>add </b>and <b>remove </b>methods generated by the compiler would be either <b>static </b>or <b>virtual, </b>respectively.</p>
<p>In addition to emitting the aforementioned three constructs, compilers also emit an event definition entry into the managed assembly's metadata. This entry contains some flags and the underlying delegate type, and refers to the <b>add </b>and <b>remove </b>accessor methods This information exists simply to draw an association between the abstract concept of an &quot;event&quot; and its accessor methods. Compilers and other tools can use this metadata, and this information can also be obtained by using the <b>System.Reflection.EventInfo </b>class. However, the CLR itself doesn't use this metadata information and requires only the accessor methods at runtime.</p>
<a name="b269"/><h2>Designing a Type That Listens for an Event</h2>
<p>The hard work is definitely behind you at this point. In this section, I'll show you how to define a type that uses an event provided by another type Let's start off by examining the code for the <b>Fax </b>type:</p>
<p><code>internal sealed class Fax {<br/>
// Pass the MailManager object to the constructor public Fax(MailManager mm) {<br/>
// Construct an instance of the EventHandler&lt;NewMailEventArgs&gt; // delegate that refers to our FaxMsg callback method. // Register our callback with MailManager's NewMail event mm.NewMail += FaxMsg;<br/>
}<br/>
// This is the method the MailManager will call // when a new e-mail message arrives<br/>
private void FaxMsg(Object sender, NewMailEventArgs e) {<br/>
// 'sender' identifies the MailManager object in case // we want to communicate back to it.<br/>
// 'e' identifies the additional event information // the MailManager wants to give us.<br/>
// Normally, the code here would fax the e-mail message. // This test implementation displays the info in the console Console.WriteLine(&quot;Faxing mail message:&quot;); Console.WriteLine(&quot;     From={0}, To={1}, Subject={2}&quot;, e.From, e.To, e.Subject);<br/>
}<br/>
// This method could be executed to have the Fax object unregister // itself with the NewMail event so that it no longer receives // notifications<br/>
public void Unregister(MailManager mm) {<br/>
// Unregister with MailManager's NewMail event mm.NewMail -= FaxMsg;<br/>
}<br/>
}</code></p>
<p>When the e-mail application initializes, it would first construct a <b>MailManager </b>object and save the reference to this object in a variable Then the application would construct a <b>Fax </b>object, passing the reference to the <b>MailManager </b>object as a parameter. In the <b>Fax </b>constructor, the <b>Fax </b>object registers its interest in <b>MailManager</b>'s <b>NewMail </b>event using C#'s += operator:</p>
<p><code>mm.NewMail += FaxMsg;</code></p>
<p>Because the C# compiler has built-in support for events, the compiler translates the use of the <b>+= </b>operator into the following line of code to add the object's interest in the event:</p>
<p><code>mm.add_NewMail(new EventHandler&lt;NewMailEventArgs&gt;(this.FaxMsg));</code></p>
<p>As you can see, the C# compiler is generating code that will construct an <b>EventHandler&lt;NewMailEventArgs&gt; </b>delegate object that wraps the <b>Fax </b>class's <b>FaxMsg </b>method. Then, the C# compiler calls the <b>MailManager</b>'s <b>add_NewMail </b>method, passing it the new delegate. Of course, you can verify all of this by compiling the code and looking at the IL with a tool such as ILDasm.exe.</p>
<p>Even if you're using a programming language that doesn't directly support events, you can still register a delegate with the event by calling the <b>add </b>accessor method explicitly. The effect is identical; the source code will just not look as pretty. It's the <b>add </b>method that registers the delegate with the event by adding it to the event's list of delegates.</p>
<p>When the <b>MailManager </b>object raises the event, the <b>Fax </b>object's <b>FaxMsg </b>method gets called. The method is passed a reference to the <b>MailManager </b>object as the first parameter, <b>sender </b>. Most of the time, this parameter is ignored, but it can be used if the <b>Fax </b>object wants to access members of the <b>MailManager </b>object in response to the event notification. The second parameter is a reference to a <b>NewMailEventArgs </b>object. This object contains any additional information the designer of <b>MailManager </b>and <b>NewMailEventArgs </b>thought would be useful to the event receivers.</p>
<p>From the <b>NewMailEventArgs </b>object, the <b>FaxMsg </b>method has easy access to the message's sender, the message's recipient, and the message's subject. In a real <b>Fax </b>object, this information would be faxed somewhere. In this example, the information is simply displayed in the console window.</p>
<p>When an object is no longer interested in receiving event notifications, it should unregister its interest. For example, the <b>Fax </b>object would unregister its interest in the <b>NewMail </b>event if the user no longer wanted his or her e-mail forwarded to a fax As long as an object has registered one of its methods with an event, the object can't be garbage collected. If your type implements <b>IDisposable</b>'s <b>Dispose </b>method, the implementation should cause it to unregister interest in all events. (See Chapter 21, &quot;Automatic Memory Management (Garbage Collection),&quot; for more information about <b>IDisposable </b>.)</p>
<p>Code that demonstrates how to unregister for an event is shown in <b>Fax</b>'s <b>Unregister </b>method. This method is practically identical to the code shown in the <b>Fax </b>constructor. The only difference is that this code uses <b>-= </b>instead of <b>+= </b>When the C# compiler sees code using the <b>-= </b>operator to unregister a delegate with an event, the compiler emits a call to the event's <b>remove </b>method:</p>
<p><code>mm.remove_NewMail(new EventHandler&lt;NewMailEventArgs&gt;(FaxMsg));</code></p>
<p>As with the <b>+= </b>operator, even if you're using a programming language that doesn't directly support events, you can still unregister a delegate with the event by calling the <b>remove </b>accessor method explicitly. The <b>remove </b>method unregisters the delegate from the event by scanning the list for a delegate that wraps the same method as the one passed in If a match is found, the existing delegate is removed from the event's list of delegates. If a match isn't found, no error occurs, and the list is unaltered.</p>
<p>By the way, C# requires your code to use the <b>+= </b>and <b>-= </b>operators to add and remove delegates from the list. If you try to call the <b>add </b>or <b>remove </b>method explicitly, the C# compiler produces the CS0571 <b>&quot;cannot explicitly call operator or accessor&quot; </b>error message.</p>
<a name="b271"/><h2>Explicitly Implementing an Event</h2>
<p>The <b>System.Windows.Forms.Control </b>type defines about 70 events. If the <b>Control </b>type implemented the events by allowing the compiler to implicitly generate the <b>add </b>and <b>remove </b>accessor methods and delegate fields, every <b>Control </b>object would have 70 delegate fields in it just for the events! Since most programmers care about just a few events, an enormous amount of memory would be wasted for each object created from a <b>Control</b>-derived type. By the way, the ASP.NET <b>System.Web.UI.Control </b>and the Windows Presentation Foundation (WPF) <b>System.Windows.UIElement </b>type also offer many events that most programmers do not use.</p>
<p>In this section, I discuss how the C# compiler allows a class developer to explicitly implement an event, allowing the developer to control how the <b>add </b>and <b>remove </b>methods manipulate the callback delegates. I'm going to demonstrate how explicitly implementing an event can be used to efficiently implement a class that offers many events. However, there are certainly other scenarios where you might want to explicitly implement a type's event.</p>
<p>To efficiently store event delegates, each object that exposes events will maintain a collection (usually a dictionary) with some sort of event identifier as the key and a delegate list as the value When a new object is constructed, this collection is empty When interest in an event is registered, the event's identifier is looked up in the collection. If the event identifier is there, the new delegate is combined with the list of delegates for this event. If the event identifier isn't in the collection, the event identifier is added with the delegate.</p>
<p>When the object needs to raise an event, the event identifier is looked up in the collection. If the collection doesn't have an entry for the event identifier, nothing has registered interest in the event and no delegates need to be called back. If the event identifier is in the collection, the delegate list associated with the event identifier is invoked. Implementing this design pattern is the responsibility of the developer who is designing the type that defines the events; the developer using the type has no idea how the events are implemented internally.</p>
<p>Here is an example of how you could accomplish this pattern First, I implemented an <b>EventSet </b>class that represents a collection of events and each event's delegate list as follows:</p>
<p><code>using System;<br/>
using System.Collections.Ceneric;<br/>
// This class exists to provide a bit more type safety and // code maintainability when using EventSet public sealed class EventKey : Object { }<br/>
public sealed class EventSet {<br/>
// The private dictionary used to maintain EventKey -&gt; Delegate mappings private readonly Dictionary&lt;EventKey, Delegate&gt; m_events =<br/>
newDictionary&lt;EventKey, Delegate&gt;();<br/>
// Adds an EventKey -&gt; Delegate mapping if it doesn't exist or<br/>
// combines a delegate to an existing EventKey<br/>
public void Add(EventKey eventKey, Delegate handler) {<br/>
Monitor.Enter(m_events);<br/>
Delegate d;<br/>
m_events.TryCetValue(eventKey, out d); m_events[eventKey] = Delegate.Combine(d, handler); Monitor.Exit(m_events);<br/>
}<br/>
// Removes a delegate from an EventKey (if it exists) and // removes the EventKey -&gt; Delegate mapping the last delegate is removed public void Remove(EventKey eventKey, Delegate handler) { Monitor.Enter(m_events);<br/>
// Call TryCetValue to ensure that an exception is not thrown if // attempting to remove a delegate from an EventKey not in the set Delegate d;<br/>
if (m_events.TryCetValue(eventKey, out d)) { d = Delegate.Remove(d, handler);<br/>
// If a delegate remains, set the new head else remove the EventKey if (d != null) m_events[eventKey] = d; else m_events.Remove(eventKey);<br/>
}<br/>
Monitor.Exit(m_events);<br/>
}<br/>
// Raises the event for the indicated EventKey<br/>
public void Raise(EventKey eventKey, Object sender, EventArgs e) { // Don't throw an exception if the EventKey is not in the set Delegate d;<br/>
Monitor.Enter(m_events); m_events.TryCetValue(eventKey, out d); Monitor.Exit(m_events);<br/>
if (d != null) {<br/>
// Because the dictionary can contain several different delegate types, // it is impossible to construct a type-safe call to the delegate at // compile time. So, I call the System.Delegate type's Dynamiclnvoke // method, passing it the callback method's parameters as an array of<br/>
// objects. Internally, Dynamiclnvoke will check the type safety of the // parameters with the callback method being called and call the method. // If there is a type mismatch, then Dynamiclnvoke will throw an exception. d.DynamicInvoke(newObject[] { sender, e }); }<br/>
}</code></p>
<hr/>
<blockquote><b>Note </b>The FCL defines a type, <b>System.ComponentModel.EventHandlerList, </b>which does essentially the same thing as my <b>EventSet </b>class The <b>System.Windows.Forms.Control </b>and <b>System.Web.UI.Control </b>types use the <b>EventHandlerList </b>type internally to maintain their sparse set of events. You're certainly welcome to use the FCL's <b>EventHandlerList </b>type if you'd like. The difference between the <b>EventHandlerList </b>type and my <b>EventSet </b>type is that <b>EventHandlerList </b>uses a linked list instead of a hash table. This means that accessing elements managed by the <b>EventHandlerList </b>is slower than using my <b>EventSet </b>. In addition, the <b>EventHandlerList </b>doesn't offer any thread-safe way to access the events; you would have to implement your own thread-safe wrapper around the <b>EventHandlerList </b>collection if you need to do this</blockquote>
<hr/>
<p>Now, I show a class that uses my <b>EventSet </b>class. This class has a field that refers to an <b>EventSet </b>object, and each of this class's events is explicitly implemented so that each event's <b>add </b>method stores the specified callback delegate in the <b>EventSet </b>object and each event's <b>remove </b>method eliminates the specified callback delegate (if found):</p>
<p><code>using System;<br/>
// Define the EventArgs-derived type for this event. public class FooEventArgs : EventArgs { }<br/>
public class TypeWithLotsOfEvents {<br/>
// Define a private instance field that references a collection. // The collection manages a set of Event/Delegate pairs. // NOTE: The EventSet type is not part of the FCL, it is my own type. private readonly EventSet m_eventSet = newEventSet();<br/>
// The protected property allows derived types access to the collection. protected EventSet EventSet { get { return m_eventSet; } }<br/>
#region Code to support the Foo event (repeat this pattern for additional events)<br/>
// Define the members necessary for the Foo event.<br/>
// 2a. Construct a static, read-only object to identify this event.<br/>
// Each object has its own hash code for looking up this<br/>
// event's delegate linked list in the object's collection.<br/>
protected static readonly EventKey s_fooEventKey = newEventKey();<br/>
// 2d. Define the event's accessor methods that add/remove the<br/>
// delegate from the collection.<br/>
public event EventHandler&lt;FooEventArgs&gt; Foo {<br/>
add      { m_eventSet.Add(s_fooEventKey, value); }<br/>
remove { m_eventSet.Remove(s_fooEventKey, value); }<br/>
}<br/>
// 2e. Define the protected, virtual On method for this event. protected virtual void OnFoo(FooEventArgs e) { m_eventSet.Raise(s_fooEventKey, this, e);<br/>
}<br/>
// 2f. Define the method that translates input to this event. public void SimulateFoo() {OnFoo(newFooEventArgs());} #endregion<br/>
}</code></p>
<p>Code that uses the <b>TypeWithLotsOfEvents </b>type can't tell whether the events have been implemented implicitly by the compiler or explicitly by the developer. They just register the events using normal syntax. Here is some code demonstrating this:</p>
<p><code>public sealed class Program { public static void Main() {<br/>
TypeWithLotsOfEvents twle = newTypeWithLotsOfEvents();<br/>
// Add a callback here twle.Foo += HandleFooEvent;<br/>
// Prove that it worked twle.SimulateFoo();<br/>
}<br/>
private static void HandleFooEvent(object sender, FooEventArgs e) { Console.WriteLine(&quot;Handling Foo Event here...&quot;);<br/>
}<br/>
}</code></p>
<mbp:pagebreak/>
<a name="Chapter12"/>
<h1>Chapter 12: Generics</h1>
<p><b>In this chapter:</b></p>
<a href="#b280">Generics in the Framework Class Library</a><br/>
<a href="#b281">Wintellect's Power Collections Library</a><br/>
<a href="#b282">Generics Infrastructure</a><br/>
<a href="#b289">Generic Interfaces</a><br/>
<a href="#b290">Generic Delegates</a><br/>
<a href="#b291">Delegate and Interface Contravariant and Covariant Generic Type Arguments</a><br/>
<a href="#b293">Generic Methods</a><br/>
<a href="#b296">Generics and Other Members</a><br/>
<a href="#b296_">Verifiability and Constraints</a><br/>
<p>Developers who are familiar with object-oriented programming know the benefits it offers. One of the big benefits that make developers extremely productive is code reuse, which is the ability to derive a class that inherits all of the capabilities of a base class The derived class can simply override virtual methods or add some new methods to customize the behavior of the base class to meet the developer's needs. Generics is another mechanism offered by the common language runtime (CLR) and programming languages that provides one more form of code reuse: algorithm reuse.</p>
<p>Basically, one developer defines an algorithm such as sorting, searching, swapping, comparing, or converting. However, the developer defining the algorithm doesn't specify what data type(s) the algorithm operates on; the algorithm can be generically applied to objects of different types. Another developer can then use this existing algorithm as long as he or she indicates the specific data type(s) the algorithm should operate on, for example, a sorting algorithm that operates on <b>Int32</b>s, <b>String</b>s, etc..or a comparing algorithm that operates on <b>DateTime</b>s, <b>Version</b>s, etc.</p>
<p>Most algorithms are encapsulated in a type, and the CLR allows the creation of generic reference types as well as generic value types, but it does not allow the creation of generic enumerated types In addition, the CLR allows the creation of generic interfaces and generic delegates. Occasionally, a single method can encapsulate a useful algorithm, and therefore, the CLR allows the creation of generic methods that are defined in a reference type, value type, or interface.</p>
<p>Let's look at a quick example. The Framework Class Library (FCL) defines a generic list algorithm that knows how to manage a set of objects; the data type of these objects is not specified by the generic algorithm. Someone wanting to use the generic list algorithm can specify the exact data type to use with it later.</p>
<p>The FCL class that encapsulates the generic list algorithm is called <b>List&lt;T&gt; </b>(pronounced List of Tee), and this class is defined in the <b>System.Collections.Generic </b>namespace. Here is what this class definition looks like (the code is severely abbreviated):</p>
<p><code>[Serializable]<br/>
public class List&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IList, ICollection, IEnumerable {<br/>
public List();<br/>
public void Add(T item);<br/>
public Int32 BinarySearch(T item);<br/>
public void Clear();<br/>
public Boolean Contains(T item);<br/>
public Int32 IndexOf(T item);<br/>
public Boolean Remove(T item);<br/>
public void Sort();<br/>
public void Sort(IComparer&lt;T&gt; comparer); public void Sort(Comparison&lt;T&gt; comparison); public T[] ToArray();<br/>
public Int32 Count { get; }<br/>
public T this[Int32 index] { get; set; }<br/>
}</code></p>
<p>The programmer who defined the generic <b>List </b>class indicates that it works with an unspecified data type by placing the <b>&lt;T&gt; </b>immediately after the class name. When defining a generic type or method, any variables it specifies for types (such as <b>T) </b>are called type parameters. <b>T </b>is a variable name that can be used in source code anywhere a data type can be used. For example, in the <b>List </b>class definition, you see <b>T </b>being used for method parameters (the <b>Add </b>method accepts a parameter of type <b>T) </b>and return values (the <b>ToArray </b>method returns a single-dimension array of type <b>T) </b>. Another example is the indexer method (called <b>this </b>in C#). The indexer has a <b>get </b>accessor method that returns a value of type <b>T </b>and a <b>set </b>accessor method that accepts a parameter of type <b>T. </b>Since the <b>T </b>variable can be used anywhere that a data type can be specified, it is also possible to use <b>T </b>when defining local variables inside a method or when defining fields inside a type.</p>
<p><b>/ <sup>1</sup></b></p>
<hr/>
<blockquote><b>Note </b>Microsoft's design guidelines state that generic parameter variables should either be.        called <b>T </b>or at least start with an uppercase <b>T </b>(as in <b>TKey </b>and <b>TVal ue). </b>The uppercase <b>T </b>stands for type, just as an uppercase <b>I </b>stands for interface (as in <b>IComparable).</b></blockquote>
<hr/>
<p>Now that the generic List&lt;T&gt; type has been defined, other developers can use this generic algorithm by specifying the exact data type they would like the algorithm to operate on When using a generic type or method, the specified data types are referred to as type arguments. For example, a developer might want to work with the List algorithm by specifying a DateTime type argument. Here is some code that shows this:</p>
<p><code>private static void SomeMethod() {<br/>
// Construct a List that operates on DateTime objects List&lt;DateTime&gt; dtList = new List&lt;DateTime&gt;();<br/>
// Add a DateTime object to the list dtList.Add(DateTime.Now);// No boxing<br/>
// Add another DateTime object to the list dtList.Add(DateTime.MinValue); // No boxing<br/>
// Attempt to add a String object to the list dtList.Add(&quot;1/1/2004&quot;);// Compile-time error<br/>
// Extract a DateTime object out of the list DateTime dt = dtList[0];// No cast required<br/>
}</code></p>
<p>Generics provide the following big benefits to developers as exhibited by the code just shown:</p>
<p>&#9632; Source code protection   The developer using a generic algorithm doesn't need to have access to the algorithm's source code. With C++ templates or Java's generics, however, the algorithm's source code must be available to the developer who is using the algorithm.</p>
<p>&#9632; Type safety  When a generic algorithm is used with a specific type, the compiler and the CLR understand this and ensure that only objects compatible with the specified data type are used with the algorithm Attempting to use an object of an incompatible type will result in either a compiler error or a runtime exception being thrown. In the example, attempting to pass a String object to the Add method results in the compiler issuing an error.</p>
<p>&#9632; Cleaner code   Since the compiler enforces type safety, fewer casts are required in your source code, meaning that your code is easier to write and maintain In the last line of SomeMethod, a developer doesn't need to use a (DateTime) cast to put the result of the indexer (querying element at index 0) into the dt variable.</p>
<p>&#9632; Better performance   Before generics, the way to define a generalized algorithm was to define all of its members to work with the Object data type. If you wanted to use the algorithm with value type instances, the CLR had to box the value type instance prior to calling the members of the algorithm. As discussed in Chapter 5, &quot;Primitive, Reference, and Value Types,&quot; boxing causes memory allocations on the managed heap, which causes more frequent garbage collections, which, in turn, hurt an application's</p>
<p>performance. Since a generic algorithm can now be created to work with a specific value type, the instances of the value type can be passed by value, and the CLR no longer has to do any boxing. In addition, since casts are not necessary (see the previous bullet), the CLR doesn't have to check the type safety of the attempted cast, and this results in faster code too.</p>
<p>To drive home the performance benefits of generics, I wrote a program that tests the performance of the generic <b>List </b>algorithm against the FCL's non-generic <b>ArrayList </b>algorithm. In fact, I tested the performance of these two algorithms by using both value type objects and reference type objects. Here is the program itself:</p>
<p><code>using System;<br/>
using System.Collections;<br/>
using System.Collections.Ceneric;<br/>
using System.Diagnostics;<br/>
public static class Program { public static void Main() { ValueTypePerfTest(); ReferenceTypePerfTest();<br/>
}<br/>
private static void ValueTypePerfTest() { const Int32 count = 10000000;<br/>
using (new OperationTimer(&quot;List&lt;Int32&gt;&quot;)) { List&lt;Int32&gt; l = new List&lt;Int32&gt;(count); for (Int32 n = 0; n &lt; count; n++) { l.Add(n); Int32 x = l[n];<br/>
}<br/>
l = null;   // Make sure this gets CC'd<br/>
}<br/>
using (new OperationTimer(&quot;ArrayList of Int32&quot;)) { ArrayList a = new ArrayList(); for (Int32 n = 0; n &lt; count; n++) { a.Add(n);<br/>
Int32 x = (Int32) a[n];<br/>
}<br/>
a = null;   // Make sure this gets CC'd<br/>
}<br/>
}<br/>
private static void ReferenceTypePerfTest() { const Int32 count = 10000000;<br/>
using (new OperationTimer(&quot;List&lt;String&gt;&quot;)) { List&lt;String&gt; l = new List&lt;String&gt;(); for (Int32 n = 0; n &lt; count; n++) { l.Add(&quot;X&quot;); String x = l[n];<br/>
}<br/>
l = null;   // Make sure this gets CC'd<br/>
}<br/>
using (new OperationTimer(&quot;ArrayList of String&quot;)) { ArrayList a = new ArrayList(); for (Int32 n = 0; n &lt; count; n++) { a.Add(&quot;X&quot;);<br/>
String x = (String) a[n];<br/>
}<br/>
a = null;   // Make sure this gets CC'd<br/>
}<br/>
}<br/>
}<br/>
// This class is useful for doing operation performance timing internal sealed class OperationTimer : IDisposable {<br/>
private Int64 m_startTime;<br/>
private String m_text;<br/>
private Int32 m_collectionCount;<br/>
public OperationTimer(String text) { PrepareForOperation();<br/>
m_text = text;<br/>
m_collectionCount = CC.CollectionCount(0);<br/>
// This should be the last statement in this<br/>
// method to keep timing as accurate as possible<br/>
m_startTime = Stopwatch.CetTimestamp();<br/>
}<br/>
public void Dispose() {<br/>
Console.WriteLine(&quot;{0,6:###.00} seconds (CCs={1,3}) {2}&quot;, (Stopwatch.CetTimestamp() - m_startTime) /<br/>
(Double) Stopwatch.Frequency, CC.CollectionCount(0) - m_collectionCount, m_text);<br/>
}<br/>
private static void PrepareForOperation() { CC.Collect();<br/>
CC.WaitForPendingFinalizers(); CC.Collect();<br/>
}<br/>
}</code></p>
<p>When I compile and run a release build (with optimizations turned on) of this program on my computer, I get the following output:</p>
<p><code>.10 seconds (CCs=   0).List&lt;Int32&gt;<br/>
3.02 seconds (CCs= 45).ArrayList of Int32<br/>
.47 seconds (CCs=   6).List&lt;String&gt;<br/>
.51 seconds (CCs=   6).ArrayList of String</code></p>
<p>The output here shows that using the generic <b>List </b>algorithm with the <b>Int32 </b>type is much faster than using the non-generic <b>ArrayList </b>algorithm with <b>Int32 </b>In fact, the difference is phenomenal:.1 second versus 3 seconds. That's 30 times faster! In addition, using a value type <b>(Int32) </b>with <b>ArrayList </b>causes a lot of boxing operations to occur, which results in 45 garbage collections. Meanwhile, the <b>List </b>algorithm required 0 garbage collections.</p>
<p>The result of the test using reference types is not as momentous Here we see that the times and number of garbage collections are about the same So it doesn't appear that the generic <b>List </b>algorithm is of any benefit here. However, keep in mind that when using a generic algorithm, you also get cleaner code and compile-time type safety So while the performance improvement is not huge, the other benefits you get when using a generic algorithm are usually an improvement.</p>
<hr/>
<blockquote><b>Note </b>You do need to realize that the CLR generates native code for each method the first time the method is called for a particular data type This will increase an application's working set size, which will hurt performance. I will talk about this more in the &quot;Generics Infrastructure&quot; section of this chapter.</blockquote>
<hr/>
<a name="b280"/><h2>Generics in the Framework Class Library</h2>
<p>Certainly, the most obvious use of generics is with collection classes, and the FCL defines several generic collection classes available for your use. Most of these classes can be found in the <b>System.Collections.Generic </b>namespace and the <b>System.Collections.ObjectModel </b>namespace There are also thread-safe generic collection classes available in the <b>System.Collections.Concurrent </b>namespace. Microsoft recommends that programmers use the generic collection classes and now discourages use of the non-generic collection classes for several reasons First, the non-generic collection classes are not generic, and so you don't get the type safety, cleaner code, and better performance that you get when you use generic collection classes Second, the generic classes have a better object model than the non-generic classes For example, fewer methods are virtual, resulting in better performance, and new members have been added to the generic collections to provide new functionality.</p>
<p>The collection classes implement many interfaces, and the objects that you place into the collections can implement interfaces that the collection classes use for operations such as sorting and searching. The FCL ships with many generic interface definitions so that the benefits of generics can be realized when working with interfaces as well. The commonly used interfaces are contained in the <b>System.Collections.Generic </b>namespace.</p>
<p>The new generic interfaces are not a replacement for the old non-generic interfaces; in many scenarios, you will have to use both The reason is backward compatibility For example, if the <b>List&lt;T&gt; </b>class implemented only the <b>IList&lt;T&gt; </b>interface, no code could consider a <b>List&lt;DateTime&gt; </b>object an <b>IList </b>.</p>
<p>I should also point out that the <b>System.Array </b>class, the base class of all array types, offers many static generic methods, such as <b>AsReadOnly, BinarySearch, ConvertAll, Exists, Find, FindAll, FindIndex, FindLast, FindLastIndex, ForEach, IndexOf, LastIndexOf, Resize, Sort, </b>and <b>TrueForAll. </b>Here are examples showing what some of these methods look like:</p>
<p><code>public abstract class Array : ICloneable, IList, ICollection, IEnumerable, IStructuralComparable, IStructuralEquatable {<br/>
public static void   Sort&lt;T&gt;(T[] array);<br/>
public static void   Sort&lt;T&gt;(T[] array, IComparer&lt;T&gt; comparer);<br/>
public static Int32 BinarySearch&lt;T&gt;(T[] array, T value); public static Int32 BinarySearch&lt;T&gt;(T[] array, T value, IComparer&lt;T&gt; comparer);<br/>
}</code></p>
<p>Here is code that demonstrates how to use some of these methods:</p>
<p><code>public static void Main() {<br/>
// Create &amp; initialize a byte array<br/>
Byte[] byteArray = new Byte[] { 5, 1, 4, 2, 3 };<br/>
// Call Byte[] sort algorithm Array.Sort&lt;Byte&gt;(byteArray);<br/>
// Call Byte[] binary search algorithm<br/>
Int32 i = Array.BinarySearch&lt;Byte&gt;(byteArray, 1);<br/>
Console.WriteLine(i);     // Displays &quot;0&quot;<br/>
}</code></p>
<a name="b281"/><h2>Wintellect's Power Collections Library</h2>
<p>At Microsoft's request, Wintellect has produced the Power Collections library to bring some of the C++ Standard Template Library's collection classes to the CLR programmer. This library is a set of collection classes that anyone can download and use free of charge See <a href="http://Wintellect.com">http://Wintellect.com</a> for details. These collection classes are generic themselves and make extensive use of generics. Table 12-1 shows a list of some of the collection classes you'll find in the Power Collections library.</p>
<p><b>table </b><b>12-1 </b><b>Generic Collection Classes from Wintellect's Power Collections Library</b></p>
<table border="1">
<tr>
<td>
<p>s</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p><b>BigList&lt;T&gt;</b></p>
</td>
<td>
<p>Collection of ordered <b>T </b>objects. Very efficient when working with more than 100 items.</p>
</td>
</tr>
<tr>
<td>
<p><b>Bag&lt;T&gt;</b></p>
</td>
<td>
<p>Collection of unordered <b>T </b>objects The collection is hashed, and duplicates are allowed.</p>
</td>
</tr>
<tr>
<td>
<p><b>OrderedBag&lt;T&gt;</b></p>
</td>
<td>
<p>Collection of ordered <b>T </b>objects. Duplicates are allowed.</p>
</td>
</tr>
<tr>
<td>
<p><b>Set&lt;T&gt;</b></p>
</td>
<td>
<p>Collection of unordered <b>T </b>items. Duplicates are not allowed.</p>
</td>
</tr>
<tr>
<td>
<p><b>OrderedSet&lt;T&gt;</b></p>
</td>
<td>
<p>Collection of ordered <b>T </b>items Duplicates are not allowed.</p>
</td>
</tr>
<tr>
<td>
<p><b>Deque&lt;T&gt;</b></p>
</td>
<td>
<p>Double-ended queue Similar to a list but more efficient for adding/removing items at the beginning than a list.</p>
</td>
</tr>
<tr>
<td>
<p><b>OrderedDictionary&lt;TKey,TValue&gt;</b></p>
</td>
<td>
<p>Dictionary in which keys are ordered, and each can have one value.</p>
</td>
</tr>
<tr>
<td>
<p><b>MultiDictionary&lt;TKey,TValue&gt;</b></p>
</td>
<td>
<p>Dictionary in which a key can have multiple values. Keys are hashed, duplicates are allowed, and items are unordered.</p>
</td>
</tr>
<tr>
<td>
<p><b>OrderedMultiDictionary&lt;TKey,TValue&gt;</b></p>
</td>
<td>
<p>Dictionary in which keys are ordered, and each can have multiple values (also maintained in sorted order). Duplicate keys are allowed.</p>
</td>
</tr>
</table>
<a name="b282"/><h2>Generics Infrastructure</h2>
<p>Generics were added to version 2 0 of the CLR, and it was a major task that required many people working for quite some time. Specifically, to make generics work, Microsoft had to do the following:</p>
<p>&#9632; Create new Intermediate Language (IL) instructions that are aware of type arguments.</p>
<p>&#9632; Modify the format of existing metadata tables so that type names and methods with generic parameters could be expressed.</p>
<p>&#9632; Modify the various programming languages (C#, Microsoft Visual Basic.NET, etc.) to support the new syntax, allowing developers to define and reference generic types and methods.</p>
<p>&#9632; Modify the compilers to emit the new IL instructions and the modified metadata format.</p>
<p>&#9632; Modify the just-in-time (JIT) compiler to process the new type-argument-aware IL instructions that produce the correct native code.</p>
<p>&#9632; Create new reflection members so that developers can query types and members to determine if they have generic parameters. Also, new reflection emit members had to be defined so that developers could create generic type and method definitions at runtime.</p>
<p>&#9632; Modify the debugger to show and manipulate generic types, members, fields, and local variables.</p>
<p>&#9632; Modify the Microsoft Visual Studio IntelliSense feature to show specific member prototypes when using a generic type or a method with a specific data type.</p>
<p>Now let's spend some time discussing how the CLR handles generics internally. This information could impact how you architect and design a generic algorithm. It could also impact your decision to use an existing generic algorithm or not.</p>
<h3>Open and Closed Types</h3>
<p>In various chapters throughout this book, I have discussed how the CLR creates an internal data structure for each and every type in use by an application. These data structures are called type objects. Well, a type with generic type parameters is still considered a type, and the CLR will create an internal type object for each of these This applies to reference types (classes), value types (structs), interface types, and delegate types. However, a type with generic type parameters is called an open type, and the CLR does not allow any instance of an open type to be constructed (similar to how the CLR prevents an instance of an interface type from being constructed).</p>
<p>When code references a generic type, it can specify a set of generic type arguments. If actual data types are passed in for all of the type arguments, the type is called a closed type, and the CLR does allow instances of a closed type to be constructed. However, it is possible for code referencing a generic type to leave some generic type arguments unspecified. This creates a new open type object in the CLR, and instances of this type cannot be created The following code should make this clear:</p>
<p><code>using System;<br/>
using System.Collections.Ceneric;<br/>
// A partially specified open type internal sealed class DictionaryStringKey&lt;TValue&gt; : Dictionary&lt;String, TValue&gt; {<br/>
}<br/>
public static class Program { public static void Main() { Object o = null;<br/>
// Dictionary&lt;,&gt; is an open type having 2 type parameters Type t = typeof(Dictionary&lt;,&gt;);<br/>
// Try to create an instance of this type (fails)<br/>
o = CreateInstance(t);<br/>
Console.WriteLine();<br/>
// DictionaryStringKey&lt;&gt; is an open type having 1 type parameter t = typeof(DictionaryStringKey&lt;&gt;);<br/>
// Try to create an instance of this type (fails)<br/>
o = CreateInstance(t);<br/>
Console.WriteLine();<br/>
// DictionaryStringKey&lt;Cuid&gt; is a closed type t = typeof(DictionaryStringKey&lt;Cuid&gt;);<br/>
// Try to create an instance of this type (succeeds) o = CreateInstance(t);<br/>
// Prove it actually worked<br/>
Console.WriteLine(&quot;Object type=&quot; + o.CetType());<br/>
}<br/>
private static Object CreateInstance(Type t) { Object o = null;<br/>
try {<br/>
o = Activator.CreateInstance(t);<br/>
Console.Write(&quot;Created instance of {0}&quot;, t.ToStringO);<br/>
}<br/>
catch (ArgumentException e) { Console.WriteLine(e.Message);<br/>
}<br/>
return o;<br/>
}<br/>
}</code></p>
<p>When I compile the code above and run it, I get the following output:</p>
<p><code>Cannot create an instance of System.Collections.Ceneric. Dictionary~2[TKey,TValue] because Type.ContainsCenericParameters is true.<br/>
Cannot create an instance of DictionaryStringKey~1[TValue] because Type.ContainsCenericParameters is true.<br/>
Created instance of DictionaryStringKey~1[System.Cuid] Object type=DictionaryStringKey~1[System.Cuid]</code></p>
<p>As you can see, <b>Activator</b>'s <b>CreateInstance </b>method throws an <b>ArgumentException </b>when you ask it to construct an instance of an open type. In fact, the exception's string message indicates that the type still contains some generic parameters.</p>
<p>In the output, you'll notice that the type names end with a backtick <b>0 </b>followed by a number. The number indicates the type's arity, which indicates the number of type parameters required by the type. For example, the <b>Dictionary </b>class has an arity of 2 since it requires that types be specified for <b>TKey </b>and <b>TValue. </b>The <b>DictionaryStringKey </b>class has an arity of 1 since it requires just one type to be specified for <b>TValue </b>.</p>
<p>I should also point out that the CLR allocates a type's static fields inside the type object (as discussed in Chapter 4, &quot;Type Fundamentals&quot;). So each closed type has its own static fields. In other words, if <b>List&lt;T&gt; </b>defined any static fields, these fields are not shared between a <b>List&lt;DateTime&gt; </b>and a <b>List&lt;String&gt;; </b>each closed type object has its own static fields. Also, if a generic type defines a static constructor (discussed in Chapter 8, &quot;Methods&quot;), this constructor will execute once per closed type. Sometimes people define a static constructor on a generic type to ensure that the type arguments will meet certain criteria. For example, if you wanted to define a generic type that can be used only with enumerated types, you could do the following:</p>
<p><code>internal sealed class CenericTypeThatRequiresAnEnum&lt;T&gt; { static CenericTypeThatRequiresAnEnum() { if (!typeof(T).IsEnum) {<br/>
throw new ArgumentException(&quot;T must be an enumerated type&quot;);<br/>
}<br/>
}<br/>
}</code></p>
<p>The CLR has a feature, called constraints, that offers a better way for you to define a generic type indicating what type arguments are valid for it I'll discuss constraints later in this chapter Unfortunately, constraints do not support the ability to limit a type argument to enumerated types only, which is why the previous example requires a static constructor to ensure that the type is an enumerated type.</p>
<h3>Generic Types and Inheritance</h3>
<p>A generic type is a type, and as such, it can be derived from any other type. When you use a generic type and specify type arguments, you are defining a new type object in the CLR, and the new type object is derived from whatever type the generic type was derived from In other words, since <b>List&lt;T&gt; </b>is derived from <b>Object, List&lt;String&gt; </b>and <b>List&lt;Guid&gt; </b>are also derived from <b>Object. </b>Similarly, since <b>DictionaryStringKey&lt;TValue&gt; </b>is derived from <b>Dictionary&lt;String, TValue&gt;, DictionaryStringKey&lt;Guid&gt; </b>is also derived from <b>Dictionary&lt;String, Guid&gt;. </b>Understanding that specifying type arguments doesn't have anything to do with inheritance hierarchies will help you to recognize what kind of casting you can and can't do.</p>
<p>For example, if a linked-list node class is defined like this:</p>
<p><code>internal sealed class Node&lt;T&gt; { public T m_data; public Node&lt;T&gt; m_next;<br/>
public Node(T data) : this(data, null) { }<br/>
public Node(T data, Node&lt;T&gt; next) { m_data = data; m_next = next;<br/>
}<br/>
public override String ToString() { return m_data.ToString() +<br/>
((m_next != null) ? m_next.ToString() : String.Empty);<br/>
}<br/>
}</code></p>
<p>then I can write some code to build up a linked list that would look something like this:</p>
<p><code>private static void SameDataLinkedList() { Node&lt;Char&gt; head = new Node&lt;Char&gt;('C); head = new Node&lt;Char&gt;('B', head); head = new Node&lt;Char&gt;('A', head); Console.WriteLine(head.ToStringO);<br/>
}</code></p>
<p>In the <b>Node </b>class just shown, the <b>m_next </b>field must refer to another node that has the same kind of data type in its <b>m_data </b>field. This means that the linked list must contain nodes in which all data items are of the same type (or derived type) For example, I can't use the <b>Node </b>class to create a linked list in which one element contains a <b>Char, </b>another element contains a <b>DateTime, </b>and another element contains a <b>String. </b>Well, I could if I use <b>Node&lt;Object&gt; </b>everywhere, but then I would lose compile-time type safety, and value types would get boxed.</p>
<p>So a better way to go would be to define a non-generic <b>Node </b>base class and then define a generic <b>TypedNode </b>class (using the <b>Node </b>class as a base class). Now, I can have a linked list in which each node can be of a specific data type (not <b>Object), </b>get compile-time type safety and avoid the boxing of value types. Here are the new class definitions:</p>
<p><code>internal class Node { protected Node m_next;<br/>
public Node(Node next) { m_next = next;<br/>
}<br/>
}<br/>
internal sealed class TypedNode&lt;T&gt; : Node { public T m_data;<br/>
public TypedNode(T data) : this(data, null) { }<br/>
public TypedNode(T data, Node next) : base(next) { m_data = data;<br/>
}<br/>
public override String ToString() { return m_data.ToString() +<br/>
((m_next != null) ? m_next.ToString() : String.Empty);<br/>
}<br/>
}</code></p>
<p>I can now write code to create a linked list in which each node is a different data type The code could look something like this:</p>
<p><code>private static void DifferentDataLinkedList() { Node head = new TypedNode&lt;Char&gt;('.'); head = new TypedNode&lt;DateTime&gt;(DateTime.Now, head); head = new TypedNode&lt;String&gt;(&quot;Today is &quot;, head); Console.WriteLine(head.ToStringO);<br/>
}</code></p>
<h3>Generic Type Identity</h3>
<p>Sometimes generic syntax confuses developers. After all, there can be a lot of less-than (<b>&lt;</b>) and greater-than (<b>&gt;</b>) signs sprinkled throughout your source code, and this hurts readability To improve syntax, some developers define a new non-generic class type that is derived from a generic type and that specifies all of the type arguments. For example, to simplify code like this:</p>
<p><code>List&lt;DateTime&gt; dtl= new List&lt;DateTime&gt;();</code></p>
<p>Some developers might first define a class like this:</p>
<p><code>internal sealed class DateTimeList : List&lt;DateTime&gt; { // No need to put any code in here!<br/>
}</code></p>
<p>Now, the code that creates a list can be rewritten more simply (without less-than and greater-than signs) like this:</p>
<p><code>DateTimeList dtl = new DateTimeList();</code></p>
<p>While this seems like a convenience, especially if you use the new type for parameters, local variables, and fields, you should never define a new class explicitly for the purpose of making your source code easier to read. The reason is because you lose type identity and equivalence, as you can see in the following code:</p>
<p><code>Boolean sameType = (typeof(List&lt;DateTime&gt;) == typeof(DateTimeList));</code></p>
<p>When the code above runs, <b>sameType </b>will be initialized to <b>false </b>because you are comparing two different type objects This also means that a method prototyped as accepting a <b>DateTimeList </b>will not be able to have a <b>List&lt;DateTime&gt; </b>passed to it. However, a method prototyped as accepting a <b>List&lt;DateTime&gt; </b>can have a <b>DateTimeList </b>passed to it since <b>DateTimeList </b>is derived from <b>List&lt;DateTime&gt;. </b>Programmers may become easily confused by all of this.</p>
<p>Fortunately, C# does offer a way to use simplified syntax to refer to a generic closed type while not affecting type equivalence at all; you can use the good old <b>using </b>directive at the top of your source code file. Here is an example:</p>
<p><code>using DateTimeList = System.Collections.Generic.List&lt;System.DateTime&gt;;</code></p>
<p>Here, the <b>using </b>directive is really just defining a symbol called <b>DateTimeList. </b>As the code compiles, the compiler substitutes all occurrences of <b>DateTimeList </b>with <b>System.Collections.Generic.List&lt;System.DateTime&gt;. </b>This just allows developers to use a simplified syntax without affecting the actual meaning of the code, and therefore, type identity and equivalence are maintained So now, when the following line executes, <b>sameType </b>will be initialized to <b>true.</b></p>
<p><code>Boolean sameType = (typeof(List&lt;DateTime&gt;) == typeof(DateTimeList));</code></p>
<p>As another convenience, you can use C#'s implicitly typed local variable feature, where the compiler infers the type of a method's local variable from the type of the expression you are assigning to it:</p>
<p><code>using System;<br/>
using System.Collections.Generic;<br/>
internal sealed class SomeType {<br/>
private static void SomeMethod () {<br/>
// Compiler infers that DateTimeList is of type<br/>
// System.Collections.Generic.List&lt;System.DateTime&gt;<br/>
var dtl = List&lt;DateTime&gt;();<br/>
}<br/>
}</code></p>
<h3>Code Explosion</h3>
<p>When a method that uses generic type parameters is JIT-compiled, the CLR takes the method's IL, substitutes the specified type arguments, and then creates native code that is specific to that method operating on the specified data types. This is exactly what you want and is one of the main features of generics. However, there is a downside to this: the CLR keeps generating native code for every method/type combination. This is referred to as code explosion. This can end up increasing the application's working set substantially, thereby hurting performance.</p>
<p>Fortunately, the CLR has some optimizations built into it to reduce code explosion First, if a method is called for a particular type argument, and later, the method is called again using the same type argument, the CLR will compile the code for this method/type combination just once. So if one assembly uses <b>List&lt;DateTime&gt;, </b>and a completely different assembly</p>
<p>(loaded in the same AppDomain) also uses <b>List&lt;DateTime&gt;, </b>the CLR will compile the methods for <b>List&lt;DateTime&gt; </b>just once. This reduces code explosion substantially.</p>
<p>The CLR has another optimization: the CLR considers all reference type arguments to be identical, and so again, the code can be shared. For example, the code compiled by the CLR for <b>List&lt;String</b>&gt;'s methods can be used for <b>List&lt;Stream</b>&gt;'s methods, since <b>String </b>and <b>Stream </b>are both reference types. In fact, for any reference type, the same code will be used. The CLR can perform this optimization because all reference type arguments or variables are really just pointers (all 32 bits on a 32-bit Windows system and 64 bits on a 64-bit Windows system) to objects on the heap, and object pointers are all manipulated in the same way.</p>
<p>But if any type argument is a value type, the CLR must produce native code specifically for that value type. The reason is because value types can vary in size. And even if two value types are the same size (such as <b>Int32 </b>and <b>UInt32, </b>which are both 32 bits), the CLR still can't share the code because different native CPU instructions can be used to manipulate these values.</p>
<a name="b289"/><h2>Generic Interfaces</h2>
<p>Obviously, the ability to define generic reference and value types was the main feature of generics. However, it was critical for the CLR to also allow generic interfaces. Without generic interfaces, any time you tried to manipulate a value type by using a non-generic interface (such as <b>IComparable), </b>boxing and a loss of compile-time type safety would happen again. This would severely limit the usefulness of generic types. And so the CLR does support generic interfaces. A reference or value type can implement a generic interface by specifying type arguments, or a type can implement a generic interface by leaving the type arguments unspecified. Let's look at some examples.</p>
<p>Here is the definition of a generic interface that ships as part of the FCL (in the <b>System.Collections.Generic </b>namespace):</p>
<p><code>public interface IEnumerator&lt;T&gt; : IDisposable, IEnumerator { T Current { get; }<br/>
}</code></p>
<p>Here is an example of a type that implements this generic interface and that specifies type arguments. Notice that a <b>Triangle </b>object can enumerate a set of <b>Point </b>objects. Also note that the <b>Current </b>property is of the <b>Point </b>data type:</p>
<p><code>internal sealed class Triangle : IEnumerator&lt;Point&gt; { private Point[] m_vertices;<br/>
// IEnumerator&lt;Point&gt;'s Current property is of type Point public Point Current { get {... } }<br/>
}</code></p>
<p>Now let's look at an example of a type that implements the same generic interface but with the type arguments left unspecified:</p>
<p><code>internal sealed class ArrayEnumerator&lt;T&gt; : IEnumerator&lt;T&gt; { private T[] m_array;<br/>
// IEnumerator&lt;T&gt;'s Current property is of type T public T Current { get {... } }<br/>
}</code></p>
<p>Notice that an <b>ArrayEnumerator </b>object can enumerate a set of <b>T </b>objects (where <b>T </b>is unspecified allowing code using the generic <b>ArrayEnumerator </b>type to specify a type for <b>T </b>later). Also note that the <b>Current </b>property is now of the unspecified data type <b>T. </b>Much more information about generic interfaces is presented in Chapter 13, &quot;Interfaces.&quot;</p>
<p>The CLR supports generic delegates to ensure that any type of object can be passed to a callback method in a type-safe way. Furthermore, generic delegates allow a value type instance to be passed to a callback method without any boxing. As discussed in Chapter 17, &quot;Delegates,&quot; a delegate is really just a class definition with four methods: a constructor, an <b>Invoke </b>method, a <b>BeginInvoke </b>method, and an <b>EndInvoke </b>method. When you define a delegate type that specifies type parameters, the compiler defines the delegate class's methods, and the type parameters are applied to any methods having parameters/return values of the specified type parameter.</p>
<p>For example, if you define a generic delegate like this:</p>
<p><code>public delegate TReturn CallMe&lt;TReturn, TKey, TValue&gt;(TKey key, TValue value); The compiler turns that into a class that logically looks like this:<br/>
public sealed class CallMe&lt;TReturn, TKey, TValue&gt; : MulticastDelegate { public CallMe(Object object, IntPtr method); public virtual TReturn Invoke(TKey key, TValue value); public virtual IAsyncResult BeginInvoke(TKey key, TValue value,<br/>
AsyncCallback callback, Object object); public virtual TReturn EndInvoke(IAsyncResult result);<br/>
}</code></p>
<a name="b290"/><h2>Generic Delegates</h2>
<hr/>
<blockquote><b>Note </b>It is recommended that you use the generic <b>Action </b>and <b>Func </b>delegates that come predefined in the Framework Class Library (FCL) wherever possible. I describe these delegate types in the &quot;Enough with the Delegate Definitions Already (Generic Delegates)&quot; section of Chapter 17, &quot;Delegates.&quot;</blockquote>
<hr/>
<a name="b291"/><h2>Delegate and Interface Contravariant and Covariant Generic Type Arguments</h2>
<p>Each of a delegate's generic type parameters can be marked as covariant or contravariant This feature allows you to cast a variable of a generic delegate type to the same delegate type where the generic parameter types differ. A generic type parameter can be any one of the following:</p>
<p>&#9632; Invariant   Meaning that that generic type parameter cannot be changed. I have shown only invariant generic type parameters so far in this chapter.</p>
<p>&#9632; Contravariant   Meaning that the generic type parameter can change from a class to a class derived from it. In C#, you indicate contravariant generic type parameters with the <b>in </b>keyword. Contravariant generic type parameters can appear only in input positions such as a method's argument.</p>
<p>&#9632; Covariant   Meaning that the generic type argument can change from a class to one of its base classes. In C#, you indicate covariant generic type parameters with the <b>out </b>keyword. Covariant generic type parameters can appear only in output positions such as a method's return type.</p>
<p>For example, let's say that the following delegate type definition exists (which, by the way, it does):</p>
<p><code>public delegate TResult Func&lt;in T, out TResult&gt;(T arg);</code></p>
<p>Here, the generic type parameter <b>T </b>is marked with the <b>in </b>keyword, making it contravariant; and the generic type parameter <b>TResult </b>is marked with the <b>out </b>keyword, making it covariant.</p>
<p>So now, if I have a variable declared as follows:</p>
<p><code>Func&lt;Object, ArgumentException&gt; fn1 = null;</code></p>
<p>I can cast it to another <b>Func </b>type, where the generic type parameters are different:</p>
<p><code>Func&lt;String, Exception&gt;fn2 = fn1;// No explicit cast is required here Exception e = fn2(&quot;&quot;);</code></p>
<p>What this is saying is that <b>fn1 </b>refers to a function that accepts an <b>Object </b>and returns an <b>ArgumentException </b>. The <b>fn2 </b>variable wants to refer to a method that takes a <b>String </b>and returns an <b>Exception </b>Since you can pass a <b>String </b>to a method that wants an <b>Object </b>(because <b>String </b>is derived from <b>Object), </b>and since you can take the result of a method that returns an <b>ArgumentException </b>and treat it as an <b>Exception </b>(because <b>Exception </b>is a base class of <b>ArgumentException), </b>the code above compiles and is known at compile time to preserve type safety.</p>
<hr/>
<blockquote><b>Note </b>Variance applies only if the compiler can verify that a reference conversion exists between types. In other words, variance is not possible for value types because boxing would be required. In my opinion, this restriction is what makes these variance features not that useful For example, if I have the following method:</blockquote>
<hr/>
<p><code>voidProcessCollection(IEnumerable&lt;Object&gt; collection) {... }</code></p>
<p>I can't call it passing in a reference to a <b>List&lt;DateTime&gt; </b>object since a reference conversion doesn't exist between the <b>DateTime </b>value type and <b>Object </b>even though <b>DateTime </b>is derived from <b>Object </b>. You solve this problem by declaring <b>ProcessCollection </b>as follows:</p>
<p><code>void ProcessCollection&lt;T&gt;(IEnumerable&lt;T&gt; collection) {... }</code></p>
<p>Plus, the big benefit of <b>ProcessCollection(IEnumerable&lt;Object&gt; collection) </b>is that there is only one version of the JITted code. However, with <b>ProcessCollection&lt;T&gt;(IEnumerable&lt;T&gt;</b></p>
<p><b>collection), </b>there is also only one version of the JITted code shared by all <b>T</b>s that are reference types You do get other versions of JITted code for <b>T</b>s that are value types, but now you can at least call the method passing it a collection of value types.</p>
<p>Also, variance is not allowed on a generic type parameter if an argument of that type is passed to a method using the <b>out </b>or <b>ref </b>keyword. For example, the line of code below causes the compiler to generate the following error message: <b>&quot;Invalid variance: The type parameter 'T' must be invariantly valid on 'SomeDelegate&lt;T&gt;.Invoke(ref T)'. 'T' is contravariant.&quot;</b></p>
<p><code>delegate void SomeDelegate&lt;in T&gt;(ref T t);</code></p>
<p>When using delegates that take generic arguments and return values, it is recommended to always specify the <b>in </b>and <b>out </b>keywords for contravariance and covariance whenever possible, as doing this has no ill effects and enables your delegate to be used in more scenarios.</p>
<p>Like delegates, an interface with generic type parameters can have its type parameters be contravariant or covariant. Here is an example of an interface with a contravariant generic type parameter:</p>
<p><code>public interface IEnumerator&lt;out T&gt; : IEnumerator { Boolean MoveNext(); T Current { get; }<br/>
}</code></p>
<p>Since <b>T </b>is contravariant, it is possible to have the following code compile and run successfully:</p>
<p><code>// This method accepts an IEnumerable of any reference type Int32 Count(IEnumerable&lt;Object&gt; collection) {... }<br/>
// The call below passes an IEnumerable&lt;String&gt; to Count Int32 c = Count(new[] { &quot;Grant&quot; });</code></p>
<hr/>
<blockquote><b>Important </b>Sometimes developers ask why they must explicitly put in or out on generic type parameters They think the compiler should be able to examine the delegate or interface declaration and automatically detect what generic type parameters can be contravariant and covariant While it is true that the compiler could detect this automatically, the C# team believes that you are declaring a contract and that you should be explicit about what you want to allow For example, it would be bad if the compiler determined that a generic type parameter could be contravariant and then, in the future, you added a member to an interface that had the type parameter used in an output position The next time you compile, the compiler would determine that the type parameter should be invariant, but all code sites that reference the other members might now produce errors if they had used the fact that the type parameter had been contravariant.</blockquote>
<hr/>
<p>For this reason, the compiler team forces you to be explicit when declaring a generic type parameter Then, if you attempt to use this type parameter in a context that doesn't match how you declared it, the compiler issues an error letting you know that you are attempting to break the contract. If you then decide to break the contract by adding <b>in </b>or <b>out </b>on generic type parameters, you should expect to have to modify some of the code sites that were using the old contract.</p>
<a name="b293"/><h2>Generic Methods</h2>
<p>When you define a generic class, struct, or interface, any methods defined in these types can refer to a type parameter specified by the type. A type parameter can be used as a method's parameter, a method's return value, or as a local variable defined inside the method. However, the CLR also supports the ability for a method to specify its very own type parameters. And these type parameters can also be used for parameters, return values, or local variables. Here is a somewhat contrived example of a type that defines a type parameter and a method that has its very own type parameter:</p>
<p><code>internal sealed class GenericType&lt;T&gt; { private T m_value;<br/>
public GenericType(T value) { m_value = value; }<br/>
public TOutput Converter&lt;TOutput&gt;() {<br/>
TOutput result = (TOutput) Convert.ChangeType(m_value, typeof(TOutput)); return result;<br/>
}<br/>
}</code></p>
<p>In this example, you can see that the <b>GenericType </b>class defines its own type parameter <b>(T), </b>and the <b>Converter </b>method defines its own type parameter <b>(TOutput) </b>. This allows a <b>GenericType </b>to be constructed to work with any type. The <b>Converter </b>method can convert the object referred to by the <b>m_value </b>field to various types depending on what type argument is passed to it when called. The ability to have type parameters and method parameters allows for phenomenal flexibility.</p>
<p>A reasonably good example of a generic method is the <b>Swap </b>method:</p>
<p><code>private static void Swap&lt;T&gt;(ref T o1, ref T o2) { T temp = o1;<br/>
01.= o2;<br/>
02.= temp;<br/>
}</code></p>
<p>Code can now call <b>Swap </b>like this:</p>
<p><code>private static void CallingSwap() { Int32 n1 = 1, n2 = 2;<br/>
Console.WriteLine(&quot;n1={0}, n2={1}&quot;, n1, n2); Swap&lt;Int32&gt;(ref n1, ref n2); Console.WriteLine(&quot;n1={0}, n2={1}&quot;, n1, n2);<br/>
String s1 = &quot;Aidan&quot;, s2 = &quot;Grant&quot;; Console.WriteLine(&quot;s1={0}, s2={1}&quot;, s1, s2); Swap&lt;String&gt;(ref s1, ref s2); Console.WriteLine(&quot;s1={0}, s2={1}&quot;, s1, s2);<br/>
}</code></p>
<p>Using generic types with methods that take <b>out </b>and <b>ref </b>parameters can be particularly interesting because the variable you pass as an <b>out/ref </b>argument must be the same type as the method's parameter to avoid a potential type safety exploit. This issue related to <b>out/ref </b>parameters is discussed toward the end of the &quot;Passing Parameters by Reference to a Method&quot; section in Chapter 9, &quot;Parameters.&quot; In fact, the <b>Interlocked </b>class's <b>Exchange </b>and <b>CompareExchange </b>methods offer generic overloads for precisely this reason<sup>1</sup>:</p>
<p><code>public static class Interlocked {<br/>
public static T Exchange&lt;T&gt;(ref T location1, T value) where T: class; public static T CompareExchange&lt;T&gt;(<br/>
ref T location1, T value, T comparand) where T: class;<br/>
}</code></p>
<h3>Generic Methods and Type Inference</h3>
<p>For many developers, the C# generic syntax can be confusing with all of its less-than and greater-than signs. To help improve code creation, readability, and maintainability, the C# compiler offers type inference when calling a generic method. Type inference means that the compiler attempts to determine (or infer) the type to use automatically when calling a generic method. Here is some code that demonstrates type inference:</p>
<p><code>private static void CallingSwapUsingInference() {<br/>
Int32 n1 = 1, n2 = 2;<br/>
Swap(ref n1, ref n2);// Calls Swap&lt;Int32&gt;<br/>
String s1 = &quot;Aidan&quot;; Object s2 = &quot;Grant&quot;;<br/>
Swap(ref s1, ref s2);// Error, type can't be inferred<br/>
}</code></p>
<p>The <b>where </b>clause will be explained in the &quot;Verifiability and Constraints&quot; section later in this chapter</p>
<p>1</p>
<p>In this code, notice that the calls to <b>Swap </b>do not specify type arguments in less-than/greater-than signs. In the first call to <b>Swap, </b>the C# compiler was able to infer that <b>n1 </b>and <b>n2 </b>are <b>Int32</b>s, and therefore, it should call <b>Swap </b>by using an <b>Int32 </b>type argument.</p>
<p>When performing type inference, C# uses the variable's data type, not the actual type of the object referred to by the variable. So in the second call to <b>Swap, </b>C# sees that <b>s1 </b>is a <b>String </b>and <b>s2 </b>is an <b>Object </b>(even though it happens to refer to a <b>String) </b>. Since <b>s1 </b>and <b>s2 </b>are variables of different data types, the compiler can't accurately infer the type to use for <b>Swap</b>'s type argument, and it issues the following message: <b>&quot;error CS0411: The type arguments for method 'Program.Swap&lt;T&gt;(ref T, ref T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.&quot;</b></p>
<p>A type can define multiple methods with one of its methods taking a specific data type and another taking a generic type parameter, as in the following example:</p>
<p><code>private static void Display(String s) { Console.WriteLine(s);<br/>
}<br/>
private static void Display&lt;T&gt;(T o) {<br/>
Display(o.ToString<b>O);   </b>// Calls Display(String)<br/>
}</code></p>
<p>Here are some ways to call the <b>Display </b>method:</p>
<p><code>Display(&quot;Jeff&quot;);// Calls Display(String)<br/>
Display(123);// Calls Display&lt;T&gt;(T)<br/>
Display&lt;String&gt;(&quot;Aidan&quot;);   // Calls Display&lt;T&gt;(T)</code></p>
<p>In the first call, the compiler could actually call either the <b>Display </b>method that takes a <b>String </b>or the generic <b>Display </b>method (replacing <b>T </b>with <b>String). </b>However, the C# compiler always prefers a more explicit match over a generic match, and therefore, it generates a call to the non-generic <b>Display </b>method that takes a <b>String. </b>For the second call, the compiler can't call the non-generic <b>Display </b>method that takes a <b>String, </b>so it must call the generic <b>Display </b>method. By the way, it is fortunate that the compiler always prefers the more explicit match; if the compiler had preferred the generic method, because the generic <b>Display </b>method calls <b>Display </b>again (but with a <b>String </b>returned by <b>ToString), </b>there would have been infinite recursion.</p>
<p>The third call to <b>Display </b>specifies a generic type argument, <b>String. </b>This tells the compiler not to try to infer type arguments but instead to use the type arguments that I explicitly specified. In this case, the compiler also assumes that I must really want to call the generic <b>Display </b>method, so the generic <b>Display </b>will be called. Internally, the generic <b>Display </b>method will call <b>ToString </b>on the passed-in string, which results in a string that is then passed to the non-generic <b>Display </b>method.</p>
<a name="b296"/><h2>Generics and Other Members</h2>
<p>In C#, properties, indexers, events, operator methods, constructors, and finalizers cannot themselves have type parameters. However, they can be defined within a generic type, and the code in these members can use the type's type parameters.</p>
<p>C# doesn't allow these members to specify their own generic type parameters because Microsoft's C# team believes that developers would rarely have a need to use these members as generic Furthermore, the cost of adding generic support to these members would be quite high in terms of designing adequate syntax into the language. For example, when you use a + operator in code, the compiler could call an operator overload method There is no way to indicate any type arguments in your code along with the + operator.</p>
<a name="b296_"/><h2>Verifiability and Constraints</h2>
<p>When compiling generic code, the C# compiler analyzes it and ensures that the code will work for any type that exists today or that may be defined in the future. Let's look at the following method:</p>
<p><code>private static Boolean MethodTakingAnyType&lt;T&gt;(T o) { T temp = o;<br/>
Console.WriteLine(o.ToStringO); Boolean b = temp.Equals(o); return b;<br/>
}</code></p>
<p>This method declares a temporary variable <b>(temp) </b>of type <b>T, </b>and then the method performs a couple of variable assignments and a few method calls. This method works for any type. If <b>T </b>is a reference type, it works. If <b>T </b>is a value or enumeration type, it works. If <b>T </b>is an interface or delegate type, it works. This method works for all types that exist today or that will be defined tomorrow because every type supports assignment and calls to methods defined by <b>Object </b>(such as <b>ToString </b>and <b>Equals) </b>.</p>
<p>Now look at the following method:</p>
<p><code>private static T Min&lt;T&gt;(T o1, T o2) { if (o1.CompareTo(o2) &lt; 0) return o1; return o2;<br/>
}</code></p>
<p>The <b>Min </b>method attempts to use the <b>o1 </b>variable to call the <b>CompareTo </b>method. But there are lots of types that do not offer a <b>CompareTo </b>method, and therefore, the C# compiler can't compile this code and guarantee that this method would work for all types. If you attempt to compile the above code, the compiler issues the following message: <b>&quot;error CS0117: 'T' does not contain a definition for 'CompareTo'.&quot;</b></p>
<p>So it would seem that when using generics, you can declare variables of a generic type, perform some variable assignments, call methods defined by <b>Object, </b>and that's about it! This makes generics practically useless. Fortunately, compilers and the CLR support a mechanism called constraints that you can take advantage of to make generics useful again.</p>
<p>A constraint is a way to limit the number of types that can be specified for a generic argument. Limiting the number of types allows you to do more with those types. Here is a new version of the <b>Min </b>method that specifies a constraint (in bold):</p>
<p><code>public static T Min&lt;T&gt;(T o1, T o2) <b>where T : IComparable&lt;T&gt; </b>{ if (o1.CompareTo(o2) &lt; 0) return o1; return o2;<br/>
}</code></p>
<p>The C# <b>where </b>token tells the compiler that any type specified for <b>T </b>must implement the generic <b>IComparable </b>interface of the same type <b>(T) </b>. Because of this constraint, the compiler now allows the method to call the <b>CompareTo </b>method since this method is defined by the <b>IComparable&lt;T&gt; </b>interface.</p>
<p>Now, when code references a generic type or method, the compiler is responsible for ensuring that a type argument that meets the constraints is specified. For example, the following code causes the compiler to issue the following message: <b>&quot;error CS0311: The type 'object' cannot be used as type parameter 'T' in the generic type or method 'SomeType.Min&lt;T&gt;(T, T)'. There is no implicit reference conversion from 'object' to 'System.IComparable&lt;object&gt;'.&quot;</b></p>
<p><code>private static void CallMin() {<br/>
Object o1 = &quot;Jeff&quot;, o2 = &quot;Richter&quot;;<br/>
Object oMin = Min&lt;Object&gt;(o1, o2);   // Error CS0311<br/>
}</code></p>
<p>The compiler issues the error because <b>System.Object </b>doesn't implement the <b>IComparable&lt;Object&gt; </b>interface In fact, <b>System.Object </b>doesn't implement any interfaces at all.</p>
<p>Now that you have a sense of what constraints are and how they work, we'll start to look a little deeper into them Constraints can be applied to a generic type's type parameters as well as to a generic method's type parameters (as shown in the <b>Min </b>method) The CLR doesn't allow overloading based on type parameter names or constraints; you can overload types or methods based only on arity. The following examples show what I mean:</p>
<p><code>// It is OK to define the following types: internal sealed class AType {} internal sealed class AType&lt;T&gt; {} internal sealed class AType&lt;T1, T2&gt; {}<br/>
// Error: conflicts with AType&lt;T&gt; that has no constraints internal sealed class AType&lt;T&gt; where T : IComparable&lt;T&gt; {}<br/>
// Error: conflicts with AType&lt;T1, T2&gt; internal sealed class AType&lt;T3, T4&gt; {}<br/>
internal sealed class AnotherType {<br/>
// It is OK to define the following methods: private static void M() {} private static void M&lt;T&gt;() {} private static void M&lt;T1, T2&gt;() {}<br/>
// Error: conflicts with M&lt;T&gt; that has no constraints private static void M&lt;T&gt;() where T : IComparable&lt;T&gt; {}<br/>
// Error: conflicts with M&lt;T1, T2&gt; private static void M&lt;T3, T4&gt;() {}<br/>
}</code></p>
<p>When overriding a virtual generic method, the overriding method must specify the same number of type parameters, and these type parameters will inherit the constraints specified on them by the base class's method In fact, the overriding method is not allowed to specify any constraints on its type parameters at all. However, it can change the names of the type parameters. Similarly, when implementing an interface method, the method must specify the same number of type parameters as the interface method, and these type parameters will inherit the constraints specified on them by the interface's method. Here is an example that demonstrates this rule by using virtual methods:</p>
<p><code>internal class Base {<br/>
public virtual void M&lt;T1, T2&gt;() where T1 : struct where T2 : class {<br/>
}<br/>
}<br/>
internal sealed class Derived : Base { public override void M&lt;T3, T4&gt;() where T3 : EventArgs   // Error where T4 : class// Error<br/>
{ }<br/>
}</code></p>
<p>Attempting to compile the code above causes the compiler to issue the following message: <b>&quot;error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method so cannot be specified directly.&quot; </b>If we remove the two <b>where </b>lines from the <b>Derived </b>class's <b>M&lt;T3, T4&gt; </b>method, the code will compile just fine. Notice that you can change the names of the type parameters (as in the example: from <b>T1 </b>to <b>T3 </b>and <b>T2 </b>to <b>T4); </b>however, you cannot change (or even specify) constraints.</p>
<p>Now let's talk about the different kinds of constraints the compiler/CLR allows you to apply to a type parameter. A type parameter can be constrained using a primary constraint, a secondary constraint, and/or a constructor constraint. I'll talk about these three kinds of constraints in the next three sections.</p>
<h3>Primary Constraints</h3>
<p>A type parameter can specify zero primary constraints or one primary constraint. A primary constraint can be a reference type that identifies a class that is not sealed. You cannot specify one of the following special reference types: <b>System.Object, System.Array, System.Delegate, System.MulticastDelegate, System.ValueType, System.Enum, </b>or <b>System.Void </b>.</p>
<p>When specifying a reference type constraint, you are promising the compiler that a specified type argument will either be of the same type or of a type derived from the constraint type. For example, see the following generic class:</p>
<p><code>internal sealed class PrimaryConstraintOfStream&lt;T&gt; where T : <b>Stream </b>{ public void M(T stream) { stream.Close();// OK<br/>
}<br/>
}</code></p>
<p>In this class definition, the type parameter <b>T </b>has a primary constraint of <b>Stream </b>(defined in the <b>System.IO </b>namespace) This tells the compiler that code using <b>PrimaryConstraintOfStream </b>must specify a type argument of <b>Stream </b>or a type derived from <b>Stream </b>(such as <b>FileStream) </b>. If a type parameter doesn't specify a primary constraint, <b>System.Object </b>is assumed However, the C# compiler issues an error message <b>(&quot;error CS0702: Constraint cannot be special class 'object' </b>&quot;) if you explicitly specify <b>System.Object </b>in your source code.</p>
<p>There are two special primary constraints: <b>class </b>and <b>struct. </b>The <b>class </b>constraint promises the compiler that a specified type argument will be a reference type. Any class type, interface type, delegate type, or array type satisfies this constraint. For example, see the following generic class:</p>
<p><code>internal sealed class PrimaryConstraintOfClass&lt;T&gt; where T : <b>class </b>{ public void M() {<br/>
T temp = null;// Allowed because T must be a reference type<br/>
}<br/>
}</code></p>
<p>In this example, setting <b>temp </b>to <b>null </b>is legal because <b>T </b>is known to be a reference type, and all reference type variables can be set to <b>null. </b>If <b>T </b>were unconstrained, the code above would not compile because <b>T </b>could be a value type, and value type variables cannot be set to <b>null.</b></p>
<p>The <b>struct </b>constraint promises the compiler that a specified type argument will be a value type. Any value type, including enumerations, satisfies this constraint. However, the compiler and the CLR treat any <b>System.Nullable&lt;T&gt; </b>value type as a special type, and nullable types do not satisfy this constraint. The reason is because the <b>Nullable&lt;T&gt; </b>type constrains its type parameter to <b>struct, </b>and the CLR wants to prohibit a recursive type such as <b>Nullable&lt;Nullable&lt;T&gt;&gt;. </b>Nullable types are discussed in Chapter 19, &quot;Nullable Value Types.&quot;</p>
<p>Here is an example class that constrains its type parameter by using the <b>struct </b>constraint:</p>
<p><code>internal sealed class PrimaryConstraintOfStruct&lt;T&gt; where T : <b>struct </b>{ public static T Factory() {<br/>
// Allowed because all value types implicitly // have a public, parameterless constructor return new T();<br/>
}<br/>
}</code></p>
<p>In this example, <b>new</b>ing up a <b>T </b>is legal because <b>T </b>is known to be a value type, and all value types implicitly have a public, parameterless constructor. If <b>T </b>were unconstrained, constrained to a reference type, or constrained to <b>class, </b>the above code would not compile because some reference types do not have public, parameterless constructors.</p>
<h3>Secondary Constraints</h3>
<p>A type parameter can specify zero or more secondary constraints where a secondary constraint represents an interface type When specifying an interface type constraint, you are promising the compiler that a specified type argument will be a type that implements the interface. And since you can specify multiple interface constraints, the type argument must specify a type that implements all of the interface constraints (and all of the primary constraints too, if specified). Chapter 13 discusses interface constraints in detail.</p>
<p>There is another kind of secondary constraint called a type parameter constraint (sometimes referred to as a naked type constraint). This kind of constraint is used much less often than an interface constraint. It allows a generic type or method to indicate that there must be a relationship between specified type arguments. A type parameter can have zero or more type constraints applied to it. Here is a generic method that demonstrates the use of a type parameter constraint:</p>
<p><code>private static List&lt;TBase&gt; ConvertIList&lt;T, TBase&gt;(IList&lt;T&gt; list) where T : <b>TBase </b>{<br/>
List&lt;TBase&gt; baseList = new List&lt;TBase&gt;(list.Count); for (Int32 index = 0; index &lt; list.Count; index++) { baseList.Add(list[index]);<br/>
}<br/>
return baseList;<br/>
}</code></p>
<p>The <b>ConvertIList </b>method specifies two type parameters in which the <b>T </b>parameter is constrained by the <b>TBase </b>type parameter. This means that whatever type argument is specified for <b>T, </b>the type argument must be compatible with whatever type argument is specified for <b>TBase. </b>Here is a method showing some legal and illegal calls to <b>ConvertIList:</b></p>
<p><code>private static void CallingConvertIList() {<br/>
// Construct and initialize a List&lt;String&gt; (which implements IList&lt;String&gt;) IList&lt;String&gt; ls = new List&lt;String&gt;(); ls.AddC'A String&quot;);<br/>
// Convert the IList&lt;String&gt; to an IList&lt;Object&gt; IList&lt;Object&gt; lo = ConvertIList&lt;String, Object&gt;(ls);<br/>
// Convert the IList&lt;String&gt; to an IList&lt;IComparable&gt; IList&lt;IComparable&gt; lc = ConvertIList&lt;String, IComparable&gt;(ls);<br/>
// Convert the IList&lt;String&gt; to an IList&lt;IComparable&lt;String&gt;&gt; IList&lt;IComparable&lt;String&gt;&gt; lcs =<br/>
ConvertIList&lt;String, IComparable&lt;String&gt;&gt;(ls);<br/>
// Convert the IList&lt;String&gt; to an IList&lt;String&gt; IList&lt;String&gt; ls2 = ConvertIList&lt;String, String&gt;(ls);<br/>
// Convert the IList&lt;String&gt; to an IList&lt;Exception&gt; IList&lt;Exception&gt; le = ConvertIList&lt;String, Exception&gt;(ls);// Error<br/>
}</code></p>
<p>In the first call to <b>ConvertIList, </b>the compiler ensures that <b>String </b>is compatible with <b>Object </b>. Since <b>String </b>is derived from <b>Object, </b>the first call adheres to the type parameter constraint. In the second call to <b>ConvertIList, </b>the compiler ensures that <b>String </b>is compatible with <b>IComparable </b>Since <b>String </b>implements the <b>IComparable </b>interface, the second call adheres to the type parameter constraint. In the third call to <b>ConvertIList, </b>the compiler ensures that <b>String </b>is compatible with <b>IComparable&lt;String&gt; </b>. Since <b>String </b>implements the <b>IComparable&lt;String&gt; </b>interface, the third call adheres to the type parameter constraint In the fourth call to <b>ConvertIList, </b>the compiler knows that <b>String </b>is compatible with itself In the fifth call to <b>ConvertIList, </b>the compiler ensures that <b>String </b>is compatible with <b>Exception </b>. Since <b>String </b>is not compatible with <b>Exception, </b>the fifth call doesn't adhere to the type parameter constraint, and the compiler issues the following message: <b>&quot;error CS0311: The type 'string' cannot be used as type parameter 'T' in the generic type or method 'Program.ConvertIList&lt;T,TBase&gt;(System.Collections. Generic.IList&lt;T&gt;)'. There is no implicit reference conversion from 'string' to 'System.Exception'.&quot;</b></p>
<h3>Constructor Constraints</h3>
<p>A type parameter can specify zero constructor constraints or one constructor constraint. When specifying a constructor constraint, you are promising the compiler that a specified type argument will be a non-abstract type that implements a public, parameterless constructor. Note that the C# compiler considers it an error to specify a constructor constraint with the <b>struct </b>constraint because it is redundant; all value types implicitly offer a public, parameterless constructor. Here is an example class that constrains its type parameter by using the constructor constraint:</p>
<p><code>internal sealed class ConstructorConstraint&lt;T&gt; where T : <b>new() </b>{ public static T Factory() {<br/>
// Allowed because all value types implicitly // have a public, parameterless constructor and because // the constraint requires that any specified reference // type also have a public, parameterless constructor return new T();<br/>
}<br/>
}</code></p>
<p>In this example, <b>new</b>ing up a <b>T </b>is legal because <b>T </b>is known to be a type that has a public, parameterless constructor. This is certainly true of all value types, and the constructor constraint requires that it be true of any reference type specified as a type argument.</p>
<p>Sometimes, developers would like to declare a type parameter by using a constructor constraint whereby the constructor takes various parameters itself As of now, the CLR (and therefore the C# compiler) supports only parameterless constructors. Microsoft feels that this will be good enough for almost all scenarios, and I agree.</p>
<h3>Other Verifiability Issues</h3>
<p>In the remainder of this section, I'd like to point out a few other code constructs that have unexpected behavior when used with generics due to verifiability issues and how constraints can be used to make the code verifiable again.</p>
<h3>Casting a Generic Type Variable</h3>
<p>Casting a generic type variable to another type is illegal unless you are casting to a type compatible with a constraint:</p>
<p><code>private static void CastingACenericTypeVariable1&lt;T&gt;(T obj) { Int32   x = (Int32) obj;     // Error String s = (String) obj;   // Error<br/>
}</code></p>
<p>The compiler issues an error on both lines above because <b>T </b>could be any type, and there is no guarantee that the casts will succeed. You can modify this code to get it to compile by casting to <b>Object </b>first:</p>
<p><code>private static void CastingACenericTypeVariable2&lt;T&gt;(T obj) { Int32   x = (Int32) (Object) obj;     // No error String s = (String) (Object) obj;   // No error<br/>
}</code></p>
<p>While this code will now compile, it is still possible for the CLR to throw an <b>InvalidCastException </b>at runtime.</p>
<p>If you are trying to cast to a reference type, you can also use the C# <b>as </b>operator Here is code modified to use the <b>as </b>operator with <b>String </b>(since <b>Int32 </b>is a value type):</p>
<p><code>private static void CastingAGenericTypeVariable3&lt;T&gt;(T obj) { String s = obj as String;   // No error<br/>
}</code></p>
<h3>Setting a Generic Type Variable to a Default Value</h3>
<p>Setting a generic type variable to <b>null </b>is illegal unless the generic type is constrained to a reference type.</p>
<p><code>private static void SettingAGenericTypeVariableToNull&lt;T&gt;() {<br/>
T temp = null;      // CS0403 - Cannot convert null to type parameter 'T' because it could // be a non-nullable value type. Consider using 'default(T)' instead<br/>
}</code></p>
<p>Since <b>T </b>is unconstrained, it could be a value type, and setting a variable of a value type to <b>null </b>is not possible. If <b>T </b>were constrained to a reference type, setting <b>temp </b>to <b>null </b>would compile and run just fine.</p>
<p>Microsoft's C# team felt that it would be useful to give developers the ability to set a variable to a default value. So the C# compiler allows you to use the <b>default </b>keyword to accomplish this:</p>
<p><code>private static void SettingAGenericTypeVariableToDefaultValue&lt;T&gt;() { T temp = default(T);   // OK<br/>
}</code></p>
<p>The use of the <b>default </b>keyword above tells the C# compiler and the CLR's JIT compiler to produce code to set <b>temp </b>to <b>null </b>if <b>T </b>is a reference type and to set <b>temp </b>to all-bits-zero if <b>T </b>is a value type.</p>
<h3>Comparing a Generic Type Variable with null</h3>
<p>Comparing a generic type variable to <b>null </b>by using the <b>== </b>or <b>!= </b>operator is legal regardless of whether the generic type is constrained:</p>
<p><code>private static void ComparingAGenericTypeVariableWithNu11&lt;T&gt;(T obj) { if (obj == null) { /* Never executes for a value type */ }<br/>
}</code></p>
<p>Since <b>T </b>is unconstrained, it could be a reference type or a value type. If <b>T </b>is a value type, <b>obj </b>can never be <b>null. </b>Normally, you'd expect the C# compiler to issue an error because of this. However, the C# compiler does not issue an error; instead, it compiles the code just fine. When this method is called using a type argument that is a value type, the JIT compiler sees that the <b>if </b>statement can never be true, and the JIT compiler will not emit the native code for the <b>if </b>test or the code in the braces. If I had used the <b>!= </b>operator, the JIT compiler would not emit the code for the <b>if </b>test (since it is always true), and it will emit the code inside the <b>if</b>'s braces.</p>
<p>By the way, if <b>T </b>had been constrained to a <b>struct, </b>the C# compiler would issue an error because you shouldn't be writing code that compares a value type variable with <b>null </b>since the result is always the same.</p>
<h3>Comparing Two Generic Type Variables with Each Other</h3>
<p>Comparing two variables of the same generic type is illegal if the generic type parameter is not known to be a reference type:</p>
<p><code>private static void ComparingTwoGenericTypeVariables&lt;T&gt;(T ol, T o2) { if (ol == o2) { }   // Error<br/>
}</code></p>
<p>In this example, <b>T </b>is unconstrained, and whereas it is legal to compare two reference type variables with one another, it is not legal to compare two value type variables with one another unless the value type overloads the <b>== </b>operator If <b>T </b>were constrained to <b>class, </b>this code would compile, and the <b>== </b>operator would return <b>true </b>if the variables referred to the same object, checking for exact identity. Note that if <b>T </b>were constrained to a reference type that overloaded the <b>operator == </b>method, the compiler would emit calls to this method when it sees the <b>== </b>operator. Obviously, this whole discussion applies to uses of the <b>!= </b>operator too.</p>
<p>When you write code to compare the primitive value types<b>唯yte, Int32, Single, Decimal, </b>etc.葉he C# compiler knows how to emit the right code. However, for non-primitive value types, the C# compiler doesn't know how to emit the code to do comparisons. So if <b>ComparingTwoGenericTypeVariables </b>method's <b>T </b>were constrained to <b>struct, </b>the compiler would issue an error. And you're not allowed to constrain a type parameter to a specific value type because it is implicitly sealed, and therefore no types exist that are derived from the value type. Allowing this would make the generic method constrained to a specific type, and the C# compiler doesn't allow this because it is more efficient to just make a non-generic method.</p>
<h3>Using Generic Type Variables as Operands</h3>
<p>Finally, it should be noted that there are a lot of issues about using operators with generic type operands. In Chapter 5, I talked about C# and how it handles its primitive types: <b>Byte, Int16, Int32, Int64, Decimal, </b>and so on. In particular, I mentioned that C# knows how to interpret operators (such as <b>+</b>, <b>-</b>, <b>*</b>, and <b>/</b>) when applied to the primitive types Well, these operators can't be applied to variables of a generic type because the compiler doesn't know the type at compile time. This means that you can't use any of these operators with variables of a generic type. So it is impossible to write a mathematical algorithm that works on an arbitrary numeric data type. Here is an example of a generic method that I'd like to write:</p>
<p><code>private static T Sum&lt;T&gt;(T num) where T : struct { T sum = default(T). for (T n = default(T). n &lt; num. n++)<br/>
sum += n; return sum;<br/>
}</code></p>
<p>I've done everything possible to try to get this method to compile. I've constrained <b>T </b>to <b>struct, </b>and I'm using <b>default(T) </b>to initialize <b>sum </b>and <b>n </b>to <b>0 </b>. But when I compile this code, I get the following three errors:</p>
<p><b>&#9632; error CS0019: Operator '&lt;' cannot be applied to operands of type 'T' and 'T'</b></p>
<p><b>&#9632; error CS0023: Operator '++' cannot be applied to operand of type 'T'</b></p>
<p><b>&#9632; error CS0019: Operator '+=' cannot be applied to operands of type 'T' and 'T'</b></p>
<p>This is a severe limitation on the CLR's generic support, and many developers (especially in the scientific, financial, and mathematical world) are very disappointed by this limitation. Many people have tried to come up with techniques to work around this limitation by using reflection (see Chapter 23, &quot;Assembly Loading and Reflection&quot;), operator overloading, and so on. But all of these cause a severe performance penalty or hurt readability of the code substantially. Hopefully, this is an area that Microsoft will address in a future version of the CLR and the compilers.</p>
<mbp:pagebreak/>
<a name="Chapter13"/>
<h1>Chapter 13: Interfaces</h1>
<p><b>In this chapter:</b></p>
<a href="#b308">Class and Interface Inheritance</a><br/>
<a href="#b308_">Defining an Interface</a><br/>
<a href="#b312">More About Calling Interface Methods</a><br/>
<a href="#b314">Implicit and Explicit Interface Method Implementations (What痴 Happening Behind the Scenes)></a><br/>
<a href="#b318">Generics and Interface Constraints</a><br/>
<a href="#b319">Implementing Multiple Interfaces That Have the Same Method Name and Signature</a><br/>
<a href="#b320">Improving Compile-Time Type Safety with Explicit Interface Method Implementations</a><br/>
<a href="#b322">Be Careful with Explicit Interface Method Implementations</a><br/>
<a href="#b325">Design: Base Class or Interface?</a><br/>
<p>Many programmers are familiar with the concept of multiple inheritance: the ability to define a class that is derived from two or more base classes. For example, imagine a class named <b>TransmitData, </b>whose function is to transmit data, and another class named <b>ReceiveData, </b>whose function is to receive data. Now imagine that you want to create a class named <b>SocketPort, </b>whose function is to transmit and receive data In order to accomplish this, you would want to derive <b>SocketPort </b>from both <b>TransmitData </b>and <b>ReceiveData.</b></p>
<p>Some programming languages allow multiple inheritance, making it possible for the <b>SocketPort </b>class to be derived from the two base classes, <b>TransmitData </b>and <b>ReceiveData. </b>However, the common language runtime (CLR)預nd therefore all managed programming languages妖oes not support multiple inheritance. Rather than not offer any kind of multiple inheritance at all, the CLR does offer scaled-down multiple inheritance via interfaces. This chapter will discuss how to define and use interfaces as well as provide some guidelines to help you determine when to use an interface rather than a base class.</p>
<a name="b308"/><h2>Class and Interface Inheritance</h2>
<p>In the Microsoft .NET Framework, there is a class called <b>System.Object </b>that defines four public instance methods: <b>ToString, Equals, GetHashCode, </b>and <b>GetType. </b>This class is the root or ultimate base class of all other classes預ll classes will inherit <b>Object</b>'s four instance methods This also means that code written to operate on an instance of the <b>Object </b>class can actually perform operations on an instance of any class.</p>
<p>Since someone at Microsoft has implemented <b>Object</b>'s methods, any class derived from <b>Object </b>is actually inheriting the following:</p>
<p><b>&#9632; The method signatures  </b>This allows code to think that it is operating on an instance of the <b>Object </b>class, when in fact, it could be operating on an instance of some other class.</p>
<p><b>&#9632; The implementation of these methods   </b>This allows the developer defining a class derived from <b>Object </b>not to be required to implement <b>Object</b>'s methods manually.</p>
<p>In the CLR, a class is always derived from one and only one class (that must ultimately be derived from <b>Object) </b>. This base class provides a set of method signatures and implementations for these methods. And a cool thing about defining a new class is that it can become the base class for another class defined in the future by some other developer預ll of the method signatures and their implementations will be inherited by the new derived class.</p>
<p>The CLR also allows developers to define an interface, which is really just a way to give a name to a set of method signatures. These methods do not come with any implementation at all A class inherits an interface by specifying the interface's name, and the class must explicitly provide implementations of the interface's methods before the CLR will consider the type definition to be valid. Of course, implementing interface methods can be tedious, which is why I referred to interface inheritance as a scaled-down mechanism to achieve multiple inheritance. The C# compiler and the CLR actually allow a class to inherit several interfaces, and of course, the class must provide implementations for all of the inherited interface methods.</p>
<p>One of the great features of class inheritance is that it allows instances of a derived type to be substituted in all contexts that expect instances of a base type Similarly, interface inheritance allows instances of a type that implements the interface to be substituted in all contexts that expect instances of the named interface type. We will now look at how to define interfaces to make our discussion more concrete.</p>
<a name="b308_"/><h2>Defining an Interface</h2>
<p>As mentioned in the previous section, an interface is a named set of method signatures Note that interfaces can also define events, parameterless properties, and parameterful properties (indexers in C#) because all of these are just syntax shorthands that map to methods anyway,</p>
<p>as shown in previous chapters. However, an interface cannot define any constructor methods. In addition, an interface is not allowed to define any instance fields.</p>
<p>Although the CLR does allow an interface to define static methods, static fields, constants, and static constructors, a Common Language Infrastructure (CLI)-compliant interface must not have any of these static members because some programming languages aren't able to define or access them. In fact, C# prevents an interface from defining any of these static members.</p>
<p>In C#, you use the <b>interface </b>keyword to define an interface, giving it a name and its set of instance method signatures. Here are the definitions of a few interfaces defined in the Framework Class Library (FCL):</p>
<p><code>public interface IDisposable { void Dispose();<br/>
}<br/>
public interface IEnumerable { IEnumerator GetEnumerator();<br/>
}<br/>
public interface IEnumerable&lt;out T&gt; : IEnumerable { new IEnumerator&lt;T&gt; GetEnumerator();<br/>
}<br/>
public interface ICollection&lt;T&gt; : IEnumerable&lt;T&gt;, IEnumerable { void      Add(T item); void Clear(); Boolean Contains(T item);<br/>
void      CopyTo(T[] array, Int32 arrayIndex); Boolean Remove(T item);<br/>
Int32     Count{ get; } // Read-only property<br/>
Boolean IsReadOnly { get; } // Read-only property<br/>
}</code></p>
<p>To the CLR, an interface definition is just like a type definition. That is, the CLR will define an internal data structure for the interface type object, and reflection can be used to query features of the interface type. Like types, an interface can be defined at file scope or defined nested within another type. When defining the interface type, you can specify whatever visibility/accessibility <b>(public, protected, internal, </b>etc.) you desire.</p>
<p>By convention, interface type names are prefixed with an uppercase <b>I, </b>making it easy to spot an interface type in source code The CLR does support generic interfaces (as you can see from some of the previous examples) as well as generic methods in an interface. I will discuss some of the many features offered by generic interfaces later in this chapter and in Chapter 12, &quot;Generics,&quot; in which I cover generics more broadly.</p>
<p>An interface definition can &quot;inherit&quot; other interfaces. However, I use the word inherit here rather loosely because interface inheritance doesn't work exactly as does class inheritance. I prefer to think of interface inheritance as including the contract of other interfaces</p>
<p>For example, the <b>ICollection&lt;T&gt; </b>interface definition includes the contracts of the <b>IEnumerable&lt;T&gt; </b>and <b>IEnumerable </b>interfaces. This means that:</p>
<p>&#9632; Any class that inherits the <b>ICollection&lt;T&gt; </b>interface must implement all of the methods defined by the <b>ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, </b>and <b>IEnumerable </b>interfaces.</p>
<p>&#9632; Any code that expects an object whose type implements the <b>ICollection&lt;T&gt; </b>interface can assume that the object's type also implements the methods of the <b>IEnumerable&lt;T&gt; </b>and <b>IEnumerable </b>interfaces.</p>
<h2>Inheriting an Interface</h2>
<p>In this section, I'll show how to define a type that implements an interface, and then I'll show how to create an instance of this type and use the object to call the interface's methods C# actually makes this pretty simple, but what happens behind the scenes is a bit more complicated. I'll explain what is happening behind the scenes later in this chapter.</p>
<p>The <b>System.IComparable&lt;T&gt; </b>interface is defined (in MSCorLib.dll) as follows:</p>
<p><code>public interface IComparable&lt;in T&gt; { Int32 CompareTo(T other);<br/>
}</code></p>
<p>The following code shows how to define a type that implements this interface and also shows code that compares two <b>Point </b>objects:</p>
<p><code>using System;<br/>
// Point is derived from System.Object and implements IComparable&lt;T&gt; for Point. public sealed class Point : IComparable&lt;Point&gt; { private Int32 m_x, m_y;<br/>
public Point(Int32 x, Int32 y) { m_x = x; m_y = y;<br/>
}<br/>
// This method implements IComparable&lt;T&gt;.CompareTo() for Point public Int32 CompareTo(Point other) {<br/>
return Math.Sign(Math.Sqrt(m_x * m_x + m_y * m_y)<br/>
- Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));<br/>
}<br/>
public override String ToString() {<br/>
return String.Format(&quot;({0}, {1})&quot;, m_x, m_y);<br/>
}<br/>
}<br/>
public static class Program { public static void Main() {<br/>
Point[] points = new Point[] { new Point(3, 3), new Point(1, 2),<br/>
};<br/>
// Here is a call to Point's IComparable&lt;T&gt; CompareTo method if Cpoints[0].CompareTo(points[1]) &gt; 0) {<br/>
Point tempPoint = points[0];<br/>
points[0] = points[1];<br/>
points[1] = tempPoint;<br/>
}<br/>
Console.Writel_ine(&quot;Points from closest to (0, 0) to farthest:&quot;); foreach (Point p in points) Console.WriteLine(p);<br/>
}<br/>
}</code></p>
<p>The C# compiler requires that a method that implements an interface be marked as public The CLR requires that interface methods be marked as virtual. If you do not explicitly mark the method as virtual in your source code, the compiler marks the method as virtual and sealed; this prevents a derived class from overriding the interface method. If you explicitly mark the method as virtual, the compiler marks the method as virtual (and leaves it unsealed); this allows a derived class to override the interface method.</p>
<p>If an interface method is sealed, a derived class cannot override the method However, a derived class can re-inherit the same interface and can provide its own implementation for the interface's methods When calling an interface's method on an object, the implementation associated with the object's type is called Here is an example that demonstrates this:</p>
<p><code>using System;<br/>
public static class Program { public static void Main() {<br/>
/************************* First Example *************************/ Base b = new Base();<br/>
// Calls Dispose by using b's type: &quot;Base's Dispose&quot; b.Dispose();<br/>
// Calls Dispose by using b's object's type: &quot;Base's Dispose&quot; ((IDisposable)b).Dispose();<br/>
/************************* Second Example ************************/ Derived d = new Derived();<br/>
// Calls Dispose by using d's type: &quot;Derived's Dispose&quot; d.Dispose();<br/>
// Calls Dispose by using d's object's type: &quot;Derived's Dispose&quot;<br/>
((IDisposable)d).Dispose();<br/>
/************************* Third Example *************************/ b = new Derived();<br/>
// Calls Dispose by using b's type: &quot;Base's Dispose&quot; b.Dispose();<br/>
// Calls Dispose by using b's object's type: &quot;Derived's Dispose&quot; ((IDisposable)b).Dispose();<br/>
}<br/>
}<br/>
// This class is derived from Object and it implements IDisposable internal class Base : IDisposable {<br/>
// This method is implicitly sealed and cannot be overridden<br/>
public void Dispose() {<br/>
Console.WriteLineC'Base's Dispose&quot;);<br/>
}<br/>
}<br/>
// This class is derived from Base and it re-implements IDisposable<br/>
internal class Derived : Base, IDisposable {<br/>
// This method cannot override Base's Dispose,  'new' is used to indicate // that this method re-implements IDisposable's Dispose method new public void Dispose() {<br/>
Console.WriteLineC'Derived's Dispose&quot;);<br/>
// NOTE: The next line shows how to call a base class's implementation (if desired) // base.Dispose();<br/>
}<br/>
}</code></p>
<a name="b312"/><h2>More About Calling Interface Methods</h2>
<p>The FCL's <b>System.String </b>type inherits <b>System.Object</b>'s method signatures and their implementations. In addition, the <b>String </b>type also implements several interfaces: <b>IComparable, ICloneable, IConvertible, IEnumerable, IComparable&lt;String&gt;, IEnumerable&lt;Char&gt;, </b>and <b>IEquatable&lt;String&gt;. </b>This means that the <b>String </b>type isn't required to implement (or override) the methods its <b>Object </b>base type offers. However, the <b>String </b>type must implement the methods declared in all of the interfaces.</p>
<p>The CLR allows you to define field, parameter, or local variables that are of an interface type. Using a variable of an interface type allows you to call methods defined by that interface. In addition, the CLR will allow you to call methods defined by <b>Object </b>because all classes inherit <b>Object</b>'s methods The following code demonstrates this:</p>
<p><code>// The s variable refers to a String object. String s = &quot;Jeffrey&quot;;<br/>
// Using s, I can call any method defined in<br/>
// String, Object, IComparable, ICloneable, IConvertible, IEnumerable, etc.<br/>
// The cloneable variable refers to the same String object ICloneable cloneable = s;<br/>
// Using cloneable, I can call any method declared by the<br/>
// ICloneable interface (or any method defined by Object) only.<br/>
// The comparable variable refers to the same String object IComparable comparable = s;<br/>
// Using comparable, I can call any method declared by the<br/>
// IComparable interface (or any method defined by Object) only.<br/>
// The enumerable variable refers to the same String object<br/>
// At run time, you can cast a variable from one interface to another as<br/>
// long as the object's type implements both interfaces.<br/>
IEnumerable enumerable = (IEnumerable) comparable;<br/>
// Using enumerable, I can call any method declared by the<br/>
// IEnumerable interface (or any method defined by Object) only.</code></p>
<p>In this code, all of the variables refer to the same &quot;Jeffrey&quot; <b>String </b>object that is in the managed heap, and therefore, any method that I call while using any of these variables affects the one &quot;Jeffrey&quot; <b>String </b>object. However, the type of the variable indicates the action that I can perform on the object. The <b>s </b>variable is of type <b>String, </b>and therefore, I can use <b>s </b>to call any members defined by the <b>String </b>type (such as the <b>Length </b>property). I can also use the variable <b>s </b>to call any methods inherited from <b>Object </b>(such as <b>GetType).</b></p>
<p>The <b>cloneable </b>variable is of the <b>ICloneable </b>interface type, and therefore, using the <b>cloneable </b>variable, I can call the <b>Clone </b>method defined by this interface. In addition, I can call any method defined by <b>Object </b>(such as <b>GetType) </b>because the CLR knows that all types derive from <b>Object </b>. However, using the <b>cloneable </b>variable, I cannot call public methods defined by <b>String </b>itself or any methods defined by any other interface that <b>String </b>implements. Similarly, using the <b>comparable </b>variable, I can call <b>CompareTo </b>or any method defined by <b>Object, </b>but no other methods are callable using this variable.</p>
<hr/>
<blockquote><b>Important </b>Like a reference type, a value type can implement zero or more interfaces. However, when you cast an instance of a value type to an interface type, the value type instance must be boxed. This is because an interface variable is a reference that must point to an object on the heap so that the CLR can examine the object's type object pointer to determine the exact type of the object Then, when calling an interface method with a boxed value type, the CLR will follow the object's type object pointer to find the type object's method table in order to call the proper method.</blockquote>
<hr/>
<a name="b314"/><h2>Implicit and Explicit Interface Method Implementations (What's Happening Behind the Scenes)</h2>
<p>When a type is loaded into the CLR, a method table is created and initialized for the type (as discussed in Chapter 1, &quot;The CLR's Execution Model&quot;). This method table contains one entry for every new method introduced by the type as well as entries for any virtual methods inherited by the type. Inherited virtual methods include methods defined by the base types in the inheritance hierarchy as well as any methods defined by the interface types. So if you have a simple type defined like this:</p>
<p><code>internal sealed class SimpleType : IDisposable {<br/>
public void Dispose() { Console.Writel_ine(&quot;Dispose&quot;); }<br/>
}</code></p>
<p>the type's method table contains entries for the following:</p>
<p>&#9632; All the virtual instance methods defined by <b>Object, </b>the implicitly inherited base class.</p>
<p>&#9632; All the interface methods defined by <b>IDisposable, </b>the inherited interface. In this example, there is only one method, <b>Dispose, </b>since the <b>IDisposable </b>interface defines just one method.</p>
<p>&#9632; The new method, <b>Dispose, </b>introduced by <b>SimpleType.</b></p>
<p>To make things simple for the programmer, the C# compiler assumes that the <b>Dispose </b>method introduced by <b>SimpleType </b>is the implementation for <b>IDisposable</b>'s <b>Dispose </b>method. The C# compiler makes this assumption because the method is <b>public, </b>and the signatures of the interface method and the newly introduced method are identical. That is, the methods have the same parameter and return types. By the way, if the new <b>Dispose </b>method were marked as <b>virtual, </b>the C# compiler would still consider this method to be a match for the interface method.</p>
<p>When the C# compiler matches a new method to an interface method, it emits metadata indicating that both entries in <b>SimpleType</b>'s method table should refer to the same implementation. To help make this clearer, here is some code that demonstrates how to call the class's public <b>Dispose </b>method as well as how to call the class's implementation of <b>IDisposable</b>'s <b>Dispose </b>method:</p>
<p><code>public sealed class Program { public static void Main() {<br/>
SimpleType st = new SimpleType();<br/>
// This calls the public Dispose method implementation st.Dispose();<br/>
// This calls IDisposable's Dispose method implementation<br/>
IDisposable d = st;<br/>
d.Dispose();<br/>
}<br/>
}</code></p>
<p>In the first call to <b>Dispose, </b>the <b>Dispose </b>method defined by <b>SimpleType </b>is called. Then I define a variable, <b>d, </b>which is of the <b>IDisposable </b>interface type. I initialize the <b>d </b>variable to refer to the <b>SimpleType </b>object. Now when I call <b>d.Dispose(), </b>I am calling the <b>IDisposable </b>interface's <b>Dispose </b>method. Since C# requires the public <b>Dispose </b>method to also be the implementation for <b>IDisposable</b>'s <b>Dispose </b>method, the same code will execute, and, in this example, you can't see any observable difference. The output is as follows:</p>
<p><code>Dispose Dispose</code></p>
<p>Now, let me rewrite the <b>SimpleType </b>from above so that you can see an observable difference:</p>
<p><code>internal sealed class SimpleType : IDisposable {<br/>
public void Dispose() { Console.WriteLineC'public Dispose&quot;); }<br/>
void IDisposable.DisposeO { Console.WriteLineC'IDisposable Dispose&quot;); }<br/>
}</code></p>
<p>Without changing the <b>Main </b>method shown earlier, if we just recompile and rerun the program, the output will be this:</p>
<p><code>public Dispose IDisposable Dispose</code></p>
<p>In C#, when you prefix the name of a method with the name of the interface that defines the method <b>(IDisposable.Dispose </b>as in this example), you are creating an explicit interface method implementation (EIMI). Note that when you define an explicit interface method in C#, you are not allowed to specify any accessibility (such as <b>public </b>or <b>private) </b>. However, when the compiler generates the metadata for the method, its accessibility is set to private, preventing any code using an instance of the class from simply calling the interface method. The only way to call the interface method is through a variable of the interface's type.</p>
<p>Also note that an EIMI method cannot be marked as <b>virtual </b>and therefore cannot be overridden. This is because the EIMI method is not really part of the type's object model; it's a way of attaching an interface (set of behaviors or methods) onto a type without making the behaviors/methods obvious. If all of this seems a bit kludgy to you, you are understanding it correctly葉his is all a bit kludgy. Later in this chapter, I'll show some valid reasons for using EIMIs.</p>
<h2>Generic Interfaces</h2>
<p>C#'s and the CLR's support of generic interfaces offers many great features for developers. In this section, I'd like to discuss the benefits offered when using generic interfaces.</p>
<p>First, generic interfaces offer great compile-time type safety Some interfaces (such as the non-generic <b>IComparable </b>interface) define methods that have <b>Object </b>parameters or return types. When code calls these interface methods, a reference to an instance of any type can be passed. But this is usually not desired. The following code demonstrates:</p>
<p><code>private void SomeMethod1() { Int32 x = 1, y = 2; IComparable c = x;<br/>
// CompareTo expects an Object; passing y (an Int32) is OK c.CompareTo(y);        // y is boxed here<br/>
// CompareTo expects an Object; passing &quot;2&quot; (a String) compiles // but an ArgumentException is thrown at runtime c.CompareTo(&quot;2&quot;);<br/>
}</code></p>
<p>Obviously, it is preferable to have the interface method strongly typed, and this is why the FCL includes a generic <b>IComparable&lt;in T&gt; </b>interface. Here is the new version of the code revised by using the generic interface:</p>
<p><code>private void SomeMethod2() { Int32 x = 1, y = 2; IComparable&lt;Int32&gt; c = x;<br/>
// CompareTo expects an Int32; passing y (an Int32) is OK c.CompareTo(y);        // y is not boxed here<br/>
// CompareTo expects an Int32; passing &quot;2&quot; (a String) results<br/>
// in a compiler error indicating that String cannot be cast to an Int32<br/>
c.CompareTo(&quot;2&quot;);     // Error<br/>
}</code></p>
<p>The second benefit of generic interfaces is that much less boxing will occur when working with value types. Notice in <b>SomeMethod1 </b>that the non-generic <b>IComparable </b>interface's <b>CompareTo </b>method expects an <b>Object; </b>passing <b>y </b>(an <b>Int32 </b>value type) causes the value in <b>y </b>to be boxed. However, in <b>SomeMethod2, </b>the generic <b>IComparable&lt;in T&gt; </b>interface's <b>CompareTo </b>method expects an <b>Int32; </b>passing <b>y </b>causes it to be passed by value, and no boxing is necessary.</p>
<hr/>
<blockquote><b>Note </b>The FCL defines non-generic and generic versions of the <b>IComparable, ICollection, IList, </b>and <b>Dictionary </b>interfaces, as well as some others. If you are defining a type, and you want to implement any of these interfaces, you should typically implement the generic versions of these interfaces The non-generic versions are in the FCL for backward compatibility to work with code written before the NET Framework supported generics The non-generic versions also provide users a way of manipulating the data in a more general, less type-safe fashion.</blockquote>
<hr/>
<p>Some of the generic interfaces inherit the non-generic versions, so your class will have to implement both the generic and non-generic versions of the interfaces For example, the generic <b>IEnumerable&lt;out T&gt; </b>interface inherits the non-generic <b>IEnumerable </b>interface. So if your class implements <b>IEnumerable&lt;out T&gt;, </b>your class must also implement <b>IEnumerable </b>.</p>
<p>Sometimes when integrating with other code, you may have to implement a non-generic interface because a generic version of the interface simply doesn't exist. In this case, if any of the interface's methods take or return <b>Object, </b>you will lose compile-time type safety, and you will get boxing with value types. You can alleviate this situation to some extent by using a technique I describe in the &quot;Improving Compile-Time Type Safety with Explicit Interface Method Implementations&quot; section near the end of this chapter.</p>
<p>The third benefit of generic interfaces is that a class can implement the same interface multiple times as long as different type parameters are used. The following code shows an example of how useful this could be:</p>
<p><code>using System;<br/>
// This class implements the generic IComparable&lt;T&gt; interface twice public sealed class Number: IComparable&lt;Int32&gt;, IComparable&lt;String&gt; { private Int32 m_va1 = 5;<br/>
// This method implements IComparable&lt;Int32&gt;'s CompareTo public Int32 CompareTo(Int32 n) { return m_val.CompareTo(n);<br/>
}<br/>
// This method implements IComparable&lt;String&gt;'s CompareTo public Int32 CompareTo(String s) {<br/>
return m_val.CompareTo(Int32.Parse(s));<br/>
}<br/>
}<br/>
public static class Program { public static void Main() { Number n = new Number();<br/>
// Here, I compare the value in n with an Int32 (5) IComparable&lt;Int32&gt; cInt32 = n; Int32 result = cInt32.CompareTo(5);<br/>
// Here, I compare the value in n with a String (&quot;5&quot;) IComparable&lt;String&gt; cString = n; result = cString.CompareTo(&quot;5&quot;);<br/>
}<br/>
}</code></p>
<p>An interface's generic type parameters can also be marked as contravariant and covariant, which allows even more flexibility for using generic interfaces. For more about contravariance and covariance, see the &quot;Delegate and Interface Contravariant and Covariant Generic Type Arguments&quot; section in Chapter 12.</p>
<a name="b318"/><h2>Generics and Interface Constraints</h2>
<p>In the previous section, I discussed the benefits of using generic interfaces. In this section, I'll discuss the benefits of constraining generic type parameters to interfaces.</p>
<p>The first benefit is that you can constrain a single generic type parameter to multiple interfaces. When you do this, the type of parameter you are passing in must implement all of the interface constraints. Here is an example:</p>
<p><code>public static class SomeType { private static void Test() { Int32 x = 5; Guid g = new Guid();<br/>
// This call to M compiles fine because<br/>
// Int32 implements IComparable AND IConvertible<br/>
M(x);<br/>
// This call to M causes a compiler error because<br/>
// Guid implements IComparable but it does not implement IConvertible<br/>
M(g);<br/>
}<br/>
// M's type parameter, T, is constrained to work only with types that // implement both the IComparable AND IConvertible interfaces private static Int32 M&lt;T&gt;(T t) where T : IComparable, IConvertible {<br/>
}<br/>
}</code></p>
<p>This is actually quite cool! When you define a method's parameters, each parameter's type indicates that the argument passed must be of the parameter's type or be derived from it If the parameter type is an interface, this indicates that the argument can be of any class type as long as the class implements the interface. Using multiple interface constraints actually lets the method indicate that the passed argument must implement multiple interfaces.</p>
<p>In fact, if we constrained <b>T </b>to a class and two interfaces, we are saying that the type of argument passed must be of the specified base class (or derived from it), and it must also implement the two interfaces. This flexibility allows the method to really dictate what callers can pass, and compiler errors will be generated if callers do not meet these constraints.</p>
<p>The second benefit of interface constraints is reduced boxing when passing instances of value types. In the previous code fragment, the <b>M </b>method was passed <b>x </b>(an instance of an <b>Int32, </b>which is a value type) No boxing will occur when <b>x </b>is passed to <b>M </b>If code inside <b>M </b>does call <b>t.CompareTo(...), </b>still no boxing occurs to make the call (boxing may still happen for arguments passed to <b>CompareTo) </b>.</p>
<p>On the other hand, if <b>M </b>had been declared like this:</p>
<p><code>private static Int32 M(IComparable t) {<br/>
}</code></p>
<p>then in order to pass <b>x </b>to <b>M, x </b>would have to be boxed.</p>
<p>For interface constraints, the C# compiler emits certain Intermediate Language (IL) instructions that result in calling the interface method on the value type directly without boxing it Aside from using interface constraints, there is no other way to get the C# compiler to emit these IL instructions, and therefore, calling an interface method on a value type always causes boxing.</p>
<a name="b319"/><h2>Implementing Multiple Interfaces That Have the Same Method Name and Signature</h2>
<p>Occasionally, you might find yourself defining a type that implements multiple interfaces that define methods with the same name and signature. For example, imagine that there are two interfaces defined as follows:</p>
<p><code>public interface IWindow { Object GetMenu();<br/>
}<br/>
public interface IRestaurant { Object GetMenu();<br/>
}</code></p>
<p>Let's say that you want to define a type that implements both of these interfaces. You'd have to implement the type's members by using explicit interface method implementations as follows:</p>
<p><code>// This type is derived from System.Object and<br/>
// implements the IWindow and IRestaurant interfaces.<br/>
public sealed class MarioPizzeria : IWindow, IRestaurant {<br/>
// This is the implementation for IWindow's GetMenu method. Object IWindow.GetMenu() {... }<br/>
// This is the implementation for IRestaurant's GetMenu method. Object IRestaurant.GetMenu() {... }<br/>
// This (optional method) is a GetMenu method that has nothing // to do with an interface. public Object GetMenu() {... }<br/>
}</code></p>
<p>Because this type must implement multiple and separate <b>GetMenu </b>methods, you need to tell the C# compiler which <b>GetMenu </b>method contains the implementation for a particular interface.</p>
<p>Code that uses a <b>MarioPizzeria </b>object must cast to the specific interface to call the desired method The following code demonstrates:</p>
<p><code>MarioPizzeria mp = new MarioPizzeria();<br/>
// This line calls MarioPizzeria's public CetMenu method mp.CetMenu();<br/>
// These lines call MarioPizzeria's IWindow.CetMenu method<br/>
IWindow window = mp;<br/>
window.CetMenu();<br/>
// These lines call MarioPizzeria's IRestaurant.CetMenu method<br/>
IRestaurant restaurant = mp;<br/>
restaurant.CetMenu();</code></p>
<a name="b320"/><h2>Improving Compile-Time Type Safety with Explicit Interface Method Implementations</h2>
<p>Interfaces are great because they define a standard way for types to communicate with each other. Earlier, I talked about generic interfaces and how they improve compile-time type safety and reduce boxing. Unfortunately, there may be times when you need to implement a non-generic interface because a generic version doesn't exist. If any of the interface's method(s) accept parameters of type <b>System.Object </b>or return a value whose type is <b>System.Object, </b>you will lose compile-time type safety, and you will get boxing. In this section, I'll show you how you can use EIMI to improve this situation somewhat.</p>
<p>Look at the very common <b>IComparable </b>interface:</p>
<p><code>public interface IComparable { Int32 CompareTo(Object other);<br/>
}</code></p>
<p>This interface defines one method that accepts a parameter of type <b>System.Object. </b>If I define my own type that implements this interface, the type definition might look like this:</p>
<p><code>internal struct SomeValueType : IComparable { private Int32 m_x;<br/>
public SomeValueType(Int32 x) { m_x = x; } public Int32 CompareTo(Object other) {<br/>
return(m_x - ((SomeValueType) other).m_x);<br/>
}<br/>
}</code></p>
<p>Using <b>SomeValueType, </b>I can now write the following code:</p>
<p><code>public static void Main() {<br/>
SomeValueType v = new SomeValueType(0); Object o = new Object();<br/>
Int32 n = v.CompareTo(v); // Undesired boxing<br/>
n = v.CompareTo(o);// InvalidCastException<br/>
}</code></p>
<p>There are two characteristics of this code that are not ideal:</p>
<p><b>&#9632; Undesired boxing   </b>When <b>v </b>is passed as an argument to the <b>CompareTo </b>method, it must be boxed because <b>CompareTo </b>expects an <b>Object </b>.</p>
<p><b>&#9632; The lack of type safety  </b>This code compiles, but an <b>InvalidCastException </b>is thrown inside the <b>CompareTo </b>method when it attempts to cast <b>o </b>to <b>SomeValueType.</b></p>
<p>Both of these issues can be fixed by using EIMIs. Here's a modified version of <b>SomeValueType </b>that has an EIMI added to it:</p>
<p><code>internal struct SomeValueType : IComparable { private Int32 m_x;<br/>
public SomeValueType(Int32 x) { m_x = x; }<br/>
public Int32 CompareTo(SomeValueType other) { return(m_x - other.m_x);<br/>
}<br/>
// NOTE: No public/private used on the next line Int32 IComparable.CompareTo(Object other) { return CompareTo((SomeValueType) other);<br/>
}<br/>
}</code></p>
<p>Notice several changes in this new version First, it now has two <b>CompareTo </b>methods The first <b>CompareTo </b>method no longer takes an <b>Object </b>as a parameter; it now takes a <b>SomeValueType </b>instead Because this parameter has changed, the code that casts <b>other </b>to <b>SomeValueType </b>is no longer necessary and has been removed. Second, changing the first <b>CompareTo </b>method to make it type-safe means that <b>SomeValueType </b>no longer adheres to the contract placed on it by implementing the <b>IComparable </b>interface. So <b>SomeValueType </b>must implement a <b>CompareTo </b>method that satisfies the <b>IComparable </b>contract. This is the job of the second <b>IComparable.CompareTo </b>method, which is an EIMI.</p>
<p>Having made these two changes means that we now get compile-time type safety and no boxing:</p>
<p><code>public static void Main() {<br/>
SomeValueType v = new SomeValueType(0);<br/>
Object o = new Object();<br/>
Int32   n = v.CompareTo(v); // No boxing<br/>
n = v.CompareTo(o);// compile-time error<br/>
}</code></p>
<p>If, however, we define a variable of the interface type, we will lose compile-time type safety and experience undesired boxing again:</p>
<p><code>public static void Main() {<br/>
SomeValueType v = new SomeValueType(O); IComparable c = v;// Boxing!<br/>
Object o = new Object();<br/>
Int32   n = c.CompareTo(v); // Undesired boxing<br/>
n = c.CompareTo(o);// InvalidCastException<br/>
}</code></p>
<p>In fact, as mentioned earlier in this chapter, when casting a value type instance to an interface type, the CLR must box the value type instance. Because of this fact, two boxings will occur in the previous <b>Main </b>method.</p>
<p>EIMIs are frequently used when implementing interfaces such as <b>IConvertible, ICollection, IList, </b>and <b>IDictionary. </b>They let you create type-safe versions of these interfaces' methods, and they enable you to reduce boxing operations for value types.</p>
<a name="b322"/><h2>Be Careful with Explicit Interface Method Implementations</h2>
<p>It is critically important for you to understand some ramifications that exist when using EIMIs. And because of these ramifications, you should try to avoid EIMIs as much as possible. Fortunately, generic interfaces help you avoid EIMIs quite a bit. But there may still be times when you will need to use them (such as implementing two interface methods with the same name and signature). Here are the big problems with EIMIs:</p>
<p>&#9632; There is no documentation explaining how a type specifically implements an EIMI method, and there is no Microsoft Visual Studio IntelliSense support.</p>
<p>&#9632; Value type instances are boxed when cast to an interface.</p>
<p>&#9632; An EIMI cannot be called by a derived type.</p>
<p>Let's take a closer look at these problems.</p>
<p>When examining the methods for a type in the .NET Framework reference documentation, explicit interface method implementations are listed, but no type-specific help exists; you can just read the general help about the interface methods. For example, the documentation for the <b>Int32 </b>type shows that it implements all of <b>IConvertible </b>interface's methods. This is good because developers know that these methods exist; however, this has been very confusing to developers because you can't call an <b>IConvertible </b>method on an <b>Int32 </b>directly. For example, the following method won't compile:</p>
<p><code>public static void Main() { Int32 x = 5;<br/>
Single s = x.ToSingle(null); // Trying to call an IConvertible method<br/>
}</code></p>
<p>When compiling this method, the C# compiler produces the following message: <b>&quot;messagepil17:  'int' does not contain a definition for 'ToSingle'.&quot; </b>This error message confuses the developer because it's clearly stating that the <b>Int32 </b>type doesn't define a <b>ToSingle </b>method when, in fact, it does.</p>
<p>To call <b>ToSingle </b>on an <b>Int32, </b>you must first cast the <b>Int32 </b>to an <b>IConvertible, </b>as shown in the following method:</p>
<p><code>public static void Main() { Int32 x = 5;<br/>
Single s = ((IConvertible) x).ToSingle(null);<br/>
}</code></p>
<p>Requiring this cast isn't obvious at all, and many developers won't figure this out on their own But an even more troublesome problem exists: casting the <b>Int32 </b>value type to an <b>IConvertible </b>also boxes the value type, wasting memory and hurting performance. This is the second of the big problems I mentioned at the beginning of this section.</p>
<p>The third and perhaps the biggest problem with EIMIs is that they cannot be called by a derived class. Here is an example:</p>
<p><code>internal class Base : IComparable {<br/>
// Explicit Interface Method Implementation Int32 IComparable.CompareTo(Object o) {<br/>
Console.WriteLineC'Base's CompareTo&quot;);<br/>
return O;<br/>
}<br/>
}<br/>
internal sealed class Derived : Base, IComparable {<br/>
// A public method that is also the interface implementation public Int32 CompareTo(Object o) {<br/>
Console.WriteLineC'Derived's CompareTo&quot;);<br/>
// This attempt to call the base class's EIMI causes a compiler error: // error CS0117:  'Base' does not contain a definition for 'CompareTo' base.CompareTo(o); return O;<br/>
}<br/>
}</code></p>
<p>In <b>Derived</b>'s <b>CompareTo </b>method, I try to call <b>base.CompareTo, </b>but this causes the C# compiler to issue an error The problem is that the <b>Base </b>class doesn't offer a public or protected <b>CompareTo </b>method that can be called; it offers a <b>CompareTo </b>method that can be called only by using a variable that is of the <b>IComparable </b>type. I could modify <b>Derived</b>'s <b>CompareTo </b>method so that it looks like this:</p>
<p><code>// A public method that is also the interface implementation public Int32 CompareTo(Object o) {<br/>
Console.WriteLineC'Derived's CompareTo&quot;);<br/>
// This attempt to call the base class's EIMI causes infinite recursion<br/>
IComparable c = this;<br/>
c.CompareTo(o);<br/>
return 0;<br/>
}</code></p>
<p>In this version, I am casting <b>this </b>to an <b>IComparable </b>variable, <b>c </b>. And then, I use <b>c </b>to call <b>CompareTo. </b>However, the <b>Derived</b>'s public <b>CompareTo </b>method serves as the implementation for <b>Derived</b>'s <b>IComparableCompareTo </b>method, and therefore, infinite recursion occurs. This could be fixed by declaring the <b>Derived </b>class without the <b>IComparable </b>interface, like this:</p>
<p><code>internal sealed class Derived : Base /*, IComparable */ {... }</code></p>
<p>Now the previous <b>CompareTo </b>method will call the <b>CompareTo </b>method in <b>Base. </b>But sometimes you cannot simply remove the interface from the type because you want the derived type to implement an interface method. The best way to fix this is for the base class to provide a virtual method in addition to the interface method that it has chosen to implement explicitly. Then the <b>Derived </b>class can override the virtual method. Here is the correct way to define the <b>Base </b>and <b>Derived </b>classes:</p>
<p><code>internal class Base : IComparable {<br/>
// Explicit Interface Method Implementation Int32 IComparable.CompareTo(Object o) {<br/>
Console.WriteLineC'Base's IComparable CompareTo&quot;);<br/>
return CompareTo(o);     // This now calls the virtual method<br/>
}<br/>
// Virtual method for derived classes (this method could have any name) public virtual Int32 CompareTo(Object o) {<br/>
Console.WriteLineC'Base's virtual CompareTo&quot;);<br/>
return 0;<br/>
}<br/>
}<br/>
internal sealed class Derived : Base, IComparable {<br/>
// A public method that is also the interface implementation public override Int32 CompareTo(Object o) { Console.WriteLineC'Derived's CompareTo&quot;);<br/>
// Now, we can call Base's virtual method return base.CompareTo(o);<br/>
}<br/>
}</code></p>
<p>Note that I have defined the virtual method above as a public method, but in some cases, you will prefer to make the method protected instead. It is fine to make this method protected instead of public, but that will necessitate other minor changes. This discussion clearly shows you that EIMIs should be used with great care. When many developers first learn about EIMIs, they think that they're cool and they start using them whenever possible. Don't do this! EIMIs are useful in some circumstances, but you should avoid them whenever possible because they make using a type much more difficult.</p>
<a name="b325"/><h2>Design: Base Class or Interface?</h2>
<p>I often hear the question, &quot;Should I design a base type or an interface?&quot; The answer isn't always clear-cut Here are some guidelines that might help you:</p>
<p><b>&#9632; IS-A vs. CAN-DO relationship  </b>A type can inherit only one implementation. If the derived type can't claim an IS-A relationship with the base type, don't use a base type; use an interface. Interfaces imply a CAN-DO relationship. If the CAN-DO functionality appears to belong with various object types, use an interface. For example, a type can convert instances of itself to another type <b>(IConvertible), </b>a type can serialize an instance of itself <b>(ISerializable), </b>etc. Note that value types must be derived from <b>System.ValueType, </b>and therefore, they cannot be derived from an arbitrary base class. In this case, you must use a CAN-DO relationship and define an interface.</p>
<p><b>&#9632; Ease of use   </b>It's generally easier for you as a developer to define a new type derived from a base type than to implement all of the methods of an interface. The base type can provide a lot of functionality, so the derived type probably needs only relatively small modifications to its behavior. If you supply an interface, the new type must implement all of the members.</p>
<p><b>&#9632; Consistent implementation   </b>No matter how well an interface contract is documented, it's very unlikely that everyone will implement the contract 100 percent correctly. In fact, COM suffers from this very problem, which is why some COM objects work correctly only with Microsoft Office Word or with Windows Internet Explorer. By providing a base type with a good default implementation, you start off using a type that works and is well tested; you can then modify parts that need modification.</p>
<p><b>&#9632; Versioning   </b>If you add a method to the base type, the derived type inherits the new method, you start off using a type that works, and the user's source code doesn't even have to be recompiled. Adding a new member to an interface forces the inheritor of the interface to change its source code and recompile.</p>
<p>In the FCL, the classes related to streaming data use an implementation inheritance design. The <b>System.IO.Stream </b>class is the abstract base class. It provides a bunch of methods, such as <b>Read </b>and <b>Write </b>. Other classes<b>祐ystem.IO.FileStream, System.IO.MemoryStream, </b>and <b>System.Net.Sockets.NetworkStream</b>are derived from <b>Stream. </b>Microsoft chose an</p>
<p>IS-A relationship between each of these three classes and the <b>Stream </b>class because it made implementing the concrete classes easier For example, the derived classes need to implement only synchronous I/O operations; they inherit the ability to perform asynchronous I/O operations from the <b>Stream </b>base class.</p>
<p>Admittedly, choosing to use inheritance for the stream classes isn't entirely clear-cut; the <b>Stream </b>base class actually provides very little implementation. However, if you consider the Microsoft Windows Forms control classes, in which <b>Button, CheckBox, ListBox, </b>and all of the other controls are derived from <b>System.Windows.Forms.Control, </b>it's easy to imagine all of the code that <b>Control </b>implements, which the various control classes simply inherit to function correctly.</p>
<p>By contrast, Microsoft designed the FCL collections to be interface based. The <b>System.Collections.Generic </b>namespace defines several collection-related interfaces: <b>IEnumerable&lt;out T&gt;, ICollection&lt;T&gt;, IList&lt;T&gt;,</b>and <b>IDictionary&lt;TKey, TValuex </b>Then Microsoft provided a number of classes, such as <b>List&lt;T&gt;, Dictionary&lt;TKey, TValue&gt;, Queue&lt;T&gt;, Stack&lt;T&gt;, </b>and so on, that implement combinations of these interfaces Here the designers chose a CAN-DO relationship between the classes and the interfaces because the implementations of these various collection classes are radically different from one another. In other words, there isn't a lot of sharable code between a <b>List&lt;T&gt;, </b>a <b>Dictionary&lt;TKey, TValue&gt;, </b>and a <b>Queue&lt;T&gt;</b></p>
<p>The operations these collection classes offer are, nevertheless, pretty consistent. For example, they all maintain a set of elements that can be enumerated, and they all allow adding and removing of elements. If you have a reference to an object whose type implements the <b>IList&lt;T&gt; </b>interface, you can write code to insert elements, remove elements, and search for an element without having to know exactly what type of collection you're working with. This is a very powerful mechanism.</p>
<p>Finally, it should be pointed out that you can actually do both: define an interface and provide a base class that implements the interface. For example, the FCL defines the <b>IComparer&lt;in T&gt; </b>interface, and any type can choose to implement this interface. In addition, the FCL provides an abstract base class, <b>Comparer&lt;T&gt;, </b>which implements this interface and provides a default implementation for the non-generic <b>IComparable</b>'s <b>Compare </b>method. Having both an interface definition and a base class offers great flexibility because developers can now choose whichever they prefer.</p>
<mbp:pagebreak/>
<a name="Chapter14"/>
<h1>Chapter 14: Chars, Strings, and Working with Text</h1>
<p><b>In this chapter:</b></p>
<a href="#b327">Characters</a><br/>
<a href="#b330">The System.String Type</a><br/>
<a href="#b346">Constructing a String Efficiently</a><br/>
<a href="#b350">Obtaining a String Representation of an Object: ToString</a><br/>
<a href="#b359">Parsing a String to Obtain an Object: Parse</a><br/>
<a href="#b361">Encodings: Converting Between Characters and Bytes</a><br/>
<a href="#b369">Secure Strings</a><br/>
<p>In this chapter, I'll explain the mechanics of working with individual characters and strings in the Microsoft .NET Framework. I'll start by talking about the <b>System.Char </b>structure and the various ways that you can manipulate a character Then I'll go over the more useful <b>System.String </b>class, which allows you to work with immutable strings. (Once created, strings can't be modified in any way.) After examining strings, I'll show you how to perform various operations efficiently to build a string dynamically via the <b>System.Text.StringBuilder </b>class. With the string basics out of the way, I'll then describe how to format objects into strings and how to efficiently persist or transmit strings by using various encodings. Finally, I'll discuss the <b>System.Security.SecureString </b>class, which can be used to protect sensitive string data such as passwords and credit card information.</p>
<a name="b327"/><h2>Characters</h2>
<p>In the .NET Framework, characters are always represented in 16-bit Unicode code values, easing the development of global applications. A character is represented with an instance of the <b>System.Char </b>structure (a value type). The <b>System.Char </b>type is pretty simple. It offers two public read-only constant fields: <b>MinValue, </b>defined as <b>'\0', </b>and <b>MaxValue, </b>defined as <span><b>'\uffff</b></span><b>.</b></p>
<p>Given an instance of a <b>Char, </b>you can call the static <b>GetUnicodeCategory </b>method, which returns a value of the <b>System.Globalization.UnicodeCategory </b>enumerated type. This value indicates whether the character is a control character, a currency symbol, a lowercase letter, an uppercase letter, a punctuation character, a math symbol, or another character (as defined by the Unicode standard).</p>
<p>To ease developing, the <b>Char </b>type also offers several static methods, such as <b>IsDigit, IsLetter, IsWhiteSpace, IsUpper, IsLower, IsPunctuation, IsLetterOrDigit, IsControl </b>, <b>IsNumber, IsSeparator, IsSurrogate, IsLowSurrogate, IsHighSurrogate, </b>and <b>IsSymbol. </b>Most of these methods call <b>GetUnicodeCategory </b>internally and simply return <b>true </b>or <b>false </b>accordingly. Note that all of these methods take either a single character for a parameter or a <b>String </b>and the index of a character within the <b>String </b>as parameters.</p>
<p>In addition, you can convert a single character to its lowercase or uppercase equivalent in a culture-agnostic way by calling the static <b>ToLowerInvariant </b>or <b>ToUpperInvariant </b>method. Alternatively, the <b>ToLower </b>and <b>ToUpper </b>methods convert the character by using the culture information associated with the calling thread (which the methods obtain internally by querying the static <b>CurrentCulture </b>property of the <b>System.Threading.Thread </b>class). You can also specify a particular culture by passing an instance of the <b>CultureInfo </b>class to these methods. <b>ToLower </b>and <b>ToUpper </b>require culture information because letter casing is a culture-dependent operation. For example, Turkish considers the uppercase of U+0069 (LATIN LOWERCASE LETTER I) to be U+0130 (LATIN UPPERCASE LETTER I WITH DOT ABOVE), whereas other cultures consider the result to be U+0049 (LATIN CAPITAL LETTER I).</p>
<p>Besides these static methods, the <b>Char </b>type also offers a few instance methods of its own. The <b>Equals </b>method returns <b>true </b>if two <b>Char </b>instances represent the same 16-bit Unicode code point. The <b>CompareTo </b>methods (defined by the <b>IComparable/IComparable&lt;Char&gt; </b>interfaces) return a comparison of two <b>Char </b>instances; this comparison is not culture-sensitive The <b>ConvertFromUtf32 </b>method produces a string consisting of two UTF-16 characters from a single UTF-32 character. The <b>ConvertToUtf32 </b>produces a UTF-16 character from a low/ high surrogate pair or from a string. The <b>ToString </b>method returns a <b>String </b>consisting of a single character. The opposite of <b>ToString </b>is <b>Parse/TryParse, </b>which takes a single-character <b>String </b>and returns its UTF-16 code point.</p>
<p>The last method, <b>GetNumericValue, </b>returns the numeric equivalent of a character. I demonstrate this method in the following code:</p>
<p><code>using System;<br/>
public static class Program { public static void Main() {<br/>
Double d;// <span>'\u0033'</span> is the &quot;digit 3&quot;<br/>
d = Char.CetNumericValue('\u0033'); // '3' would work too Console.WriteLine(d.ToString<b>O);      </b>// Displays &quot;3&quot;<br/>
// <span>'\u00bc'</span> is the &quot;vulgar fraction one quarter (&quot;A')&quot; d = Char.CetNumericValue('\u00bc');<br/>
Console.WriteLine(d.ToString<b>O);      </b>// Displays &quot;0.25&quot;<br/>
// 'A' is the &quot;Latin capital letter A&quot; d = Char.CetNumericValue('A'); Console.WriteLine(d.ToString<b>O);      </b>// Displays<br/>
}<br/>
}</code></p>
<p>Finally, three techniques allow you to convert between various numeric types to <b>Char </b>instances and vice versa The techniques are listed here in order of preference:</p>
<p><b>&#9632; Casting   </b>The easiest way to convert a <b>Char </b>to a numeric value such as an <b>Int32 </b>is simply by casting. Of the three techniques, this is the most efficient because the compiler emits Intermediate Language (IL) instructions to perform the conversion, and no methods have to be called. In addition, some languages (such as C#) allow you to indicate whether the conversion should be performed using checked or unchecked code (discussed in Chapter 5, &quot;Primitive, Reference, and Value Types&quot;).</p>
<p><b>&#9632; Use the Convert type   </b>The <b>System.Convert </b>type offers several static methods that are capable of converting a <b>Char </b>to a numeric type and vice versa. All of these methods perform the conversion as a checked operation, causing an <b>OverflowException </b>to be thrown if the conversion results in the loss of data.</p>
<p><b>&#9632; Use the IConvertible interface   </b>The <b>Char </b>type and all of the numeric types in the .NET Framework Class Library (FCL) implement the <b>IConvertible </b>interface. This interface defines methods such as <b>ToUInt16 </b>and <b>ToChar </b>This technique is the least efficient of the three because calling an interface method on a value type requires that the instance be boxed<b>佑har </b>and all of the numeric types are value types The methods of <b>IConvertible </b>throw a <b>System.InvalidCastException </b>if the type can't be converted (such as converting a <b>Char </b>to a <b>Boolean) </b>or if the conversion results in a loss of data. Note that many types (including the FCL's <b>Char </b>and numeric types) implement <b>IConvertible</b>'s methods as explicit interface member implementations (described in Chapter 13, &quot;Interfaces&quot;). This means that you must explicitly cast the instance to an <b>IConvertible </b>before you can call any of the interface's methods. All of the methods of <b>IConvertible </b>except <b>GetTypeCode </b>accept a reference to an object that implements the <b>IFormatProvider </b>interface. This parameter is useful if for some reason the conversion needs to take culture information into account For most conversions, you can pass <b>null </b>for this parameter because it would be ignored anyway.</p>
<p>The following code demonstrates how to use these three techniques:</p>
<p><code>using System;<br/>
public static class Program { public static void Main() { Char c; Int32 n;<br/>
// Convert number &lt;-&gt; character using C# casting c = (Char) 65;<br/>
Console.WriteLine(c);// Displays &quot;A&quot;<br/>
n = (Int32) c;<br/>
Console.WriteLine(n);// Displays &quot;65&quot;<br/>
c = unchecked((Char) (65536 + 65));<br/>
Console.WriteLine(c);// Displays &quot;A&quot;<br/>
// Convert number &lt;-&gt; character using Convert c = Convert.ToChar(65);<br/>
Console.WriteLine(c);// Displays &quot;A&quot;<br/>
n = Convert.ToInt32(c);<br/>
Console.WriteLine(n);// Displays &quot;65&quot;<br/>
// This demonstrates Convert&quot;s range checking<br/>
try {<br/>
c = Convert.ToChar(70000);// Too big for 16 bits<br/>
Console.WriteLine(c);// Doesn't execute<br/>
}<br/>
catch (OverflowException) {<br/>
Console.WriteLine(&quot;Can't convert 70000 to a Char.&quot;);<br/>
}<br/>
// Convert number &lt;-&gt; character using IConvertible c = ((IConvertible) 65).ToChar(null); Console.WriteLine(c);// Displays &quot;A&quot;<br/>
n = ((IConvertible) c).ToInt32(null); Console.WriteLine(n);// Displays &quot;65&quot;<br/>
}<br/>
}</code></p>
<a name="b330"/><h2>The System.String Type</h2>
<p>One of the most used types in any application is <b>System.String. </b>A <b>String </b>represents an immutable ordered set of characters The <b>String </b>type is derived immediately from <b>Object, </b>making it a reference type, and therefore, <b>String </b>objects (its array of characters) always live in the heap, never on a thread's stack The <b>String </b>type also implements several interfaces <b>(IComparable/IComparable&lt;String&gt;, ICloneable, IConvertible, IEnumerable/ IEnumerable&lt;Char&gt;,</b>and <b>IEquatable&lt;String&gt;) </b>.</p>
<h3>Constructing Strings</h3>
<p>Many programming languages (including C#) consider <b>String </b>to be a primitive type葉hat is, the compiler lets you express literal strings directly in your source code. The compiler places these literal strings in the module's metadata, and they are then loaded and referenced at runtime.</p>
<p>In C#, you can't use the <b>new </b>operator to construct a <b>String </b>object from a literal string: using System;</p>
<p><code>public static class Program { public static void Main() {<br/>
String s = new String(&quot;Hi there.&quot;);   // &lt; Error Console.WriteLine(s);<br/>
}<br/>
}</code></p>
<p>Instead, you must use the following simplified syntax: using System;</p>
<p><code>public static class Program { public static void Main() { String s = &quot;Hi there.&quot;; Console.WriteLine(s);<br/>
}<br/>
}</code></p>
<p>If you compile this code and examine its IL (using ILDasm exe), you'd see the following: .method public hidebysig static void   Main() cil managed</p>
<p><code>{<br/>
.entrypoint<br/>
// Code size        13 (0xd)<br/>
.maxstack 1<br/>
.locals init (string V_0) IL_0000:   ldstr.&quot;Hi there.&quot;<br/>
IL_0005: stloc.0 IL_0006: ldloc.0<br/>
IL_0007:   call.void [mscorlib]System.Console::WriteLine(string)<br/>
IL_000c: ret } // end of method Program::Main</code></p>
<p>The <b>newobj </b>IL instruction constructs a new instance of an object. However, no <b>newobj </b>instruction appears in the IL code example. Instead, you see the special <b>ldstr </b>(load string) IL instruction, which constructs a <b>String </b>object by using a literal string obtained from metadata. This shows you that the common language runtime (CLR) does, in fact, have a special way of constructing literal <b>String </b>objects.</p>
<p>If you are using unsafe code, you can construct a <b>String </b>object from a <b>Char* </b>or <b>SByte* </b>. To accomplish this, you would use C#'s <b>new </b>operator and call one of the constructors provided by the <b>String </b>type that takes <b>Char* </b>or <b>SByte* </b>parameters. These constructors create a <b>String </b>object, initializing the string from an array of <b>Char </b>instances or signed bytes. The other constructors don't have any pointer parameters and can be called using safe (verifiable) code written in any managed programming language.</p>
<p>C# offers some special syntax to help you enter literal strings into the source code For special characters such as new lines, carriage returns, and backspaces, C# uses the escape mechanism familiar to C/C++ developers:</p>
<p><code>// String containing carriage-return and newline characters String s = &quot;Hi\r\nthere.&quot;;</code></p>
<hr/>
<blockquote><b>Important </b>Although the preceding example hard-codes carriage-return and newline characters</blockquote>
<hr/>
<p>into the string, I don't recommend this practice. Instead, the <b>System.Environment </b>type defines a read-only <b>NewLine </b>property that returns a string consisting of these characters when your application is running on Microsoft Windows. However, the <b>NewLine </b>property is platform sensitive, and it returns the appropriate string required to obtain a newline by the underlying platform. So, for example, if the Common Language Infrastructure (CLI) is ported to a UNIX system, the <b>NewLine </b>property would return a string consisting of just a single character <b>\n </b>. Here's the proper way to define the previous string so that it works correctly on any platform:</p>
<p><code>String s = &quot;Hi&quot; + Environment.NewLine + &quot;there.&quot;;</code></p>
<p>You can concatenate several strings to form a single string by using C#'s + operator as follows:</p>
<p><code>// Three literal strings concatenated to form a single literal string String s = &quot;Hi&quot; + &quot; &quot; + &quot;there.&quot;;</code></p>
<p>In this code, because all of the strings are literal strings, the C# compiler concatenates them at compile time and ends up placing just one string<b>&quot;Hi there</b>.&quot;擁n the module's metadata Using the <b>+ </b>operator on nonliteral strings causes the concatenation to be performed at runtime To concatenate several strings together at runtime, avoid using the <b>+ </b>operator because it creates multiple string objects on the garbage-collected heap Instead, use the <b>System.Text.StringBuilder </b>type (which I'll explain later in this chapter).</p>
<p>Finally, C# also offers a special way to declare a string in which all characters between quotes are considered part of the string. These special declarations are called verbatim strings and are typically used when specifying the path of a file or directory or when working with regular expressions. Here is some code showing how to declare the same string with and without using the verbatim string character (<b>@</b>).</p>
<p><code>// Specifying the pathname of an application String file = &quot;C:\\Windows\\System32\\Notepad.exe&quot;;<br/>
// Specifying the pathname of an application by using a verbatim string String file = @&quot;C:\Windows\System32\Notepad.exe&quot;;</code></p>
<p>You could use either one of the preceding code lines in a program because they produce identical strings in the assembly's metadata. However, the <b>@ </b>symbol before the string on the second line tells the compiler that the string is a verbatim string In effect, this tells the compiler to treat backslash characters as backslash characters instead of escape characters, making the path much more readable in your source code.</p>
<p>Now that you've seen how to construct a string, let's talk about some of the operations you can perform on <b>String </b>objects.</p>
<h3>Strings Are Immutable</h3>
<p>The most important thing to know about a <b>String </b>object is that it is immutable. That is, once created, a string can never get longer, get shorter, or have any of its characters changed. Having immutable strings offers several benefits. First, it allows you to perform operations on a string without actually changing the string:</p>
<p><code>if (s.ToUpperInvariant().Substring(10, 21).EndsWith(&quot;EXE&quot;)) {<br/>
}</code></p>
<p>Here, <b>ToUpperInvariant </b>returns a new string; it doesn't modify the characters of the string <b>s </b>. <b>Substring </b>operates on the string returned by <b>ToUpperInvariant </b>and also returns a new string, which is then examined by <b>EndsWith </b>. The two temporary strings created by <b>ToUpperInvariant </b>and <b>Substring </b>are not referenced for long by the application code, and the garbage collector will reclaim their memory at the next collection. If you perform a lot of string manipulations, you end up creating a lot of <b>String </b>objects on the heap, which causes more frequent garbage collections, thus hurting your application's performance To perform a lot of string manipulations efficiently, use the <b>StringBuilder </b>class.</p>
<p>Having immutable strings also means that there are no thread synchronization issues when manipulating or accessing a string In addition, it's possible for the CLR to share multiple identical <b>String </b>contents through a single <b>String </b>object. This can reduce the number of strings in the system葉hereby conserving memory usage預nd it is what string interning (discussed later in the chapter) is all about.</p>
<p>For performance reasons, the <b>String </b>type is tightly integrated with the CLR. Specifically, the CLR knows the exact layout of the fields defined within the <b>String </b>type, and the CLR accesses these fields directly. This performance and direct access come at a small development cost: the <b>String </b>class is sealed, which means that you cannot use it as a base class for your own type. If you were able to define your own type, using <b>String </b>as a base type, you could add your own fields, which would break the CLR's assumptions. In addition, you could break some assumptions that the CLR team has made about <b>String </b>objects being immutable.</p>
<h3>Comparing Strings</h3>
<p>Comparing is probably the most common operation performed on strings. There are two reasons to compare two strings with each other We compare two strings to determine equality or to sort them (usually for presentation to a user).</p>
<p>In determining string equality or when comparing strings for sorting, it is highly recommended that you call one of these methods (defined by the <b>String </b>class):</p>
<p><code>Boolean Equals(String value, StringComparison comparisonType) static Boolean Equals(String a, String b, StringComparison comparisonType)<br/>
static Int32 Compare(String strA, String strB, StringComparison comparisonType) static Int32 Compare(string strA, string strB, Boolean ignoreCase, CultureInfo culture) static Int32 Compare(String strA, String strB, CultureInfo culture, CompareOptions options) static Int32 Compare(String strA, Int32 indexA, String strB, Int32 indexB, Int32 length,<br/>
StringComparison comparisonType) static Int32 Compare(String strA, Int32 indexA, String strB, Int32 indexB, Int32 length,<br/>
CultureInfo culture, CompareOptions options) static Int32 Compare(String strA, Int32 indexA, String strB, Int32 indexB, Int32 length,<br/>
Boolean ignoreCase, CultureInfo culture)<br/>
Boolean StartsWith(String value, StringComparison comparisonType) Boolean StartsWith(String value,<br/>
Boolean ignoreCase, CultureInfo culture)<br/>
Boolean EndsWith(String value, StringComparison comparisonType) Boolean EndsWith(String value, Boolean ignoreCase, CultureInfo culture)</code></p>
<p>When sorting, you should always perform case-sensitive comparisons The reason is that if two strings differing only by case are considered to be equal, they could be ordered differently each time you sort them; this would confuse the user.</p>
<p>The <b>comparisonType </b>argument (in most of the methods shown above) is one of the values defined by the <b>StringComparison </b>enumerated type, which is defined as follows:</p>
<p><code>public enum StringComparison { CurrentCulture = 0, CurrentCultureIgnoreCase = 1, InvariantCulture = 2, InvariantCultureIgnoreCase = 3, Ordinal = 4, OrdinalIgnoreCase = 5<br/>
}</code></p>
<p>The <b>CompareOptions </b>argument (in two of the methods above) is one of the values defined by the <b>CompareOptions </b>enumerator type:</p>
<p><code>[Flags]<br/>
public enum CompareOptions { None = 0, IgnoreCase = 1, IgnoreNonSpace = 2, IgnoreSymbols   = 4, IgnoreKanaType = 8, IgnoreWidth = 0x00000010, Ordinal = 0x40000000, OrdinalIgnoreCase = 0x10000000, StringSort = 0x20000000<br/>
}</code></p>
<p>Methods that accept a <b>CompareOptions </b>argument also force you to explicitly pass in a culture. When passing in the <b>Ordinal </b>or <b>OrdinalIgnoreCase </b>flag, these <b>Compare </b>methods ignore the specified culture.</p>
<p>Many programs use strings for internal programmatic purposes such as path names, file names, URLs, registry keys and values, environment variables, reflection, Extensible Markup Language (XML) tags, XML attributes, and so on. Often, these strings are not shown to a user and are used only within the program. When comparing programmatic strings, you should always use <b>StringComparison.Ordinal </b>or <b>StringComparison.OrdinalIgnoreCase. </b>This is the fastest way to perform a comparison that is not to be affected in any linguistic way because culture information is not taken into account when performing the comparison.</p>
<p>On the other hand, when you want to compare strings in a linguistically correct manner (usually for display to an end user), you should use <b>StringComparison.CurrentCulture </b>or <b>StringComparison.CurrentCultureIgnoreCase </b>.</p>
<hr/>
<blockquote><b>Important </b>For the most part, <b>StringComparison.InvariantCulture </b>and <b>StringComparison.InvariantCultureIgnoreCase </b>should not be used. Although these values cause the comparison to be linguistically correct, using them to compare programmatic strings takes longer than performing an ordinal comparison Furthermore, the invariant culture is culture agnostic, which makes it an incorrect choice when working with strings that you want to show to an end user.</blockquote>
<hr/>
<p><b>I-</b></p>
<hr/>
<blockquote><b>Important </b>If you want to change the case of a string's characters before performing an ordinal comparison, you should use <b>String</b>'s <b>ToUpperInvariant </b>or <b>ToLowerInvariant </b>method. When normalizing strings, it is highly recommended that you use <b>ToUpperInvariant </b>instead of <b>ToLowerInvariant </b>because Microsoft has optimized the code for performing uppercase comparisons In fact, the FCL internally normalizes strings to uppercase prior to performing case-insensitive comparisons. We use <b>ToUpperInvariant </b>and <b>ToLowerInvariant </b>methods because the <b>String </b>class does not offer <b>ToUpperOrdinal </b>and <b>ToLowerOrdinal </b>methods. We do not use the <b>ToUpper </b>and <b>ToLower </b>methods because these are culture sensitive.</blockquote>
<hr/>
<p>Sometimes, when you compare strings in a linguistically correct manner, you want to specify a specific culture rather than use a culture that is associated with the calling thread. In this case, you can use the overloads of the <b>StartsWith, EndsWith, </b>and <b>Compare </b>methods shown earlier, all of which take <b>Boolean </b>and <b>CultureInfo </b>arguments.</p>
<hr/>
<blockquote><b>Important </b>The <b>String </b>type defines several overloads of the <b>Equals, StartsWith, EndsWith,</b></blockquote>
<hr/>
<p>and <b>Compare </b>methods in addition to the versions shown earlier Microsoft recommends that these other versions (not shown in this book) be avoided. Furthermore, <b>String</b>'s other comparison methods<b>CompareTo </b>(required by the <b>IComparable </b>interface), <b>CompareOrdinal, </b>and the <b>== </b>and <b>!= </b>operators耀hould also be avoided. The reason for avoiding these methods and operators is because the caller does not explicitly indicate how the string comparison should be performed, and you cannot determine from the name of the method what the default comparison will be For example, by default, <b>CompareTo </b>performs a culture-sensitive comparison, whereas <b>Equals </b>performs an ordinal comparison. Your code will be easier to read and maintain if you always indicate explicitly how you want to perform your string comparisons.</p>
<p>Now, let's talk about how to perform linguistically correct comparisons. The .NET Framework uses the <b>System.Globalization.CultureInfo </b>type to represent a language/country pair (as described by the RFC 1766 standard). For example, &quot;en-US&quot; identifies English as written in the United States, &quot;en-AU&quot; identifies English as written in Australia, and &quot;de-DE&quot; identifies German as written in Germany. In the CLR, every thread has two properties associated with it. Each of these properties refers to a <b>CultureInfo </b>object. The two properties are:</p>
<p><b>&#9632; CurrentUICulture   </b>This property is used to obtain resources that are shown to an end user It is most useful for GUI or Web Forms applications because it indicates the language that should be used when displaying UI elements such as labels and buttons By default, when you create a thread, this thread property is set to a <b>CultureInfo </b>object, which identifies the language of the Windows version the application is running on using the Win32 <b>GetUserDefaultUILanguage </b>function. If you're running a Multilingual User Interface (MUI) version of Windows, you can set this via the &quot;Regional and Language Options&quot; Control Panel Settings dialog box. On a non-MUI version of Windows, the language is determined by the localized version of the OS installed (or the installed language pack) and the language is not changeable.</p>
<p><b>&#9632; CurrentCulture   </b>This property is used for everything that <b>CurrentUICulture </b>isn't used for, including number and date formatting, string casing, and string comparing. When formatting, both the language and country parts of the <b>CultureInfo </b>object are used. By default, when you create a thread, this thread property is set to a <b>CultureInfo </b>object, whose value is determined by calling the Win32 <b>GetUserDefaultLCID </b>method, whose value is set in the &quot;Regional and Language&quot; Control Panel applet</p>
<p>On many computers, a thread's <b>CurrentUICulture </b>and <b>CurrentCulture </b>properties will be set to the same <b>CultureInfo </b>object, which means that they both use the same language/ country information. However, they can be set differently. For example: an application running in the United States could use Spanish for all of its menu items and other GUI elements while properly displaying all of the currency and date formatting for the United States. To do this, the thread's <b>CurrentUICulture </b>property should be set to a <b>CultureInfo </b>object initialized with a language of &quot;es&quot; (for Spanish), while the thread's <b>CurrentCulture </b>property should be set to a <b>CultureInfo </b>object initialized with a language/country pair of &quot;en-US.&quot;</p>
<p>Internally, a <b>CultureInfo </b>object has a field that refers to a <b>System.Globalization.</b></p>
<p><b>CompareInfo </b>object, which encapsulates the culture's character-sorting table information as defined by the Unicode standard. The following code demonstrates the difference between performing an ordinal comparison and a culturally aware string comparison:</p>
<p><code>using System;<br/>
using System.Globalization;<br/>
public static class Program { public static void Main() { String s1 = &quot;Strasse&quot;; String s2 = &quot;Stralie&quot;; Boolean eq;<br/>
// CompareOrdinal returns nonzero.<br/>
eq = String.Compare(s1, s2, StringComparison.Ordinal) == 0; Console.WriteLineC'Ordinal   comparison:  '{0}' {2} '{1}'&quot;, s1, s2, eq ? &quot;==&quot; : &quot;!=&quot;);<br/>
// Compare Strings appropriately for people // who speak German (de) in Germany (DE) CultureInfo ci = new CultureInfo(&quot;de-DE&quot;);<br/>
// Compare returns zero.<br/>
eq = String.Compare(s1, s2, true, ci) == 0;<br/>
Console.WriteLineC'Cultural comparison:  '{0}' {2} '{1}'&quot;, s1, s2, eq ? &quot;==&quot; : &quot;!=&quot;);<br/>
}<br/>
}</code></p>
<p>Building and running this code produces the following output:</p>
<p><code>Ordinal comparison: 'Strasse' != 'Stralie' Cultural comparison:  'Strasse' == 'Stralie'</code></p>
<p>I-[-</p>
<hr/>
<blockquote><b>Note </b>When the <b>Compare </b>method is not performing an ordinal comparison, it performs character expansions A character expansion is when a character is expanded to multiple characters regardless of culture. In the above case, the German Eszet character '13' is always expanded to 'ss.' Similarly, the 7E' ligature character is always expanded to 'AE.' So in the code example, the second call to <b>Compare </b>will always return 0 regardless of which culture I actually pass in to it.</blockquote>
<hr/>
<p>In some rare circumstances, you may need to have even more control when comparing strings for equality or for sorting. This could be necessary when comparing strings consisting of Japanese characters. This additional control can be accessed via the <b>CultureInfo </b>object's <b>CompareInfo </b>property As mentioned earlier, a <b>CompareInfo </b>object encapsulates a culture's character comparison tables, and there is just one <b>CompareInfo </b>object per culture.</p>
<p>When you call <b>String</b>'s <b>Compare </b>method, if the caller specifies a culture, the specified culture is used, or if no culture is specified, the value in the calling thread's <b>CurrentCulture </b>property is used Internally, the <b>Compare </b>method obtains the reference to the <b>CompareInfo </b>object for the appropriate culture and calls the <b>Compare </b>method of the <b>CompareInfo </b>object, passing along the appropriate options (such as case insensitivity). Naturally, you could call the <b>Compare </b>method of a specific <b>CompareInfo </b>object yourself if you need the additional control.</p>
<p>The <b>Compare </b>method of the <b>CompareInfo </b>type takes as a parameter a value from the <b>CompareOptions </b>enumerated type (as shown earlier). You can OR these bit flags together to gain significantly greater control when performing string comparisons. For a complete description of these symbols, consult the .NET Framework documentation.</p>
<p>The following code demonstrates how important culture is to sorting strings and shows various ways of performing string comparisons:</p>
<p><code>using System;<br/>
using System.Text;<br/>
using System.Windows.Forms;<br/>
using System.Globalization;<br/>
using System.Threading;<br/>
public sealed class Program { public static void Main() {<br/>
String output = String.Empty;<br/>
String[] symbol = new String[] { &quot;&lt;&quot;, &quot;=&quot;, &quot;&gt;&quot; }; Int32 x; CultureInfo ci;<br/>
// The code below demonstrates how strings compare // differently for different cultures. String s1 = &quot;cote&quot;; String s2 = &quot;cote&quot;;<br/>
// Sorting strings for French in France.<br/>
ci = new CultureInfo(&quot;fr-FR&quot;);<br/>
x = Math.Sign(ci.CompareInfo.Compare(s1, s2));<br/>
output += String.Format(&quot;{0} Compare: {1} {3} {2}&quot;,<br/>
ci.Name, s1, s2, symbo1[x + 1]); output += Environment.NewLine;<br/>
// Sorting strings for Japanese in Japan.<br/>
ci = new CultureInfo(&quot;ja-JP&quot;);<br/>
x = Math.Sign(ci.CompareInfo.Compare(s1, s2));<br/>
output += String.Format(&quot;{0} Compare: {1} {3} {2}&quot;,<br/>
ci.Name, s1, s2, symbo1[x + 1]); output += Environment.NewLine;<br/>
// Sorting strings for the thread's culture<br/>
ci = Thread.CurrentThread.CurrentCulture;<br/>
x = Math.Sign(ci.CompareInfo.Compare(s1, s2));<br/>
output += String.Format(&quot;{0} Compare: {1} {3} {2}&quot;,<br/>
ci.Name, s1, s2, symbo1[x + 1]); output += Environment.NewLine + Environment.NewLine;<br/>
//.The code below demonstrates how to use CompareInfo.Compare's<br/>
//.advanced options with 2 Japanese strings. One string represents<br/>
//.the word &quot;shinkansen&quot; (the name for the Japanese high-speed<br/>
//.train) in hiragana (one subtype of Japanese writing), and the<br/>
//.other represents the same word in katakana (another subtype of<br/>
//.Japanese writing).<br/>
s1.= &quot; LA,a&raquo;A,-arA/';   // (&quot;<span>\u3057\u3093\u304B\u3093\u305b\u3093</span>&quot;)<br/>
s2.= &quot;-&gt;w&gt;&gt;*^&quot;;   // (&quot;<span>\u30b7\u30f3\u30ab\u30f3\u30bb\u30f3</span>&quot;)<br/>
// Here is the result of a default comparison<br/>
ci = new CultureInfo(&quot;ja-JP&quot;);<br/>
x = Math.Sign(String.Compare(s1, s2, true, ci));<br/>
output += String.FormatC'Simple {0} Compare: {1} {3} {2}&quot;,<br/>
ci.Name, s1, s2, symbo1[x + 1]); output += Environment.NewLine;<br/>
// Here is the result of a comparison that ignores // kana type (a type of Japanese writing)<br/>
CompareInfo compareInfo = CompareInfo.GetCompareInfo(&quot;ja-JP&quot;); x = Math.Sign(compareInfo.Compare(s1, s2, CompareOptions.IgnoreKanaType)); output += String.Format(&quot;Advanced {0} Compare: {1} {3} {2}&quot;, ci.Name, s1, s2, symbo1[x + 1]);<br/>
MessageBox.Show(output, &quot;Comparing Strings For Sorting&quot;);<br/>
}<br/>
}</code></p>
<hr/>
<blockquote><b>Note </b>This source code file can't be saved in ANSI or the Japanese characters will be lost. To save this file in Microsoft Visual Studio, go to the Save File As dialog box, click the down arrow that is part of the Save button and select Save With Encoding. I selected &quot;Unicode (UTF-8 with signature) - Codepage 65001&quot;. Microsoft's C# compiler can successfully parse source code files using this code page.</blockquote>
<hr/>
<p>Building and running this code produces the output shown in Figure 14-1.</p>
<img src="37.jpg"/>
<p><b>Figure 14-1 </b>String sorting results</p>
<p>In addition to <b>Compare, </b>the <b>CompareInfo </b>class offers the <b>IndexOf, LastIndexOf, IsPrefix, </b>and <b>IsSuffix </b>methods. Because all of these methods offer overloads that take a <b>CompareOptions </b>enumeration value as a parameter, they give you more control than the <b>Compare, IndexOf, LastIndexOf, StartsWith, </b>and <b>EndsWith </b>methods defined by the <b>String </b>class. Also, you should be aware that the FCL includes a <b>System.StringComparer </b>class that you can also use for performing string comparisons This class is useful when you want to perform the same kind of comparison repeatedly for many different strings.</p>
<h3>String Interning</h3>
<p>As I said in the preceding section, checking strings for equality is a common operation for many applications葉his task can hurt performance significantly. When performing an ordinal equality check, the CLR quickly tests to see if both strings have the same number of characters. If they don't, the strings are definitely not equal; if they do, the strings might be equal, and the CLR must then compare each individual character to determine for sure When performing a culturally aware comparison, the CLR must always compare all of the individual characters because strings of different lengths might be considered equal.</p>
<p>In addition, if you have several instances of the same string duplicated in memory, you're wasting memory because strings are immutable. You'll use memory much more efficiently if there is just one instance of the string in memory and all variables needing to refer to the string can just point to the single string object.</p>
<p>If your application frequently compares strings for equality using case-sensitive, ordinal comparisons, or if you expect to have many string objects with the same value, you can enhance performance substantially if you take advantage of the string interning mechanism in the CLR When the CLR initializes, it creates an internal hash table in which the keys are strings and the values are references to <b>String </b>objects in the managed heap. Initially, the table is empty (of course). The <b>String </b>class offers two methods that allow you to access this internal hash table:</p>
<p><code>public static String Intern(String str); public static String IsInterned(String str);</code></p>
<p>The first method, <b>Intern, </b>takes a <b>String, </b>obtains a hash code for it, and checks the internal hash table for a match. If an identical string already exists, a reference to the already existing <b>String </b>object is returned. If an identical string doesn't exist, a copy of the string is made, the copy is added to the internal hash table, and a reference to this copy is returned. If the application no longer holds a reference to the original <b>String </b>object, the garbage collector is able to free the memory of that string. Note that the garbage collector can't free the strings that the internal hash table refers to because the hash table holds the reference to those <b>String </b>objects. <b>String </b>objects referred to by the internal hash table can't be freed until the AppDomain is unloaded or the process terminates.</p>
<p>As does the <b>Intern </b>method, the <b>IsInterned </b>method takes a <b>String </b>and looks it up in the internal hash table If a matching string is in the hash table, <b>IsInterned </b>returns a reference to the interned string object If a matching string isn't in the hash table, however, <b>IsInterned </b>returns <b>null; </b>it doesn't add the string to the hash table.</p>
<p>By default, when an assembly is loaded, the CLR interns all of the literal strings described in the assembly's metadata Microsoft learned that this hurts performance significantly due to the additional hash table lookups, so it is now possible to turn this &quot;feature&quot; off If an assembly is marked with a</p>
<p><b>System.Runtime.CompilerServices.CompilationRelaxationsAttribute </b>specifying the <b>System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning</b></p>
<p>flag value, the CLR may, according to the ECMA specification, choose not to intern all of the strings defined in that assembly's metadata. Note that, in an attempt to improve your application's performance, the C# compiler always specifies this attribute/flag whenever you compile an assembly.</p>
<p>Even if an assembly has this attribute/flag specified, the CLR may choose to intern the strings, but you should not count on this. In fact, you really should never write code that relies on strings being interned unless you have written code that explicitly calls the <b>String</b>'s <b>Intern </b>method yourself The following code demonstrates string interning:</p>
<p><code>String s1 = &quot;Hello&quot;; String s2 = &quot;Hello&quot;;<br/>
Console.WriteLine(Object.ReferenceEquals(s1, s2));     // Should be 'False'<br/>
s1 = String.Intern(s1); s2 = String.Intern(s2);<br/>
Console.WriteLine(Object.ReferenceEquals(s1, s2));     // 'True'</code></p>
<p>In the first call to the <b>ReferenceEquals </b>method, <b>s1 </b>refers to a <b>&quot;Hello&quot; </b>string object in the heap, and <b>s2 </b>refers to a different <b>&quot;Hello&quot; </b>string object in the heap. Since the references are different, <b>False </b>should be displayed. However, if you run this on version 4. 0 of the CLR, you'll see that <b>True </b>is displayed The reason is because this version of the CLR chooses to ignore the attribute/flag emitted by the C# compiler, and the CLR interns the literal <b>&quot;Hello&quot; </b>string when the assembly is loaded into the AppDomain. This means that <b>s1 </b>and <b>s2 </b>refer to the single <b>&quot;Hello&quot; </b>string in the heap. However, as mentioned previously, you should never write code that relies on this behavior because a future version of the CLR might honor the attribute/flag and not intern the <b>&quot;Hello&quot; </b>string. In fact, version 4. 0 of the CLR does honor the attribute/flag when this assembly's code has been compiled using the NGen.exe utility.</p>
<p>Before the second call to the <b>ReferenceEquals </b>method, the <b>&quot;Hello&quot; </b>string has been explicitly interned, and <b>s1 </b>now refers to an interned <b>&quot;Hello&quot;. </b>Then by calling <b>Intern </b>again, <b>s2 </b>is set to refer to the same <b>&quot;Hello&quot; </b>string as <b>s1. </b>Now, when <b>ReferenceEquals </b>is called the second time, we are guaranteed to get a result of <b>True </b>regardless of whether the assembly was compiled with the attribute/flag.</p>
<p>So now, let's look at an example to see how you can use string interning to improve performance and reduce memory usage. The <b>NumTimesWordAppearsEquals </b>method below takes two arguments: a word and an array of strings in which each array element refers to a single word. This method then determines how many times the specified word appears in the wordlist and returns this count:</p>
<p><code>private static Int32 NumTimesWordAppearsEquals(String word, String[] wordlist) { Int32 count = 0;<br/>
for (Int32 wordnum = 0; wordnum &lt; wordlist.Length; wordnum++) { if (word.Equals(wordlist[wordnum], StringComparison.Ordinal)) count++;<br/>
}<br/>
return count;<br/>
}</code></p>
<p>As you can see, this method calls <b>String</b>'s <b>Equals </b>method, which internally compares the strings' individual characters and checks to ensure that all characters match This comparison can be slow. In addition, the wordlist array might have multiple entries that refer to multiple <b>String </b>objects containing the same set of characters. This means that multiple identical strings might exist in the heap and are surviving ongoing garbage collections.</p>
<p>Now, let's look at a version of this method that was written to take advantage of string interning:</p>
<p><code>private static Int32 NumTimesWordAppearsIntern(String word, String[] wordlist) { // This method assumes that all entries in wordlist refer to interned strings. word = String.Intern(word); Int32 count = 0;<br/>
for (Int32 wordnum = 0; wordnum &lt; wordlist.Length; wordnum++) { if (Object.ReferenceEquals(word, wordlist[wordnum])) count++;<br/>
}<br/>
return count;<br/>
}</code></p>
<p>This method interns the word and assumes that the wordlist contains references to interned strings. First, this version might be saving memory if a word appears in the wordlist multiple times because, in this version, <b>wordlist </b>would now contain multiple references to the same single <b>String </b>object in the heap. Second, this version will be faster because determining if the specified word is in the array is simply a matter of comparing pointers.</p>
<p>Although the <b>NumTimesWordAppearsIntern </b>method is faster than the <b>NumTimesWordAppearsEquals </b>method, the overall performance of the application might be slower when using the <b>NumTimesWordAppearsIntern </b>method because of the time it takes to intern all of the strings when they were added to the <b>wordlist </b>array (code not shown). The <b>NumTimesWordAppearsIntern </b>method will really show its performance and memory improvement if the application needs to call the method multiple times using the same wordlist The point of this discussion is to make it clear that string interning is useful, but it should be used with care and caution. In fact, this is why the C# compiler indicates that it doesn't want string interning to be enabled.</p>
<h3>String Pooling</h3>
<p>When compiling source code, your compiler must process each literal string and emit the string into the managed module's metadata. If the same literal string appears several times in your source code, emitting all of these strings into the metadata will bloat the size of the resulting file.</p>
<p>To remove this bloat, many compilers (include the C# compiler) write the literal string into the module's metadata only once. All code that references the string will be modified to refer to the one string in the metadata. This ability of a compiler to merge multiple occurrences of a single string into a single instance can reduce the size of a module substantially This process is nothing new佑/C++ compilers have been doing it for years. (Microsoft's C/C++ compiler calls this string pooling) Even so, string pooling is another way to improve the performance of strings and just one more piece of knowledge that you should have in your repertoire.</p>
<h3>Examining a String's Characters and Text Elements</h3>
<p>Although comparing strings is useful for sorting them or for detecting equality, sometimes you need just to examine the characters within a string. The <b>String </b>type offers several properties and methods to help you do this, including <b>Length, Chars </b>(an indexer in C#), <b>GetEnumerator, ToCharArray, Contains, IndexOf, LastIndexOf, IndexOfAny, </b>and <b>LastIndexOfAny.</b></p>
<p>In reality, a <b>System.Char </b>represents a single 16-bit Unicode code value that doesn't necessarily equate to an abstract Unicode character. For example, some abstract Unicode characters are a combination of two code values. When combined, the U+0625 (the Arabic letter Alef with Hamza below) and U+0650 (the Arabic Kasra) characters form a single abstract character or text element</p>
<p>In addition, some Unicode text elements require more than a 16-bit value to represent them. These text elements are represented using two 16-bit code values. The first code value is called the high surrogate, and the second code value is called the low surrogate. High surrogates have a value between U+D800 and U+DBFF, and low surrogates have a value between U+DC00 and U+DFFF. The use of surrogates allows Unicode to express more than a million different characters.</p>
<p>Surrogates are rarely used in the United States and Europe but are more commonly used in East Asia. To properly work with text elements, you should use the <b>System.Globalization.StringInfo </b>type. The easiest way to use this type is to construct an instance of it, passing its constructor a string. Then you can see how many text elements are in the string by querying the <b>StringInfo</b>'s <b>LengthInTextElements </b>property. You can then call <b>StringInfo</b>'s <b>SubstringByTextElements </b>method to extract the text element or the number of consecutive text elements that you desire.</p>
<p>In addition, the <b>StringInfo </b>class offers a static <b>GetTextElementEnumerator </b>method, which acquires a <b>System.Globalization.TextElementEnumerator </b>object that allows you to enumerate through all of the abstract Unicode characters contained in the string Finally, you could call <b>StringInfo</b>'s static <b>ParseCombiningCharacters </b>method to obtain an array of <b>Int32 </b>values. The length of the array indicates how many text elements are contained in the string. Each element of the array identifies an index into the string where the first code value for a new text element can be found.</p>
<p>The following code demonstrates the various ways of using the <b>StringInfo </b>class to manipulate a string's text elements:</p>
<p><code>using.System;<br/>
using.System.Text;<br/>
using.System.Globalization;<br/>
using.System.Windows.Forms;<br/>
public sealed class Program { public static void Main() {<br/>
// The string below contains combining characters<br/>
String s = &quot;a\u0304\u0308bc\u0327&quot;;<br/>
SubstringByTextElements(s);<br/>
EnumTextElements(s);<br/>
EnumTextElementIndexes(s);<br/>
}<br/>
private static void SubstringByTextElements(String s) { String output = String.Empty;<br/>
StringInfo si = new StringInfo(s);<br/>
for (Int32 element = 0; element &lt; si.LengthInTextElements; element++) { output += String.Format(<br/>
&quot;Text element {0} is '{1}'{2}&quot;,<br/>
element, si.SubstringByTextElements(element, 1),<br/>
Environment.NewLine);<br/>
}<br/>
MessageBox.Show(output, &quot;Result of SubstringByTextElements&quot;);<br/>
}<br/>
private static void EnumTextElements(String s) { String output = String.Empty;<br/>
TextElementEnumerator charEnum =<br/>
StringInfo.GetTextElementEnumerator(s); while (charEnum.MoveNext()) {<br/>
output += String.Format(<br/>
&quot;Character at index {0} is '{1}'{2}&quot;,<br/>
charEnum.ElementIndex, charEnum.GetTextElement(), Environment.NewLine);<br/>
}<br/>
MessageBox.Show(output, &quot;Result of GetTextElementEnumerator&quot;);<br/>
}<br/>
private static void EnumTextElementIndexes(String s) { String output = String.Empty;<br/>
Int32[] textElemIndex = StringInfo.ParseCombiningCharacters(s); for (Int32 i = 0; i &lt; textElemIndex.Length; { output += String.Format(<br/>
&quot;Character {0} starts at index {1}{2}&quot;, i, textElemIndex[i], Environment.NewLine);<br/>
}<br/>
MessageBox.Show(output, &quot;Result of ParseCombiningCharacters&quot;);<br/>
}<br/>
}</code></p>
<p>Building and running this code produces the message boxes shown in Figures 14-2, 14-3, and 14-4.</p>
<p><b>Figure 14-2 </b>Result of <b>SubstringByTextElements</b></p>
<p>X</p>
<img src="38.jpg"/>
<p><b>Figure 14-3 </b>Result of <b>GetTextElementEnumerator</b></p>
<img src="39.jpg"/>
<p><b>Figure 14-4 </b>Result of <b>ParseCombiningCharacters</b></p>
<img src="40.jpg"/>
<p>s</p>
<p>The <b>String </b>type also offers methods that allow you to copy a string or parts of it. Table 14-1 summarizes these methods.</p>
<p><b>Table 14-1 </b><b>Methods for Copying Strings</b></p>
<table border="1">
<tr>
<td>
<p>r</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Instance</p>
</td>
<td>
<p>Returns a reference to the same object <b>(this) </b>. This is OK because <b>String </b>objects are immutable. This method implements <b>String</b>'s <b>ICloneable </b>interface.</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>Static</p>
</td>
<td>
<p>Returns a new duplicate string of the specified string. This method is rarely used and exists to help applications that treat strings as tokens. Normally, strings with the same set of characters are interned to a single string This method creates a new string object so that the references (pointers) are different even though the strings contain the same characters.</p>
</td>
</tr>
<tr>
<td>
<p>o</p>
</td>
<td>
<p>Instance</p>
</td>
<td>
<p>Copies a portion of the string's characters to an array of characters.</p>
</td>
</tr>
<tr>
<td>
<p>g</p>
</td>
<td>
<p>Instance</p>
</td>
<td>
<p>Returns a new string that represents a portion of the original string.</p>
</td>
</tr>
<tr>
<td>
<p>g</p>
</td>
<td>
<p>Instance</p>
</td>
<td>
<p>Returns a reference to the same object <b>(this) </b>.</p>
</td>
</tr>
</table>
<p>In addition to these methods, <b>String </b>offers many static and instance methods that manipulate a string, such as <b>Insert, Remove, PadLeft, Replace, Split, Join, ToLower, ToUpper, Trim, Concat, Format, </b>and so on. Again, the important thing to remember about all of these methods is that they return new string objects; because strings are immutable, once they're created, they can't be modified (using safe code).</p>
<a name="b346"/><h2>Constructing a String Efficiently</h2>
<p>Because the <b>String </b>type represents an immutable string, the FCL provides another type, <b>System.Text.StringBuilder, </b>which allows you to perform dynamic operations efficiently with strings and characters to create a <b>String. </b>Think of <b>StringBuilder </b>as a fancy constructor to create a <b>String </b>that can be used with the rest of the framework. In general, you should design methods that take <b>String </b>parameters, not <b>StringBuilder </b>parameters.</p>
<p>Logically, a <b>StringBuilder </b>object contains a field that refers to an array of <b>Char </b>structures. <b>StringBuilder</b>'s members allow you to manipulate this character array, effectively shrinking the string or changing the characters in the string. If you grow the string past the allocated array of characters, the <b>StringBuilder </b>automatically allocates a new, larger array, copies the characters, and starts using the new array. The previous array is garbage collected.</p>
<p>When finished using the <b>StringBuilder </b>object to construct your string, &quot;convert&quot; the <b>StringBuilder</b>'s character array into a <b>String </b>simply by calling the <b>StringBuilder</b>'s</p>
<p><b>ToString </b>method. This creates a new <b>String </b>object in the heap that contains the string that was in the <b>StringBuilder </b>at the time you called <b>ToString. </b>At this point, you can continue to manipulate the string inside the <b>StringBuilder, </b>and later you can call <b>ToString </b>again to convert it into another <b>String </b>object.</p>
<h3>Constructing a StringBuilder Object</h3>
<p>Unlike with the <b>String </b>class, the CLR has no special information about the <b>StringBuilder </b>class. In addition, most languages (including C#) don't consider the <b>StringBuilder </b>class to be a primitive type. You construct a <b>StringBuilder </b>object as you would any other non-primitive type:</p>
<p><code>StringBuilder sb = new StringBuilder();</code></p>
<p>The <b>StringBuilder </b>type offers many constructors. The job of each constructor is to allocate and initialize the state maintained by each <b>StringBuilder </b>object:</p>
<p><b>&#9632; Maximum capacity  </b>An <b>Int32 </b>value that specifies the maximum number of characters that can be placed in the string. The default is <b>Int32.MaxValue </b>(approximately 2 billion). It's unusual to change this value. However, you might specify a smaller maximum capacity to ensure that you never create a string over a certain length Once constructed, a <b>StringBuilder</b>'s maximum capacity value can't be changed.</p>
<p><b>&#9632; Capacity  </b>An <b>Int32 </b>value indicating the size of the character array being maintained by the <b>StringBuilder </b>. The default is 16. If you have some idea of how many characters you'll place in the <b>StringBuilder, </b>you should use this number to set the capacity when constructing the <b>StringBuilder </b>object.</p>
<p>When appending characters to the character array, the <b>StringBuilder </b>detects if the array is trying to grow beyond the array's capacity. If it is, the <b>StringBuilder </b>automatically doubles the capacity field, allocates a new array (the size of the new capacity), and copies the characters from the original array into the new array The original array will be garbage collected in the future. Dynamically growing the array hurts performance; avoid this by setting a good initial capacity.</p>
<p><b>&#9632; Character array  </b>An array of <b>Char </b>structures that maintains the set of characters in the &quot;string.&quot; The number of characters is always less than or equal to the capacity and maximum capacity values. You can use the <b>StringBuilder</b>'s <b>Length </b>property to obtain the number of characters used in the array. The <b>Length </b>is always less than or equal to the <b>StringBuilder</b>'s capacity value. When constructing a <b>StringBuilder, </b>you can pass</p>
<p>a <b>String </b>to initialize the character array. If you don't specify a string, the array initially contains no characters葉hat is, the <b>Length </b>property returns <b>0.</b></p>
<p>s</p>
<p>Unlike a <b>String, </b>a <b>StringBuilder </b>represents a mutable string. This means that most of <b>StringBuilder</b>'s members change the contents in the array of characters and don't cause new objects to be allocated on the managed heap. A <b>StringBuilder </b>allocates a new object on only two occasions:</p>
<p>&#9632; You dynamically build a string whose length is longer than the capacity you've set.</p>
<p>&#9632; You call <b>StringBuilder</b>'s <b>ToString </b>method.</p>
<p>Table 14-2 summarizes <b>StringBuilder</b>'s members.</p>
<p><b>Table 14-2 </b><b>StringBuilder Members</b></p>
<table border="1">
<tr>
<td>
<p>r</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>Read-only property</p>
</td>
<td>
<p>Returns the largest number of characters that can be placed in the string.</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>Read/write property</p>
</td>
<td>
<p>Gets or sets the size of the character array. Trying to set the capacity smaller than the string's length or bigger than <b>MaxCapacity </b>throws an <b>ArgumentOutOfRangeException </b>.</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Guarantees that the character array is at least the size specified. If the value passed is larger than the <b>StringBuilder</b>'s current capacity, the current capacity increases If the current capacity is already larger than the value passed to this property, no change occurs.</p>
</td>
</tr>
<tr>
<td>
<p>h</p>
</td>
<td>
<p>Read/write property</p>
</td>
<td>
<p>Gets or sets the number of characters in the &quot;string. &quot; This will likely be smaller than the character array's current capacity Setting this property to <b>0 </b>resets the <b>StringBuilder</b>'s contents to an empty string.</p>
</td>
</tr>
<tr>
<td>
<p>g</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>The parameterless version of this method returns a <b>String </b>representing the <b>StringBuilder</b>'s character array</p>
</td>
</tr>
<tr>
<td>
<p>s</p>
</td>
<td>
<p>Read/write indexer property</p>
</td>
<td>
<p>Gets or sets the character at the specified index into the character array. In C#, this is an indexer (parameterful property) that you access using array syntax (<b>[]</b>).</p>
</td>
</tr>
<tr>
<td>
<p>r</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Clears the contents of the <b>StringBuilder </b>object, the same as setting its <b>Length </b>property to <b>0.</b></p>
</td>
</tr>
<tr>
<td>
<p>d</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Appends a single object to the end of the character array, growing the array if necessary The object is converted to a string by using the general format and the culture associated with the calling thread.</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Inserts a single object into the character array, growing the array if necessary The object is converted to a string by using the general format and the culture associated with the calling thread.</p>
</td>
</tr>
</table>
<table border="1">
<tr>
<td>
<p>r</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Appends the specified objects to the end of the character array, growing the array if necessary. The objects are converted to strings by using the formatting and culture information provided by the caller. <b>AppendFormat </b>is one of the most common methods used with <b>StringBuilder </b>objects.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Appends a blank line or a string with a blank line to the end of the character array, increasing the capacity of the array if necessary.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Replaces one character with another or one string with another from within the character array.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Removes a range of characters from the character array.</p>
</td>
</tr>
<tr>
<td>
<p>s</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Returns <b>true </b>only if both <b>StringBuilder </b>objects have the same maximum capacity, capacity, and characters in the array.</p>
</td>
</tr>
<tr>
<td>
<p>o</p>
</td>
<td>
<p>Method</p>
</td>
<td>
<p>Copies a subset of the <b>StringBuilder</b>'s characters to a <b>Char </b>array.</p>
</td>
</tr>
</table>
<p>One important thing to note about <b>StringBuilder</b>'s methods is that most of them return a reference to the same <b>StringBuilder </b>object. This allows a convenient syntax to chain several operations together:</p>
<p><code>StringBuilder sb = new StringBuilder();<br/>
String s = sb.AppendFormat(&quot;{0} {1}&quot;, &quot;Jeffrey&quot;, &quot;Richter&quot;).<br/>
ReplaceC  ',  '-').Remove(4, 3).ToString(); Console.WriteLine(s);   // &quot;Jeff-Richter&quot;</code></p>
<p>You'll notice that the <b>String </b>and <b>StringBuilder </b>classes don't have full method parity; that is, <b>String </b>has <b>ToLower, ToUpper, EndsWith, PadLeft, PadRight, Trim, </b>and so on.</p>
<p>The <b>StringBuilder </b>class doesn't offer any of these methods. On the other hand, the <b>StringBuilder </b>class offers a richer <b>Replace </b>method that allows you to replace characters or strings in a portion of the string (not the whole string) It's unfortunate that there isn't complete parity between these two classes because now you must convert between <b>String </b>and <b>StringBuilder </b>to accomplish certain tasks. For example, to build up a string, convert all characters to uppercase, and then insert a string requires code like this:</p>
<p><code>// Construct a StringBuilder to perform string manipulations. StringBuilder sb = new StringBuilder();<br/>
// Perform some string manipulations by using the StringBuilder. sb.AppendFormat(&quot;{0} {1}&quot;, &quot;Jeffrey&quot;, &quot;Richter&quot;).Replace(&quot; &quot;, &quot;-&quot;);<br/>
// Convert the StringBuilder to a String in // order to uppercase all the characters. String s = sb.ToString().ToUpper();<br/>
// Clear the StringBuilder (allocates a new Char array). sb.Length = 0;<br/>
// Load the uppercase String into the StringBuilder, // and perform more manipulations. sb.Append(s).Insert(8, &quot;Marc-&quot;);<br/>
// Convert the StringBuilder back to a String. s = sb.ToString();<br/>
// Display the String to the user. Console.WriteLine(s);   // &quot;JEFFREY-Marc-RICHTER&quot;</code></p>
<p>It's inconvenient and inefficient to have to write this code just because <b>StringBuilder </b>doesn't offer all of the operations that <b>String </b>does. In the future, I hope that Microsoft will add more string operation methods to <b>StringBuilder </b>to make it a more complete class.</p>
<a name="b350"/><h2>Obtaining a String Representation of an Object: ToString</h2>
<p>You frequently need to obtain a string representation of an object. Usually, this is necessary when you want to display a numeric type (such as <b>Byte, Int32, </b>and <b>Single) </b>or a <b>DateTime </b>object to the user. Because the .NET Framework is an object-oriented platform, every type is responsible for providing code that converts an instance's value to a string equivalent When designing how types should accomplish this, the designers of the FCL devised a pattern that would be used consistently throughout. In this section, I'll describe this pattern.</p>
<p>You can obtain a string representation for any object by calling the <b>ToString </b>method. A public, virtual, parameterless <b>ToString </b>method is defined by <b>System.Object </b>and is therefore callable using an instance of any type. Semantically, <b>ToString </b>returns a string representing the object's current value, and this string should be formatted for the calling thread's current culture; that is, the string representation of a number should use the proper decimal separator, digit-grouping symbol, and other elements associated with the culture assigned to the calling thread.</p>
<p><b>System.Object</b>'s implementation of <b>ToString </b>simply returns the full name of the object's type. This value isn't particularly useful, but it is a reasonable default for the many types that can't offer a sensible string. For example, what should a string representation of a <b>FileStream </b>or a <b>Hashtable </b>object look like?</p>
<p>All types that want to offer a reasonable way to obtain a string representing the current value of the object should override the <b>ToString </b>method. All base types built into the FCL <b>(Byte, Int32, UInt64, Double, </b>and so on) override their <b>ToString </b>method and return a culturally aware string. In the Visual Studio debugger, a datatip is displayed when the mouse is placed over a particular variable. The text shown in the datatip is obtained by calling the object's <b>ToString </b>method. So, when you define a class, you should always override the <b>ToString </b>method so that you get good debugging support.</p>
<h3>Specific Formats and Cultures</h3>
<p>The parameterless <b>ToString </b>method has two problems First, the caller has no control over the formatting of the string For example, an application might want to format a number into a currency string, decimal string, percent string, or hexadecimal string. Second, the caller can't easily choose to format a string by using a specific culture. This second problem is more troublesome for server-side application code than for client-side code On rare occasions, an application needs to format a string by using a culture other than the culture associated with the calling thread. To have more control over string formatting, you need a version of the <b>ToString </b>method that allows you to specify precise formatting and culture information.</p>
<p>Types that offer the caller a choice in formatting and culture implement the <b>System. IFormattable </b>interface:</p>
<p><code>public interface IFormattable {<br/>
String ToString(String format, IFormatProvider formatProvider);<br/>
}</code></p>
<p>In the FCL, all of the base types <b>(Byte, SByte, Int16/UInt16, Int32/UInt32, Int64/UInt64, Single, Double, Decimal, </b>and <b>DateTime) </b>implement this interface. In addition, some other types, such as <b>Guid, </b>implement it. Finally, every enumerated type definition will automatically implement the <b>IFormattable </b>interface so that a meaningful string symbol from an instance of the enumerated type can be obtained.</p>
<p><b>IFormattable</b>'s <b>ToString </b>method takes two parameters. The first, <b>format, </b>is a string that tells the method how the object should be formatted. <b>ToString</b>'s second parameter, <b>formatProvider, </b>is an instance of a type that implements the <b>System.IFormatProvider </b>interface. This type supplies specific culture information to the <b>ToString </b>method. I'll discuss how shortly.</p>
<p>The type implementing the <b>IFormattable </b>interface's <b>ToString </b>method determines which format strings it's going to recognize. If you pass a format string that the type doesn't recognize, the type is supposed to throw a <b>System.FormatException </b>.</p>
<p>Many of the types Microsoft has defined in the FCL recognize several formats. For example, the <b>DateTime </b>type supports &quot;d&quot; for short date, &quot;D&quot; for long date, &quot;g&quot; for general, &quot;M&quot; for month/day, &quot;s&quot; for sortable, &quot;T&quot; for long time, &quot;u&quot; for universal time in ISO 8601 format, &quot;U&quot; for universal time in full date format, &quot;Y&quot; for year/month, and others All enumerated types support &quot;G&quot; for general, &quot;F&quot; for flags, &quot;D&quot; decimal, and &quot;X&quot; for hexadecimal. I'll cover formatting enumerated types in more detail in Chapter 15, &quot;Enumerated Types and Bit Flags.&quot;</p>
<p>Also, all of the built-in numeric types support &quot;C&quot; for currency, &quot;D&quot; for decimal, &quot;E&quot; for exponential (scientific) notation, &quot;F&quot; for fixed-point, &quot;G&quot; for general, &quot;N&quot; for number, &quot;P&quot; for percent, &quot;R&quot; for round-trip, and &quot;X&quot; for hexadecimal In fact, the numeric types also support picture format strings just in case the simple format strings don't offer you exactly what you're looking for Picture format strings contain special characters that tell the type's <b>ToString </b>method exactly how many digits to show, exactly where to place a decimal separator, exactly how many digits to place after the decimal separator, and so on. For complete information about format strings, see &quot;Formatting Types&quot; in the .NET Framework SDK.</p>
<p>For most types, calling <b>ToString </b>and passing <b>null </b>for the format string is identical to calling <b>ToString </b>and passing &quot;G&quot; for the format string. In other words, objects format themselves using the &quot;General format&quot; by default. When implementing a type, choose a format that you think will be the most commonly used format; this format is the &quot;General format.&quot; By the way, the <b>ToString </b>method that takes no parameters assumes that the caller wants the &quot;General format &quot;</p>
<p>So now that format strings are out of the way, let's turn to culture information. By default, strings are formatted using the culture information associated with the calling thread. The parameterless <b>ToString </b>method certainly does this, and so does <b>IFormattable</b>'s <b>ToString </b>if you pass <b>null </b>for the <b>formatProvider </b>parameter.</p>
<p>Culture-sensitive information applies when you're formatting numbers (including currency, integers, floating point, percentages, dates, and times). The <b>Guid </b>type has a <b>ToString </b>method that returns only a string representing its value. There's no need to consider a culture when generating the <b>Guid</b>'s string because <b>GUID</b>s are used for programmatic purposes only.</p>
<p>When formatting a number, the <b>ToString </b>method sees what you've passed for the <b>formatProvider </b>parameter. If <b>null </b>is passed, <b>ToString </b>determines the culture associated with the calling thread by reading the</p>
<p><b>System.Threading.Thread.CurrentThread.CurrentCulture </b>property. This property returns an instance of the <b>System.Globalization.CultureInfo </b>type.</p>
<p>Using this object, <b>ToString </b>reads its <b>NumberFormat </b>or <b>DateTimeFormat </b>property, depending on whether a number or date/time is being formatted These properties return an instance of <b>System.Globalization.NumberFormatInfo </b>or <b>System.Globalization. DateTimeFormatInfo, </b>respectively. The <b>NumberFormatInfo </b>type defines a bunch of properties, such as <b>CurrencyDecimalSeparator, CurrencySymbol, NegativeSign, NumberGroupSeparator, </b>and <b>PercentSymbol. </b>Likewise, the <b>DateTimeFormatInfo </b>type defines an assortment of properties, such as <b>Calendar, DateSeparator, DayNames, LongDatePattern, ShortTimePattern, </b>and <b>TimeSeparator. ToString </b>reads these properties when constructing and formatting a string.</p>
<p>When calling <b>IFormattable</b>'s <b>ToString </b>method, instead of passing <b>null, </b>you can pass a reference to an object whose type implements the <b>IFormatProvider </b>interface:</p>
<p><code>public interface IFormatProvider { Object CetFormat(Type formatType);<br/>
}</code></p>
<p>Here's the basic idea behind the <b>IFormatProvider </b>interface: when a type implements this interface, it is saying that an instance of the type is able to provide culture-specific formatting information and that the culture information associated with the calling thread should be ignored.</p>
<p>The <b>System.Globalization.CultureInfo </b>type is one of the very few types defined in the FCL that implements the <b>IFormatProvider </b>interface. If you want to format a string for, say, Vietnam, you'd construct a <b>CultureInfo </b>object and pass that object in as <b>ToString</b>'s <b>formatProvider </b>parameter. The following code obtains a string representation of a <b>Decimal </b>numeric value formatted as currency appropriate for Vietnam:</p>
<p><code>Decimal price = 123.54M;<br/>
String s = price.ToStringC'C&quot;, new CultureInfo(&quot;vi-VN&quot;)); MessageBox.Show(s);</code></p>
<p>If you build and run this code, the message box shown in Figure 14-5 appears.</p>
<img src="41.jpg"/>
<p><b>Figure 14-5 </b>Numeric value formatted correctly to represent Vietnamese currency</p>
<p>Internally, <b>Decimal</b>'s <b>ToString </b>method sees that the <b>formatProvider </b>argument is not <b>null </b>and calls the object's <b>GetFormat </b>method as follows:</p>
<p><code>NumberFormatInfo nfi = (NumberFormatInfo)<br/>
formatProvider.GetFormat(typeof(NumberFormatInfo));</code></p>
<p>This is how <b>ToString </b>requests the appropriate number-formatting information from the <b>(CultureInfo) </b>object. Number types (such as <b>Decimal) </b>request only number-formatting information. But other types (such as <b>DateTime) </b>could call <b>GetFormat </b>like this:</p>
<p><code>DateTimeFormatInfo dtfi = (DateTimeFormatInfo)<br/>
formatProvider.GetFormat(typeof(DateTimeFormatInfo));</code></p>
<p>Actually, because <b>GetFormat</b>'s parameter can identify any type, the method is flexible enough to allow any type of format information to be requested. The types in the .NET Framework call <b>GetFormat, </b>requesting only number or date/time information; in the future, other kinds of formatting information could be requested.</p>
<p>By the way, if you want to obtain a string for an object that isn't formatted for any particular culture, you should call <b>System.Globalization.CultureInfo</b>'s static <b>InvariantCulture </b>property and pass the object returned as <b>ToString</b>'s <b>formatProvider </b>parameter:</p>
<p><code>Decimal price = 123.54M;<br/>
String s = price.ToStringC'C&quot;, CultureInfo.InvariantCulture); MessageBox.Show(s);</code></p>
<p>If you build and run this code, the message box shown in Figure 14-6 appears. Notice the first character in the resulting string: <b>a. </b>This is the international sign for currency (U+00A4).</p>
<img src="42.jpg"/>
<p><b>Figure 14-6 </b>Numeric value formatted to represent a culture-neutral currency</p>
<p>Normally, you wouldn't display a string formatted by using the invariant culture to a user. Typically, you'd just save this string in a data file so that it could be parsed later.</p>
<p>In the FCL, just three types implement the <b>IFormatProvider </b>interface. The first is <b>CultureInfo, </b>which I've already explained. The other two are <b>NumberFormatInfo </b>and <b>DateTimeFormatInfo. </b>When <b>GetFormat </b>is called on a <b>NumberFormatInfo </b>object, the method checks if the type being requested is a <b>NumberFormatInfo. </b>If it is, <b>this </b>is returned; if it's not, <b>null </b>is returned. Similarly, calling <b>GetFormat </b>on a <b>DateTimeFormatInfo </b>object returns <b>this </b>if a <b>DateTimeFormatInfo </b>is requested and <b>null </b>if it's not. These two types implement this interface simply as a programming convenience. When trying to obtain a string representation of an object, the caller commonly specifies a format and uses the culture associated with the calling thread. For this reason, you often call <b>ToString, </b>passing a string for the format parameter and <b>null </b>for the <b>formatProvider </b>parameter. To make calling <b>ToString </b>easier for you, many types offer several overloads of the <b>ToString </b>method. For example, the <b>Decimal </b>type offers four different <b>ToString </b>methods:</p>
<p><code>// This version calls ToString(nu11, null).<br/>
// Meaning: General numeric format, thread's culture information public override String ToString();<br/>
// This version is where the actual implementation of ToString goes.<br/>
// This version implements IFormattable's ToString method.<br/>
// Meaning: Caller-specified format and culture information<br/>
public String ToString(String format, IFormatProvider formatProvider);<br/>
// This version simply calls ToString(format, null).<br/>
// Meaning: Caller-specified format, thread's culture information<br/>
public String ToString(String format);<br/>
// This version simply calls ToString(nu11, formatProvider). // This version implements Convertible's ToString method. // Meaning: General format, caller-specified culture information public String ToString(IFormatProvider formatProvider);</code></p>
<h3>Formatting Multiple Objects into a Single String</h3>
<p>So far, I've explained how an individual type formats its own objects. At times, however, you want to construct strings consisting of many formatted objects. For example, the following string has a date, a person's name, and an age:</p>
<p><code>String s = String.Format(&quot;On {0}, {1} is {2} years old.&quot;,<br/>
new DateTime(2010, 4, 22, 14, 35, 5), &quot;Aidan&quot;, 7); Console.WriteLine(s);</code></p>
<p>If you build and run this code where &quot;en-US&quot; is the thread's current culture, you'll see the following line of output:</p>
<p><code>On 4/22/2010 2:35:05 PM, Aidan is 7 years old.</code></p>
<p><b>String</b>'s static <b>Format </b>method takes a format string that identifies replaceable parameters using numbers in braces The format string used in this example tells the <b>Format </b>method to replace <b>{0} </b>with the first parameter after the format string (the date/time), replace <b>{1} </b>with the second parameter after the format string (&quot;Aidan&quot;), and replace <b>{2} </b>with the third parameter after the format string (7).</p>
<p>Internally, the <b>Format </b>method calls each object's <b>ToString </b>method to obtain a string representation for the object. Then the returned strings are all appended and the complete, final string is returned. This is all fine and good, but it means that all of the objects are formatted by using their general format and the calling thread's culture information.</p>
<p>You can have more control when formatting an object if you specify format information within braces For example, the following code is identical to the previous example except that I've added formatting information to replaceable parameters 0 and 2:</p>
<p><code>String s = String.Format(&quot;On {0:D}, {1} is {2:E} years old.&quot;,<br/>
new DateTime(2010, 4, 22, 14, 35, 5), &quot;Aidan&quot;, 7); Console.WriteLine(s);</code></p>
<p>If you build and run this code where &quot;en-US&quot; is the thread's current culture, you'll see the following line of output:</p>
<p><code>On Thursday, April 22, 2010, Aidan is 7.000000E+000 years old.</code></p>
<p>When the <b>Format </b>method parses the format string, it sees that replaceable parameter 0 should have its <b>IFormattable </b>interface's <b>ToString </b>method called passing <b>&quot;D&quot; </b>and <b>null </b>for its two parameters Likewise, <b>Format </b>calls replaceable parameter 2's <b>IFormattable ToString </b>method, passing <b>&quot;E&quot; </b>and <b>null. </b>If the type doesn't implement the <b>IFormattable </b>interface, <b>Format </b>calls its parameterless <b>ToString </b>method inherited from <b>Object </b>(and possibly overridden), and the default format is appended into the resulting string.</p>
<p>The <b>String </b>class offers several overloads of the static <b>Format </b>method. One version takes an object that implements the <b>IFormatProvider </b>interface so that you can format all of the replaceable parameters by using caller-specified culture information. Obviously, <b>Format </b>calls each object's <b>IFormattableToString </b>method, passing it whatever <b>IFormatProvider </b>object was passed to <b>Format </b>.</p>
<p>If you're using <b>StringBuilder </b>instead of <b>String </b>to construct a string, you can call <b>StringBuilder</b>'s <b>AppendFormat </b>method. This method works exactly as <b>String</b>'s <b>Format </b>method except that it formats a string and appends to the <b>StringBuilder</b>'s character array. As does <b>String</b>'s <b>Format, AppendFormat </b>takes a format string, and there's a version that takes an<b>IFormatProvider </b>.</p>
<p><b>System.Console </b>offers <b>Write </b>and <b>WriteLine </b>methods that also take format strings and replaceable parameters. However, there are no overloads of <b>Console</b>'s <b>Write </b>and <b>WriteLine </b>methods that allow you to pass an <b>IFormatProvider. </b>If you want to format a string for a specific culture, you have to call <b>String</b>'s <b>Format </b>method, first passing the desired <b>IFormatProvider </b>object and then passing the resulting string to <b>Console</b>'s <b>Write </b>or <b>WriteLine </b>method. This shouldn't be a big deal because, as I said earlier, it's rare for client-side code to format a string by using a culture other than the one associated with the calling thread.</p>
<h3>Providing Your Own Custom Formatter</h3>
<p>By now it should be clear that the formatting capabilities in the NET Framework were designed to offer you a great deal of flexibility and control. However, we're not quite finished. It's possible for you to define a method that <b>StringBuilder</b>'s <b>AppendFormat </b>method will call whenever any object is being formatted into a string. In other words, instead of calling <b>ToString </b>for each object, <b>AppendFormat </b>can call a function you define, allowing you to format any or all of the objects in any way you want. What I'm about to describe also works with <b>String</b>'s <b>Format </b>method.</p>
<p>Let me explain this mechanism by way of an example. Let's say that you're formatting HTML text that a user will view in an Internet browser. You want all <b>Int32 </b>values to appear in bold. To accomplish this, every time an <b>Int32 </b>value is formatted into a <b>String, </b>you want to surround the string with HTML bold tags: <b>&lt;B&gt; </b>and <b>&lt;/B&gt;. </b>The following code demonstrates how easy it is to do this:</p>
<p><code>using System; using System.Text; using System.Threading;<br/>
public static class Program { public static void Main() {<br/>
StringBuilder sb = new StringBuilder();<br/>
sb.AppendFormat(new BoldInt32s(), &quot;{0} {1} {2:M}&quot;, &quot;Jeff&quot;, 123, DateTime.Now); Console.WriteLine(sb);<br/>
}<br/>
}<br/>
internal sealed class BoldInt32s : IFormatProvider, ICustomFormatter { public Object GetFormat(Type formatType) {<br/>
if (formatType == typeof(ICustomFormatter)) return this;<br/>
return Thread.CurrentThread.CurrentCulture.GetFormat(formatType);<br/>
}<br/>
public String Format(String format, Object arg, IFormatProvider formatProvider) { String s;<br/>
IFormattable formattable = arg as IFormattable;<br/>
if (formattable == null) s = arg.ToString();<br/>
else s = formattable.ToString(format, formatProvider);<br/>
if (arg.GetType() == typeof(Int32))<br/>
return &quot;&lt;B&gt;&quot; + s + &quot;&lt;/B&gt;&quot;; return s;<br/>
}<br/>
}</code></p>
<p>When you compile and run this code where &quot;en-US&quot; is the thread's current culture, it displays the following output (your date may be different, of course):</p>
<p><code>Jeff &lt;B&gt;123&lt;/B&gt; January 23</code></p>
<p>In <b>Main, </b>I'm constructing an empty <b>StringBuilder </b>and then appending a formatted string into it. When I call <b>AppendFormat, </b>the first parameter is an instance of the <b>BoldInt32s </b>class. This class implements the <b>IFormatProvider </b>interface that I discussed earlier. In addition, this class implements the <b>ICustomFormatter </b>interface:</p>
<p><code>public interface ICustomFormatter {<br/>
String Format(String format, Object arg, IFormatProvider formatProvider);<br/>
}</code></p>
<p>This interface's <b>Format </b>method is called whenever <b>StringBuilder</b>'s <b>AppendFormat </b>needs to obtain a string for an object. You can do some pretty clever things inside this method that give you a great deal of control over string formatting. Let's look inside the <b>AppendFormat </b>method to see exactly how it works. The following pseudocode shows how <b>AppendFormat </b>works:</p>
<p><code>public StringBuilder AppendFormat(IFormatProvider formatProvider, String format, params Object[] args) {<br/>
// If an IFormatProvider was passed, find out // whether it offers an ICustomFormatter object. ICustomFormatter cf = null;<br/>
if (formatProvider != null) cf = (ICustomFormatter)<br/>
formatProvider.CetFormat(typeof(ICustomFormatter));<br/>
// Keep appending literal characters (not shown in this pseudocode) // and replaceable parameters to the StringBuilder&quot;s character array. Boolean MoreReplaceableArgumentsToAppend = true; while (MoreReplaceableArgumentsToAppend) {<br/>
// argFormat refers to the replaceable format string obtained<br/>
// from the format parameter<br/>
String argFormat = /*... */;<br/>
// argObj refers to the corresponding element // from the args array parameter Object argObj = /*... */;<br/>
// argStr will refer to the formatted string to be appended // to the final, resulting string String argStr = null;<br/>
// If a custom formatter is available, let it format the argument. if (cf != null)<br/>
argStr = cf.Format(argFormat, argObj, formatProvider);<br/>
// If there is no custom formatter or if it didn&quot;t format // the argument, try something else. if (argStr == null) {<br/>
// Does the argument's type support rich formatting? IFormattable formattable = argObj as IFormattable; if (formattable != null) {<br/>
// Yes; pass the format string and provider to<br/>
// the type&quot;s IFormattable ToString method.<br/>
argStr = formattable.ToString(argFormat, formatProvider);<br/>
} else {<br/>
// No; get the default format by using<br/>
// the thread&quot;s culture information.<br/>
if (argObj != null) argStr = argObj.ToString();<br/>
else argStr = String.Empty;<br/>
}<br/>
}<br/>
// Append argStr&quot;s characters to the character array field member.<br/>
/*... */<br/>
// Check if any remaining parameters to format MoreReplaceableArgumentsToAppend = /*... */;<br/>
}<br/>
return this;<br/>
}</code></p>
<p>When <b>Main </b>calls <b>AppendFormat, AppendFormat </b>calls my format provider's <b>GetFormat </b>method, passing it the <b>ICustomFormatter </b>type. The <b>GetFormat </b>method defined in my <b>BoldInt32s </b>type sees that the <b>ICustomFormatter </b>is being requested and returns a reference to itself because it implements this interface. If my <b>GetFormat </b>method is called and is passed any other type, I call the <b>GetFormat </b>method of the <b>CultureInfo </b>object associated with the calling thread.</p>
<p>Whenever <b>AppendFormat </b>needs to format a replaceable parameter, it calls <b>ICustomFormatter</b>'s <b>Format </b>method. In my example, <b>AppendFormat </b>calls the <b>Format </b>method defined by my <b>BoldInt32s </b>type. In my <b>Format </b>method, I check whether the object being formatted supports rich formatting via the <b>IFormattable </b>interface. If the object doesn't, I then call the simple, parameterless <b>ToString </b>method (inherited from <b>Object) </b>to format the object. If the object does support <b>IFormattable, </b>I then call the rich <b>ToString </b>method, passing it the format string and the format provider.</p>
<p>Now that I have the formatted string, I check whether the corresponding object is an <b>Int32 </b>type, and if it is, I wrap the formatted string in <b>&lt;B&gt; </b>and <b>&lt;/B&gt; </b>HTML tags and return the new string. If the object is not an <b>Int32, </b>I simply return the formatted string without any further processing.</p>
<a name="b359"/><h2>Parsing a String to Obtain an Object: Parse</h2>
<p>In the preceding section, I explained how to take an object and obtain a string representation of that object. In this section, I'll talk about the opposite: how to take a string and obtain an object representation of it Obtaining an object from a string isn't a very common operation, but it does occasionally come in handy. Microsoft felt it necessary to formalize a mechanism by which strings can be parsed into objects.</p>
<p>Any type that can parse a string offers a public, static method called <b>Parse </b>This method takes a <b>String </b>and returns an instance of the type; in a way, <b>Parse </b>acts as a factory. In the FCL, a <b>Parse </b>method exists on all of the numeric types as well as for <b>DateTime, TimeSpan, </b>and a few other types (such as the SQL data types).</p>
<p>Let's look at how to parse a string into a number type. Almost all of the numeric types <b>(Byte, SByte, Int16/UInt16, Int32/UInt32, Int64/UInt64, Single, Double, Decimal, </b>and <b>BigInteger) </b>offer at least one <b>Parse </b>method. Here I'll show you just the <b>Parse </b>method defined by the <b>Int32 </b>type. (The <b>Parse </b>methods for the other numeric types work similarly to <b>Int32</b>'s <b>Parse </b>method.</p>
<p><code>public static Int32 Parse(String s, NumberStyles style, IFormatProvider provider);</code></p>
<p>Just from looking at the prototype, you should be able to guess exactly how this method works. The <b>String </b>parameter, <b>s, </b>identifies a string representation of a number you want parsed into an <b>Int32 </b>object. The <b>System.Globalization.NumberStyles </b>parameter, <b>style, </b>is a set of bit flags that identify characters that <b>Parse </b>should expect to find in the string. And the <b>IFormatProvider </b>parameter, <b>provider, </b>identifies an object that the <b>Parse </b>method can use to obtain culture-specific information, as discussed earlier in this chapter.</p>
<p>For example, the following code causes <b>Parse </b>to throw a <b>System.FormatException </b>because the string being parsed contains a leading space:</p>
<p><code>Int32 x = Int32.Parse(&quot; 123&quot;, NumberStyles.None, null);</code></p>
<p>To allow <b>Parse </b>to skip over the leading space, change the <b>style </b>parameter as follows: Int32 x = Int32.Parse(&quot; 123&quot;, NumberStyles.AllowLeadingWhite, null);</p>
<p>See the .NET Framework SDK documentation for a complete description of the bit symbols and common combinations that the <b>NumberStyles </b>enumerated type defines.</p>
<p>Here's a code fragment showing how to parse a hexadecimal number:</p>
<p><code>Int32 x = Int32.Parse(&quot;1A&quot;, NumberStyles.HexNumber, null); Console.WriteLine(x);   // Displays &quot;26&quot;</code></p>
<p>This <b>Parse </b>method accepts three parameters. For convenience, many types offer additional overloads of <b>Parse </b>so you don't have to pass as many arguments. For example, <b>Int32 </b>offers four overloads of the <b>Parse </b>method:</p>
<p><code>// Passes NumberStyles.Integer for style<br/>
// and thread's culture's provider information.<br/>
public static Int32 Parse(String s);<br/>
// Passes thread's culture's provider information. public static Int32 Parse(String s, NumberStyles style);<br/>
// Passes NumberStyles.Integer for the style parameter. public static Int32 Parse(String s, IFormatProvider provider);<br/>
// This is the method I've been talking about in this section. public static Int32 Parse(String s, NumberStyles style, IFormatProvider provider);</code></p>
<p>The <b>DateTime </b>type also offers a <b>Parse </b>method:</p>
<p><code>public static DateTime Parse(String s,<br/>
IFormatProvider provider, DateTimeStyles styles);</code></p>
<p>This method works just as the <b>Parse </b>method defined on the number types except that <b>DateTime</b>'s <b>Parse </b>method takes a set of bit flags defined by the</p>
<p><b>System.Globalization.DateTimeStyles </b>enumerated type instead of the <b>NumberStyles</b></p>
<p>enumerated type. See the .NET Framework SDK documentation for a complete description of the bit symbols and common combinations the <b>DateTimeStyles </b>type defines.</p>
<p><b>Chapter 14  Chars, Strings, and Working with Text 361 </b>For convenience, the <b>DateTime </b>type offers three overloads of the <b>Parse </b>method:</p>
<p><code>// Passes thread's culture's provider information // and DateTimeStyles.None for the style public static DateTime Parse(String s);<br/>
// Passes DateTimeStyles.None for the style<br/>
public static DateTime Parse(String s, IFormatProvider provider);<br/>
// This is the method I've been talking about in this section. public static DateTime Parse(String s,<br/>
IFormatProvider provider, DateTimeStyles styles);</code></p>
<p>Parsing dates and times is complex. Many developers have found the <b>Parse </b>method of the <b>DateTime </b>type too forgiving in that it sometimes parses strings that don't contain dates or times. For this reason, the <b>DateTime </b>type also offers a <b>ParseExact </b>method that accepts a picture format string that indicates exactly how the date/time string should be formatted and how it should be parsed. For more information about picture format strings, see the <b>DateTimeFormatInfo </b>class in the .NET Framework SDK.</p>
<hr/>
<blockquote><b>Note </b>Some developers have reported the following back to Microsoft: when their application calls <b>Parse </b>frequently, and <b>Parse </b>throws exceptions repeatedly (due to invalid user input), performance of the application suffers For these performance-sensitive uses of <b>Parse, </b>Microsoft added <b>TryParse </b>methods to all of the numeric data types, <b>DateTime, DateTimeOffset, TimeSpan, </b>and even <b>IPAddress </b>. This is what one of the two <b>Int32</b>'s two <b>TryParse </b>method overloads looks like:</blockquote>
<hr/>
<p><code>public static Boolean TryParse(String s, NumberStyles style, IFormatProvider provider, out Int32 result);</code></p>
<p>As you can see, this method returns <b>true </b>or <b>false </b>indicating whether the specified string can be parsed into an <b>Int32 </b>If the method returns <b>true, </b>the variable passed by reference to the result parameter will contain the parsed numeric value The <b>TryXxx </b>pattern is discussed in Chapter 20, &quot;Exceptions and State Management.&quot;</p>
<a name="b361"/><h2>Encodings: Converting Between Characters and Bytes</h2>
<p>In Win32, programmers all too frequently have to write code to convert Unicode characters and strings to Multi-Byte Character Set (MBCS) characters and strings. I've certainly written my share of this code, and it's very tedious to write and error-prone to use. In the CLR, all characters are represented as 16-bit Unicode code values and all strings are composed of 16-bit Unicode code values. This makes working with characters and strings easy at runtime.</p>
<p>At times, however, you want to save strings to a file or transmit them over a network. If the strings consist mostly of characters readable by English-speaking people, saving or transmitting a set of 16-bit values isn't very efficient because half of the bytes written would contain zeros. Instead, it would be more efficient to encode the 16-bit values into a compressed array of bytes and then decode the array of bytes back into an array of 16-bit values.</p>
<p>Encodings also allow a managed application to interact with strings created by non-Unicode systems. For example, if you want to produce a file readable by an application running on a Japanese version of Microsoft Windows 95, you have to save the Unicode text by using the Shift-JIS (code page 932) encoding. Likewise, you'd use Shift-JIS encoding to read a text file produced on a Japanese Windows 95 system into the CLR.</p>
<p>Encoding is typically done when you want to send a string to a file or network stream by using the <b>System.IO.BinaryWriter </b>or <b>System.IO.StreamWriter </b>type. Decoding is typically done when you want to read a string from a file or network stream by using the <b>System.IO.BinaryReader </b>or <b>System.IO.StreamReader </b>type. If you don't explicitly select an encoding, all of these types default to using UTF-8. (UTF stands for Unicode Transformation Format.) However, at times, you might want to explicitly encode or decode a string. Even if you don't want to explicitly do this, this section will give you more insight into the reading and writing of strings from and to streams.</p>
<p>Fortunately, the FCL offers some types to make character encoding and decoding easy The two most frequently used encodings are UTF-16 and UTF-8.</p>
<p>&#9632; UTF-16 encodes each 16-bit character as 2 bytes. It doesn't affect the characters at all, and no compression occurs擁ts performance is excellent. UTF-16 encoding is also referred to as Unicode encoding Also note that UTF-16 can be used to convert from little-endian to big-endian and vice versa.</p>
<p>&#9632; UTF-8 encodes some characters as 1 byte, some characters as 2 bytes, some characters as 3 bytes, and some characters as 4 bytes. Characters with a value below 0x0080 are compressed to 1 byte, which works very well for characters used in the United States. Characters between 0x0080 and 0x07FF are converted to 2 bytes, which works well for European and Middle Eastern languages. Characters of 0x0800 and above are converted to 3 bytes, which works well for East Asian languages Finally, surrogate pairs are written out as 4 bytes. UTF-8 is an extremely popular encoding, but it's less efficient than UTF-16 if you encode many characters with values of 0x0800 or above.</p>
<p>Although the UTF-16 and UTF-8 encodings are by far the most common, the FCL also supports some encodings that are used less frequently:</p>
<p>&#9632; UTF-32 encodes all characters as 4 bytes. This encoding is useful when you want to write a simple algorithm to traverse characters and you don't want to have to deal with characters taking a variable number of bytes For example, with UTF-32, you do not need to think about surrogates because every character is 4 bytes. Obviously, UTF-32</p>
<p>is not an efficient encoding in terms of memory usage and is therefore rarely used for saving or transmitting strings to a file or network. This encoding is typically used inside the program itself Also note that UTF-32 can be used to convert from little-endian to big-endian and vice versa.</p>
<p>&#9632; UTF-7 encoding is typically used with older systems that work with characters that can be expressed using 7-bit values. You should avoid this encoding because it usually ends up expanding the data rather than compressing it The Unicode Consortium has deprecated this encoding.</p>
<p>&#9632; ASCII encodes the 16-bit characters into ASCII characters; that is, any 16-bit character with a value of less than 0x0080 is converted to a single byte. Any character with a value greater than 0x007F can't be converted, so that character's value is lost For strings consisting of characters in the ASCII range (0x00 to 0x7F), this encoding compresses the data in half and is very fast (because the high byte is just cut off). This encoding isn't appropriate if you have characters outside of the ASCII range because the character's values will be lost.</p>
<p>Finally, the FCL also allows you to encode 16-bit characters to an arbitrary code page. As with the ASCII encoding, encoding to a code page is dangerous because any character whose value can't be expressed in the specified code page is lost. You should always use UTF-16 or UTF-8 encoding unless you must work with some legacy files or applications that already use one of the other encodings.</p>
<p>When you need to encode or decode a set of characters, you should obtain an instance of a class derived from <b>System.Text.Encoding. Encoding </b>is an abstract base class that offers several static <b>readonly </b>properties, each of which returns an instance of an <b>Encoding</b>-derived class.</p>
<p>Here's an example that encodes and decodes characters by using UTF-8:</p>
<p><code>using System; using System.Text;<br/>
public static class Program { public static void Main() {<br/>
// This is the string we&quot;re going to encode. String s = &quot;Hi there.&quot;;<br/>
// Obtain an Encoding-derived object that knows how // to encode/decode using UTF8 Encoding encodingUTF8 = Encoding.UTF8;<br/>
// Encode a string into an array of bytes. Byte[] encodedBytes = encodingUTF8.CetBytes(s);<br/>
// Show the encoded byte values. Console.WriteLine(&quot;Encoded bytes: &quot; + BitConverter.ToString(encodedBytes));<br/>
// Decode the byte array back to a string.<br/>
String decodedString = encodingUTF8.CetString(encodedBytes);<br/>
// Show the decoded string.<br/>
Console.WriteLine(&quot;Decoded string: &quot; + decodedString);<br/>
}<br/>
}</code></p>
<p>This code yields the following output:</p>
<p><code>Encoded bytes: 48-69-20-74-68-65-72-65-2E Decoded string: Hi there.</code></p>
<p>In addition to the <b>UTF8 </b>static property, the <b>Encoding </b>class also offers the following static properties: <b>Unicode, BigEndianUnicode, UTF32, UTF7, ASCII, </b>and <b>Default. </b>The <b>Default</b></p>
<p>property returns an object that is able to encode/decode using the user's code page as specified by the Language for Non-Unicode Programs option of the Regional And Language dialog box in Control Panel (See the <b>GetACP </b>Win32 function for more information. However, using the <b>Default </b>property is discouraged because your application's behavior would be machine-setting dependent, so if you change the system's default code page or if your application runs on another machine, your application will behave differently.</p>
<p>In addition to these properties, <b>Encoding </b>also offers a static <b>GetEncoding </b>method that allows you to specify a code page (by integer or by string) and returns an object that can encode/ decode using the specified code page. You can call <b>GetEncoding, </b>passing <b>&quot;Shift-JIS&quot; </b>or <b>932, </b>for example.</p>
<p>When you first request an encoding object, the <b>Encoding </b>class's property or <b>GetEncoding </b>method constructs a single object for the requested encoding and returns this object If an already-requested encoding object is requested in the future, the encoding class simply returns the object it previously constructed; it doesn't construct a new object for each request. This efficiency reduces the number of objects in the system and reduces pressure in the garbage-collected heap.</p>
<p>Instead of calling one of <b>Encoding</b>'s static properties or its <b>GetEncoding </b>method, you could also construct an instance of one of the following classes: <b>System.Text.UnicodeEncoding, System.Text.UTF8Encoding, System.Text.UTF32Encoding, System.Text.UTF7Encoding, </b>or <b>System.Text.ASCIIEncoding. </b>However, keep in mind that constructing any of these classes creates new objects in the managed heap, which hurts performance.</p>
<p>Four of these classes, <b>UnicodeEncoding, UTF8Encoding, UTF32Encoding, </b>and <b>UTF7Encoding,</b></p>
<p>offer multiple constructors, providing you with more control over the encoding and preamble. (Preamble is sometimes referred to as a byte order mark or BOM.) The first three aforementioned classes also offer constructors that let you tell the class to throw exceptions when decoding an invalid byte sequence; you should use these constructors when you want your application to be secure and resistant to invalid incoming data.</p>
<p>You might want to explicitly construct instances of these encoding types when working with a <b>BinaryWriter </b>or a <b>StreamWriter </b>The <b>ASCIIEncoding </b>class has only a single constructor and therefore doesn't offer any more control over the encoding. If you need an <b>ASCIIEncoding </b>object, always obtain it by querying <b>Encoding</b>'s <b>ASCII </b>property; this returns a reference to a single <b>ASCIIEncoding </b>object. If you construct <b>ASCIIEncoding </b>objects yourself, you are creating more objects on the heap, which hurts your application's performance.</p>
<p>Once you have an <b>Encoding</b>-derived object, you can convert a string or an array of characters to an array of bytes by calling the <b>GetBytes </b>method. (Several overloads of this method exist.) To convert an array of bytes to an array of characters, call the <b>GetChars </b>method or the more useful <b>GetString </b>method. (Several overloads exist for both of these methods.) The preceding code demonstrated calls to the <b>GetBytes </b>and <b>GetString </b>methods.</p>
<p>All <b>Encoding</b>-derived types offer a <b>GetByteCount </b>method that obtains the number of bytes necessary to encode a set of characters without actually encoding. Although <b>GetByteCount </b>isn't especially useful, you can use this method to allocate an array of bytes. There's also a <b>GetCharCount </b>method that returns the number of characters that would be decoded without actually decoding them. These methods are useful if you're trying to save memory and reuse an array.</p>
<p>The <b>GetByteCount/GetCharCount </b>methods aren't that fast because they must analyze the array of characters/bytes in order to return an accurate result. If you prefer speed to an exact result, you can call the <b>GetMaxByteCount </b>or <b>GetMaxCharCount </b>method instead Both methods take an integer specifying the number of characters or number of bytes and return a worst-case value.</p>
<p>Each <b>Encoding</b>-derived object offers a set of public read-only properties that you can query to obtain detailed information about the encoding See the NET Framework SDK documentation for a description of these properties.</p>
<p>To illustrate most of the properties and their meanings, I wrote the following program that displays the property values for several different encodings:</p>
<p><code>using System; using System.Text;<br/>
public static class Program { public static void Main() {<br/>
foreach (EncodingInfo ei in Encoding.CetEncodings()) { Encoding e = ei.CetEncoding(); Console.WriteLine(&quot;{1}{0}&quot; +<br/>
&quot;\tCodePage={2}, WindowsCodePage={3}{0}&quot; + &quot;\tWebName={4}, HeaderName={5}, BodyName={6}{0}&quot; + &quot;\tIsBrowserDisplay={7}, IsBrowserSave={8}{0}&quot; + &quot;\tIsMailNewsDisplay={9}, IsMailNewsSave={10}{0}&quot;,<br/>
Environment.NewLine,<br/>
e.EncodingName, e.CodePage, e.WindowsCodePage, e.WebName, e.HeaderName, e.BodyName, e.IsBrowserDisplay, e.IsBrowserSave, e.IsMailNewsDisplay, e.IsMailNewsSave);<br/>
}<br/>
}<br/>
}</code></p>
<p>Running this program yields the following output (abridged to conserve paper):</p>
<p><code>IBM EBCDIC (US-Canada)<br/>
CodePage=37, WindowsCodePage=1252 WebName=IBM037, HeaderName=IBM037, BodyName=IBM037 IsBrowserDisplay=False, IsBrowserSave=False IsMailNewsDisplay=False, IsMailNewsSave=False<br/>
OEM United States<br/>
CodePage=437, WindowsCodePage=12 52 WebName=IBM437, HeaderName=IBM437, BodyName=IBM437 IsBrowserDisplay=False, IsBrowserSave=False IsMailNewsDisplay=False, IsMailNewsSave=False<br/>
IBM EBCDIC (International)<br/>
CodePage=500, WindowsCodePage=12 52 WebName=IBM500, HeaderName=IBM500, BodyName=IBM500 IsBrowserDisplay=False, IsBrowserSave=False IsMailNewsDisplay=False, IsMailNewsSave=False<br/>
Arabic (ASMO 708)<br/>
CodePage=708, WindowsCodePage=12 56<br/>
WebName=ASMO-708, HeaderName=ASMO-708, BodyName=ASMO-708 IsBrowserDisplay=True, IsBrowserSave=True IsMailNewsDisplay=False, IsMailNewsSave=False<br/>
Unicode<br/>
CodePage=1200, WindowsCodePage=1200 WebName=utf-16, HeaderName=utf-16, BodyName=utf-16 IsBrowserDisplay=False, IsBrowserSave=True IsMailNewsDisplay=False, IsMailNewsSave=False<br/>
Unicode (Big-Endian)<br/>
CodePage=1201, WindowsCodePage=1200<br/>
WebName=unicodeFFFE, HeaderName=unicodeFFFE, BodyName=unicodeFFFE IsBrowserDisplay=False, IsBrowserSave=False IsMailNewsDisplay=False, IsMailNewsSave=False<br/>
Western European (DOS)<br/>
CodePage=850, WindowsCodePage=12 52 WebName=ibm850, HeaderName=ibm850, BodyName=ibm850 IsBrowserDisplay=False, IsBrowserSave=False IsMailNewsDisplay=False, IsMailNewsSave=False<br/>
Unicode (UTF-8)<br/>
CodePage=65001, WindowsCodePage=1200 WebName=utf-8, HeaderName=utf-8, BodyName=utf-8 IsBrowserDisplay=True, IsBrowserSave=True IsMailNewsDisplay=True, IsMailNewsSave=True</code></p>
<p>Table 14-3 covers the most commonly used methods offered by all <b>Encoding</b>-derived classes.</p>
<a name="b367"/><b>Table 14-3 </b>
<table border="1">
<tr>
<td>
<p>Method</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Returns an array of bytes indicating what should be written to a stream before writing any encoded bytes Frequently, these bytes are referred to as BOM bytes. When you start reading from a stream, the BOM bytes automatically help detect the encoding that was used when the stream was written so that the correct decoder can be used For some <b>Encoding-</b>derived classes, this method returns an array of 0 bytes葉hat is, no preamble bytes A <b>UTF8Encoding </b>object can be explicitly constructed so that this method returns a 3-byte array of OxEF, OxBB, OxBF. A <b>UnicodeEncoding </b>object can be explicitly constructed so that this method returns a 2-byte array of OxFE, OxFF for big-endian encoding or a 2-byte array of OxFF, OxFE for little-endian encoding. The default is little-endian.</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>Converts an array of bytes specified in a source encoding to an array of bytes specified by a destination encoding. Internally, this static method calls the source encoding object's <b>GetChars </b>method and passes the result to the destination encoding object's <b>GetBytes </b>method The resulting byte array is returned to the caller.</p>
</td>
</tr>
<tr>
<td>
<p>s</p>
</td>
<td>
<p>Returns <b>true </b>if two <b>Encoding</b>-derived objects represent the same code page and preamble setting.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Returns the encoding object's code page.</p>
</td>
</tr>
</table>
<p>s</p>
<p>Imagine that you're reading a UTF-16 encoded string via a <b>System.Net.Sockets. NetworkStream </b>object. The bytes will very likely stream in as chunks of data. In other words, you might first read 5 bytes from the stream, followed by 7 bytes. In UTF-16, each character consists of 2 bytes. So calling <b>Encoding</b>'s <b>GetString </b>method passing the first array of 5 bytes will return a string consisting of just two characters. If you later call <b>GetString, </b>passing in the next 7 bytes that come in from the stream, <b>GetString </b>will return a string consisting of three characters, and all of the code points will have the wrong values!</p>
<p>This data corruption problem occurs because none of the <b>Encoding</b>-derived classes maintains any state in between calls to their methods. If you'll be encoding or decoding characters/bytes in chunks, you must do some additional work to maintain state between calls, preventing any loss of data.</p>
<p>To decode chunks of bytes, you should obtain a reference to an <b>Encoding</b>-derived object (as described in the previous section) and call its <b>GetDecoder </b>method This method returns a reference to a newly constructed object whose type is derived from the <b>System.Text.Decoder </b>class. Like the <b>Encoding </b>class, the <b>Decoder </b>class is an abstract base class. If you look in the .NET Framework SDK documentation, you won't find any classes that represent concrete implementations of the <b>Decoder </b>class. However, the FCL does define a bunch of <b>Decoder</b>-derived classes. These classes are all internal to the FCL, but the <b>GetDecoder </b>method can construct instances of these classes and return them to your application code.</p>
<p>All <b>Decoder</b>-derived classes offer two important methods: <b>GetChars </b>and <b>GetCharCount </b>Obviously, these methods are used for decoding an array of bytes and work similarly to <b>Encoding</b>'s <b>GetChars </b>and <b>GetCharCount </b>methods, discussed earlier. When you call one of these methods, it decodes the byte array as much as possible. If the byte array doesn't contain enough bytes to complete a character, the leftover bytes are saved inside the decoder object. The next time you call one of these methods, the decoder object uses the leftover bytes plus the new byte array passed to it葉his ensures that the chunks of data are decoded properly. <b>Decoder </b>objects are very useful when reading bytes from a stream.</p>
<p>An <b>Encoding</b>-derived type can be used for stateless encoding and decoding. However, a <b>Decoder</b>-derived type can be used only for decoding. If you want to encode strings in chunks, call <b>GetEncoder </b>instead of calling the <b>Encoding </b>object's <b>GetDecoder </b>method. <b>GetEncoder </b>returns a newly constructed object whose type is derived from the abstract base class <b>System.Text.Encoder </b>Again, the NET Framework SDK documentation doesn't contain any classes representing concrete implementations of the <b>Encoder </b>class However, the FCL does define some <b>Encoder</b>-derived classes. As with the <b>Decoder</b>-derived classes, these classes are all internal to the FCL, but the <b>GetEncoder </b>method can construct instances of these classes and return them to your application code.</p>
<p>All <b>Encoder</b>-derived classes offer two important methods: <b>GetBytes </b>and <b>GetByteCount </b>On each call, the <b>Encoder</b>-derived object maintains any leftover state information so that you can encode data in chunks.</p>
<h3>Base-64 String Encoding and Decoding</h3>
<p>As of this writing, the UTF-16 and UTF-8 encodings are becoming quite popular. It is also quite popular to encode a sequence of bytes to a base-64 string The FCL does offer methods to do base-64 encoding and decoding, and you might expect that this would be accomplished via an <b>Encoding</b>-derived type However, for some reason, base-64 encoding and decoding is done using some static methods offered by the <b>System.Convert </b>type.</p>
<p>To encode a base-64 string as an array of bytes, you call <b>Convert</b>'s static <b>FromBase64String </b>or <b>FromBase64CharArray </b>method. Likewise, to decode an array of bytes as a base-64 string, you call <b>Convert</b>'s static <b>ToBase64String </b>or <b>ToBase64CharArray </b>method. The following code demonstrates how to use some of these methods:</p>
<p><code>using System;<br/>
public static class Program { public static void Main() {<br/>
// Get a set of 10 randomly generated bytes Byte[] bytes = new Byte[10];<br/>
new Random().NextBytes(bytes); // Display the bytes<br/>
Console.WriteLine(BitConverter.ToString(bytes));<br/>
// Decode the bytes into a base-64 string and show the string String s = Convert.ToBase64String(bytes); Console.WriteLine(s);<br/>
// Encode the base-64 string back to bytes and show the bytes bytes = Convert.FromBase64String(s); Console.WriteLine(BitConverter.ToString(bytes));<br/>
}<br/>
}</code></p>
<p>Compiling this code and running the executable file produces the following output (your output might vary from mine because of the randomly generated bytes):</p>
<p><code>3B-B9-27-40-59-35-86-54-5F-F1<br/>
O7knQFklh1Rf8Q==<br/>
3B-B9-27-40-59-35-86-54-5F-F1</code></p>
<a name="b369"/><h2>Secure Strings</h2>
<p>Often, <b>String </b>objects are used to contain sensitive data such as a user's password or credit-card information. Unfortunately, <b>String </b>objects contain an array of characters in memory, and if some unsafe or unmanaged code is allowed to execute, the unsafe/unmanaged code could snoop around the process's address space, locate the string containing the sensitive information, and use this data in an unauthorized way. Even if the <b>String </b>object is used for just a short time and then garbage collected, the CLR might not immediately reuse the <b>String </b>object's memory (especially if the <b>String </b>object was in an older generation), leaving the <b>String</b>'s characters in the process's memory, where the information could be compromised In addition, since strings are immutable, as you manipulate them, the old copies linger in memory and you end up with different versions of the string scattered all over memory.</p>
<p>Some governmental departments have stringent security requirements that require very specific security guarantees. To meet these requirements, Microsoft added a more secure string class to the FCL: <b>System.Security.SecureString. </b>When you construct a <b>SecureString </b>object, it internally allocates a block of unmanaged memory that contains an array of characters. Unmanaged memory is used so that the garbage collector isn't aware of it.</p>
<p>These string's characters are encrypted, protecting the sensitive information from any malicious unsafe/unmanaged code. You can append, insert, remove, or set a character in the secure string by using any of these methods: <b>AppendChar, InsertAt, RemoveAt, </b>and <b>SetAt </b>. Whenever you call any of these methods, internally, the method decrypts the characters, performs the operation in place, and then re-encrypts the characters. This means that the characters are in an unencrypted state for a very short period of time. This also means that the performance of each operation is less than stellar, so you should perform as few of these operations as possible.</p>
<p>The <b>SecureString </b>class implements the <b>IDisposable </b>interface to provide an easy way to deterministically destroy the string's secured contents. When your application no longer needs the sensitive string information, you simply call <b>SecureString</b>'s <b>Dispose </b>method. Internally, <b>Dispose </b>zeroes out the contents of the memory buffer to make sure that the sensitive information is not accessible to malicious code, and then the buffer is freed Internally, a <b>SecureString </b>object has a field to a <b>SafeBuffer</b>-derived object, which maintains the actual string. Since the <b>SafeBuffer </b>class is ultimately derived from <b>CriticalFinalizerObject, </b>discussed in Chapter 21, &quot;Automatic Memory Management (Garbage Collection),&quot; the string's characters are guaranteed to be zeroed out and have its buffer freed when it is garbage collected. Unlike a <b>String </b>object, when a <b>SecureString </b>object is collected, the encrypted string's characters will no longer be in memory.</p>
<p>Now that you know how to create and modify a <b>SecureString </b>object, let's talk about how to use one. Unfortunately, the most recent FCL has limited support for the <b>SecureString </b>class. In other words, there are only a few methods that accept a <b>SecureString </b>argument. In version 4 of the .NET Framework, you can pass a <b>SecureString </b>as a password when</p>
<p>&#9632; Working with a cryptographic service provider (CSP). See the <b>System.Security.Cryptography.CspParameters </b>class.</p>
<p>&#9632; Creating, importing, or exporting an X. 5O9 certificate. See the <b>System.Security.Cryptography.X509Certificates.X509Certificate </b>and <b>System.Security.Cryptography.X509Certificates.X509Certificate2 </b>classes.</p>
<p>&#9632; Starting a new process under a specific user account. See the <b>System.Diagnostics.Process </b>and <b>System.Diagnostics.ProcessStartInfo</b></p>
<p>classes.</p>
<p>&#9632; Constructing an event log session See the <b>System.Diagnostics.Eventing.Reader.EventLogSession </b>class.</p>
<p>&#9632; Using the <b>System.Windows.Controls.PasswordBox </b>control. See this class's <b>SecurePassword </b>property.</p>
<p>Finally, you can create your own methods that can accept a <b>SecureString </b>object parameter. Inside your method, you must have the <b>SecureString </b>object create an unmanaged memory buffer that contains the decrypted characters before your method uses the buffer To keep the window of opportunity for malicious code to access the sensitive data as small as possible, your code should require access to the decrypted string for as short a period of time as possible. When finished using the string, your code should zero the buffer and free it as soon as possible. Also, never put the contents of a <b>SecureString </b>into a <b>String: </b>if you do, the <b>String </b>lives unencrypted in the heap and will not have its characters zeroed out until the memory is reused after a garbage collection. The <b>SecureString </b>class does not override the</p>
<p><b>ToString </b>method specifically to avoid exposing the sensitive data (which converting it to a <b>String </b>would do).</p>
<p>Here is some sample code demonstrating how to initialize and use a <b>SecureString </b>(when compiling this, you'll need to specify the <b>/unsafe </b>switch to the C# compiler):</p>
<p><code>using System;<br/>
using System.Security;<br/>
using System.Runtime.InteropServices;<br/>
public static class Program { public static void Main() {<br/>
using (SecureString ss = new SecureString()) { Console.Write(&quot;Please enter password: &quot;); while (true) {<br/>
ConsoleKeyInfo cki = Console.ReadKey(true); if (cki.Key == ConsoleKey.Enter) break;<br/>
// Append password characters into the SecureString<br/>
ss.AppendChar(cki.KeyChar);<br/>
Console.Write(&quot;*&quot;);<br/>
}<br/>
Console.WriteLineO;<br/>
// Password entered, display it for demonstration purposes DisplaySecureString(ss);<br/>
}<br/>
// After 'using', the SecureString is Disposed; no sensitive data in memory<br/>
}<br/>
// This method is unsafe because it accesses unmanaged memory private unsafe static void DisplaySecureString(SecureString ss) { Char* pc = null;<br/>
try {<br/>
// Decrypt the SecureString into an unmanaged memory buffer pc = (Char*) Marshal.SecureStringToCoTaskMemUnicode(ss);<br/>
// Access the unmanaged memory buffer that // contains the decrypted SecureString for (Int32 index = 0; pc[index] != 0; index++) Console.Write(pc[index]);<br/>
}<br/>
finally {<br/>
// Make sure we zero and free the unmanaged memory buffer that contains // the decrypted SecureString characters if (pc != null)<br/>
Marshal.ZeroFreeCoTaskMemUnicode((IntPtr) pc);<br/>
}<br/>
}<br/>
}</code></p>
<p>The <b>System.Runtime.InteropServices.Marshal </b>class offers five methods that you can call to decrypt a <b>SecureString</b>'s characters into an unmanaged memory buffer. All of these methods are static, all accept a <b>SecureString </b>argument, and all return an <b>IntPtr </b>. Each of these methods has a corresponding method that you must call in order to zero the internal buffer and free it. Table 14-4 shows the <b>System.Runtime.InteropServices.Marshal </b>class's methods to decrypt a <b>SecureString </b>into a memory buffer and the corresponding method to zero and free the buffer.</p>
<p><b>Table 14-4 </b><b>Methods of the Marshal Class for Working with Secure Strings</b></p>
<table border="1">
<tr>
<td>
<p><b>Method to Decrypt SecureString to Buffer</b></p>
</td>
<td>
<p><b>Method to Zero and Free Buffer</b></p>
</td>
</tr>
<tr>
<td>
<p>SecureStringToBSTR</p>
</td>
<td>
<p>ZeroFreeBSTR</p>
</td>
</tr>
<tr>
<td>
<p>SecureStringToCoTaskMemAnsi</p>
</td>
<td>
<p>ZeroFreeCoTaskMemAnsi</p>
</td>
</tr>
<tr>
<td>
<p>SecureStringToCoTaskMemUnicode</p>
</td>
<td>
<p>ZeroFreeCoTaskMemUnicode</p>
</td>
</tr>
<tr>
<td>
<p>SecureStringToGlobalAllocAnsi</p>
</td>
<td>
<p>ZeroFreeGlobalAllocAnsi</p>
</td>
</tr>
<tr>
<td>
<p>SecureStringToGlobalAllocUnicode</p>
</td>
<td>
<p>ZeroFreeGlobalAllocUnicode</p>
</td>
</tr>
</table>
<mbp:pagebreak/>
<a name="Chapter15"/>
<h1>Chapter 15: Enumerated Types and Bit Flags</h1>
<p><b>In this chapter:</b></p>
<a href="#b373">Enumerated Types</a><br/>
<a href="#b379">Bit Flags</a><br/>
<a href="#b383">Adding Methods to Enumerated Types</a><br/>
<p>In this chapter, I'll discuss enumerated types and bit flags. Since Microsoft Windows and many programming languages have used these constructs for so many years, I'm sure that many of you are already familiar with how to use enumerated types and bit flags. However, the common language runtime (CLR) and the Framework Class Library (FCL) work together to make enumerated types and bit flags real object-oriented types that offer cool new features that I suspect most developers aren't familiar with. It's amazing to me how these new features, which are the focus of this chapter, make developing application code so much easier.</p>
<a name="b373"/><h2>Enumerated Types</h2>
<p>An enumerated type is a type that defines a set of symbolic name and value pairs. For example, the <b>Color </b>type shown here defines a set of symbols, with each symbol identifying a single color:</p>
<p><code>internal enum Color {<br/>
White,// Assigned a value of 0<br/>
Red,// Assigned a value of 1<br/>
Creen,// Assigned a value of 2<br/>
Blue,// Assigned a value of 3<br/>
Orange// Assigned a value of 4<br/>
}</code></p>
<p>Of course, programmers can always write a program using 0 to represent white, 1 to represent red, and so on However, programmers shouldn't hard-code numbers into their code and should use an enumerated type instead, for at least two reasons:</p>
<p>&#9632;   Enumerated types make the program much easier to write, read, and maintain With enumerated types, the symbolic name is used throughout the code, and the programmer doesn't have to mentally map the meaning of each hard-coded value (for example, white is 0 or vice versa) Also, should a symbol's numeric value change, the code can simply be recompiled without requiring any changes to the source code. In addition, documentation tools and other utilities, such as a debugger, can show meaningful symbolic names to the programmer.</p>
<p>&#9632;   Enumerated types are strongly typed. For example, the compiler will report an error if I attempt to pass <b>Color.Orange </b>as a value to a method requiring a <b>Fruit </b>enumerated type as a parameter.</p>
<p>In the Microsoft .NET Framework, enumerated types are more than just symbols that the compiler cares about. Enumerated types are treated as first-class citizens in the type system, which allows for very powerful operations that simply can't be done with enumerated types in other environments (such as in unmanaged C++, for example).</p>
<p>Every enumerated type is derived directly from <b>System.Enum, </b>which is derived from <b>System.ValueType, </b>which in turn is derived from <b>System.Object </b>. So enumerated types are value types (described in Chapter 5, &quot;Primitive, Reference, and Value Types&quot;) and can be represented in unboxed and boxed forms. However, unlike other value types, an enumerated type can't define any methods, properties, or events. However, you can use C#'s extension methods feature to simulate adding methods to an enumerated type See the &quot;Adding Methods to Enumerated Types&quot; section at the end of this chapter for an example of this.</p>
<p>When an enumerated type is compiled, the C# compiler turns each symbol into a constant field of the type. For example, the compiler treats the <b>Color </b>enumeration shown earlier as if you had written code similar to the following:</p>
<p><code>internal struct Color : System.Enum {<br/>
// Below are public constants defining Color's symbols and values public const Color White = (Color) 0; public const Color Red = (Color) 1; public const Color Green = (Color) 2; public const Color Blue = (Color) 3; public const Color Orange = (Color) 4;<br/>
// Below is a public instance field containing a Color variable's value // You cannot write code that references this instance field directly public Int32 value_;<br/>
}</code></p>
<p>The C# compiler won't actually compile this code because it forbids you from defining a type derived from the special <b>System.Enum </b>type. However, this pseudo-type definition shows you what's happening internally. Basically, an enumerated type is just a structure with a bunch of constant fields defined in it and one instance field. The constant fields are emitted to the assembly's metadata and can be accessed via reflection. This means that you can get all of the symbols and their values associated with an enumerated type at runtime It also means that you can convert a string symbol into its equivalent numeric value These operations are made available to you by the <b>System.Enum </b>base type, which offers several static and instance methods that can be performed on an instance of an enumerated type, saving you the trouble of having to use reflection. I'll discuss some of these operations next.</p>
<hr/>
<blockquote><b>Important </b>Symbols defined by an enumerated type are constant values. So when a compiler sees code that references an enumerated type's symbol, the compiler substitutes the symbol's numeric value at compile time, and this code no longer references the enumerated type that defined the symbol. This means that the assembly that defines the enumerated type may not be required at runtime; it was required only when compiling. If you have code that references the enumerated type羊ather than just having references to symbols defined by the type葉he assembly containing the enumerated type's definition will be required at runtime. Some version-ing issues arise because enumerated type symbols are constants instead of read-only values I explained these issues in the &quot;Constants&quot; section of Chapter 7, &quot;Constants and Fields.&quot;</blockquote>
<hr/>
<p>For example, the <b>System.Enum </b>type has a static method called <b>GetUnderlyingType, </b>and the <b>System.Type </b>type has an instance method called <b>GetEnumUnderlyingType:</b></p>
<p><code>public static Type GetUnderlyingType(Type enumType);// Defined in System.Enum<br/>
public.Type GetEnumUnderlyingType();// Defined in System.Type</code></p>
<p>These methods return the core type used to hold an enumerated type's value Every enumerated type has an underlying type, which can be a <b>byte, sbyte, short, ushort, int </b>(the most common type and what C# chooses by default), <b>uint, long, </b>or <b>ulong. </b>Of course, these C# primitive types correspond to FCL types. However, to make the implementation of the compiler itself simpler, the C# compiler requires you to specify a primitive type name here; using an FCL type name (such as <b>Int32) </b>generates the following message: <b>&quot;error CS1008: Type byte, sbyte, short, ushort, int, uint, long, or ulong expected.&quot; </b>The following code shows how to declare an enumerated type with an underlying type of <b>byte (System.Byte):</b></p>
<p><code>internal enum Color : byte { White, Red, Green, Blue, Orange<br/>
}</code></p>
<p>With the <b>Color </b>enumerated type defined in this way, the following code shows what <b>GetUnderlyingType </b>will return:</p>
<p><code>// The following line displays &quot;System.Byte&quot;. Console.Writel_ine(Enum.GetllnderlyingType(typeof(Color)));</code></p>
<p>The C# compiler treats enumerated types as primitive types. As such, you can use many of the familiar operators (<b>==</b>, <b>!=</b>, <b>&lt;</b>, <b>&gt;</b>, <b>&lt;=</b>, <b>&gt;=</b>, <b>+</b>, <b>-</b>, <b>a</b><b>, &amp;</b>, <b>|</b>, <b>~</b>, <b>++</b>, and <b>--</b>) to manipulate enumerated type instances. All of these operators actually work on the <b>value</b>_instance field inside each enumerated type instance. Furthermore, the C# compiler allows you to explicitly cast instances of an enumerated type to a different enumerated type. You can also explicitly cast an enumerated type instance to a numeric type.</p>
<p>Given an instance of an enumerated type, it's possible to map that value to one of several string representations by calling the <b>ToString </b>method inherited from <b>System.Enum:</b></p>
<p><code>Color c = Color.Blue;<br/>
Console.WriteLine(c);//.&quot;Blue&quot;.(General format)<br/>
Console.WriteLine(c.ToStringO);//.&quot;Blue&quot;.(General format)<br/>
Console.WriteLine(c.ToString(&quot;G&quot;));//.&quot;Blue&quot;.(General format)<br/>
Console.WriteLine(c.ToString(&quot;D&quot;));//.&quot;3&quot;.(Decimal format)<br/>
Console.WriteLine(c.ToString(&quot;X&quot;));//.&quot;03&quot;.(Hex format)</code></p>
<hr/>
<blockquote><b>Note </b>When using hex formatting, <b>ToString </b>always outputs uppercase letters. In addition, the number of digits outputted depends on the enum's underlying type: 2 digits for <b>byte/sbyte, </b>4 digits for <b>short/ushort, </b>8 digits for <b>int/uint, </b>and 16 digits for <b>long/ulong. </b>Leading zeros are outputted if necessary.</blockquote>
<hr/>
<p>In addition to the <b>ToString </b>method, the <b>System.Enum </b>type offers a static <b>Format </b>method that you can call to format an enumerated type's value:</p>
<p><code>public static String Format(Type enumType, Object value, String format);</code></p>
<p>Generally, I prefer to call the <b>ToString </b>method because it requires less code and it's easier to call But using <b>Format </b>has one advantage over <b>ToString: Format </b>lets you pass a numeric value for the value parameter; you don't have to have an instance of the enumerated type For example, the following code will display &quot;Blue&quot;:</p>
<p><code>// The following line displays &quot;Blue&quot;. Console.WriteLine(Enum.Format(typeof(Color), 3, &quot;G&quot;));</code></p>
<hr/>
<blockquote><b>Note </b>It's possible to declare an enumerated type that has multiple symbols, all with the same numeric value When converting a numeric value to a symbol by using general formatting, <b>Enum</b>'s methods return one of the symbols However, there's no guarantee of which symbol name is returned. Also, if no symbol is defined for the numeric value you're looking up, a string containing the numeric value is returned.</blockquote>
<hr/>
<p>It's also possible to call <b>System.Enum</b>'s static <b>GetValues </b>method or <b>System.Type</b>'s instance <b>GetEnumValues </b>method to obtain an array that contains one element for each symbolic name in an enumerated type; each element contains the symbolic name's numeric value:</p>
<p><code>public static Array GetValues(Type enumType);// Defined in System.Enum<br/>
public.Array GetEnumValues();// Defined in System.Type</code></p>
<p>Using this method along with the <b>ToString </b>method, you can display all of an enumerated type's symbolic and numeric values, like so:</p>
<p><code>Color[] colors = (Color[]) Enum.GetValues(typeof(Color)); Console.WriteLine<b>C</b>'Number of symbols defined: &quot; + colors.Length);<br/>
Console.WriteLine(&quot;Value\tSymbo1\n-----\t------&quot;);<br/>
foreach (Color c in colors) {<br/>
// Display each symbol in Decimal and General format.<br/>
Console.WriteLine(&quot;{0,5:D}\t{0:G}&quot;, c);<br/>
}</code></p>
<p>The previous code produces the following output:</p>
<p><code>Number of symbols defined: 5 Value Symbol<br/>
0.White<br/>
1.Red<br/>
2.Green<br/>
3.Blue<br/>
4.Orange</code></p>
<p>This discussion shows some of the cool operations that can be performed on enumerated types. I suspect that the <b>ToString </b>method with the general format will be used quite frequently to show symbolic names in a program's user interface elements (list boxes, combo boxes, and the like), as long as the strings don't need to be localized (since enumerated types offer no support for localization). In addition to the <b>GetValues </b>method, the <b>System.Enum </b>type and the <b>System.Type </b>type also offer the following methods that return an enumerated type's symbols:</p>
<p><code>// Returns a String representation for the numeric value<br/>
public static String GetName(Type enumType, Object value); // Defined in System.Enum public.String GetEnumName(Object value);// Defined in System.Type<br/>
// Returns an array of Strings: one per symbol defined in the enum<br/>
public static String[] GetNames(Type enumType);// Defined in System.Enum<br/>
public.String[] GetEnumNames();// Defined in System.Type</code></p>
<p>I've discussed a lot of methods that you can use to look up an enumerated type's symbol But you also need a method that can look up a symbol's equivalent value, an operation that could be used to convert a symbol that a user enters into a text box, for example Converting a symbol to an instance of an enumerated type is easily accomplished by using one of <b>Enum</b>'s static <b>Parse </b>and <b>TryParse </b>methods:</p>
<p><code>public static Object Parse(Type enumType, String value);<br/>
public static Object Parse(Type enumType, String value, Boolean ignoreCase); public static Boolean TryParse&lt;TEnum&gt;(String value, out TEnum result) where TEnum: struct; public static Boolean TryParse&lt;TEnum&gt;(String value, Boolean ignoreCase, out TEnum result) where TEnum : struct;</code></p>
<p>Here's some code demonstrating how to use this method:</p>
<p><code>// Because Orange is defined as 4,  'c' is initialized to 4. Color c = (Color) Enum.Parse(typeof(Color), &quot;orange&quot;, true);<br/>
// Because Brown isn't defined, an ArgumentException is thrown. c = (Color) Enum.Parse(typeof(Color), &quot;Brown&quot;, false);<br/>
// Creates an instance of the Color enum with a value of 1 Enum.TryParse&lt;Color&gt;(&quot;1&quot;, false, out c);<br/>
// Creates an instance of the Color enum with a value of 23 Enum.TryParse&lt;Color&gt;(&quot;23&quot;, false, out c);</code></p>
<p>Finally, using <b>Enum</b>'s static <b>IsDefined </b>method and <b>Type</b>'s <b>IsEnumDefined </b>method,</p>
<p><code>public static Boolean IsDefined(Type enumType, Object value); // Defined in System.Enum public.Boolean IsEnumDefined(Object value);// Defined in System.Type you can determine whether a numeric value is legal for an enumerated type:<br/>
// Displays &quot;True&quot; because Color defines Red as 1 Console.WriteLine(Enum.IsDefined(typeof(Color), 1));<br/>
// Displays &quot;True&quot; because Color defines White as 0 Console.WriteLine(Enum.IsDefined(typeof(Color), &quot;White&quot;));<br/>
// Displays &quot;False&quot; because a case-sensitive check is performed Console.WriteLine(Enum.IsDefined(typeof(Color), &quot;white&quot;));<br/>
// Displays &quot;False&quot; because Color doesn't have a symbol of value 10 Console.WriteLine(Enum.IsDefined(typeof(Color), 10));</code></p>
<p>The <b>IsDefined </b>method is frequently used for parameter validation. Here's an example:</p>
<p><code>public void SetColor(Color c) {<br/>
if (!Enum.IsDefined(typeof(Color), c)) {<br/>
throw(new ArgumentOutOfRangeException(&quot;c&quot;, c, &quot;Invalid Color value.&quot;));<br/>
}<br/>
// Set color to White, Red, Creen, Blue, or Orange<br/>
}</code></p>
<p>The parameter validation is useful because someone could call <b>SetColor </b>like this: SetColor((Color) 547);</p>
<p>Because no symbol has a corresponding value of 547, the <b>SetColor </b>method will throw an <b>ArgumentOutOfRangeException </b>exception, indicating which parameter is invalid and why.</p>
<hr/>
<blockquote><b>Important </b>The <b>IsDefined </b>method is very convenient, but you must use it with caution. First, <b>IsDefined </b>always does a case-sensitive search, and there is no way to get it to perform a case-insensitive search. Second, <b>IsDefined </b>is pretty slow because it uses reflection internally; if you wrote code to manually check each possible value, your application's performance would most certainly be better. Third, you should really use <b>IsDefined </b>only if the enum type itself is defined in the same assembly that is calling <b>IsDefined. </b>Here's why: Let's say the <b>Color </b>enum is defined in one assembly and the <b>SetColor </b>method is defined in another assembly. The <b>SetColor </b>method calls <b>IsDefined, </b>and if the color is <b>White, Red, Green, Blue, </b>or <b>Orange, SetColor </b>performs its work. However, if the <b>Color </b>enum changes in the future to include <b>Purple, SetColor </b>will now allow <b>Purple, </b>which it never expected before, and the method might execute with unpredictable results.</blockquote>
<hr/>
<p>Finally, the <b>System.Enum </b>type offers a set of static <b>ToObject </b>methods that convert an instance of a <b>Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, </b>or <b>UInt64 </b>to an instance of an enumerated type.</p>
<p>Enumerated types are always used in conjunction with some other type Typically, they're used for the type's method parameters or return type, properties, and fields. A common question that arises is whether to define the enumerated type nested within the type that requires it or to define the enumerated type at the same level as the type that requires it. If you examine the FCL, you'll see that an enumerated type is usually defined at the same level as the class that requires it. The reason is simply to make the developer's life a little easier by reducing the amount of typing required. So you should define your enumerated type at the same level unless you're concerned about name conflicts.</p>
<a name="b379"/><h2>Bit Flags</h2>
<p>Programmers frequently work with sets of bit flags. When you call the <b>System.IO.File </b>type's <b>GetAttributes </b>method, it returns an instance of a <b>FileAttributes </b>type. A <b>FileAttributes </b>type is an instance of an <b>Int32</b>-based enumerated type, in which each bit reflects a single attribute of the file. The <b>FileAttributes </b>type is defined in the FCL as follows:</p>
<p><code>[Flags, Serializable] public enum FileAttributes {<br/>
ReadOnly.=.0x0001,<br/>
Hidden.=.0x0002,<br/>
System.=.0x0004,<br/>
Directory.=.0x0010,<br/>
Archive.=.0x0020,<br/>
Device.=.0x0040,<br/>
Normal.=.0x0080,<br/>
Temporary.=.0x0100,<br/>
SparseFile.=.0x0200,<br/>
ReparsePoint.=.0x0400,<br/>
Compressed.=.0x0800,<br/>
Offline.=.0x1000,<br/>
NotContentIndexed.=.0x2000,<br/>
Encrypted.=.0x4000<br/>
}</code></p>
<p>To determine whether a file is hidden, you would execute code like this:</p>
<p><code>String file = Assembly.CetEntryAssembly().Location; FileAttributes attributes = File.CetAttributes(file);<br/>
Console.WriteLine(&quot;Is {0} hidden? {1}&quot;, file, (attributes &amp; FileAttributes.Hidden) != 0);</code></p>
<hr/>
<blockquote><b>Note </b>The <b>Enum </b>class defines a <b>HasFlag </b>method defined as follows: public Boolean HasFlag(Enum flag);</blockquote>
<hr/>
<p>Using this method, you could rewrite the call to <b>Console.WriteLine </b>like this:</p>
<p><code>Console.WriteLine(&quot;Is {0} hidden? {1}&quot;, file, attributes.HasFlag(FileAttributes.Hidden));</code></p>
<p>However, I recommend that you avoid the <b>HasFlag </b>method for this reason: Since it takes a parameter of type <b>Enum, </b>any value you pass to it must be boxed, requiring a memory allocation.</p>
<p>And here's code demonstrating how to change a file's attributes to read-only and hidden: File.SetAttributes(file, FileAttributes.ReadOnly | FileAttributes.Hidden);</p>
<p>As the <b>FileAttributes </b>type shows, it's common to use enumerated types to express the set of bit flags that can be combined. However, although enumerated types and bit flags are similar, they don't have exactly the same semantics. For example, enumerated types represent single numeric values, and bit flags represent a set of bits, some of which are on, and some of which are off</p>
<p>When defining an enumerated type that is to be used to identify bit flags, you should, of course, explicitly assign a numeric value to each symbol. Usually, each symbol will have an individual bit turned on. It is also common to see a symbol called <b>None </b>defined with a value of <b>0, </b>and you can also define symbols that represent commonly used combinations (see the <b>ReadWrite </b>symbol below). It's also highly recommended that you apply the <b>System.FlagsAttribute </b>custom attribute type to the enumerated type, as shown here:</p>
<p><code>[Flags]      // The C# compiler allows either &quot;Flags&quot; or &quot;FlagsAttribute&quot;. internal enum Actions {<br/>
None.= 0<br/>
Read.= 0x0001,<br/>
Write        = 0x0002,<br/>
ReadWrite = Actions.Read | Actions.Write, Delete      = 0x0004, Query        = 0x0008, Sync.= 0x0010<br/>
}</code></p>
<p>Because <b>Actions </b>is an enumerated type, you can use all of the methods described in the previous section when working with bit-flag enumerated types. However, it would be nice if some of those functions behaved a little differently. For example, let's say you had the following code:</p>
<p><code>Actions actions = Actions.Read | Actions.Delete; // 0x0005 Console.WriteLine(actions.ToString());// &quot;Read, Delete&quot;</code></p>
<p>When <b>ToString </b>is called, it attempts to translate the numeric value into its symbolic equivalent. The numeric value is 0x0005, which has no symbolic equivalent. However, the <b>ToString </b>method detects the existence of the <b>[Flags] </b>attribute on the <b>Actions </b>type, and <b>ToString </b>now treats the numeric value not as a single value but as a set of bit flags. Because the 0x0001 and 0x0004 bits are set, <b>ToString </b>generates the following string: &quot;Read, Delete&quot;. If you remove the <b>[Flags] </b>attribute from the <b>Actions </b>type, <b>ToString </b>would return &quot;5.&quot;</p>
<p>I discussed the <b>ToString </b>method in the previous section, and I showed that it offered three ways to format the output: &quot;G&quot; (general), &quot;D&quot; (decimal), and &quot;X&quot; (hex). When you're formatting an instance of an enumerated type by using the general format, the type is first checked to see if the <b>[Flags] </b>attribute is applied to it. If this attribute is not applied, a symbol matching the numeric value is looked up and returned. If the <b>[Flags] </b>attribute is applied, <b>ToString </b>works like this:</p>
<p><b>1. </b>The set of numeric values defined by the enumerated type is obtained, and the numbers are sorted in descending order.</p>
<p><b>2. </b>Each numeric value is bitwise-ANDed with the value in the enum instance, and if the result equals the numeric value, the string associated with the numeric value is appended to the output string, and the bits are considered accounted for and are turned off This step is repeated until all numeric values have been checked or until the enum instance has all of its bits turned off</p>
<p><b>3. </b>If, after all the numeric values have been checked, the enum instance is still not 0, the enum instance has some bits turned on that do not correspond to any defined symbols. In this case, <b>ToString </b>returns the original number in the enum instance as a string.</p>
<p><b>4. </b>If the enum instance's original value wasn't 0, the string with the comma-separated set of symbols is returned.</p>
<p><b>5. </b>If the enum instance's original value was 0 and if the enumerated type has a symbol defined with a corresponding value of 0, the symbol is returned.</p>
<p><b>6. </b>If we reach this step, &quot;0&quot; is returned.</p>
<p>If you prefer, you could define the <b>Actions </b>type without the <b>[Flags] </b>attribute and still get the correct string by using the &quot;F&quot; format:</p>
<p><code>// [Flags]      // Commented out now internal enum Actions {<br/>
None.= 0<br/>
Read.= 0x0001,<br/>
Write        = 0x0002,<br/>
ReadWrite = Actions.Read | Actions.Write, Delete      = 0x0004, Query        = 0x0008, Sync.= 0x0010<br/>
}<br/>
Actions actions = Actions.Read | Actions.Delete; // 0x0005 Console.Writel_ine(actions.ToString(&quot;F&quot;));// &quot;Read, Delete&quot;</code></p>
<p>If the numeric value has a bit that cannot be mapped to a symbol, the returned string will contain just a decimal number indicating the original numeric value; no symbols will appear in the string.</p>
<p>Note that the symbols you define in your enumerated type don't have to be pure powers of 2. For example, the <b>Actions </b>type could define a symbol called <b>All </b>with a value of 0x001F. If an instance of the <b>Actions </b>type has a value of 0x001F, formatting the instance will produce a string that contains &quot;All.&quot; The other symbol strings won't appear.</p>
<p>So far, I've discussed how to convert numeric values into a string of flags. It's also possible to convert a string of comma-delimited symbols into a numeric value by calling <b>Enum</b>'s static <b>Parse </b>and <b>TryParse </b>method. Here's some code demonstrating how to use this method:</p>
<p><code>// Because Query is defined as 8,  'a' is initialized to 8. Actions a = (Actions) Enum.Parse(typeof(Actions), &quot;Query&quot;, true); Console.Writel_ine(a.ToString());   // &quot;Query&quot;<br/>
// Because Query and Read are defined,  'a' is initialized to 9. Enum.TryParse&lt;Actions&gt;(&quot;Query, Read&quot;, false, out a); Console.Writeline(a.ToString());   // &quot;Read, Query&quot;<br/>
// Creates an instance of the Actions enum with a value of 28 a = (Actions) Enum.Parse(typeof(Actions), &quot;28&quot;, false); Console.Writeline(a.ToString());   // &quot;Delete, Query, Sync&quot;</code></p>
<p>When <b>Parse </b>and <b>TryParse </b>are called, the following actions are performed internally:</p>
<p><b>1. </b>It removes all whitespace characters from the start and end of the string.</p>
<p><b>2. </b>If the first character of the string is a digit, plus sign (+), or minus sign (-), the string is assumed to be a number, and an enum instance is returned whose numeric value is equal to the string converted to its numeric equivalent.</p>
<p><b>3. </b>The passed string is split into a set of tokens (separated by commas), and all white space is trimmed away from each token.</p>
<p><b>4. </b>Each token string is looked up in the enum type's defined symbols. If the symbol is not found, <b>Parse </b>throws a <b>System.ArgumentException </b>and <b>TryParse </b>returns <b>false </b>. If the symbol is found, bitwise-OR its numeric value into a running result, and then look up the next token.</p>
<p><b>5. </b>If all tokens have been sought and found, return the running result.</p>
<p>You should never use the <b>IsDefined </b>method with bit flag-enumerated types. It won't work for two reasons:</p>
<p>&#9632; If you pass a string to <b>IsDefined, </b>it doesn't split the string into separate tokens to look up; it will attempt to look up the string as through it were one big symbol with commas in it. Since you can't define an enum with a symbol that has commas in it, the symbol will never be found.</p>
<p>&#9632; If you pass a numeric value to <b>IsDefined, </b>it checks if the enumerated type defines a single symbol whose numeric value matches the passed-in number. Since this is unlikely for bit flags, <b>IsDefined </b>will usually return <b>false.</b></p>
<a name="b383"/><h2>Adding Methods to Enumerated Types</h2>
<p>Earlier in this chapter, I mentioned that you cannot define a method as part of an enumerated type. And, for many years, this has saddened me because there are many occasions when I would love to have been able to supply some methods to my enumerated type. Fortunately, I can now use C#'s relatively new extension method feature (discussed in Chapter 8, &quot;Methods&quot;) to simulate adding methods to an enumerated type.</p>
<p>If I want to add some methods to the <b>FileAttributes </b>enumerated type, I can define a static class with extension methods as follows:</p>
<p><code>internal static class FileAttributesExtensionMethods {<br/>
public static Boolean IsSet(this FileAttributes flags, FileAttributes flagToTest) { if (flagToTest == 0)<br/>
throw new ArgumentOutOfRangeException(&quot;flagToTest&quot;, &quot;Value must not be 0&quot;); return (flags &amp; flagToTest) == flagToTest;<br/>
}<br/>
public static Boolean IsClear(this FileAttributes flags, FileAttributes flagToTest) { if (flagToTest == 0)<br/>
throw new ArgumentOutOfRangeException(&quot;flagToTest&quot;, &quot;Value must not be 0&quot;); return !IsSet(flags, flagToTest);<br/>
}<br/>
public static Boolean AnyFlagsSet(this FileAttributes flags, FileAttributes testFlags) { return ((flags &amp; testFlags) != 0);<br/>
}<br/>
public static FileAttributes Set(this FileAttributes flags, FileAttributes setFlags) { return flags | setFlags;<br/>
}<br/>
public static FileAttributes Clear(this FileAttributes flags, FileAttributes clearFlags) { return flags &amp; ~clearFlags;<br/>
}<br/>
public static void ForEach(this FileAttributes flags, Action&lt;FileAttributes&gt; processFlag) {<br/>
if (processFlag == null) throw new ArgumentNullException(&quot;processFlag&quot;); for (UInt32 bit = 1; bit != 0; bit &lt;&lt;= 1) {<br/>
UInt32 temp = ((UInt32)flags) &amp; bit;<br/>
if (temp != 0) processFlag((FileAttributes)temp);<br/>
}<br/>
}<br/>
}</code></p>
<p>And here is some code that demonstrates calling some of these methods. As you can see, the code looks as if I'm calling methods on the enumerated type:</p>
<p><code>FileAttributes fa = FileAttributes.System; fa = fa.Set(FileAttributes.ReadOnly); fa = fa.Clear(FileAttributes.System); fa.ForEach(f =&gt; Console.WriteLine(f));</code></p>
<mbp:pagebreak/>
<a name="Chapter16"/>
<h1>Chapter 16: Arrays</h1>
<p><b>In this chapter:</b></p>
<a href="#b388">Initializing Array Elements</a><br/>
<a href="#b390">Casting Arrays</a><br/>
<a href="#b392">All Arrays Are Implicitly Derived from System.Array</a><br/>
<a href="#b393">All Arrays Implicitly Implement IEnumerable, ICollection, and IList</a><br/>
<a href="#b394">Passing and Returning Arrays</a><br/>
<a href="#b395">Creating Non-Zero-Lower Bound Arrays</a><br/>
<a href="#b396">Array Access Performance</a><br/>
<a href="#b401">Unsafe Array Access and Fixed-Size Array</a><br/>
<p>Arrays are mechanisms that allow you to treat several items as a single collection. The Microsoft .NET common language runtime (CLR) supports single-dimensional arrays, multidimensional arrays, and jagged arrays (that is, arrays of arrays). All array types are implicitly derived from the <b>System.Array </b>abstract class, which itself is derived from <b>System.Object </b>. This means that arrays are always reference types that are allocated on the managed heap and that your application's variable or field contains a reference to the array and not the elements of the array itself. The following code makes this clearer:</p>
<p><code>Int32[] myIntegers;// Declares a reference to an array<br/>
myIntegers = new Int32[100]; // Creates an array of 100 Int32s</code></p>
<p>On the first line, <b>myIntegers </b>is a variable that's capable of pointing to a single-dimensional array of <b>Int32</b>s. Initially, <b>myIntegers </b>will be set to <b>null </b>because I haven't allocated an array. The second line of code allocates an array of 100 <b>Int32 </b>values; all of the <b>Int32</b>s are initialized to 0. Since arrays are reference types, the memory block required to hold the 100 unboxed <b>Int32</b>s is allocated on the managed heap Actually, in addition to the array's elements, the memory block occupied by an array object also contains a type object pointer, a sync block index, and some additional overhead members as well The address of this array's memory block is returned and saved in the variable <b>myIntegers </b>.</p>
<p>You can also create arrays of reference types:</p>
<p><code>Control[] myControls;// Declares a reference to an array<br/>
myControls = new Control[50]; // Creates an array of 50 Control references</code></p>
<p>On the first line, <b>myControls </b>is a variable capable of pointing to a single-dimensional array of <b>Control </b>references. Initially, <b>myControls </b>will be set to <b>null </b>because I haven't allocated</p>
<p>386</p>
<p>an array. The second line allocates an array of 50 <b>Control </b>references; all of these references are initialized to <b>null. </b>Because <b>Control </b>is a reference type, creating the array creates only a bunch of references; the actual objects aren't created at this time. The address of this memory block is returned and saved in the variable <b>myControls </b>.</p>
<p>Figure 16-1 shows how arrays of value types and arrays of reference types look in the managed heap.</p>
<p><b>Figure 16-1 </b>Arrays of value and reference types in the managed heap</p>
<p>In the figure, the <b>Controls </b>array shows the result after the following lines have executed:</p>
<p><code>myControls[1]   = new Button(); myControls[2]   = new TextBox();<br/>
myControls[3]   = myControls[2];   // Two elements refer to the same object. myControls[46] = new DataGrid(); myControls[48] = new ComboBox(); myControls[49] = new Button();</code></p>
<p>Common Language Specification (CLS) compliance requires all arrays to be zero-based. This allows a method written in C# to create an array and pass the array's reference to code written in another language, such as Microsoft Visual Basic.NET. In addition, because zero-based arrays are, by far, the most common arrays, Microsoft has spent a lot of time optimizing their performance. However, the CLR does support non-zero-based arrays even though their use is discouraged. For those of you who don't care about a slight performance penalty or cross-language portability, I'll demonstrate how to create and use non-zero-based arrays later in this chapter.</p>
<p>Notice in Figure 16-1 that each array has some additional overhead information associated with it. This information contains the rank of the array (number of dimensions), the lower bounds for each dimension of the array (almost always 0), and the length of each dimension.</p>
<img src="43.jpg"/>
<p>The overhead also contains the array's element type. I'll mention the methods that allow you to query this overhead information later in this chapter.</p>
<p>So far, I've shown examples demonstrating how to create single-dimensional arrays. When possible, you should stick with single-dimensional, zero-based arrays, sometimes referred to as SZ arrays, or vectors. Vectors give the best performance because you can use specific Intermediate Language (IL) instructions耀uch as <b>newarr, ldelem, ldelema, ldlen, </b>and <b>stelem</b>葉o manipulate them. However, if you prefer to work with multi-dimensional arrays, you can Here are some examples of multi-dimensional arrays:</p>
<p><code>// Create a two-dimensional array of Doubles. Double[,] myDoubles = new Double[10, 20];<br/>
// Create a three-dimensional array of String references. String[,,] myStrings = new String[5, 3, 10];</code></p>
<p>The CLR also supports jagged arrays, which are arrays of arrays. Zero-based, single-dimensional jagged arrays have the same performance as normal vectors However, accessing the elements of a jagged array means that two or more array accesses must occur. Here are some examples of how to create an array of polygons with each polygon consisting of an array of <b>Point </b>instances:</p>
<p><code>// Create a single-dimensional array of Point arrays. Point[][] myPolygons = new Point[3][];<br/>
// myPolygons[0] refers to an array of 10 Point instances. myPolygons[0] = new Point[10];<br/>
// myPolygons[1] refers to an array of 20 Point instances. myPolygons[1] = new Point[20];<br/>
// myPolygons[2] refers to an array of 30 Point instances. myPolygons[2] = new Point[30];<br/>
// Display the Points in the first polygon. for (Int32 x = 0; x &lt; myPolygons[0].Length; x++) Console.WriteLine(myPolygons[0][x]);</code></p>
<hr/>
<blockquote><b>Note </b>The CLR verifies that an index into an array is valid. In other words, you can't create an array with 100 elements in it (numbered 0 through 99) and then try to access the element at index -5 or 100. Doing so will cause a <b>System.IndexOutOfRangeException </b>to be thrown. Allowing access to memory outside the range of an array would be a breach of type safety and a potential security hole, and the CLR doesn't allow verifiable code to do this. Usually, the performance degradation associated with index checking is insubstantial because the just-in-time (JIT) compiler normally checks array bounds once before a loop executes instead of at each loop iteration However, if you're still concerned about the performance hit of the CLR's index checks, you can use unsafe code in C# to access the array. The &quot;Array Access Performance&quot; section later in this chapter demonstrates how to do this.</blockquote>
<hr/>
<a name="b388"/><h2>Initializing Array Elements</h2>
<p>In the previous section, I showed how to create an array object and then I showed how to initialize the elements of the array C# offers syntax that allows you to do these two operations in one statement For example:</p>
<p><code>String[] names = new String[] { &quot;Aidan&quot;, &quot;Grant&quot; };</code></p>
<p>The comma-separated set of tokens contained within the braces is called an array initializer. Each token can be an arbitrarily complex expression or, in the case of a multi-dimensional array, a nested array initializer. In the example above, I used just two simple <b>String </b>expressions.</p>
<p>If you are declaring a local variable in a method to refer to the initialized array, then you can use C#'s implicitly typed local variable <b>(var) </b>feature to simplify the code a little:</p>
<p><code>// Using C#'s implicitly typed local variable feature: var names = new String[] { &quot;Aidan&quot;, &quot;Grant&quot; };</code></p>
<p>Here, the compiler is inferring that the <b>names </b>local variable should be of the <b>String[] </b>type since that is the type of the expression on the right of the assignment operator (<b>=</b>).</p>
<p>You can use C#'s implicitly typed array feature to have the compiler infer the type of the array's elements. Notice the line below has no type specified between <b>new </b>and <b>[]</b>:</p>
<p><code>// Using C#'s implicitly typed local variable and implicitly typed array features: var names = new[] { &quot;Aidan&quot;, &quot;Grant&quot;, null };</code></p>
<p>In the line above, the compiler examines the types of the expressions being used inside the array to initialize the array's elements, and the compiler chooses the closest base class that all the elements have in common to determine the type of the array. In this example, the compiler sees two <b>String</b>s and <b>null. </b>Since <b>null </b>is implicitly castable to any reference type (including <b>String), </b>the compiler infers that it should be creating and initializing an array of <b>String </b>references.</p>
<p>If you had this code,</p>
<p><code>// Using C#'s implicitly typed local variable &amp; implicitly typed array features: (error) var names = new[] { &quot;Aidan&quot;, &quot;Grant&quot;, 123 };</code></p>
<p>the compiler would issue the message <b>&quot;error CS0826: No best type found for implicitly-typed array.&quot; </b>This is because the base type in common between the two <b>String</b>s and the <b>Int32 </b>is <b>Object, </b>which would mean that the compiler would have to create an array of <b>Object </b>references and then box the <b>123 </b>and have the last array element refer to a boxed <b>Int32 </b>with a value of <b>123. </b>The C# compiler team thinks that boxing array elements is too heavy-handed for the compiler to do for you implicitly, and that is why the compiler issues the error.</p>
<p>As an added syntactical bonus when initializing an array, you can write the following:</p>
<p><code>String[] names = { &quot;Aidan&quot;, &quot;Grant&quot; };</code></p>
<p>Notice that on the right of the assignment operator (<b>=</b>), only the array initializer expression is given with no <b>new, </b>no type, and no []s. This syntax is nice, but unfortunately, the C# compiler does not allow you to use implicitly typed local variables with this syntax:</p>
<p><code>// This is a local variable now (error) var names = { &quot;Aidan&quot;, &quot;Grant&quot; };</code></p>
<p>If you try to compile the line of code above, the compiler issues two messages: <b>&quot;error CS0820: Cannot initialize an implicitly-typed local variable with an array initializer&quot; </b>and <b>&quot;error CS0622: Can only use array initializer expressions to assign to array types. Try using a new expression instead.&quot; </b>While the compiler could make this work, the C# team thought that the compiler would be doing too much for you here. It would be inferring the type of the array, <b>new</b>'ing the array, initializing the array, and inferring the type of the local variable, too.</p>
<p>The last thing I'd like to show you is how to use implicitly typed arrays with anonymous types and implicitly typed local variables. Anonymous types and how type identity applies to them are discussed in Chapter 10, &quot;Properties.&quot; Examine the code below:</p>
<p><code>// Using C#'s implicitly typed local, implicitly typed array, and anonymous type features: var kids = new[] {new { Name=&quot;Aidan&quot; }, new { Name=&quot;Grant&quot; }};<br/>
// Sample usage (with another implicitly typed local variable): foreach (var kid in kids)<br/>
Console.WriteLine(kid.Name);</code></p>
<p>In this example, I am using an array initializer that has two expressions for the array elements. Each expression represents an anonymous type (since no type name is specified after the <b>new </b>operator). Since the two anonymous types have the identical structure (one field called <b>Name </b>of type <b>String), </b>the compiler knows that these two objects are of the exact same type. Now, I use C#'s implicitly typed array feature (no type specified between the <b>new </b>and the []s) so that the compiler will infer the type of the array itself, construct this array object, and initialize its references to the two instances of the one anonymous type. <sup>1</sup> Finally, a reference to this array object is assigned to the <b>kids </b>local variable, the type of which is inferred by the compiler due to C#'s implicitly typed local variable feature.</p>
<p>I show the <b>foreach </b>loop as an example of how to use this array that was just created and initialized with the two anonymous type objects. I have to use an implicitly typed local variable <b>(kid) </b>for the loop, too When I run this code, I get the following output:</p>
<p><code>Aidan Grant</code></p>
<p>If you think these sentences are fun to read, you can only imagine how fun they were to write in the first place!</p>
<a name="b390"/><h2>Casting Arrays</h2>
<p>For arrays with reference type elements, the CLR allows you to implicitly cast the source array's element type to a target type. For the cast to succeed, both array types must have the same number of dimensions, and an implicit or explicit conversion from the source element type to the target element type must exist. The CLR doesn't allow the casting of arrays with value type elements to any other type. (However, by using the <b>Array.Copy </b>method, you can create a new array and populate its elements in order to obtain the desired effect.) The following code demonstrates how array casting works:</p>
<p><code>// Create a two-dimensional FileStream array. FileStream[,] fs2dim = new FileStream[5, 10];<br/>
// Implicit cast to a two-dimensional Object array Object[,] o2dim = fs2dim;<br/>
// Can't cast from two-dimensional array to one-dimensional array // Compiler error CS0030: Cannot convert type 'object[*,*]' to // 'System.IO.Stream[]' Stream[] sldim = (Stream[]) o2dim;<br/>
// Explicit cast to two-dimensional Stream array Stream[,] s2dim = (Stream[,]) o2dim;<br/>
// Explicit cast to two-dimensional String array<br/>
// Compiles but throws InvalidCastException at runtime<br/>
String[,] st2dim = (String[,]) o2dim;<br/>
// Create a one-dimensional Int32 array (value types). Int32[] ildim = new Int32[5];<br/>
// Can't cast from array of value types to anything else<br/>
// Compiler error CS0030: Cannot convert type 'int[]' to 'object[]'<br/>
Object[] oldim = (Object[]) ildim;<br/>
// Create a new array, then use Array.Copy to coerce each element in the<br/>
// source array to the desired type in the destination array.<br/>
// The following code creates an array of references to boxed Int32s.<br/>
Object[] obldim = new Object[ildim.Length];<br/>
Array.Copy(ildim, obldim, ildim.Length);</code></p>
<p>The <b>Array.Copy </b>method is not just a method that copies elements from one array to another. The <b>Copy </b>method handles overlapping regions of memory correctly, as does C's <b>memmove </b>function C's <b>memcpy </b>function, on the other hand, doesn't handle overlapping regions correctly. The <b>Copy </b>method can also convert each array element as it is copied if conversion is required The <b>Copy </b>method is capable of performing the following conversions:</p>
<p>&#9632;   Boxing value type elements to reference type elements, such as copying an <b>Int32[] </b>to an <b>Object[],</b></p>
<p>&#9632; Unboxing reference type elements to value type elements, such as copying an <b>Object[]</b>to an <b>Int32[],</b></p>
<p>&#9632; Widening CLR primitive value types, such as copying elements from an <b>Int32[] </b>to a <b>Double[],</b></p>
<p>&#9632; Downcasting elements when copying between array types that can't be proven to be compatible based on the array's type, such as when casting from an <b>Object[] </b>to an <b>IFormattable[]. </b>If every object in the <b>Object[] </b>implements <b>IFormattable[], Copy </b>will succeed.</p>
<p>Here's another example showing the usefulness of <b>Copy:</b></p>
<p><code>// Define a value type that implements an interface. internal struct MyValueType : IComparable { public Int32 CompareTo(Object obj) {<br/>
}<br/>
}<br/>
public static class Program { public static void Main() {<br/>
// Create an array of 100 value types. MyValueType[] src = new MyValueType[100];<br/>
// Create an array of IComparable references. IComparable[] dest = new IComparable[src.l_ength];<br/>
// Initialize an array of IComparable elements to refer to boxed // versions of elements in the source array. Array.Copy(src, dest, src.Length);<br/>
}<br/>
}</code></p>
<p>As you might imagine, the Framework Class Library (FCL) takes advantage of <b>Array</b>'s <b>Copy </b>method quite frequently.</p>
<p>In some situations, it is useful to cast an array from one type to another. This kind of functionality is called array covariance. When you take advantage of array covariance, you should be aware of an associated performance penalty. Let's say you have the following code:</p>
<p><code>String[] sa = new String[100];<br/>
Object[] oa = sa;   // oa refers to an array of String elements oa[5] = &quot;Jeff&quot;;      // Perf hit: CLR checks oa's element type for String; OK oa[3] = 5;// Perf hit: CLR checks oa's element type for Int32; throws<br/>
// ArrayTypeMismatchException</code></p>
<p>In the code above, the <b>oa </b>variable is typed as an <b>Object[]; </b>however, it really refers to a</p>
<p><b>String[]. </b>The compiler will allow you to write code that attempts to put a 5 into an array element because 5 is an <b>Int32, </b>which is derived from <b>Object. </b>Of course, the CLR must ensure type safety, and when assigning to an array element, the CLR must ensure that the assignment is legal. So the CLR must check at runtime whether the array contains <b>Int32 </b>elements In this case, it doesn't, and the assignment cannot be allowed; the CLR will throw an <b>ArrayTypeMismatchException </b>.</p>
<hr/>
<blockquote><b>Note </b>If you just need to make a copy of some array elements to another array, <b>System. Buffer</b>'s</blockquote>
<hr/>
<p><b>)        BlockCopy </b>method executes faster than <b>Array</b>'s <b>Copy </b>method. However, <b>Buffer</b>'s <b>BlockCopy </b>supports only primitive types; it does not offer the same casting abilities as <b>Array</b>'s <b>Copy </b>method. The <b>Int32 </b>parameters are expressed as byte offsets within the array, not as element indexes <b>BlockCopy </b>is really designed for copying data that is bitwise-compatible from one array type to another blittable array type, such as copying a <b>Byte[] </b>containing Unicode characters (in the proper byte order) to a <b>Char[] </b>This method allows programmers to partially make up for the lack of the ability to treat an array as a block of memory of any type.</p>
<p>If you need to reliably copy a set of array elements from one array to another array, you should use <b>System.Array</b>'s <b>ConstrainedCopy </b>method. This method guarantees that the copy operation will either complete or throw an exception without destroying any data within the destination array This allows <b>ConstrainedCopy </b>to be used in a constrained execution region (CER) In order to offer this guarantee, <b>ConstrainedCopy </b>requires that the source array's element type be the same as or derived from the destination array's element type. In addition, it will not perform any boxing, unboxing, or downcasting.</p>
<a name="b392"/><h2>All Arrays Are Implicitly Derived from System.Array</h2>
<p>When you declare an array variable like this, FileStream[] fsArray;</p>
<p>then the CLR automatically creates a <b>FileStream[] </b>type for the AppDomain. This type will be implicitly derived from the <b>System.Array </b>type, and therefore, all of the instance methods and properties defined on the <b>System.Array </b>type will be inherited by the <b>FileStream[] </b>type, allowing these methods and properties to be called using the <b>fsArray </b>variable This makes working with arrays extremely convenient because there are many helpful instance methods and properties defined by <b>System.Array, </b>such as <b>Clone, CopyTo, GetLength, GetLongLength, GetLowerBound, GetUpperBound, Length, Rank, </b>and others.</p>
<p>The <b>System.Array </b>type also exposes a large number of extremely useful static methods that operate on arrays. These methods all take a reference to an array as a parameter. Some of the useful static methods are <b>AsReadOnly, BinarySearch, Clear, ConstrainedCopy, ConvertAll, Copy, Exists, Find, FindAll, FindIndex, FindLast, FindLastIndex, ForEach, IndexOf, LastIndexOf, Resize, Reverse, Sort, </b>and <b>TrueForAll. </b>There are many overloads for each of these methods. In fact, many of the methods provide generic overloads for compile-time type safety as well as good performance. I encourage you to examine the SDK documentation to get an understanding of how useful and powerful these methods are.</p>
<a name="b393"/><h2>All Arrays Implicitly Implement IEnumerable, ICollection, and IList</h2>
<p>There are many methods that operate on various collection objects because the methods are declared with parameters such as <b>IEnumerable, ICollection, </b>and <b>IList. </b>It is possible to pass arrays to these methods because <b>System.Array </b>also implements these three interfaces. <b>System.Array </b>implements these non-generic interfaces because they treat all elements as <b>System.Object. </b>However, it would be nice to have <b>System.Array </b>implement the generic equivalent of these interfaces, providing better compile-time type safety as well as better performance.</p>
<p>The CLR team didn't want <b>System.Array </b>to implement <b>IEnumerable&lt;T&gt;, ICollection&lt;T&gt;, </b>and <b>IList&lt;T&gt;, </b>though, because of issues related to multi-dimensional arrays and non-zero-based arrays. Defining these interfaces on <b>System.Array </b>would have enabled these interfaces for all array types Instead, the CLR performs a little trick: when a single-dimensional, zero-lower bound array type is created, the CLR automatically makes the array type implement <b>IEnumerable&lt;T&gt;, ICollection&lt;T&gt;, </b>and <b>IList&lt;T&gt; </b>(where <b>T </b>is the array's element type) and also implements the three interfaces for all of the array type's base types as long as they are reference types. The following hierarchy diagram helps make this clear:</p>
<p><code>Object<br/>
Array (non-generic IEnumerable, ICollection, IList)<br/>
Object[].(IEnumerable, ICollection, IList of.Object)<br/>
String[].(IEnumerable, ICollection, IList of.String)<br/>
Stream[].(IEnumerable, ICollection, IList of.Stream)<br/>
FileStream[] (IEnumerable, ICollection, IList of.FileStream)<br/>
..(other arrays of reference types)</code></p>
<p>So, for example, if you have the following line of code, FileStream[] fsArray;</p>
<p>then when the CLR creates the <b>FileStream[] </b>type, it will cause this type to automatically implement the <b>IEnumerable&lt;FileStream&gt;, ICollection&lt;FileStream&gt;, </b>and <b>IList&lt;FileStream&gt; </b>interfaces. Furthermore, the <b>FileStream[] </b>type will also implement the interfaces for the base types: <b>IEnumerable&lt;Stream&gt;, IEnumerable&lt;Object&gt;, ICollection&lt;Stream&gt;, ICollection&lt;Object&gt;, IList&lt;Stream&gt;, </b>and <b>IList&lt;Object&gt;. </b>Since all of these interfaces are automatically implemented by the CLR, the <b>fsArray </b>variable could be used wherever any of these interfaces exist. For example, the <b>fsArray </b>variable could be passed to methods that have any of the following prototypes:</p>
<p><code>void M1(IList&lt;FileStream&gt; fsList) {... }<br/>
void M2(ICollection&lt;Stream&gt; sCollection) {... }<br/>
void M3(IEnumerable&lt;Object&gt; oEnumerable) {... }</code></p>
<p>Note that if the array contains value type elements, the array type will not implement the interfaces for the element's base types For example, if you have the following line of code,</p>
<p><code>DateTime[] dtArray; // An array of value types then the <b>DateTime[] </b>type will implement <b>IEnumerable&lt;DateTime&gt;, ICollection&lt;DateTime&gt;, </b>and <b>IList&lt;DateTime&gt; </b>only; it will not implement versions of these interfaces that are generic over <b>System.ValueType </b>or <b>System.Object </b>. This means that the <b>dtArray </b>variable cannot be passed as an argument to the <b>M3 </b>method shown earlier The reason for this is because arrays of value types are laid out in memory differently than arrays of reference types. Array memory layout was discussed earlier in this chapter.</code></p>
<a name="b394"/><h2>Passing and Returning Arrays</h2>
<p>When passing an array as an argument to a method, you are really passing a reference to that array. Therefore, the called method is able to modify the elements in the array. If you don't want to allow this, you must make a copy of the array and pass the copy into the method. Note that the <b>Array.Copy </b>method performs a shallow copy, and therefore, if the array's elements are reference types, the new array refers to the already existing objects.</p>
<p>Similarly, some methods return a reference to an array. If the method constructs and initializes the array, returning a reference to the array is fine. But if the method wants to return a reference to an internal array maintained by a field, you must decide if you want the method's caller to have direct access to this array and its elements. If you do, just return the array's reference. But most often, you won't want the method's caller to have such access, so the method should construct a new array and call <b>Array.Copy, </b>returning a reference to the new array. Again, be aware that <b>Array.Copy </b>makes a shallow copy of the original array.</p>
<p>If you define a method that returns a reference to an array, and if that array has no elements in it, your method can return either <b>null </b>or a reference to an array with zero elements in it. When you're implementing this kind of method, Microsoft strongly recommends that you implement the method by having it return a zero-length array because doing so simplifies the code that a developer calling the method must write. For example, this easy-to-understand code runs correctly even if there are no appointments to iterate over:</p>
<p><code>// This code is easier to write and understand. Appointment[] appointments = GetAppointmentsForToday(); for (Int32 a = 0; a &lt; appointments.Length; a++) {<br/>
}</code></p>
<p>The following code also runs correctly if there are no appointments to iterate over. However, this code is slightly more difficult to write and understand:</p>
<p><code>// This code is harder to write and understand. Appointment[] appointments = GetAppointmentsForToday(); if (appointments != null) {<br/>
for (Int32 a = 0, a &lt; appointments.Length; a++) { // Do something with appointments[a]<br/>
}<br/>
}</code></p>
<p>If you design your methods to return arrays with zero elements instead of <b>null, </b>callers of your methods will have an easier time working with them. By the way, you should do the same for fields. If your type has a field that's a reference to an array, you should consider having the field refer to an array even if the array has no elements in it.</p>
<a name="b395"/><h2>Creating Non-Zero-Lower Bound Arrays</h2>
<p>Earlier I mentioned that it's possible to create and work with arrays that have non-zero lower bounds. You can dynamically create your own arrays by calling <b>Array</b>'s static <b>CreateInstance </b>method. Several overloads of this method exist, allowing you to specify the type of the elements in the array, the number of dimensions in the array, the lower bounds of each dimension, and the number of elements in each dimension. <b>CreateInstance </b>allocates memory for the array, saves the parameter information in the overhead portion of the array's memory block, and returns a reference to the array. If the array has two or more dimensions, you can cast the reference returned from <b>CreateInstance </b>to an <b>ElementType[] </b>variable (where <b>ElementType </b>is some type name), making it easier for you to access the elements in the array. If the array has just one dimension, in C#, you have to use <b>Array</b>'s <b>GetValue </b>and <b>SetValue </b>methods to access the elements of the array.</p>
<p>Here's some code that demonstrates how to dynamically create a two-dimensional array of <b>System.Decimal </b>values. The first dimension represents calendar years from 2005 to 2009 inclusive, and the second dimension represents quarters from 1 to 4 inclusive. The code iterates over all the elements in the dynamic array I could have hard-coded the array's bounds into the code, which would have given better performance, but I decided to use <b>System.Array</b>'s <b>GetLowerBound </b>and <b>GetUpperBound </b>methods to demonstrate their use:</p>
<p><code>using System;<br/>
public static class DynamicArrays { public static void Main() {<br/>
// I want a two-dimensional array [2005..2009][1..4]. Int32[] lowerBounds = { 2005, 1 }; Int32[] lengths        = {      5, 4 }; Decima1[,] quarterlyRevenue = (Decima1[,])<br/>
Array.CreateInstance(typeof(Decima1), lengths, lowerBounds);<br/>
Console.WriteLine(&quot;{0,4}   {1,9}   {2,9}   {3,9} {4,9}&quot;,<br/>
&quot;Year&quot;, &quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;, &quot;Q4&quot;); Int32 firstYear      = quarterlyRevenue.GetLowerBound(0);<br/>
Int32 lastYear = quarterlyRevenue.CetUpperBound(0); Int32 firstQuarter = quarterlyRevenue.CetLowerBound(1); Int32 lastQuarter   = quarterlyRevenue.CetUpperBound(1);<br/>
for (Int32 year = firstYear; year &lt;= lastYear; year++) { Console.Write(year + &quot; &quot;);<br/>
for (Int32 quarter = firstQuarter; quarter &lt;= lastQuarter; quarter++) { Console.Write(&quot;{0,9:C}   &quot;, quarterlyRevenue[year, quarter]);<br/>
}<br/>
Console.WriteLine<b>O;</b><br/>
}<br/>
}<br/>
}</code></p>
<p>If you compile and run this code, you get the following output: Year.Q1.Q2.Q3 Q4</p>
<p><code>2005.$0.00.$0.00.$0.00 $0.00<br/>
2006.$0.00.$0.00.$0.00 $0.00<br/>
2007.$0.00.$0.00.$0.00 $0.00<br/>
2008.$0.00       $0.00       $0.00 $0.00<br/>
2009.$0.00       $0.00       $0.00 $0.00</code></p>
<a name="b396"/><h2>Array Access Performance</h2>
<p>Internally, the CLR actually supports two different kinds of arrays:</p>
<p>&#9632; Single-dimensional arrays with a lower bound of 0. These arrays are sometimes called SZ (for single-dimensional, zero-based) arrays or vectors.</p>
<p>&#9632; Single-dimensional and multi-dimensional arrays with an unknown lower bound.</p>
<p>You can actually see the different kinds of arrays by executing the following code (the output is shown in the code's comments):</p>
<p><code>using System;<br/>
public sealed class Program {<br/>
public static void Main() { Array a;<br/>
// Create a 1-dim, 0-based array, with no elements in it a = new String[0];<br/>
Console.WriteLine(a.GetType<b>O);     </b>// &quot;System.String[]&quot;<br/>
// Create a 1-dim, 0-based array, with no elements in it a = Array.CreateInstance(typeof(String),<br/>
new Int32[] { 0 }, new Int32[] { 0 });<br/>
Console.WriteLine(a.GetType<b>O);     </b>// &quot;System.String[]&quot;<br/>
// Create a 1-dim, 1-based array, with no elements in it a = Array.CreateInstance(typeof(String),<br/>
new Int32[] { 0 }, new Int32[] { 1 }); Console.WriteLine(a.GetType<b>O);     </b>// &quot;System.String[*]&quot;   &lt;-- INTERESTING!<br/>
Console.WriteLine<b>O;</b><br/>
// Create a 2-dim, 0-based array, with no elements in it a = new String[0, 0];<br/>
Console.WriteLine(a.GetType<b>O);     </b>// &quot;System.String[,]&quot;<br/>
// Create a 2-dim, 0-based array, with no elements in it a = Array.CreateInstance(typeof(String),<br/>
new Int32[] { 0, 0 }, new Int32[] { 0, 0 });<br/>
Console.WriteLine(a.GetType<b>O);     </b>// &quot;System.String[,]&quot;<br/>
// Create a 2-dim, 1-based array, with no elements in it a = Array.CreateInstance(typeof(String),<br/>
new Int32[] { 0, 0 }, new Int32[] { 1, 1 });<br/>
Console.WriteLine(a.GetType<b>O);     </b>// &quot;System.String[,]&quot;<br/>
}<br/>
}</code></p>
<p>Next to each <b>Console.WriteLine </b>is a comment that indicates the output. For the single-dimensional arrays, the zero-based arrays display a type name of <b>System.String[], </b>whereas the 1-based array displays a type name of <b>System.String[*]. </b>The <b>* </b>indicates that the CLR knows that this array is not zero-based. Note that C# does not allow you to declare a variable of type <b>String[*], </b>and therefore it is not possible to use C# syntax to access a single-dimensional, non-zero-based array. Although you can call <b>Array</b>'s <b>GetValue </b>and <b>SetValue </b>methods to access the elements of the array, this access will be slow due to the overhead of the method call.</p>
<p>For multi-dimensional arrays, the zero-based and 1-based arrays all display the same type name: <b>System.String[,]. </b>The CLR treats all multi-dimensional arrays as though they are not zero-based at runtime. This would make you think that the type name should display as <b>System.String[*,*]; </b>however, the CLR doesn't use the *s for multi-dimensional arrays because they would always be present, and the asterisks would just confuse most developers.</p>
<p>Accessing the elements of a single-dimensional, zero-based array is slightly faster than accessing the elements of a non-zero-based, single-dimensional array or a multi-dimensional array. There are several reasons for this. First, there are specific IL instructions耀uch as <b>newarr, ldelem, ldelema, ldlen, </b>and <b>stelem</b>to manipulate single-dimensional, zero-based arrays, and these special IL instructions cause the JIT compiler to emit optimized code. For example, the JIT compiler will emit code that assumes that the array is zero-based, and this means that an offset doesn't have to be subtracted from the specified index when accessing an element. Second, in common situations, the JIT compiler is able to hoist the index range-checking code out of the loop, causing it to execute just once For example, look at the following commonly written code:</p>
<p><code>using System;<br/>
public static class Program { public static void Main() { Int32[] a = new Int32[5];<br/>
for(Int32 index = 0; index &lt; a.Length; index++) { // Do something with a[index]<br/>
}<br/>
}<br/>
}</code></p>
<p>The first thing to notice about this code is the call to the array's <b>Length </b>property in the <b>for </b>loop's test expression. Since <b>Length </b>is a property, querying the length actually represents a method call. However, the JIT compiler knows that <b>Length </b>is a property on the <b>Array </b>class, and the JIT compiler will actually generate code that calls the property just once and stores the result in a temporary variable that will be checked with each iteration of the loop. The result is that the JITted code is fast. In fact, some developers have underestimated the abilities of the JIT compiler and have tried to write &quot;clever code&quot; in an attempt to help the JIT compiler. However, any clever attempts that you come up with will almost certainly impact performance negatively and make your code harder to read, reducing its maintainability. You are better off leaving the call to the array's <b>Length </b>property in the code above instead of attempting to cache it in a local variable yourself</p>
<p>The second thing to notice about the code above is that the JIT compiler knows that the <b>for </b>loop is accessing array elements 0 through <b>Length - 1 </b>. So the JIT compiler produces code that, at runtime, tests that all array accesses will be within the array's valid range. Specifically, the JIT compiler produces code to check if <b>(0 &gt;= a.GetLowerBound(O)) </b>&amp;&amp; <b>((Length - 1) &lt;= a.GetUpperBound(O)). </b>This check occurs just before the loop. If the check is good, the JIT compiler will not generate code inside the loop to verify that each array access is within the valid range. This allows array access within the loop to be very fast.</p>
<p>Unfortunately, as I alluded to earlier in this chapter, accessing elements of a non-zero-based single-dimensional array or of a multi-dimensional array is much slower than a single-dimensional, zero-based array. For these array types, the JIT compiler doesn't hoist index checking outside of loops, so each array access validates the specified indices. In addition, the JIT compiler adds code to subtract the array's lower bounds from the specified index, which also slows the code down, even if you're using a multi-dimensional array that happens to be zero-based.</p>
<p>So if performance is a concern to you, you might want to consider using an array of arrays (a jagged array) instead of a rectangular array. C# and the CLR also allow you to access an array by using unsafe (non-verifiable) code, which is, in effect, a technique that allows you to turn off the index bounds checking when accessing an array. Note that this unsafe array manipulation technique is usable with arrays whose elements are <b>SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Char, Single, Double, Decimal, Boolean, </b>an enumerated type, or a value type structure whose fields are any of the aforementioned types.</p>
<p>This is a very powerful feature that should be used with extreme caution because it allows you to perform direct memory accesses. If these memory accesses are outside the bounds of the array, an exception will not be thrown; instead, you will be corrupting memory, violating type safety, and possibly opening a security hole! For this reason, the assembly containing the unsafe code must either be granted full trust or at least have the Security Permission with Skip Verification turned on.</p>
<p>The following C# code demonstrates three techniques (safe, jagged, and unsafe), for accessing a two-dimensional array:</p>
<p><code>using System;<br/>
using System.Diagnostics;<br/>
public static class Program {<br/>
private const Int32 c_numElements = 10000;<br/>
public static void Main() { const Int32 testCount = 10; Stopwatch sw;<br/>
// Declare a two-dimensional array<br/>
Int32[,] a2Dim = new Int32[c_numElements, c_numElements];<br/>
// Declare a two-dimensional array as a jagged array (a vector of vectors) Int32[][] aJagged = new Int32[c_numElements][]; for (Int32 x = 0; x &lt; c_numElements; x++) aJagged[x] = new Int32[c_numElements];<br/>
// 1: Access all elements of the array using the usual, safe technique sw = Stopwatch.StartNew();<br/>
for (Int32 test = 0; test &lt; testCount; test++)<br/>
Safe2DimArrayAccess(a2Dim); Console.WriteLine(&quot;{0}: Safe2DimArrayAccess&quot;, sw.Elapsed);<br/>
// 2: Access all elements of the array using the jagged array technique sw = Stopwatch.StartNew();<br/>
for (Int32 test = 0; test &lt; testCount; test++)<br/>
SafeJaggedArrayAccess(aJagged); Console.WriteLine(&quot;{0}: SafeJaggedArrayAccess&quot;, sw.Elapsed);<br/>
// 3: Access all elements of the array using the unsafe technique sw = Stopwatch.StartNew();<br/>
for (Int32 test = 0; test &lt; testCount; test++)<br/>
Unsafe2DimArrayAccess(a2Dim); Console.WriteLine(&quot;{0}: Unsafe2DimArrayAccess&quot;, sw.Elapsed); Console.ReadLineO;<br/>
}<br/>
private static Int32 Safe2DimArrayAccess(Int32[,] a) { Int32 sum = 0;<br/>
for (Int32 x = 0; x &lt; c_numElements; x++) { for (Int32 y = 0; y &lt; c_numElements; y++) {<br/>
sum += a[x, y];<br/>
}<br/>
}<br/>
return sum;<br/>
}<br/>
private static Int32 SafeJaggedArrayAccess(Int32[][] a) { Int32 sum = 0;<br/>
for (Int32 x = 0; x &lt; c_numElements; x++) { for (Int32 y = 0; y &lt; c_numElements; y++) { sum += a[x][y];<br/>
}<br/>
}<br/>
return sum;<br/>
}<br/>
private static unsafe Int32 Unsafe2DimArrayAccess(Int32[,] a) { Int32 sum = 0; fixed (Int32* pi = a) {<br/>
for (Int32 x = 0; x &lt; c_numElements; x++) { Int32 baseOfDim = x * c_numElements; for (Int32 y = 0; y &lt; c_numElements; y++) { sum += pi[baseOfDim + y];<br/>
}<br/>
}<br/>
}<br/>
return sum;<br/>
}<br/>
}</code></p>
<p>The <b>Unsafe2DimArrayAccess </b>method is marked with the <b>unsafe </b>modifier, which is required to use C#'s <b>fixed </b>statement. To compile this code, you'll have to specify the <b>/unsafe </b>switch when invoking the C# compiler or check the &quot;Allow Unsafe Code&quot; check box on the Build tab of the Project Properties pane in Microsoft Visual Studio.</p>
<p>When I run this program on my machine, I get the following output:</p>
<p><code>00:00:02.0017692: Safe2DimArrayAccess 00:00:01.5197844: SafeJaggedArrayAccess 00:00:01.7343436: Unsafe2DimArrayAccess</code></p>
<p>As you can see, the safe two-dimensional array access technique is the slowest. The safe jagged array access technique takes a little less time to complete than the safe two-dimensional array access technique. However, you should note that creating the jagged array is more time-consuming than creating the multi-dimensional array because creating the jagged array requires an object to be allocated on the heap for each dimension, causing the garbage collector to kick in periodically So there is a trade-off: If you need to create a lot of &quot;multidimensional arrays&quot; and you intend to access the elements infrequently, it is quicker to create a multi-dimensional array. If you need to create the &quot;multi-dimensional array&quot; just once, and you access its elements frequently, a jagged array will give you better performance. Certainly, in most applications, the latter scenario is more common.</p>
<p>Finally, notice that the unsafe two-dimensional array access technique is about as fast as the safe two-dimensional array access technique, but it would be considered the fastest of them all if you also took into account that it accesses a single two-dimensional array (which is one memory allocation), as compared to creating the jagged array (which requires many memory allocations). Obviously, the unsafe technique has a time and place when it can best be used by your own code, but beware that there are three serious downsides to using this technique:</p>
<p>&#9632; The code that manipulates the array elements is more complicated to read and write than that which manipulates the elements using the other techniques because you are using C#'s <b>fixed </b>statement and performing memory-address calculations.</p>
<p>&#9632; If you make a mistake in the calculation, you are accessing memory that is not part of the array This can result in an incorrect calculation, corruption of memory, a type-safety violation, and a potential security hole.</p>
<p>&#9632; Due to the potential problems, the CLR forbids unsafe code from running in reduced-security environments (like Microsoft Silverlight).</p>
<a name="b401"/><h2>Unsafe Array Access and Fixed-Size Array</h2>
<p>Unsafe array access is very powerful because it allows you to access:</p>
<p>&#9632; Elements within a managed array object that resides on the heap (as the previous section demonstrated).</p>
<p>&#9632; Elements within an array that resides on an unmanaged heap. The <b>SecureString </b>example in Chapter 14, &quot;Chars, Strings, and Working with Text,&quot; demonstrated using unsafe array access on an array returned from calling the <b>System.Runtime. InteropServices.Marshal </b>class's <b>SecureStringToCoTaskMemUnicode </b>method.</p>
<p>&#9632; Elements within an array that resides on the thread's stack.</p>
<p>In cases in which performance is extremely critical, you could avoid allocating a managed array object on the heap and instead allocate the array on the thread's stack by using C#'s <b>stackalloc </b>statement (which works a lot like C's <b>alloca </b>function). The <b>stackalloc </b>statement can be used to create a single-dimensional, zero-based array of value type elements only, and the value type must not contain any reference type fields. Really, you should think of this as allocating a block of memory that you can manipulate by using unsafe pointers, and therefore, you cannot pass the address of this memory buffer to the vast majority of FCL methods. Of course, the stack-allocated memory (array) will automatically be freed when the method returns; this is where we get the performance improvement. Using this feature also requires you specify the <b>/unsafe </b>switch to the C# compiler.</p>
<p>The <b>StackallocDemo </b>method in the code below shows an example of how to use C#'s <b>stackalloc </b>statement:</p>
<p><code>using System;<br/>
public static class Program { public static void Main() { StackallocDemo(); InlineArrayDemo();<br/>
}<br/>
private static void StackallocDemo() { unsafe {<br/>
const Int32 width = 20;<br/>
Char* pc = stackalloc Char[width]; // Allocates array on stack<br/>
String s = &quot;Jeffrey Richter&quot;;// 15 characters<br/>
for (Int32 index = 0; index &lt; width; index++) { pc[width - index - 1] =<br/>
(index &lt; s.Length) ? s[index] :<br/>
}<br/>
// The line below displays &quot;.....rethciR yerffeJ&quot;<br/>
Console.WriteLine(new String(pc, 0, width));<br/>
}<br/>
}<br/>
private static void InlineArrayDemo() { unsafe {<br/>
CharArray ca;// Allocates array on stack<br/>
Int32 widthInBytes = sizeof(CharArray); Int32 width = widthInBytes / 2;<br/>
String s = &quot;Jeffrey Richter&quot;; // 15 characters<br/>
for (Int32 index = 0; index &lt; width; index++) { ca.Characters[width - index - 1] = (index &lt; s.Length) ? s[index] :<br/>
}<br/>
// The line below displays &quot;.....rethciR yerffeJ&quot;<br/>
Console.WriteLine(new String(ca.Characters, 0, width));<br/>
}<br/>
}<br/>
}<br/>
internal unsafe struct CharArray {<br/>
// This array is embedded inline inside the structure public fixed Char Characters[20];<br/>
}</code></p>
<p>Normally, because arrays are reference types, an array field defined in a structure is really just a pointer or reference to an array; the array itself lives outside of the structure's memory. However, it is possible to embed an array directly inside a structure as shown by the <b>CharArray </b>structure in the preceding code. To embed an array directly inside a structure, there are several requirements:</p>
<p>&#9632; The type must be a structure (value type); you cannot embed an array inside a class (reference type).</p>
<p>&#9632; The field or its defining structure must be marked with the <b>unsafe </b>keyword.</p>
<p>&#9632; The array field must be marked with the <b>fixed </b>keyword.</p>
<p>&#9632; The array must be single-dimensional and zero-based.</p>
<p>&#9632; The array's element type must be one of the following types: <b>Boolean, Char, SByte, Byte, Int32, UInt32, Int64, UInt64, Single, </b>or <b>Double.</b></p>
<p>Inline arrays are typically used for scenarios that involve interoperating with unmanaged code where the unmanaged data structure also has an inline array. However, inline arrays can be used in other scenarios as well. The <b>InlineArrayDemo </b>method in the code shown earlier offers an example of how to use an inline array. The <b>InlineArrayDemo </b>method performs the same function as the <b>StackallocDemo </b>method; it just does it in a different way.</p>
<mbp:pagebreak/>
<a name="Chapter17"/>
<h1>Chapter 17: Delegates</h1>
<p><b>In this chapter:</b></p>
<a href="#b405">A First Look at Delegates</a><br/>
<a href="#b408">Using Delegates to Call Back Static Methods</a><br/>
<a href="#b409">Using Delegates to Call Back Instance Methods</a><br/>
<a href="#b410">Demystifying Delegates</a><br/>
<a href="#b415">Using Delegates to Call Back Many Methods (Chaining)</a><br/>
<a href="#b422">Enough with the Delegate Definitions Already (Generic Delegates)</a><br/>
<a href="#b423">C#'s Syntactical Sugar for Delegates</a><br/>
<a href="#b431">Delegates and Reflection</a><br/>
<p>In this chapter, I talk about callback functions. Callback functions are an extremely useful programming mechanism that has been around for years. The Microsoft .NET Framework exposes a callback function mechanism by using delegates. Unlike callback mechanisms used in other platforms, such as unmanaged C++, delegates offer much more functionality. For example, delegates ensure that the callback method is type-safe, in keeping with one of the most important goals of the common language runtime (CLR) Delegates also integrate the ability to call multiple methods sequentially and support the calling of static methods as well as instance methods.</p>
<a name="b405"/><h2>A First Look at Delegates</h2>
<p>The C runtime's <b>qsort </b>function takes a pointer to a callback function to sort elements within an array. In Microsoft Windows, callback functions are required for window procedures, hook procedures, asynchronous procedure calls, and more. In the .NET Framework, callback methods are used for a whole slew of things. For example, you can register callback methods to get a variety of notifications such as unhandled exceptions, window state changes, menu item selections, file system changes, form control events, and completed asynchronous operations.</p>
<p>In unmanaged C/C++, the address of a non-member function is just a memory address. This address doesn't carry any additional information such as the number of parameters the function expects, the types of these parameters, the function's return value type, and the function's calling convention. In short, unmanaged C/C++ callback functions are not type-safe (although they are a very lightweight mechanism).</p>
<p>In the .NET Framework, callback functions are just as useful and pervasive as in unmanaged Windows programming. However, the .NET Framework provides a type-safe mechanism called delegates. I'll start off the discussion of delegates by showing you how to use them. The following code demonstrates how to declare, create, and use delegates.</p>
<p><code>using System;<br/>
using System.Windows.Forms; using System.IO;<br/>
// Declare a delegate type; instances refer to a method that // takes an Int32 parameter and returns void. internal delegate void Feedback(Int32 value);<br/>
public sealed class Program { public static void Main() { StaticDelegateDemo(); InstanceDelegateDemo(); ChainDelegateDemo1(new Program()); ChainDelegateDemo2(new Program());<br/>
}<br/>
private static void StaticDelegateDemo() {<br/>
Console.WriteLine(&quot;-----.Static Delegate Demo -----&quot;);<br/>
Counter(1, 3, null);<br/>
Counter(1, 3, new Feedback(Program.FeedbackToConsole));<br/>
Counter(1, 3, new Feedback(FeedbackToMsgBox)); // &quot;Program.&quot; is optional<br/>
Console.WriteLine<b>O;</b><br/>
}<br/>
private static void InstanceDelegateDemo() {<br/>
Console.WriteLine<b>O</b>-----Instance Delegate Demo-----&quot;);<br/>
Program p = new Program();<br/>
Counter(1, 3, new Feedback(p.FeedbackToFile)); Console.WriteLine<b>O;</b><br/>
}<br/>
private static void ChainDelegateDemo1(Program p) {<br/>
Console.WriteLine<b>O</b>-----Chain Delegate Demo 1-----&quot;);<br/>
Feedback fb1 = new Feedback(FeedbackToConsole); Feedback fb2 = new Feedback(FeedbackToMsgBox); Feedback fb3 = new Feedback(p.FeedbackToFile);<br/>
Feedback fbChain = null;<br/>
fbChain = (Feedback) Delegate.Combine(fbChain, fb1); fbChain = (Feedback) Delegate.Combine(fbChain, fb2); fbChain = (Feedback) Delegate.Combine(fbChain, fb3); Counter(1, 2, fbChain);<br/>
Console.WriteLine<b>O; </b>fbChain = (Feedback)<br/>
Delegate.Remove(fbChain, new Feedback(FeedbackToMsgBox)); Counter(1, 2, fbChain);<br/>
}<br/>
private static void ChainDelegateDemo2(Program p) {<br/>
Console.WriteLine(&quot;-----Chain Delegate Demo 2-----&quot;);<br/>
Feedback fb1 = new Feedback(FeedbackToConsole); Feedback fb2 = new Feedback(FeedbackToMsgBox); Feedback fb3 = new Feedback(p.FeedbackToFile);<br/>
Feedback fbChain = null; fbChain += fb1; fbChain += fb2; fbChain += fb3; Counter(1, 2, fbChain);<br/>
Console.WriteLine();<br/>
fbChain -= new Feedback(FeedbackToMsgBox); Counter(1, 2, fbChain);<br/>
}<br/>
private static void Counter(Int32 from, Int32 to, Feedback fb) { for (Int32 val = from; val &lt;= to; val++) {<br/>
// If any callbacks are specified, call them if (fb != null)<br/>
fb(val);<br/>
}<br/>
}<br/>
private static void FeedbackToConsole(Int32 value) { Console.WriteLine(&quot;Item=&quot; + value);<br/>
}<br/>
private static void FeedbackToMsgBox(Int32 value) { MessageBox.Show(&quot;Item=&quot; + value);<br/>
}<br/>
private void FeedbackToFile(Int32 value) {<br/>
StreamWriter sw = new StreamWriter(&quot;Status&quot;, true);<br/>
sw.WriteLine(&quot;Item=&quot; + value);<br/>
sw.Close();<br/>
}<br/>
}</code></p>
<p>Now I'll describe what this code is doing. At the top, notice the declaration of the internal delegate, <b>Feedback. </b>A delegate indicates the signature of a callback method. In this example, a <b>Feedback </b>delegate identifies a method that takes one parameter (an <b>Int32) </b>and returns <b>void </b>. In a way, a delegate is very much like an unmanaged C/C++ <b>typedef </b>that represents the address of a function.</p>
<p>The <b>Program </b>class defines a private, static method named <b>Counter </b>. This method counts integers from the <b>from </b>argument to the <b>to </b>argument. The <b>Counter </b>method also takes an <b>fb, </b>which is a reference to a <b>Feedback </b>delegate object. <b>Counter </b>iterates through all of the integers, and for each integer, if the <b>fb </b>variable is not <b>null, </b>the callback method (specified by the <b>fb </b>variable) is called. This callback method is passed the value of the item being processed, the item number. The callback method can be designed and implemented to process each item in any manner deemed appropriate.</p>
<a name="b408"/><h2>Using Delegates to Call Back Static Methods</h2>
<p>Now that you understand how the <b>Counter </b>method is designed and how it works, let's see how to use delegates to call back static methods. The <b>StaticDelegateDemo </b>method that appears in the previous code sample is the focus of this section.</p>
<p>The <b>StaticDelegateDemo </b>method calls the <b>Counter </b>method, passing <b>null </b>in the third parameter, which corresponds to <b>Counter</b>'s <b>fb </b>parameter. Because <b>Counter</b>'s <b>fb </b>parameter receives <b>null, </b>each item is processed without calling any callback method.</p>
<p>Next, the <b>StaticDelegateDemo </b>method calls <b>Counter </b>a second time, passing a newly constructed <b>Feedback </b>delegate object in the third parameter of the method call This delegate object is a wrapper around a method, allowing the method to be called back indirectly via the wrapper. In this example, the name of the static method, <b>Program.FeedbackToConsole, </b>is passed to the <b>Feedback </b>type's constructor, indicating that it is the method to be wrapped The reference returned from the <b>new </b>operator is passed to <b>Counter </b>as its third parameter. Now when <b>Counter </b>executes, it will call the <b>Program </b>type's static <b>FeedbackToConsole </b>method for each item in the series. <b>FeedbackToConsole </b>simply writes a string to the console indicating the item being processed.</p>
<hr/>
<blockquote><b>Note </b>The <b>FeedbackToConsole </b>method is defined as <b>private </b>inside the <b>Program </b>type, but the <b>Counter </b>method is able to call <b>Program</b>'s private method In this case, you might not expect a problem because both <b>Counter </b>and <b>FeedbackToConsole </b>are defined in the same type. However, this code would work just fine even if the <b>Counter </b>method was defined in another type. In short, it is not a security or accessibility violation for one type to have code that calls another type's private member via a delegate as long as the delegate object is created by code that has ample security/accessibility</blockquote>
<hr/>
<p>The third call to <b>Counter </b>in the <b>StaticDelegateDemo </b>method is almost identical to the second call. The only difference is that the <b>Feedback </b>delegate object wraps the static <b>Program.FeedbackToMsgBox </b>method. <b>FeedbackToMsgBox </b>builds a string indicating the item being processed. This string is then displayed in a message box.</p>
<p>Everything in this example is type-safe. For instance, when constructing a <b>Feedback </b>delegate object, the compiler ensures that the signatures of <b>Program</b>'s <b>FeedbackToConsole </b>and <b>FeedbackToMsgBox </b>methods are compatible with the signature defined by the <b>Feedback </b>delegate. Specifically, both methods must take one argument (an <b>Int32), </b>and both methods must have the same return type <b>(void) </b>. If <b>FeedbackToConsole </b>had been defined like this:</p>
<p><code>private static Boolean FeedbackToConsole(String value) {<br/>
}</code></p>
<p>the C# compiler wouldn't compile the code and would issue the following error: <b>&quot;error CS0123: No overload for 'FeedbackToConsole' matches delegate 'Feedback'.&quot;</b></p>
<p>Both C# and the CLR allow for covariance and contra-variance of reference types when binding a method to a delegate. Covariance means that a method can return a type that is derived from the delegate's return type. Contra-variance means that a method can take a parameter that is a base of the delegate's parameter type. For example, given a delegate defined like this:</p>
<p><code>delegate Object MyCallback(FileStream s);</code></p>
<p>it is possible to construct an instance of this delegate type bound to a method that is prototyped like this:</p>
<p><code>String SomeMethod(Stream s);</code></p>
<p>Here, <b>SomeMethod</b>'s return type <b>(String) </b>is a type that is derived from the delegate's return type <b>(Object); </b>this covariance is allowed. <b>SomeMethod</b>'s parameter type <b>(Stream) </b>is a type that is a base class of the delegate's parameter type <b>(FileStream); </b>this contra-variance is allowed.</p>
<p>Note that covariance and contra-variance are supported only for reference types, not for value types or for <b>void </b>. So, for example, I cannot bind the following method to the <b>MyCallback </b>delegate:</p>
<p><code>Int32 SomeOtherMethod(Stream s);</code></p>
<p>Even though <b>SomeOtherMethod</b>'s return type <b>(Int32) </b>is derived from <b>MyCallback</b>'s return type <b>(Object), </b>this form of covariance is not allowed because <b>Int32 </b>is a value type. Obviously, the reason why value types and <b>void </b>cannot be used for covariance and contra-variance is because the memory structure for these things varies, whereas the memory structure for reference types is always a pointer. Fortunately, the C# compiler will produce an error if you attempt to do something that is not supported.</p>
<a name="b409"/><h2>Using Delegates to Call Back Instance Methods</h2>
<p>I just explained how delegates can be used to call static methods, but they can also be used to call instance methods for a specific object. To understand how calling back an instance method works, look at the <b>InstanceDelegateDemo </b>method that appears in the code shown at the beginning of this chapter.</p>
<p>Notice that a <b>Program </b>object named <b>p </b>is constructed in the <b>InstanceDelegateDemo </b>method. This <b>Program </b>object doesn't have any instance fields or properties associated with it; I created it merely for demonstration purposes. When the new <b>Feedback </b>delegate object is constructed in the call to the <b>Counter </b>method, its constructor is passed <b>p.FeedbackToFile. </b>This causes the delegate to wrap a reference to the <b>FeedbackToFile </b>method, which is an instance method (not a static method). When <b>Counter </b>calls the callback method identified by its <b>fb </b>argument, the <b>FeedbackToFile </b>instance method is called, and the address of the recently constructed object <b>p </b>will be passed as the implicit <b>this </b>argument to the instance method.</p>
<p>The <b>FeedbackToFile </b>method works as the <b>FeedbackToConsole </b>and <b>FeedbackToMsgBox</b></p>
<p>methods, except that it opens a file and appends the string to the end of the file. (The Status file that the method creates can be found in the application's AppBase directory.)</p>
<p>Again, the purpose of this example is to demonstrate that delegates can wrap calls to instance methods as well as static methods. For instance methods, the delegate needs to know the instance of the object the method is going to operate on. Wrapping an instance method is useful because code inside the object can access the object's instance members. This means that the object can have some state that can be used while the callback method is doing its processing.</p>
<a name="b410"/><h2>Demystifying Delegates</h2>
<p>On the surface, delegates seem easy to use: you define them by using C#'s <b>delegate </b>keyword, you construct instances of them by using the familiar <b>new </b>operator, and you invoke the callback by using the familiar method-call syntax (except instead of a method name, you use the variable that refers to the delegate object).</p>
<p>However, what's really going on is quite a bit more complex than what the earlier examples illustrate. The compilers and the CLR do a lot of behind-the-scenes processing to hide the complexity. In this section, I'll focus on how the compiler and the CLR work together to implement delegates. Having this knowledge will improve your understanding of delegates and will teach you how to use them efficiently and effectively. I'll also touch on some additional features delegates make available.</p>
<p>Let's start by reexamining this line of code:</p>
<p><code>internal delegate void Feedback(Int32 value);</code></p>
<p>When it sees this line, the compiler actually defines a complete class that looks something like this:</p>
<p><code>internal class Feedback : System.MulticastDelegate { // Constructor<br/>
public Feedback(Object object, IntPtr method);<br/>
// Method with same prototype as specified by the source code public virtual void Invoke(Int32 value);<br/>
// Methods allowing the callback to be called asynchronously public virtual IAsyncResult BeginInvoke(Int32 value,<br/>
AsyncCallback callback, Object object); public virtual void EndInvoke(IAsyncResult result);<br/>
}</code></p>
<p>The class defined by the compiler has four methods: a constructor, <b>Invoke, BeginInvoke, </b>and <b>EndInvoke. </b>In this chapter, I'll concentrate on the constructor and <b>Invoke </b>methods. I'll address the <b>BeginInvoke </b>and <b>EndInvoke </b>methods in Chapter 27, &quot;I/O-Bound Asynchronous Operations,&quot; in the &quot;The APM and Compute-Bound Operations&quot; section.</p>
<p>In fact, you can verify that the compiler did indeed generate this class automatically by examining the resulting assembly with ILDasm.exe, as shown in Figure 17-1.</p>
<img src="44.jpg"/>
<p><b>Figure 17-1 </b>ILDasm.exe showing the metadata produced by the compiler for the delegate</p>
<p>In this example, the compiler has defined a class called <b>Feedback </b>that is derived from the <b>System.MulticastDelegate </b>type defined in the Framework Class Library (FCL). (All delegate types are derived from <b>MulticastDelegate.)</b></p>
<hr/>
<blockquote><b>Important </b>The <b>System.MulticastDelegate </b>class is derived from <b>System.Delegate,</b></blockquote>
<hr/>
<p>which is itself derived from <b>System.Object </b>. The reason why there are two delegate classes is historical and unfortunate; there should be just one delegate class in the FCL Sadly, you need to be aware of both of these classes because even though all delegate types you create have <b>MulticastDelegate </b>as a base class, you'll occasionally manipulate your delegate types by using methods defined by the <b>Delegate </b>class instead of the <b>MulticastDelegate </b>class. For example, the <b>Delegate </b>class has static methods called <b>Combine </b>and <b>Remove. </b>(I explain what these methods do later.) The signatures for both of these methods indicate that they take <b>Delegate </b>parameters. Because your delegate type is derived from <b>MulticastDelegate, </b>which is derived from <b>Delegate, </b>instances of your delegate type can be passed to these methods.</p>
<p>The class has private visibility because the delegate is declared as <b>internal </b>in the source code. If the source code had indicated <b>public </b>visibility, the <b>Feedback </b>class the compiler generated would also be public. You should be aware that delegate types can be defined within a type (nested within another type) or at global scope Basically, because delegates are classes, a delegate can be defined anywhere a class can be defined.</p>
<p>Because all delegate types are derived from <b>MulticastDelegate, </b>they inherit <b>MulticastDelegate</b>'s fields, properties, and methods. Of all of these members, three non-public fields are probably most significant. Table 17-1 describes these significant fields.</p>
<p><b>Table 17-1 </b><b>MulticastDelegate's Significant Non-Public Fields</b></p>
<table border="1">
<tr>
<td>
<p>d</p>
</td>
<td>
<p><b><sup>Type</sup></b></p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p><b>System.Object</b></p>
</td>
<td>
<p>When the delegate object wraps a static method, this field is <b>null</b>. When the delegate objects wraps an instance method, this field refers to the object that should be operated on when the callback method is called. In other words, this field indicates the value that should be passed for the instance method's implicit <b>this </b>parameter.</p>
</td>
</tr>
<tr>
<td>
<p>r</p>
</td>
<td>
<p><b>System.IntPtr</b></p>
</td>
<td>
<p>An internal integer the CLR uses to identify the method that is to be called back</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p><b>System.Object</b></p>
</td>
<td>
<p>This field is usually <b>null. </b>It can refer to an array of delegates when building a delegate chain (discussed later in this chapter).</p>
</td>
</tr>
</table>
<p>Notice that all delegates have a constructor that takes two parameters: a reference to an object and an integer that refers to the callback method. However, if you examine the source code, you'll see that I'm passing in values such as <b>Program.FeedbackToConsole </b>or <b>p.FeedbackToFile </b>. Everything you've learned about programming tells you that this code shouldn't compile!</p>
<p>However, the C# compiler knows that a delegate is being constructed and parses the source code to determine which object and method are being referred to. A reference to the object is passed for the constructor's <b>object </b>parameter, and a special <b>IntPtr </b>value (obtained from a <b>MethodDef </b>or <b>MemberRef </b>metadata token) that identifies the method is passed for the <b>method </b>parameter. For static methods, <b>null </b>is passed for the <b>object </b>parameter. Inside the constructor, these two arguments are saved in the <b>_target </b>and <b>_methodPtr </b>private fields, respectively. In addition, the constructor sets the <b>_invocationList </b>field to <b>null. </b>I'll postpone discussing this <b>_invocationList </b>field until the next section, &quot;Using Delegates to Call Back Many Methods (Chaining).&quot;</p>
<p>So each delegate object is really a wrapper around a method and an object to be operated on when the method is called So if I have two lines of code that look like this:</p>
<p><code>Feedback fbStatic     = new Feedback(Program.FeedbackToConsole); Feedback fbInstance = new Feedback(new Program().FeedbackToFile);</code></p>
<p>the <b>fbStatic </b>and <b>fbInstance </b>variables refer to two separate <b>Feedback </b>delegate objects that are initialized, as shown in Figure 17-2.</p>
<p><b>Figure 17-2 </b>A variable that refers to a delegate to a static method and a variable that refers to a delegate to an instance method</p>
<p>The <b>Delegate </b>class defines two read-only public instance properties: <b>Target </b>and <b>Method </b>. Given a reference to a delegate object, you can query these properties. The <b>Target </b>property returns a reference to the object that will be operated on if the method is called back. Basically, the <b>Target </b>property returns the value stored in the private <b>_target </b>field. If the delegate object wraps a static method, <b>Target </b>returns <b>null. </b>The <b>Method </b>property returns a reference to a <b>System.Reflection.MethodInfo </b>object that identifies the callback method. Basically, the <b>Method </b>property has an internal mechanism that converts the value in the private <b>_methodPtr </b>field to a <b>MethodInfo </b>object and returns it.</p>
<p>You could use this information in several ways. For example, you could check to see if a delegate object refers to an instance method of a specific type:</p>
<p><code>Boolean DelegateRefersToInstanceMethodOfType(MulticastDelegate d, Type type) { return((d.Target != null) &amp;&amp; d.Target.CetType() == type);<br/>
}</code></p>
<p>You could also write code to check if the callback method has a specific name (such as <b>FeedbackToMsgBox):</b></p>
<p><code>Boolean DelegateRefersToMethodOfName(MulticastDelegate d, String methodName) { return(d.Method.Name == methodName);<br/>
}</code></p>
<p>There are many other potential uses of these properties.</p>
<p>Now that you know how delegate objects are constructed and what their internal structure looks like, let's talk about how the callback method is invoked For convenience, I've repeated the code for the <b>Counter </b>method here:</p>
<p><code>private static void Counter(Int32 from, Int32 to, Feedback fb) { for (Int32 val = from; val &lt;= to; val++) {<br/>
// If any callbacks are specified, call them if (fb != null) fb(val);<br/>
}<br/>
}</code></p>
<img src="45.jpg"/>
<p>Look at the line of code just below the comment. The <b>if </b>statement first checks to see if <b>fb </b>is not <b>null. </b>If <b>fb </b>is not <b>null, </b>on the next line, you see the code that invokes the callback method. The <b>null </b>check is required because <b>fb </b>is really just a variable that can refer to a <b>Feedback </b>delegate object; it could also be <b>null. </b>It might seem as if I'm calling a function named <b>fb </b>and passing it one parameter <b>(val) </b>. However, there is no function called <b>fb. </b>Again, because it knows that <b>fb </b>is a variable that refers to a delegate object, the compiler generates code to call the delegate object's <b>Invoke </b>method In other words, the compiler sees this:</p>
<p><code>fb(val);</code></p>
<p>But the compiler generates code as though the source code said this: fb.Invoke(val);</p>
<p>You can verify that the compiler produces code to call the delegate type's <b>Invoke </b>method by using ILDasm exe to examine the Intermediate Language (IL) code created for the <b>Counter </b>method. Here is the IL for the <b>Counter </b>method. The instruction at IL_0009 in the figure indicates the call to <b>Feedback</b>'s <b>Invoke </b>method.</p>
<p><code>.method private hidebysig static void   Counter(int32 from,<br/>
int32 'to',<br/>
class Feedback fb) cil managed<br/>
{<br/>
// Code size.23 (0x17)<br/>
.maxstack 2<br/>
.locals init (int32 V_0) IL_0000: ldarg.0 IL_0001: stloc.0 IL_0002:   br.s IL_0012 IL_0004: ldarg.2<br/>
IL_0005:  brfalse.s IL_000e IL_0007: ldarg.2<br/>
IL_0008: ldloc.0<br/>
IL_0009:   callvirt     instance void Feedback::Invoke(int32)<br/>
IL_000e: ldloc.0<br/>
IL_000f: ldc.i4.1<br/>
IL_0010:.add<br/>
IL_0011:.stloc.0<br/>
IL_0012:.ldloc.0<br/>
IL_0013:.ldarg.1<br/>
IL_0014:.ble.s IL_0004<br/>
IL_0016:.ret<br/>
} // end of method Program::Counter</code></p>
<p>In fact, you could modify the <b>Counter </b>method to call <b>Invoke </b>explicitly, as shown here:</p>
<p><code>private static void Counter(Int32 from, Int32 to, Feedback fb) { for (Int32 val = from; val &lt;= to; val++) {<br/>
// If any callbacks are specified, call them if (fb != null) fb.Invoke(val);<br/>
}<br/>
}</code></p>
<p>You'll recall that the compiler defined the <b>Invoke </b>method when it defined the <b>Feedback </b>class. When <b>Invoke </b>is called, it uses the private <b>_target </b>and <b>_methodPtr </b>fields to call the desired method on the specified object. Note that the signature of the <b>Invoke </b>method matches the signature of the delegate; because the <b>Feedback </b>delegate takes one <b>Int32 </b>parameter and returns <b>void, </b>the <b>Invoke </b>method (as produced by the compiler) takes one <b>Int32 </b>parameter and returns <b>void.</b></p>
<a name="b415"/><h2>Using Delegates to Call Back Many Methods (Chaining)</h2>
<p>By themselves, delegates are incredibly useful. But add in their support for chaining, and delegates become even more useful. Chaining is a set or collection of delegate objects, and it provides the ability to invoke, or call, all of the methods represented by the delegates in the set. To understand this, see the <b>ChainDelegateDemol </b>method that appears in the code shown at the beginning of this chapter. In this method, after the <b>Console.WriteLine </b>statement, I construct three delegate objects and have variables<b>fb1, fb2, </b>and <b>fb3</b>羊efer to each object, as shown in Figure 17-3.</p>
<img src="46.jpg"/>
<p><b>Figure 17-3 </b>Initial state of the delegate objects referred to by the <b>fb1, fb2, </b>and <b>fb3 </b>variables</p>
<p>The reference variable to a <b>Feedback </b>delegate object, <b>fbChain, </b>is intended to refer to a chain or set of delegate objects that wrap methods that can be called back. Initializing <b>fbChain </b>to <b>null </b>indicates that there currently are no methods to be called back. The <b>Delegate </b>class's public, static <b>Combine </b>method is used to add a delegate to the chain:</p>
<p><code>fbChain = (Feedback) Delegate.Combine(fbChain, fbl);</code></p>
<p>When this line of code executes, the <b>Combine </b>method sees that we are trying to combine <b>null </b>and <b>fb1 </b>. Internally, <b>Combine </b>will simply return the value in <b>fb1, </b>and the <b>fbChain </b>variable will be set to refer to the same delegate object referred to by the <b>fb1 </b>variable, as shown in Figure 17-4.</p>
<img src="47.jpg"/>
<p><b>Figure 17-4 </b>State of the delegate objects after inserting the first delegate in the chain To add another delegate to the chain, the <b>Combine </b>method is called again: fbChain = (Feedback) Delegate.Combine(fbChain, fb2);</p>
<p>Internally, the <b>Combine </b>method sees that <b>fbChain </b>already refers to a delegate object, so <b>Combine </b>will construct a new delegate object. This new delegate object initializes its private <b>_target </b>and <b>_methodPtr </b>fields to values that are not important for this discussion. However, what is important is that the <b>_invocationList </b>field is initialized to refer to an array of delegate objects. The first element of this array (index 0) will be initialized to refer to the delegate that wraps the <b>FeedbackToConsole </b>method (this is the delegate that <b>fbChain </b>currently refers to). The second element of the array (index 1) will be initialized to refer to the delegate that wraps the <b>FeedbackToMsgBox </b>method (this is the delegate that <b>fb2 </b>refers to) Finally, <b>fbChain </b>will be set to refer to the newly created delegate object, shown in Figure 17-5.</p>
<p>To add the third delegate to the chain, the <b>Combine </b>method is called once again:</p>
<p><code>fbChain = (Feedback) Delegate.Combine(fbChain, fb3);</code></p>
<p>Again, <b>Combine </b>sees that <b>fbChain </b>already refers to a delegate object, and this causes a new delegate object to be constructed, as shown in Figure 17-6. As before, this new delegate object initializes the private <b>_target </b>and <b>_methodPtr </b>fields to values unimportant to this discussion, and the <b>_invocationList </b>field is initialized to refer to an array of delegate objects. The first and second elements of this array (indexes 0 and 1) will be initialized to refer to the same delegates the previous delegate object referred to in its array The third element of the array (index 2) will be initialized to refer to the delegate that wraps the <b>FeedbackToFile </b>method (this is the delegate that <b>fb3 </b>refers to). Finally, <b>fbChain </b>will be set to refer to this newly created delegate object. Note that the previously created delegate and the array referred to by its <b>_invocationList </b>field are now candidates for garbage collection.</p>
<img src="48.jpg"/>
<p><b>Figure 17-5 </b>State of the delegate objects after inserting the second delegate in the chain</p>
<p><b>Figure 17-6 </b>Final state of the delegate objects when the chain is complete</p>
<img src="49.jpg"/>
<p>After all of the code has executed to set up the chain, the <b>fbChain </b>variable is then passed to the <b>Counter </b>method:</p>
<p><code>Counter(1, 2, fbChain);</code></p>
<p>Inside the <b>Counter </b>method is the code that implicitly calls the <b>Invoke </b>method on the <b>Feedback </b>delegate object as I detailed earlier When <b>Invoke </b>is called on the delegate referred to by <b>fbChain, </b>the delegate sees that the private <b>_invocationList </b>field is not <b>null, </b>causing it to execute a loop that iterates through all of the elements in the array, calling the method wrapped by each delegate. In this example, <b>FeedbackToConsole </b>will get called first, followed by <b>FeedbackToMsgBox, </b>followed by <b>FeedbackToFile </b>.</p>
<p><b>Feedback</b>'s <b>Invoke </b>method is essentially implemented something like this (in pseudocode):</p>
<p><code>public void Invoke(Int32 value) {<br/>
Delegate[] delegateSet = _invocationList as Delegate[]; if (delegateSet != null) {<br/>
// This delegate's array indicates the delegates that should be called foreach (Feedback d in delegateSet) d(value);     // Call each delegate } else {<br/>
// This delegate identifies a single method to be called back // Call the callback method on the specified target object. _methodPtr.Invoke(_target, value);<br/>
// The line above is an approximation of the actual code. // What really happens cannot be expressed in C#.<br/>
}<br/>
}</code></p>
<p>Note that it is also possible to remove a delegate from a chain by calling <b>Delegate</b>'s public, static <b>Remove </b>method. This is demonstrated toward the end of the <b>ChainDelegateDemo1 </b>method:</p>
<p><code>fbChain = (Feedback) Delegate.Remove(fbChain, new Feedback(FeedbackToMsgBox));</code></p>
<p>When <b>Remove </b>is called, it scans the delegate array (from the end toward index 0) maintained inside the delegate object referred to by the first parameter <b>(fbChain, </b>in my example). <b>Remove </b>is looking for a delegate entry whose <b>_target </b>and <b>_methodPtr </b>fields match those in the second argument (the new <b>Feedback </b>delegate, in my example). If a match is found and there is only one item left in the array, that array item is returned. If a match is found and there are multiple items left in the array, a new delegate object is constructed葉he <b>_invocationList </b>array created and initialized will refer to all items in the original array except for the item being removed, of course預nd a reference to this new delegate object is returned. If you are removing the only element in the chain, <b>Remove </b>returns <b>null. </b>Note that each call to <b>Remove </b>removes just one delegate from the chain; it does not remove all delegates that have matching <b>_target </b>and <b>_methodPtr </b>fields.</p>
<p>So far, I've shown examples in which my delegate type, <b>Feedback, </b>is defined as having a <b>void </b>return value. However, I could have defined my <b>Feedback </b>delegate as follows:</p>
<p><code>public delegate Int32 Feedback(Int32 value);<br/>
public Int32 Invoke(Int32 value) { Int32 result;<br/>
Delegate[] delegateSet = _invocationList as Delegate[]; if (delegateSet != null) {<br/>
// This delegate's array indicates the delegates that should be called<br/>
foreach (Feedback d in delegateSet)<br/>
result = d(value);     // Call each delegate } else {<br/>
// This delegate identifies a single method to be called back // Call the callback method on the specified target object. result = _methodPtr.Invoke(_target, value); // The line above is an approximation of the actual code. // What really happens cannot be expressed in C#.<br/>
}<br/>
return result;<br/>
}</code></p>
<p>As each delegate in the array is called, its return value is saved in the result variable. When the loop is complete, the <b>result </b>variable will contain only the result of the last delegate called (previous return values are discarded); this value is returned to the code that called <b>Invoke </b>.</p>
<h3>C#'s Support for Delegate Chains</h3>
<p>To make things easier for C# developers, the C# compiler automatically provides overloads of the <b>+= </b>and <b>-= </b>operators for instances of delegate types. These operators call <b>Delegate.Combine </b>and <b>Delegate.Remove, </b>respectively. Using these operators simplifies the building of delegate chains. The <b>ChainDelegateDemo1 </b>and <b>ChainDelegateDemo2 </b>methods in the source code shown at the beginning of this chapter produce absolutely identical IL code. The only difference between the methods is that the <b>ChainDelegateDemo2 </b>method simplifies the source code by taking advantage of C#'s += and -= operators.</p>
<p>If you require proof that the resulting IL code is identical for the two methods, you can build the code and look at its IL for both methods by using ILDasm.exe. This will confirm that the C# compiler did in fact replace all += and -= operators with calls to the <b>Delegate </b>type's public static <b>Combine </b>and <b>Remove </b>methods, respectively.</p>
<h3>Having More Control over Delegate Chain Invocation</h3>
<p>At this point, you understand how to build a chain of delegate objects and how to invoke all of the objects in that chain All items in the chain are invoked because the delegate type's <b>Invoke </b>method includes code to iterate through all of the items in the array, invoking each item. This is obviously a very simple algorithm. And although this simple algorithm is good enough for a lot of scenarios, it has many limitations. For example, the return values of the callback methods are all discarded except for the last one Using this simple algorithm,</p>
<p>there's no way to get the return values for all of the callback methods called But this isn't the only limitation. What happens if one of the invoked delegates throws an exception or blocks for a very long time? Because the algorithm invoked each delegate in the chain serially, a &quot;problem&quot; with one of the delegate objects stops all of the subsequent delegates in the chain from being called. Clearly, this algorithm isn't robust.</p>
<p>For those scenarios in which this algorithm is insufficient, the <b>MulticastDelegate </b>class offers an instance method, <b>GetInvocationList, </b>that you can use to call each delegate in a chain explicitly, using any algorithm that meets your needs:</p>
<p><code>public abstract class MulticastDelegate : Delegate { // Creates a delegate array where each element refers // to a delegate in the chain.<br/>
public sealed override Delegate[] CetInvocationList();<br/>
}</code></p>
<p>The <b>GetInvocationList </b>method operates on a <b>MulticastDelegate</b>-derived object and returns an array of <b>Delegate </b>references where each reference points to one of the chain's delegate objects. Internally, <b>GetInvocationList </b>constructs an array and initializes it with each element referring to a delegate in the chain; a reference to the array is then returned. If the <b>_invocationList </b>field is <b>null, </b>the returned array contains one element that references the only delegate in the chain: the delegate instance itself</p>
<p>You can easily write an algorithm that explicitly calls each object in the array. The following code demonstrates:</p>
<p><code>using System; using System.Text;<br/>
// Define a Light component. internal sealed class Light {<br/>
// This method returns the light's status.<br/>
public String SwitchPosition() { return &quot;The light is off&quot;;<br/>
}<br/>
}<br/>
// Define a Fan component. internal sealed class Fan {<br/>
// This method returns the fan's status.<br/>
public String Speed() {<br/>
throw new InvalidOperationException(&quot;The fan broke due to overheating&quot;);<br/>
}<br/>
}<br/>
// Define a Speaker component. internal sealed class Speaker {<br/>
// This method returns the speaker's status.<br/>
public String Volume() {<br/>
return &quot;The volume is loud&quot;;<br/>
}<br/>
}<br/>
public sealed class Program {<br/>
// Definition of delegate that allows querying a component's status. private delegate String CetStatus();<br/>
public static void Main() {<br/>
// Declare an empty delegate chain. CetStatus getStatus = null;<br/>
// Construct the three components, and add their status methods // to the delegate chain.<br/>
getStatus += new CetStatus(new Light().SwitchPosition); getStatus += new CetStatus(new Fan().Speed); getStatus += new CetStatus(new Speaker().Volume);<br/>
// Show consolidated status report reflecting<br/>
// the condition of the three components.<br/>
Console.WriteLine(CetComponentStatusReport(getStatus));<br/>
}<br/>
// Method that queries several components and returns a status report private static String CetComponentStatusReport(CetStatus status) {<br/>
// If the chain is empty, there is nothing to do. if (status == null) return null;<br/>
// Use this to build the status report. StringBuilder report = new StringBuilder();<br/>
// Cet an array where each element is a delegate from the chain. Delegate[] arrayOfDelegates = status.CetInvocationList();<br/>
// Iterate over each delegate in the array. foreach (CetStatus getStatus in arrayOfDelegates) {<br/>
try {<br/>
// Cet a component's status string, and append it to the report. report.AppendFormat(&quot;{0}{1}{1}&quot;, getStatus(), Environment.NewLine);<br/>
}<br/>
catch (InvalidOperationException e) {<br/>
// Cenerate an error entry in the report for this component.<br/>
Object component = getStatus.Target;<br/>
report.AppendFormat(<br/>
&quot;Failed to get status from {1}{2}{0}    Error: {3}{0}{0}&quot;,<br/>
Environment.NewLine,<br/>
((component == null) ? &quot;&quot; : component.CetType() + &quot;.&quot;),<br/>
getStatus.Method.Name,<br/>
e.Message);<br/>
}<br/>
}<br/>
// Return the consolidated report to the caller. return report.ToString();<br/>
}<br/>
}</code></p>
<p>When you build and run this code, the following output appears: The light is off</p>
<p><code>Failed to get status from Fan.Speed<br/>
Error: The fan broke due to overheating<br/>
The volume is loud</code></p>
<a name="b422"/><h2>Enough with the Delegate Definitions Already (Generic Delegates)</h2>
<p>Many years ago, when the NET Framework was just starting to be developed, Microsoft introduced the notion of delegates As programmers were adding classes to the FCL, they would define new delegate types any place they introduced a callback method. Over time, many, many delegates got defined. In fact, in MSCorLib.dll alone, close to 50 delegate types are now defined. Let's just look at a few of them:</p>
<p><code>public delegate void TryCode(Object userData); public delegate void WaitCallback(Object state); public delegate void TimerCallback(Object state); public delegate void ContextCallback(Object state); public delegate void SendOrPostCallback(Object state); public delegate void ParameterizedThreadStart(Object obj);</code></p>
<p>Do you notice anything similar about the few delegate definitions that I selected? They are really all the same: a variable of any of these delegate types must refer to a method that takes an <b>Object </b>and returns <b>void </b>. There is really no reason to have all of these delegate types defined; there really just needs to be one.</p>
<p>In fact, now that the .NET Framework supports generics, we really just need a few generic delegates (defined in the <b>System </b>namespace) that represent methods that take up to 16 arguments:</p>
<p><code>public delegate void Action();      // OK, this one is not generic<br/>
public delegate void Action&lt;T&gt;(T obj);<br/>
public delegate void Action&lt;T1, T2&gt;(T1 arg1, T2 arg2);<br/>
public delegate void Action&lt;T1, T2, T3&gt;(T1 arg1, T2 arg2, T3 arg3);<br/>
public delegate void Action&lt;T1.....T16&gt;(T1 arg1.....T16 arg16);</code></p>
<p>So the .NET Framework now ships with 17 <b>Action </b>delegates that range from having no arguments to having 16 arguments. If you ever need to call a method that has more than 16 arguments, you will be forced to define your own delegate type, but this is very unlikely.</p>
<p>In addition to the <b>Action </b>delegates, the .NET Framework ships with 17 <b>Func </b>delegates, which allow the callback method to return a value:</p>
<p><code>public delegate TResult Func&lt;TResult&gt;();<br/>
public delegate TResult Func&lt;T, TResult&gt;(T arg);<br/>
public delegate TResult Func&lt;T1, T2, TResult&gt;(T1 arg1, T2 arg2);<br/>
public delegate TResult Func&lt;T1, T2, T3, TResult&gt;(T1 arg1, T2 arg2, T3 arg3);<br/>
public delegate TResult Func&lt;T1......T16, TResult&gt;(T1 arg1.....T16 arg16);</code></p>
<p>It is now recommended that these delegate types be used wherever possible instead of developers defining even more delegate types in their code. This reduces the number of types in the system and also simplifies coding. However, you might have to define your own delegate if you need to pass an argument by reference using the <b>ref </b>or <b>out </b>keyword:</p>
<p><code>delegate void Bar(ref Int32 z);</code></p>
<p>You may also have to do this if you want your delegate to take a variable number of arguments via C#'s <b>params </b>keyword, if you want to specify any default values for any of your delegate's arguments, or if you need to constrain a delegate's generic type argument, as in the following code:</p>
<p><code>delegate void EventHandler&lt;TEventArgs&gt;(Object sender, TEventArgs e) where TEventArgs : EventArgs;</code></p>
<p><b>I-</b></p>
<hr/>
<blockquote><b>Note </b>The <b>Action </b>and <b>Func </b>delegate types that take 0 to 8 arguments are defined in MSCorLib.dll since methods that take this many of arguments are fairly commonplace. However, the <b>Action </b>and <b>Func </b>delegate types that take 9 to 16 arguments are defined in System.Core.dll, as methods that take this many arguments are rare. And, in fact, these delegate definitions are mostly used internally by dynamic programming languages and are not generally used by developers directly.</blockquote>
<hr/>
<p>When using delegates that take generic arguments and return values, contra-variance and covariance come into play, and it is recommended that you always take advantage of these features because they have no ill effects and enable your delegates to be used in more scenarios. For more information about this, see the &quot;Delegate and Interface Contravariant and Covariant Generic Type Arguments&quot; section in Chapter 12, &quot;Generics.&quot;</p>
<a name="b423"/><h2>C#'s Syntactical Sugar for Delegates</h2>
<p>Most programmers find working with delegates to be cumbersome because the syntax is so strange For example, take this line of code:</p>
<p><code>buttonLClick += new EventHandler(button1_Click);</code></p>
<p>where <b>button1_Click </b>is a method that looks something like this:</p>
<p><code>void button1_Click(Object sender, EventArgs e) { // Do something, the button was clicked...<br/>
}</code></p>
<p>The idea behind the first line of code is to register the address of the <b>button1_Click </b>method with a button control so that when the button is clicked, the method will be called. To most programmers, it feels quite unnatural to construct an <b>EventHandler </b>delegate object just to specify the address of the <b>button1_Click </b>method. However, constructing the <b>EventHandler </b>delegate object is required for the CLR because this object provides a wrapper that ensures that the method can be called only in a type-safe fashion. The wrapper also allows the calling of instance methods and chaining. Unfortunately, most programmers don't want to think about these details. Programmers would prefer to write the code above as follows:</p>
<p><code>buttonLClick += button1_Click;</code></p>
<p>Fortunately, Microsoft's C# compiler offers programmers some syntax shortcuts when working with delegates. I'll explain all of these shortcuts in this section. One last point before we begin: what I'm about to describe really boils down to C# syntactical sugar; these new syntax shortcuts are really just giving programmers an easier way to produce the IL that must be generated so that the CLR and other programming languages can work with delegates This also means that what I'm about to describe is specific to C#; other compilers might not offer the additional delegate syntax shortcuts.</p>
<h3>Syntactical Shortcut #1: No Need to Construct a Delegate Object</h3>
<p>As demonstrated already, C# allows you to specify the name of a callback method without having to construct a delegate object wrapper Here is another example:</p>
<p><code>internal sealed class AClass {<br/>
public static void CallbackWithoutNewingADelegateObject() { ThreadPool.QueueUserWorkItem(SomeAsyncTask, 5);<br/>
}<br/>
private static void SomeAsyncTask(Object o) { Console.WriteLine(o);<br/>
}<br/>
}</code></p>
<p>Here, the <b>ThreadPool </b>class's static <b>QueueUserWorkItem </b>method expects a reference to a <b>WaitCallback </b>delegate object that contains a reference to the <b>SomeAsyncTask </b>method. Since the C# compiler is capable of inferring this on its own, it allows me to omit code that constructs the <b>WaitCallback </b>delegate object, making the code much more readable and understandable Of course, when the code is compiled, the C# compiler does produce IL that does, in fact, new up the <b>WaitCallback </b>delegate object謡e just got a syntactical shortcut.</p>
<h3>Syntactical Shortcut #2: No Need to Define a Callback Method</h3>
<p>In the code above, the name of the callback method, <b>SomeAsyncTask, </b>is passed to the <b>ThreadPool</b>'s <b>QueueUserWorkItem </b>method. C# allows you to write the code for the callback method inline so it doesn't have to be written inside its very own method. For example, the code above could be rewritten as follows:</p>
<p><code>internal sealed class AClass {<br/>
public static void CallbackWithoutNewingADelegateObject() {<br/>
ThreadPool.QueueUserWorkItem( obj =&gt; Console.WriteLine(obj), 5);<br/>
}<br/>
}</code></p>
<p>Notice that the first &quot;argument&quot; to the <b>QueueUserWorkItem </b>method is code (which I italicized)! More formally, the italicized code is called a C# lambda expression, and it is easy to detect due to the use of C#'s lambda expression operator: <b>=&gt;</b>. You may use a lambda expression in your code where the compiler would normally expect to see a delegate. And, when the compiler sees the use of this lambda expression, the compiler automatically defines a new private method in the class <b>(AClass, </b>in this example). This new method is called an anonymous function because the compiler creates the name of the method for you automatically, and normally, you wouldn't know its name. However, you could use a tool such as ILDasm exe to examine the compiler-generated code After I wrote the code above and compiled it, I was able to see, by using ILDasm.exe, that the C# compiler decided to name this method <b>&lt;CallbackWithoutNewingADelegateObject&gt;b__0 </b>and ensured that this method took a single <b>Object </b>argument and returned <b>void.</b></p>
<p>The compiler chose to start the method name with a <b>&lt; </b>sign because in C#, an identifier cannot contain a <b>&lt; </b>sign; this ensures that you will not accidentally define a method that coincides with the name the compiler has chosen for you. Incidentally, while C# forbids identifiers to contain a <b>&lt; </b>sign, the CLR allows it, and that is why this works. Also, note that while you could access the method via reflection by passing the method name as a string, the C# language specification states that there is no guarantee of how the compiler generates the name For example, each time you compile the code, the compiler could produce a different name for the method.</p>
<p>Using ILDasm.exe, you might also notice that the C# compiler applies the <b>System.Runtime.CompilerServices.CompilerGeneratedAttribute </b>attribute to this method to indicate to various tools and utilities that this method was produced by a compiler as opposed to a programmer. The code to the right of the <b>=&gt; </b>operator is then placed in this compiler-generated method.</p>
<hr/>
<blockquote><b>Note </b>When writing a lambda expression, there is no way to apply your own custom attribute to the compiler-generated method. Furthermore, you cannot apply any method modifiers (such as <b>unsafe) </b>to the method. But this is usually not a problem because anonymous methods generated by the compiler always end up being private, and the method is either static or nonstatic depending on whether the method accesses any instance members. So there is no need to apply modifiers such as <b>public, protected, internal, virtual, sealed, override, </b>or <b>abstract </b>to the method.</blockquote>
<hr/>
<p>Finally, if you write the code shown above and compile it, it's as if the C# compiler rewrote your code to look like this (comments inserted by me):</p>
<p><code>internal sealed class AClass {<br/>
// This private field is created to cache the delegate object.<br/>
// Pro: CallbackWithoutNewingADelegateObject will not create<br/>
//.a new object each time it is called.<br/>
// Con: The cached object never gets garbage collected<br/>
[CompilerCenerated]<br/>
private static WaitCallback &lt;&gt;9_CachedAnonymousMethodDelegate1;<br/>
public static void CallbackWithoutNewingADelegateObject() {<br/>
if (&lt;&gt;9_CachedAnonymousMethodDelegate1 == null) {<br/>
// First time called, create the delegate object and cache it.<br/>
&lt;&gt;9_CachedAnonymousMethodDelegate1 =<br/>
new WaitCallback(&lt;CallbackWithoutNewingADelegateObject&gt;b_0);<br/>
}<br/>
ThreadPool.QueueUserWorkItem(&lt;&gt;9_CachedAnonymousMethodDelegate1, 5);<br/>
}<br/>
[CompilerCenerated]<br/>
private static void &lt;CallbackWithoutNewingADelegateObject&gt;b_0(Object obj) {<br/>
Console.WriteLine(obj);<br/>
}<br/>
}</code></p>
<p>The lambda expression must match that of the <b>WaitCallback </b>delegate: it returns <b>void </b>and takes an <b>Object </b>parameter. However, I specified the name of the parameter by simply putting <b>obj </b>to the left of the <b>=&gt; </b>operator. On the right of the <b>=&gt; </b>operator, <b>Console.WriteLine </b>happens to return <b>void. </b>However, if I had placed an expression that did not return <b>void, </b>the compiler-generated code would just ignore the return value because the method that the compiler generates must have a <b>void </b>return type to satisfy the <b>WaitCallback </b>delegate.</p>
<p>It is also worth noting that the anonymous function is marked as <b>private; </b>this forbids any code not defined within the type from accessing the method (although reflection will reveal that the method does exist). Also, note that the anonymous method is marked as <b>static; </b>this is because the code doesn't access any instance members (which it can't since <b>CallbackWithoutNewingADelegateObject </b>is itself a static method. However, the code can reference any static fields or static methods defined within the class. Here is an example:</p>
<p><code>internal sealed class AClass {<br/>
private static String sm_name;   // A static field<br/>
public static void CallbackWithoutNewingADelegateObject() { ThreadPool.QueueUserWorkItem(<br/>
// The callback code can reference static members. obj =&gt;Console.WriteLine(sm_name+ &quot;: &quot; + obj),<br/>
5);<br/>
}<br/>
}</code></p>
<p>If the <b>CallbackWithoutNewingADelegateObject </b>method had not been static, the anonymous method's code could contain references to instance members If it doesn't contain references to instance members, the compiler will still produce a static anonymous method since this is more efficient than an instance method because the additional <b>this </b>parameter is not necessary. But, if the anonymous method's code does reference an instance member, the compiler will produce a nonstatic anonymous method:</p>
<p><code>internal sealed class AClass {<br/>
private String m_name;   // An instance field<br/>
// An instance method<br/>
public void CallbackWithoutNewingADelegateObject() { ThreadPool.QueueUserWorkItem(<br/>
// The callback code can reference instance members. obj =&gt; Console.WriteLine(m_name+ &quot;: &quot; + obj),<br/>
5);<br/>
}<br/>
}</code></p>
<p>On the left-hand side of the <b>=&gt; </b>operator is where you specify the names of any arguments that are to be passed to the lambda expression. There are some rules you must follow here. See the examples below:</p>
<p><code>// If the delegate takes no arguments, use () Func&lt;String&gt; f = () =&gt; &quot;Jeff&quot;;<br/>
// If the delegate takes 1+ arguments, you can explicitly specify the types Func&lt;Int32, String&gt; f2 = (Int32 n) =&gt; n.ToString<b>O;</b><br/>
Func&lt;Int32, Int32, String&gt; f3 = (Int32 n1, Int32 n2) =&gt; (n1 + n2).ToString();<br/>
// If the delegate takes 1+ arguments, the compiler can infer the types<br/>
Func&lt;Int32, String&gt; f4 = (n) =&gt; n.ToString<b>O;</b><br/>
Func&lt;Int32, Int32, String&gt; f5 = (n1, n2) =&gt; (n1 + n2).ToString();<br/>
// If the delegate takes 1 argument, you can omit the ()s Func&lt;Int32, String&gt; f6 = n =&gt; n.ToString<b>O;</b><br/>
// If the delegate has ref/out arguments, you must explicitly specify ref/out and the type Bar b = (out Int32 n) =&gt; n = 5;</code></p>
<p>For the last example, assume that <b>Bar </b>is defined as follows: delegate void Bar(out Int32 z);</p>
<p>On the right-hand side of the <b>=&gt; </b>operator is where you specify the anonymous function body. It is very common for the body to consist of a simple or complex expression that ultimately returns a non<b>-void </b>value. In the code just above, I was assigning lambda expressions that returned <b>String</b>s to all the <b>Func </b>delegate variables. It is also quite common for the body to consist of a single statement. An example of this is when I called <b>ThreadPool.QueueUserWorkItem, </b>passing it a lambda expression that called <b>Console.WriteLine </b>(which returns <b>void).</b></p>
<p>If you want the body to consist of two or more statements, then you must enclose it in curly braces. And if the delegate expects a return value, then you must have a <b>return </b>statement inside the body. Here is an example:</p>
<p><code>Func&lt;Int32, Int32, String&gt; f7 = (n1, n2) =&gt; { Int32 sum = n1 + n2; return sum.ToStringO; };</code></p>
<hr/>
<blockquote><b>Important </b>In case it's not obvious, let me explicitly point out that the main benefit of lambda expressions is that they remove a level of indirection from within your source code. Normally, you'd have to write a separate method, give that method a name, and then pass the name of that method where a delegate is required The name gives you a way to refer to a body of code, and if you need to refer to the same body of code from multiple locations in your source code, then writing a method and giving it a name is a great way to go. However, if you need to have a body of code that is referred to only once within your source code, then a lambda expression allows you to put that code directly inline without having to assign it a name, thus increasing programmer productivity.</blockquote>
<hr/>
<hr/>
<blockquote><b>Note </b>When C# 2.0 came out, it introduced a feature called anonymous methods. Like lambda expressions (introduced in C# 3.0), anonymous methods describes a syntax for creating anonymous functions. It is now recommended (in section 7 14 of the C# Language Specification) that developers use the newer lambda expression syntax rather than the older anonymous method syntax because the lambda expression syntax is more terse, making code easier to write, read, and maintain. Of course, Microsoft's C# compiler continues to support parsing both syntaxes for creating anonymous functions so that developers are not forced to modify any code that was originally written for C# 2.0. In this book, I will explain and use only the lambda expression syntax.</blockquote>
<hr/>
<h3>Syntactical Shortcut #3: No Need to Wrap Local Variables in a Class Manually to Pass Them to a Callback Method</h3>
<p>I've already shown how the callback code can reference other members defined in the class. However, sometimes, you might like the callback code to reference local parameters or variables that exist in the defining method. Here's an interesting example:</p>
<p><code>internal sealed class AClass {<br/>
public static void UsingLocalVariablesInTheCallbackCode(Int32 numToDo) { // Some local variables Int32[] squares = new Int32[numToDo]; AutoResetEvent done = new AutoResetEvent(false);<br/>
// Do a bunch of tasks on other threads for (Int32 n = 0; n &lt; squares.Length; n++) { ThreadPool.QueueUserWorkItem( obj =&gt; {<br/>
Int32 num = (Int32) obj;<br/>
// This task would normally be more time consuming squares[num] = num * num;<br/>
// If last task, let main thread continue running if (Interlocked.DecrementCref numToDo) == 0) done.SetC);<br/>
}, n);<br/>
}<br/>
// Wait for all the other threads to finish done.WaitOneC);<br/>
// Show the results<br/>
for (Int32 n = 0; n &lt; squares.Length; n++)<br/>
Console.WriteLineC'Index {0}, Square={1}&quot;, n, squares[n]);<br/>
}<br/>
}</code></p>
<p>This example really shows off how easy C# makes implementing what used to be a pretty complex task. The method above defines one parameter, <b>numToDo, </b>and two local variables, <b>squares </b>and <b>done </b>. And the body of the lambda expression refers to these variables.</p>
<p>Now imagine that the code in the body of the lambda expression is placed in a separate method (as is required by the CLR). How would the values of the variables be passed to the separate method? The only way to do this is to define a new helper class that also defines a field for each value that you want passed to the callback code. In addition, the callback code would have to be defined as an instance method in this helper class. Then, the <b>UsingLocalVariablesInTheCallbackCode </b>method would have to construct an instance of the helper class, initialize the fields from the values in its local variables, and then construct the delegate object bound to the helper object/instance method.</p>
<hr/>
<blockquote><b>Note </b>When a lambda expression causes the compiler to generate a class with parameter/local variables turned into fields, the lifetime of the objects that the variables refer to are lengthened. Usually, a parameter/local variable goes out of scope at the last usage of the variable within a method. However, turning the variable into a field causes the field to keep the object that it refers to alive for the whole lifetime of the object containing the field. This is not a big deal in most applications, but it is something that you should be aware of.</blockquote>
<hr/>
<p>This is very tedious and error-prone work, and, of course, the C# compiler does all this for you automatically When you write the code shown above, it's as if the C# compiler rewrites your code so that it looks something like this (comments inserted by me):</p>
<p><code>internal sealed class AClass {<br/>
public static void UsingLocalVariablesInTheCallbackCode(Int32 numToDo) {<br/>
// Some local variables WaitCallback callback1 = null;<br/>
// Construct an instance of the helper class<br/>
&lt;&gt;c_DisplayClass2 class1 = new &lt;&gt;c_DisplayClass2();<br/>
// Initialize the helper class's fields classl.numToDo = numToDo; classl.squares = new Int32[class1.numToDo]; classLdone = new AutoResetEvent(false);<br/>
// Do a bunch of tasks on other threads for (Int32 n = 0; n &lt; classLsquares.Length; n++) { if (callback1 == null) {<br/>
// New up delegate object bound to the helper object and // its anonymous instance method callback1 = new WaitCallback(<br/>
class1.&lt;UsingLocalVariablesInTheCallbackCode&gt;b_0);<br/>
}<br/>
ThreadPool.QueueUserWorkItem(callback1, n);<br/>
}<br/>
// Wait for all the other threads to finish class1.done.WaitOne();<br/>
// Show the results<br/>
for (Int32 n = 0; n &lt; classLsquares.Length; n++)<br/>
Console.WriteLineC'Index {0}, Square={1}&quot;, n, class1.squares[n]);<br/>
}<br/>
// The helper class is given a strange name to avoid potential // conflicts and is private to forbid access from outside AClass [CompilerGenerated]<br/>
private sealed class &lt;&gt;c__DisplayClass2 : Object {<br/>
// One public field per local variable used in the callback code public Int32[] squares; public Int32 numToDo; public AutoResetEvent done;<br/>
// public parameterless constructor public &lt;&gt;c__DisplayClass2 { }<br/>
// Public instance method containing the callback code<br/>
public void &lt;UsingLocalVariablesInTheCallbackCode&gt;b__0(Object obj) {<br/>
Int32 num = (Int32) obj;<br/>
squares[num] = num * num;<br/>
if (Interlocked.Decrement(ref numToDo) == 0) done.Set();<br/>
}<br/>
}<br/>
}</code></p>
<hr/>
<blockquote><b>Important </b>Without a doubt, it doesn't take much for programmers to start abusing C#'s lambda expression feature. When I first started using lambda expressions, it definitely took me some time to get used to them. After all, the code that you write in a method is not actually inside that method, and this also can make debugging and single-stepping through the code a bit more challenging. In fact, I'm amazed at how well the Microsoft Visual Studio debugger actually handles stepping through lambda expressions in my source code.</blockquote>
<hr/>
<p>I've set up a rule for myself: If I need my callback method to contain more than three lines of code, I will not use a lambda expression; instead, I'll write the method manually and assign it a name of my own creation. But, used judiciously, lambda expressions can greatly increase programmer productivity as well as the maintainability of your code. Below is some code in which using lambda expressions feels very natural Without them, this code would be tedious to write, harder to read, and harder to maintain:</p>
<p><code>// Create an initialize a String array<br/>
String[] names = { &quot;Jeff&quot;, &quot;Kristin&quot;, &quot;Aidan&quot;, &quot;Grant&quot; };<br/>
// Get just the names that have a lowercase 'a' in them. Char charToFind = 'a';<br/>
names = Array.FindAll(names, name =&gt; name.IndexOf(charToFind) &gt;= 0);<br/>
// Convert each string's characters to uppercase<br/>
names = Array.ConvertAll(names, name =&gt; name.ToUpperO);<br/>
// Display the results<br/>
Array.ForEach(names, Console.WriteLine);</code></p>
<a name="b431"/><h2>Delegates and Reflection</h2>
<p>So far in this chapter, the use of delegates has required the developer to know up front the prototype of the method that is to be called back. For example, if <b>fb </b>is a variable that references a <b>Feedback </b>delegate (see this chapter's first program listing), to invoke the delegate, the code would look like this:</p>
<p><code>fb(item);     // item is defined as Int32</code></p>
<p>As you can see, the developer must know when coding how many parameters the callback method requires and the types of those parameters Fortunately, the developer almost always has this information, so writing code like the preceding code isn't a problem.</p>
<p>In some rare circumstances, however, the developer doesn't have this information at compile time. I showed an example of this in Chapter 11, &quot;Events,&quot; when I discussed the <b>EventSet </b>type. In this example, a dictionary maintained a set of different delegate types. At runtime, to raise an event, one of the delegates was looked up in the dictionary and invoked. At compile time, it wasn't possible to know exactly which delegate would be called and which parameters were necessary to pass to the delegate's callback method.</p>
<p>Fortunately, <b>System.Delegate </b>offers a few methods that allow you to create and invoke a delegate when you just don't have all the necessary information about the delegate at compile time. Here are the corresponding methods that <b>Delegate </b>defines:</p>
<p><code>public abstract class Delegate {<br/>
// Construct a 'type' delegate wrapping the specified static method. public static Delegate CreateDelegate(Type type, MethodInfo method); public static Delegate CreateDelegate(Type type, MethodInfo method, Boolean throwOnBindFailure);<br/>
// Construct a 'type' delegate wrapping the specified instance method. public static Delegate CreateDelegate(Type type,<br/>
Object firstArgument, MethodInfo method); // firstArgument means 'this' public static Delegate CreateDelegate(Type type,<br/>
Object firstArgument, MethodInfo method, Boolean throwOnBindFailure);<br/>
// Invoke a delegate passing it parameters<br/>
public Object DynamicInvoke(params Object[] args);<br/>
}</code></p>
<p>All of the <b>CreateDelegate </b>methods here construct a new object of a <b>Delegate</b>-derived type identified by the first parameter, <b>type </b>. The <b>Methodlnfo </b>parameter indicates the method that should be called back; you'd use reflection APIs (discussed in Chapter 23, &quot;Assembly Loading and Reflection&quot;) to obtain this value. If you want the delegate to wrap an instance method, you will also pass to <b>CreateDelegate </b>a <b>firstArgument </b>parameter indicating the object that should be passed as the <b>this </b>parameter (first argument) to the instance method. Finally, <b>CreateDelegate </b>normally throws an <b>ArgumentException </b>if the delegate cannot bind to the method specified by the <b>method </b>parameter This can happen if the signature of the method identified by <b>method </b>doesn't match the signature required by the delegate identified by the <b>type </b>parameter. However, if you pass <b>false </b>for the <b>throwOnBindFailure </b>parameter, an <b>ArgumentException </b>will not be thrown; <b>null </b>will be returned instead.</p>
<hr/>
<blockquote><b>Important </b>The <b>System.Delegate </b>class has many more overloads of the <b>CreateDelegate</b></blockquote>
<hr/>
<p>method that I do not show here. You should never call any of these other methods. As a matter of fact, Microsoft regrets even defining them in the first place. The reason is because these other methods identify the method to bind to by using a <b>String </b>instead of a <b>MethodInfo </b>This means that an ambiguous bind is possible causing your application to behave unpredictably.</p>
<p><b>System.Delegate</b>'s <b>DynamicInvoke </b>method allows you to invoke a delegate object's callback method, passing a set of parameters that you determine at runtime When you call <b>DynamicInvoke, </b>it internally ensures that the parameters you pass are compatible with the parameters the callback method expects. If they're compatible, the callback method is called. If they're not, an <b>ArgumentException </b>is thrown. <b>DynamicInvoke </b>returns the object the callback method returned.</p>
<p>The following code shows how to use the <b>CreateDelegate </b>and <b>DynamicInvoke </b>methods:</p>
<p><code>using System;<br/>
using System.Reflection;<br/>
using System.IO;<br/>
// Here are some different delegate definitions internal delegate Object TwoInt32s(Int32 n1, Int32 n2); internal delegate Object OneString(String s1);<br/>
public static class Program {<br/>
public static void Main(String[] args) { if (args.Length &lt; 2) {<br/>
String fileName = Path.CetFileNameWithoutExtension( Assembly.CetEntryAssembly().Location); String usage = @&quot;Usage:&quot; +<br/>
&quot;{0}{1} delType methodName [Arg1] [Arg2]&quot; +<br/>
&quot;{0}     where delType must be TwoInt32s or OneString&quot;+<br/>
&quot;{0}     if delType is TwoInt32s, methodName must be Add or Subtract&quot; +<br/>
&quot;{0}     if delType is OneString, methodName must be NumChars or Reverse&quot; +<br/>
&quot;{0}&quot; +<br/>
&quot;{0}Examples:&quot; +<br/>
&quot;{0}   {1} TwoInt32s Add 123 321&quot; + &quot;{0}   {1} TwoInt32s Subtract 123 321&quot; +<br/>
&quot;{0}     {1} OneString NumChars \&quot;Hello there\&quot;&quot; + &quot;{0}     {1} OneString Reverse   \&quot;Hello there\&quot;&quot;; Console.WriteLine(usage, Environment.NewLine, fileName); return;<br/>
}<br/>
// Convert the delType argument to a delegate type Type delType = Type.CetType(args[0]); if (delType == null) {<br/>
Console.WriteLine(&quot;Invalid delType argument: &quot; + args[0]);<br/>
return;<br/>
}<br/>
Delegate d;<br/>
try {<br/>
// Convert the Arg1 argument to a method MethodInfo mi = typeof(Program).CetMethod(args[1], BindingFlags.NonPublic | BindingFlags.Static);<br/>
// Create a delegate object that wraps the static method d = Delegate.CreateDelegate(delType, mi);<br/>
}<br/>
catch (ArgumentException) {<br/>
Console.WriteLine(&quot;Invalid methodName argument: &quot; + args[1]); return;<br/>
}<br/>
// Create an array that will contain just the arguments // to pass to the method via the delegate object Object[] callbackArgs = new Object[args.Length - 2];<br/>
if (d.CetType() == typeof(TwoInt32s)) {<br/>
try {<br/>
// Convert the String arguments to Int32 arguments for (Int32 a = 2; a &lt; args.Length; a++)<br/>
callbackArgs[a - 2] = Int32.Parse(args[a]);<br/>
}<br/>
catch (FormatException) {<br/>
Console.WriteLine(&quot;Parameters must be integers.&quot;); return;<br/>
}<br/>
}<br/>
if (d.GetType() == typeof(OneString)) { // Just copy the String argument<br/>
Array.Copy(args, 2, callbackArgs, 0, callbackArgs.Length);<br/>
}<br/>
try {<br/>
// Invoke the delegate and show the result Object result = d.DynamicInvoke(callbackArgs); Console.WriteLine(&quot;Result = &quot; + result);<br/>
}<br/>
catch (TargetParameterCountException) {<br/>
Console.WriteLine(&quot;Incorrect number of parameters specified.&quot;);<br/>
}<br/>
}<br/>
// This callback method takes 2 Int32 arguments private static Object Add(Int32 n1, Int32 n2) { return n1 + n2;<br/>
}<br/>
// This callback method takes 2 Int32 arguments private static Object Subtract(Int32 n1, Int32 n2) { return n1 - n2;<br/>
}<br/>
// This callback method takes 1 String argument private static Object NumChars(String s1) { return s1.Length;<br/>
}<br/>
// This callback method takes 1 String argument private static Object Reverse(String s1) {<br/>
Char[] chars = s1.ToCharArray();<br/>
Array.Reverse(chars);<br/>
return new String(chars);<br/>
}<br/>
}</code></p>
<mbp:pagebreak/>
<a name="Chapter18"/>
<h1>Chapter 18: Custom Attributes</h1>
<p><b>In this chapter:</b></p>
<a href="#b435">Using Custom Attributes</a><br/>
<a href="#b439">Defining Your Own Attribute Class</a><br/>
<a href="#b443">Attribute Constructor and Field/Property Data Types</a><br/>
<a href="#b444">Detecting the Use of a Custom Attribute</a><br/>
<a href="#b448">Matching Two Attribute Instances Against Each Other</a><br/>
<a href="#b451">Detecting the Use of a Custom Attribute Without Creating Attribute-Derived Objects</a><br/>
<a href="#b454">Conditional Attribute Classes</a><br/>
<p>In this chapter, I'll discuss one of the most innovative features the Microsoft .NET Framework has to offer: custom attributes. Custom attributes allow you to declaratively annotate your code constructs, thereby enabling special features. Custom attributes allow information to be defined and applied to almost any metadata table entry. This extensible metadata information can be queried at runtime to dynamically alter the way code executes. As you use the various .NET Framework technologies (Windows Forms, Web Forms, XML Web services, and so on), you'll see that they all take advantage of custom attributes, allowing developers to express their intentions within code very easily. A solid understanding of custom attributes is necessary for any .NET Framework developer.</p>
<a name="b435"/><h2>Using Custom Attributes</h2>
<p>Attributes, such as <b>public, private, static, </b>and so on, can be applied to types and members I think we'd all agree on the usefulness of applying attributes, but wouldn't it be even more useful if we could define our own attributes? For example, what if I could define a type and somehow indicate that the type can be remoted via serialization? Or maybe I could apply an attribute to a method to indicate that certain security permissions must be granted before the method can execute.</p>
<p>Of course, creating and applying user-defined attributes to types and methods would be great and convenient, but it would require the compiler to be aware of these attributes so it would emit the attribute information into the resulting metadata. Because compiler vendors usually prefer not to release the source code for their compiler, Microsoft came up with another way to allow user-defined attributes. This mechanism, called custom attributes, is an incredibly powerful mechanism that's useful at both application design time and runtime. Anyone can define and use custom attributes, and all compilers that target the common language runtime (CLR) must be designed to recognize custom attributes and emit them into the resulting metadata.</p>
<p>The first thing you should realize about custom attributes is that they're just a way to associate additional information with a target The compiler emits this additional information into the managed module's metadata Most attributes have no meaning for the compiler; the compiler simply detects the attributes in the source code and emits the corresponding metadata.</p>
<p>The .NET Framework Class Library (FCL) defines literally hundreds of custom attributes that can be applied to items in your own source code Here are some examples:</p>
<p>&#9632; Applying the <b>DllImport </b>attribute to a method informs the CLR that the implementation of the method is actually in unmanaged code contained in the specified DLL.</p>
<p>&#9632; Applying the <b>Serializable </b>attribute to a type informs the serialization formatters that an instance's fields may be serialized and deserialized.</p>
<p>&#9632; Applying the <b>AssemblyVersion </b>attribute to an assembly sets the version number of the assembly.</p>
<p>&#9632; Applying the <b>Flags </b>attribute to an enumerated type causes the enumerated type to act as a set of bit flags.</p>
<p>Following is some C# code with many attributes applied to it. In C#, you apply a custom attribute to a target by placing the attribute in square brackets immediately before the target. It's not important to understand what this code does I just want you to see what attributes look like.</p>
<p><code>using System;<br/>
using System.Runtime.InteropServices;<br/>
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]<br/>
internal sealed class OSVERSIONINFO { public OSVERSIONINFO() {<br/>
OSVersionInfoSize = (UInt32).Marshal.SizeOf(this);<br/>
}<br/>
public UInt32 OSVersionInfoSize.= 0;<br/>
public UInt32 MajorVersion.= 0;<br/>
public UInt32 MinorVersion.= 0;<br/>
public UInt32 BuildNumber.= 0;<br/>
public UInt32 PlatformId.= 0;<br/>
[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)] public String CSDVersion.= null;<br/>
}<br/>
internal sealed class MyClass {<br/>
[DllImport(&quot;Kernel32&quot;, CharSet = CharSet.Auto, SetLastError = true)] public static extern Boolean GetVersionEx([In, Out] OSVERSIONINFO ver);<br/>
}</code></p>
<p>In this case, the <b>StructLayout </b>attribute is applied to the <b>OSVERSIONINFO </b>class, the <b>MarshalAs </b>attribute is applied to the <b>CSDVersion </b>field, the <b>DllImport </b>attribute is applied to the <b>GetVersionEx </b>method, and the <b>In </b>and <b>Out </b>attributes are applied to <b>GetVersionEx</b>'s <b>ver </b>parameter. Every programming language defines the syntax a developer must use in order to apply a custom attribute to a target. Microsoft Visual Basic.NET, for example, requires angle brackets (<b>&lt;</b>, <b>&gt;</b>) instead of square brackets.</p>
<p>The CLR allows attributes to be applied to just about anything that can be represented in a file's metadata. Most commonly, attributes are applied to entries in the following definition tables: TypeDef (classes, structures, enumerations, interfaces, and delegates), MethodDef (including constructors), ParamDef, FieldDef, PropertyDef, EventDef, AssemblyDef, and ModuleDef Specifically, C# allows you to apply an attribute only to source code that defines any of the following targets: assembly, module, type (class, struct, enum, interface, delegate), field, method (including constructors), method parameter, method return value, property, event, and generic type parameter.</p>
<p>When you're applying an attribute, C# allows you to specify a prefix specifically indicating the target the attribute applies to. The following code shows all of the possible prefixes. In many cases, if you leave out the prefix, the compiler can still determine the target an attribute applies to, as shown in the previous example. In some cases, the prefix must be specified to make your intentions clear to the compiler. The prefixes shown in italics below are mandatory.</p>
<p><code>using System;</code></p>
<p>[assembly: SomeAttr]// Applied to assembly</p>
<p>[module:     SomeAttr]// Applied to module</p>
<p><code>[type:        SomeAttr]// Applied to type<br/>
internal sealed class SomeType&lt;[typevar: SomeAttr] T&gt; {    // Applied to generic type variable<br/>
[field: SomeAttr]// Applied.to field public Int32 SomeField = 0;</code></p>
<p>[return: SomeAttr]// Applied.to return value</p>
<p><code>[method: SomeAttr]// Applied.to method public Int32 SomeMethod(<br/>
[param: SomeAttr]// Applied.to parameter<br/>
Int32 SomeParam) { return SomeParam; }<br/>
[property: SomeAttr]// Applied to property<br/>
public String SomeProp {<br/>
[method: SomeAttr]// Applied to get accessor method<br/>
get { return null; }<br/>
}<br/>
[event:   SomeAttr]// Applied to event</code></p>
<p>[field:   SomeAttr]// Applied to compiler-generated field</p>
<p>[method: SomeAttr]// Applied to compiler-generated add &amp; remove methods</p>
<p><code>public event EventHandler SomeEvent;<br/>
}</code></p>
<p>Now that you know how to apply a custom attribute, let's find out what an attribute really is. A custom attribute is simply an instance of a type. For Common Language Specification (CLS) compliance, custom attribute classes must be derived, directly or indirectly, from the public abstract <b>System.Attribute </b>class. C# allows only CLS-compliant attributes. By examining the .NET Framework SDK documentation, you'll see that the following classes (from the earlier example) are defined: <b>StructLayoutAttribute, MarshalAsAttribute, DllImportAttribute, InAttribute, </b>and <b>OutAttribute. </b>All of these classes happen to be defined in the <b>System.Runtime.InteropServices </b>namespace, but attribute classes can be defined in any namespace. Upon further examination, you'll notice that all of these classes are derived from <b>System.Attribute, </b>as all CLS-compliant attribute classes must be.</p>
<hr/>
<blockquote><b>Note </b>When applying an attribute to a target in source code, the C# compiler allows you to omit the <b>Attribute </b>suffix to reduce programming typing and to improve the readability of the source code My code examples in this chapter take advantage of this C# convenience For example, my source code contains <b>[DllImport(...)] </b>instead of <b>[DllImportAttribute(...)].</b></blockquote>
<hr/>
<p>As I mentioned earlier, an attribute is an instance of a class. The class must have a public constructor so that instances of it can be created. So when you apply an attribute to a target, the syntax is similar to that for calling one of the class's instance constructors. In addition, a language might permit some special syntax to allow you to set any public fields or properties associated with the attribute class Let's look at an example Recall the application of the <b>DllImport </b>attribute as it was applied to the <b>GetVersionEx </b>method earlier:</p>
<p><code>[DllImport(''Kernel32&quot;, CharSet = CharSet.Auto, SetLastError = true)]</code></p>
<p>The syntax of this line should look pretty strange to you because you could never use syntax like this when calling a constructor. If you examine the <b>DllImportAttribute </b>class in the documentation, you'll see that its constructor requires a single <b>String </b>parameter In this example, <b>&quot;Kernel32&quot; </b>is being passed for this parameter. A constructor's parameters are called positional parameters and are mandatory; the parameter must be specified when the attribute is applied.</p>
<p>What are the other two &quot;parameters&quot;? This special syntax allows you to set any public fields or properties of the <b>DllImportAttribute </b>object after the object is constructed. In this example, when the <b>DllImportAttribute </b>object is constructed and <b>&quot;Kernel32&quot; </b>is passed to the constructor, the object's public instance fields, <b>CharSet </b>and <b>SetLastError, </b>are set to <b>CharSet.Auto </b>and <b>true, </b>respectively. The &quot;parameters&quot; that set fields or properties are called named parameters and are optional because the parameters don't have to be specified when you're applying an instance of the attribute. A little later on, I'll explain what causes an instance of the <b>DllImportAttribute </b>class to actually be constructed.</p>
<p>Also note that it's possible to apply multiple attributes to a single target For example, in this chapter's first program listing, the <b>GetVersionEx </b>method's <b>ver </b>parameter has both the <b>In </b>and <b>Out </b>attributes applied to it When applying multiple attributes to a single target, be aware that the order of attributes has no significance. Also, in C#, each attribute can be enclosed in square brackets, or multiple attributes can be comma-separated within a single set of square brackets. If the attribute class's constructor takes no parameters, the parentheses are optional. Finally, as mentioned earlier, the <b>Attribute </b>suffix is also optional. The following lines behave identically and demonstrate all of the possible ways of applying multiple attributes:</p>
<p><code>[Serializable][Flags]<br/>
[Serializable, Flags]<br/>
[FlagsAttribute, SerializableAttribute]<br/>
[FlagsAttribute()][Serializable()]</code></p>
<a name="b439"/><h2>Defining Your Own Attribute Class</h2>
<p>You know that an attribute is an instance of a class derived from <b>System.Attribute, </b>and you also know how to apply an attribute. Let's now look at how to define your own custom attribute classes. Say you're the Microsoft employee responsible for adding the bit flag support to enumerated types. To accomplish this, the first thing you have to do is define a <b>FlagsAttribute </b>class:</p>
<p><code>namespace System {<br/>
public class FlagsAttribute : System.Attribute { public FlagsAttribute() { }<br/>
}<br/>
}</code></p>
<p>Notice that the <b>FlagsAttribute </b>class inherits from <b>Attribute; </b>this is what makes the <b>FlagsAttribute </b>class a CLS-compliant custom attribute. In addition, the class's name has a suffix of <b>Attribute; </b>this follows the standard convention but is not mandatory. Finally, all non-abstract attributes must contain at least one public constructor The simple <b>FlagsAttribute </b>constructor takes no parameters and does absolutely nothing.</p>
<hr/>
<blockquote><b>Important </b>You should think of an attribute as a logical state container. That is, while an attribute type is a class, the class should be simple The class should offer just one public constructor that accepts the attribute's mandatory (or positional) state information, and the class can offer public fields/properties that accept the attribute's optional (or named) state information. The class should not offer any public methods, events, or other members.</blockquote>
<hr/>
<p>In general, I always discourage the use of public fields, and I still discourage them for attributes. It is much better to use properties because this allows more flexibility if you ever decide to change how the attribute class is implemented.</p>
<p>So far, instances of the <b>FlagsAttribute </b>class can be applied to any target, but this attribute should really be applied to enumerated types only. It doesn't make sense to apply the attribute to a property or a method. To tell the compiler where this attribute can legally be applied, you apply an instance of the <b>System.AttributeUsageAttribute </b>class to the attribute class. Here's the new code:</p>
<p><code>namespace System {<br/>
[AttributeUsage(AttributeTargets.Enum, Inherited = false)] public class FlagsAttribute : System.Attribute { public FlagsAttribute() { }<br/>
}<br/>
}</code></p>
<p>In this new version, I've applied an instance of <b>AttributeUsageAttribute </b>to the attribute After all, the attribute type is just a class, and a class can have attributes applied to it The <b>AttributeUsage </b>attribute is a simple class that allows you to specify to a compiler where your custom attribute can legally be applied. All compilers have built-in support for this attribute and generate errors when a user-defined custom attribute is applied to an invalid target. In this example, the <b>AttributeUsage </b>attribute specifies that instances of the <b>Flags </b>attribute can be applied only to enumerated type targets.</p>
<p>Because all attributes are just types, you can easily understand the</p>
<p><b>AttributeUsageAttribute </b>class. Here's what the FCL source code for the class looks like: [Serializable]</p>
<p><code>[AttributeUsage(AttributeTargets.Class, Inherited=true)] public sealed class AttributeUsageAttribute : Attribute { internal static AttributeUsageAttribute Default = new AttributeUsageAttribute(AttributeTargets.All);<br/>
internal Boolean m_allowMultiple = false;<br/>
internal AttributeTargets m_attributeTarget = AttributeTargets.All; internal Boolean m_inherited = true;<br/>
// This is the one public constructor<br/>
public AttributeUsageAttribute(AttributeTargets validOn) { m_attributeTarget = validOn;<br/>
}<br/>
internal AttributeUsageAttribute(AttributeTargets validOn, Boolean allowMultiple, Boolean inherited) { m_attributeTarget = validOn; m_allowMultiple = allowMultiple; m_inherited = inherited;<br/>
}<br/>
public Boolean AllowMultiple { get { return m_allowMultiple; } set { m_allowMultiple = value; }<br/>
}<br/>
public Boolean Inherited { get { return m_inherited; } set { m_inherited = value; }<br/>
}<br/>
public AttributeTargets ValidOn { get { return m_attributeTarget; }<br/>
}<br/>
}</code></p>
<p>As you can see, the <b>AttributeUsageAttribute </b>class has a public constructor that allows you to pass bit flags that indicate where your attribute can legally be applied. The <b>System.AttributeTargets </b>enumerated type is defined in the FCL as follows:</p>
<p><code>[Flags, Serializable]<br/>
public enum AttributeTargets {<br/>
Assembly.= 0x0001,<br/>
Module.= 0x0002,<br/>
Class.= 0x0004,<br/>
Struct.= 0x0008,<br/>
Enum.= 0x0010,<br/>
Constructor.= 0x0020,<br/>
Method.= 0x0040,<br/>
Property.= 0x0080,<br/>
Field.= 0x0100,<br/>
Event.= 0x0200,<br/>
Interface.= 0x0400,<br/>
Parameter.= 0x0800,<br/>
Delegate.= 0x1000,<br/>
ReturnValue.= 0x2000,<br/>
CenericParameter = 0x4000,<br/>
All.= Assembly       | Module       | Class       | Struct | Enum |<br/>
Constructor | Method       | Property | Field    | Event | Interface     | Parameter | Delegate | ReturnValue | CenericParameter<br/>
}</code></p>
<p>The <b>AttributeUsageAttribute </b>class offers two additional public properties that can optionally be set when the attribute is applied to an attribute class: <b>AllowMultiple </b>and <b>Inherited </b>.</p>
<p>For most attributes, it makes no sense to apply them to a single target more than once. For example, nothing is gained by applying the <b>Flags </b>or <b>Serializable </b>attributes more than once to a single target. In fact, if you tried to compile the code below, the compiler would report the following message: <b>&quot;error CS0579: Duplicate 'Flags' attribute.&quot;</b></p>
<p><code>[Flags][Flags]<br/>
internal enum Color {<br/>
Red<br/>
}</code></p>
<p>For a few attributes, however, it does make sense to apply the attribute multiple times to a single target. In the FCL, the <b>ConditionalAttribute </b>attribute class allows multiple instances of itself to be applied to a single target. If you don't explicitly set <b>AllowMultiple </b>to <b>true, </b>your attribute can be applied no more than once to a selected target.</p>
<p><b>AttributeUsageAttribute</b>'s other property, <b>Inherited, </b>indicates if the attribute should be applied to derived classes and overriding methods when applied on the base class The following code demonstrates what it means for an attribute to be inherited:</p>
<p><code>[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited=true)] internal class TastyAttribute : Attribute {<br/>
}<br/>
[Tasty][Serializable] internal class BaseType {<br/>
[Tasty] protected virtual void DoSomething() { }<br/>
}<br/>
internal class DerivedType : BaseType {<br/>
protected override void DoSomething() { }<br/>
}</code></p>
<p>In this code, <b>DerivedType </b>and its <b>DoSomething </b>method are both considered <b>Tasty </b>because the <b>TastyAttribute </b>class is marked as inherited. However, <b>DerivedType </b>is not serializable because the FCL's <b>SerializableAttribute </b>class is marked as a noninherited attribute.</p>
<p>Be aware that the .NET Framework considers targets only of classes, methods, properties, events, fields, method return values, and parameters to be inheritable. So when you're defining an attribute type, you should set <b>Inherited </b>to <b>true </b>only if your targets include any of these targets. Note that inherited attributes do not cause additional metadata to be emitted for the derived types into the managed module. I'll say more about this a little later in the &quot;Detecting the Use of a Custom Attribute&quot; section.</p>
<p><b>f-</b></p>
<hr/>
<blockquote><b>Note </b>If you define your own attribute class and forget to apply an <b>AttributeUsage </b>attribute</blockquote>
<hr/>
<p><b>i </b>to your class, the compiler and the CLR will assume that your attribute can be applied to all targets, can be applied only once to a single target, and is inherited These assumptions mimic the default field values in the <b>AttributeUsageAttribute </b>class.</p>
<a name="b443"/><h2>Attribute Constructor and Field/Property Data Types</h2>
<p>When defining your own custom attribute class, you can define its constructor to take parameters that must be specified by developers when they apply an instance of your attribute type. In addition, you can define nonstatic public fields and properties in your type that identify settings that a developer can optionally choose for an instance of your attribute class.</p>
<p>When defining an attribute class's instance constructor, fields, and properties, you must restrict yourself to a small subset of data types. Specifically, the legal set of data types is limited to the following: <b>Boolean, Char, Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, String, Type, Object, </b>or an enumerated type. In addition, you can use a single-dimensional, zero-based array of any of these types. However, you should avoid using arrays because a custom attribute class whose constructor takes an array is not CLS-compliant.</p>
<p>When applying an attribute, you must pass a compile-time constant expression that matches the type defined by the attribute class. Wherever the attribute class defines a <b>Type </b>parameter, <b>Type </b>field, or <b>Type </b>property, you must use C#'s <b>typeof </b>operator, as shown in the following code. Wherever the attribute class defines an <b>Object </b>parameter, <b>Object </b>field, or <b>Object </b>property, you can pass an <b>Int32, String, </b>or any other constant expression (including <b>null) </b>. If the constant expression represents a value type, the value type will be boxed at runtime when an instance of the attribute is constructed.</p>
<p>Here's an example of an attribute and its usage:</p>
<p><code>using System;<br/>
internal enum Color { Red }<br/>
[AttributeUsage(AttributeTargets.All)]<br/>
internal sealed class SomeAttribute : Attribute {<br/>
public SomeAttribute(String name, Object o, Type[] types) { // 'name' refers to a String<br/>
// 'o' refers to one of the legal types (boxing if necessary) // 'types' refers to a 1-dimension, 0-based array of Types<br/>
}<br/>
}<br/>
[Some(&quot;Jeff&quot;, Color.Red, new Type[] { typeof(Math), typeof(Console) })] internal sealed class SomeType {<br/>
}</code></p>
<p>Logically, when a compiler detects a custom attribute applied to a target, the compiler constructs an instance of the attribute class by calling its constructor, passing it any specified parameters. Then the compiler initializes any public fields and properties using the values specified via the enhanced constructor syntax. Now that the custom attribute object is initialized, the compiler serializes the attribute object's state out to the target's metadata table entry.</p>
<hr/>
<blockquote><b>Important </b>I've found this to be the best way for developers to think of custom attributes: instances of classes that have been serialized to a byte stream that resides in metadata Later, at runtime, an instance of the class can be constructed by deserializing the bytes contained in the metadata In reality, what actually happens is that the compiler emits the information necessary to create an instance of the attribute class into metadata Each constructor parameter is written out with a 1-byte type ID followed by the value. After &quot;serializing&quot; the constructor's parameters, the compiler emits each of the specified field and property values by writing out the field/property name followed by a 1-byte type ID and then the value. For arrays, the count of elements is saved first, followed by each individual element.</blockquote>
<hr/>
<a name="b444"/><h2>Detecting the Use of a Custom Attribute</h2>
<p>Defining an attribute class is useless by itself. Sure, you could define attribute classes all you want and apply instances of them all you want, but this would just cause additional metadata to be written out to the assembly葉he behavior of your application code wouldn't change.</p>
<p>In Chapter 15, &quot;Enumerated Types and Bit Flags,&quot; you saw that applying the <b>Flags </b>attribute to an enumerated type altered the behavior of <b>System.Enum</b>'s <b>ToString </b>and <b>Format </b>methods. The reason that these methods behave differently is that they check at runtime if the enumerated type that they're operating on has the <b>Flags </b>attribute metadata associated with it. Code can look for the presence of attributes by using a technology called reflection. I'll give some brief demonstrations of reflection here, but I'll discuss it fully in Chapter 23, &quot;Assembly Loading and Reflection.&quot;</p>
<p>If you were the Microsoft employee responsible for implementing <b>Enum</b>'s <b>Format </b>method, you would implement it like this:</p>
<p><code>public static String Format(Type enumType, Object value, String format) {<br/>
// Does the enumerated type have an instance of<br/>
// the FlagsAttribute type applied to it?<br/>
if (enumType.IsDefined(typeof(FlagsAttribute), false)) {<br/>
// Yes; execute code treating value as a bit flag enumerated type.<br/>
} else {<br/>
// No; execute code treating value as a normal enumerated type.<br/>
}<br/>
}</code></p>
<p>This code calls <b>Type</b>'s <b>IsDefined </b>method, effectively asking the system to look up the metadata for the enumerated type and see whether an instance of the <b>FlagsAttribute </b>class is associated with it. If <b>IsDefined </b>returns <b>true, </b>an instance of <b>FlagsAttribute </b>is associated with the enumerated type, and the <b>Format </b>method knows to treat the value as though it contained a set of bit flags. If <b>IsDefined </b>returns <b>false, Format </b>treats the value as a normal enumerated type.</p>
<p>So if you define your own attribute classes, you must also implement some code that checks for the existence of an instance of your attribute class (on some target) and then execute some alternate code path. This is what makes custom attributes so useful!</p>
<p>The FCL offers many ways to check for the existence of an attribute. If you're checking for the existence of an attribute via a <b>System.Type </b>object, you can use the <b>IsDefined </b>method as shown earlier. However, sometimes you want to check for an attribute on a target other than a type, such as an assembly, a module, or a method. For this discussion, let's concentrate on the methods defined by the <b>System.Attribute </b>class. You'll recall that all CLS-compliant attributes are derived from <b>System.Attribute. </b>This class defines three static methods for retrieving the attributes associated with a target: <b>IsDefined, GetCustomAttributes, </b>and <b>GetCustomAttribute. </b>Each of these functions has several overloaded versions. For example, each method has a version that works on type members (classes, structs, enums, interfaces, delegates, constructors, methods, properties, fields, events, and return types), parameters, modules, and assemblies. There are also versions that allow you to tell the system to walk up the derivation hierarchy to include inherited attributes in the results. Table 18-1 briefly describes what each method does.</p>
<p><b>Table 18-1 </b><b>System.Attribute's Methods That Reflect over Metadata Looking for Instances of CLS-Compliant Custom Attributes</b></p>
<table border="1">
<tr>
<td>
<p>d</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>d</p>
</td>
<td>
<p>Returns <b>true </b>if there is at least one instance of the specified <b>Attribute</b>-derived class associated with the target. This method is efficient because it doesn't construct (deserialize) any instances of the attribute class.</p>
</td>
</tr>
<tr>
<td>
<p>s</p>
</td>
<td>
<p>Returns an array in which each element is an instance of the specified attribute class that was applied to the target. If no attribute class is given to the method, the array contains the instances of all applied attributes, whatever class they have Each instance is constructed (deserialized) by using the parameters, fields, and properties specified during compilation. If the target has no instances of the specified attribute class, an empty array is returned. This method is typically used with attributes that have <b>AllowMultiple </b>set to <b>true </b>or to list all applied attributes.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Returns an instance of the specified attribute class that was applied to the target The instance is constructed (deserialized) by using the parameters, fields, and properties specified during compilation. If the target has no instances of the specified attribute class, <b>null </b>is returned. If the target has multiple instances of the specified attribute applied to it, a <b>System.Reflection. AmbiguousMatchException </b>exception is thrown. This method is typically used with attributes that have <b>AllowMultiple </b>set to <b>false </b>.</p>
</td>
</tr>
</table>
<p>If you just want to see if an attribute has been applied to a target, you should call <b>IsDefined </b>because it's more efficient than the other two methods. However, you know that when an attribute is applied to a target, you can specify parameters to the attribute's constructor and optionally set fields and properties. Using <b>IsDefined </b>won't construct an attribute object, call its constructor, or set its fields and properties.</p>
<p>If you want to construct an attribute object, you must call either <b>GetCustomAttributes </b>or <b>GetCustomAttribute. </b>Every time one of these methods is called, it constructs new instances of the specified attribute type and sets each of the instance's fields and properties based on the values specified in the source code. These methods return references to fully constructed instances of the applied attribute classes.</p>
<p>When you call any of these methods, internally, they must scan the managed module's metadata, performing string comparisons to locate the specified custom attribute class. Obviously, these operations take time. If you're performance conscious, you should consider caching the result of calling these methods rather than calling them repeatedly asking for the same information.</p>
<p>The <b>System.Reflection </b>namespace defines several classes that allow you to examine the contents of a module's metadata: <b>Assembly, Module, ParameterInfo, MemberInfo, Type, MethodInfo, ConstructorInfo, FieldInfo, EventInfo, PropertyInfo, </b>and their respective <b>*Builder </b>classes All of these classes also offer <b>IsDefined </b>and <b>GetCustomAttributes </b>methods. Only <b>System.Attribute </b>offers the very convenient <b>GetCustomAttribute </b>method.</p>
<p>The version of <b>GetCustomAttributes </b>defined by the reflection classes returns an array of <b>Object </b>instances <b>(Object[]) </b>instead of an array of <b>Attribute </b>instances <b>(Attribute[]) </b>. This is because the reflection classes are able to return objects of non-CLS-compliant attribute classes. You shouldn't be concerned about this inconsistency because non-CLS-compliant attributes are incredibly rare. In fact, in all of the time I've been working with the .NET Framework, I've never even seen one.</p>
<hr/>
<blockquote><b>Note </b>Be aware that only <b>Attribute, Type, </b>and <b>MethodInfo </b>classes implement reflection methods that honor the Boolean <b>inherit </b>parameter. All other reflection methods that look up attributes ignore the <b>inherit </b>parameter and do not check the inheritance hierarchy. If you need to check the presence of an inherited attribute for events, properties, fields, constructors, or parameters, you must call one of <b>Attribute</b>'s methods.</blockquote>
<hr/>
<p>There's one more thing you should be aware of: When you pass a class to <b>IsDefined, GetCustomAttribute, </b>or <b>GetCustomAttributes, </b>these methods search for the application of the attribute class you specify or any attribute class derived from the specified class. If your code is looking for a specific attribute class, you should perform an additional check on the returned value to ensure that what these methods returned is the exact class you're looking for. You might also want to consider defining your attribute class to be <b>sealed </b>to reduce potential confusion and eliminate this extra check.</p>
<p>Here's some sample code that lists all of the methods defined within a type and displays the attributes applied to each method. The code is for demonstration purposes; normally, you wouldn't apply these particular custom attributes to these targets as I've done here.</p>
<p><code>using System;<br/>
using System.Diagnostics;<br/>
using System.Reflection;<br/>
[assembly: CLSCompliant(true)]<br/>
[Serializable]<br/>
[DefaultMemberAttribute(&quot;Main&quot;)]<br/>
[DebuggerDisplayAttributeC'Richter&quot;, Name = &quot;Jeff&quot;, Target = typeof(Program))] public sealed class Program {<br/>
[Conditiona1(&quot;Debug&quot;)]<br/>
[Conditiona1(&quot;Release&quot;)]<br/>
public void DoSomething() { }<br/>
public Program() { }<br/>
[CLSCompliant(true)] [STAThread]<br/>
public static void Main() {<br/>
// Show the set of attributes applied to this type ShowAttributes(typeof(Program));<br/>
// Get the set of methods associated with the type MemberInfo[] members = typeof(Program).FindMembers(<br/>
MemberTypes.Constructor | MemberTypes.Method,<br/>
BindingFlags.DeclaredOnly | BindingFlags.Instance |<br/>
BindingFlags.Public | BindingFlags.Static,<br/>
Type.FilterName, &quot;*&quot;);<br/>
foreach (Memberlnfo member in members) {<br/>
// Show the set of attributes applied to this member ShowAttributes(member);<br/>
}<br/>
}<br/>
private static void ShowAttributes(MemberInfo attributeTarget) {<br/>
Attribute[] attributes = Attribute.GetCustomAttributes(attributeTarget);<br/>
Console.WriteLineC'Attributes applied to {0}: {1}&quot;,<br/>
attributeTarget.Name, (attributes.Length == 0 ? &quot;None&quot; : String.Empty));<br/>
foreach (Attribute attribute in attributes) { // Display the type of each applied attribute Console.WriteLine(&quot;   {0}&quot;, attribute.GetType().ToString());<br/>
if (attribute is DefaultMemberAttribute) Console.WriteLine(&quot; MemberName={0}&quot;,<br/>
((DefaultMemberAttribute) attribute).MemberName);<br/>
if (attribute is ConditionalAttribute)<br/>
Console.WriteLine(&quot; ConditionString={0}&quot;,<br/>
((ConditionalAttribute) attribute).ConditionString);<br/>
if (attribute is CLSCompliantAttribute) Console.WriteLine(&quot; IsCompliant={0}&quot;,<br/>
((CLSCompliantAttribute) attribute).IsCompliant);<br/>
DebuggerDisplayAttribute dda = attribute as DebuggerDisplayAttribute; if (dda != null) {<br/>
Console.WriteLine(&quot;      Value={0}, Name={1}, Target={2}&quot;, dda.Value, dda.Name, dda.Target);<br/>
}<br/>
}<br/>
Console.WriteLineO;<br/>
}<br/>
}</code></p>
<p>Building and running this application yields the following output:</p>
<p><code>Attributes applied to Program: System.SerializableAttribute System.Diagnostics.DebuggerDisplayAttribute<br/>
Value=Richter, Name=Jeff, Target=Program System.Reflection.DefaultMemberAttribute<br/>
MemberName=Main<br/>
Attributes applied to DoSomething:<br/>
System.Diagnostics.ConditionalAttribute<br/>
ConditionString=Release System.Diagnostics.ConditionalAttribute<br/>
ConditionString=Debug<br/>
Attributes applied to Main: System.CLSCompliantAttribute<br/>
IsCompliant=True System.STAThreadAttribute<br/>
Attributes applied to.ctor: None</code></p>
<a name="b448"/><h2>Matching Two Attribute Instances Against Each Other</h2>
<p>Now that your code knows how to check if an instance of an attribute is applied to a target, it might want to check the fields of the attribute to see what values they have. One way to do this is to write code that explicitly checks the values of the attribute class's fields. However, <b>System.Attribute </b>overrides <b>Object</b>'s <b>Equals </b>method, and internally, this method compares the types of the two objects. If they are not identical, <b>Equals </b>returns <b>false. </b>If the types are identical, then <b>Equals </b>uses reflection to compare the values of the two attribute objects' fields (by calling <b>Equals </b>for each field). If all the fields match, then <b>true </b>is returned; otherwise, <b>false </b>is returned. You might override <b>Equals </b>in your own attribute class to remove the use of reflection, improving performance.</p>
<p><b>System.Attribute </b>also exposes a virtual <b>Match </b>method that you can override to provide richer semantics. The default implementation of <b>Match </b>simply calls <b>Equals </b>and returns its result. The following code demonstrates how to override <b>Equals </b>and <b>Match </b>(which returns <b>true </b>if one attribute represents a subset of the other) and then shows how <b>Match </b>is used:</p>
<p><code>using System; [Flags]<br/>
internal enum Accounts { Savings     = 0x0001, Checking   = 0x0002, Brokerage = 0x0004<br/>
}<br/>
[AttributeUsage(AttributeTargets.Class)] internal sealed class AccountsAttribute : Attribute { private Accounts m_accounts;<br/>
public AccountsAttribute(Accounts accounts) { m_accounts = accounts;<br/>
}<br/>
public override Boolean Match(Object obj) {<br/>
// If the base class implements Match and the base class // is not Attribute, then uncomment the line below. // if (!base.Match(obj)) return false;<br/>
// Since 'this' isn't null, if obj is null,<br/>
// then the objects can't match<br/>
// NOTE: This line may be deleted if you trust<br/>
// that the base type implemented Match correctly.<br/>
if (obj == null) return false;<br/>
// If the objects are of different types, they can't match<br/>
// NOTE: This line may be deleted if you trust<br/>
// that the base type implemented Match correctly.<br/>
if (this.GetType() != obj.GetType()) return false;<br/>
// Cast obj to our type to access fields. NOTE: This cast // can't fail since we know objects are of the same type AccountsAttribute other = (AccountsAttribute) obj;<br/>
// Compare the fields as you see fit<br/>
// This example checks if 'this' accounts is a subset<br/>
// of others' accounts<br/>
if ((other.m_accounts &amp; m_accounts) != m_accounts) return false;<br/>
return true;     // Objects match<br/>
}<br/>
public override Boolean Equals(Object obj) {<br/>
// If the base class implements Equals, and the base class // is not Object, then uncomment the line below. // if (!base.Equals(obj)) return false;<br/>
// Since 'this' isn't null, if obj is null,<br/>
// then the objects can't be equal<br/>
// NOTE: This line may be deleted if you trust<br/>
// that the base type implemented Equals correctly.<br/>
if (obj == null) return false;<br/>
// If the objects are of different types, they can't be equal<br/>
// NOTE: This line may be deleted if you trust<br/>
// that the base type implemented Equals correctly.<br/>
if (this.GetType() != obj.GetType()) return false;<br/>
// Cast obj to our type to access fields. NOTE: This cast // can't fail since we know objects are of the same type AccountsAttribute other = (AccountsAttribute) obj;<br/>
// Compare the fields to see if they have the same value // This example checks if 'this' accounts is the same // as other's accounts if (other.m_accounts != m_accounts) return false;<br/>
return true;     // Objects are equal<br/>
}<br/>
// Override GetHashCode since we override Equals public override Int32 GetHashCode() { return (Int32) m_accounts;<br/>
}<br/>
}<br/>
[Accounts(Accounts.Savings)]<br/>
internal sealed class ChildAccount { }<br/>
[Accounts(Accounts.Savings | Accounts.Checking | Accounts.Brokerage)] internal sealed class AdultAccount { }<br/>
public sealed class Program { public static void Main() {<br/>
CanWriteCheck(new ChildAccount());<br/>
CanWriteCheck(new AdultAccount());<br/>
// This just demonstrates that the method works correctly on a // type that doesn't have the AccountsAttribute applied to it. CanWriteCheck(new Program());<br/>
}<br/>
private static void CanWriteCheck(Object obj) {<br/>
// Construct an instance of the attribute type and initialize it // to what we are explicitly looking for.<br/>
Attribute checking = new AccountsAttribute(Accounts.Checking);<br/>
// Construct the attribute instance that was applied to the type Attribute validAccounts = Attribute.GetCustomAttribute( obj.GetType(), typeof(AccountsAttribute), false);<br/>
// If the attribute was applied to the type AND the<br/>
// attribute specifies the &quot;Checking&quot; account, then the<br/>
// type can write a check<br/>
if ((validAccounts != null) &amp;&amp; checking.Match(validAccounts)) { Console.Writel_ine(&quot;{0} types can write checks.&quot;, obj.GetType());<br/>
} else {<br/>
Console.Writel_ine(&quot;{0} types can NOT write checks.&quot;, obj.GetType());<br/>
}<br/>
}<br/>
}</code></p>
<p>Building and running this application yields the following output:</p>
<p><code>ChildAccount types can NOT write checks. AdultAccount types can write checks. Program types can NOT write checks.</code></p>
<a name="b451"/><h2>Detecting the Use of a Custom Attribute Without Creating Attribute-Derived Objects</h2>
<p>In this section, I discuss an alternate technique for detecting custom attributes applied to a metadata entry. In some security-conscious scenarios, this alternate technique ensures that no code in an <b>Attribute</b>-derived class will execute. After all, when you call <b>Attribute</b>'s <b>GetCustomAttribute(s) </b>methods, internally, these methods call the attribute class's constructor and can also call property set accessor methods. In addition, the first access to a type causes the CLR to invoke the type's type constructor (if it exists). The constructor, set accessor, and type constructor methods could contain code that will execute whenever code is just looking for an attribute. This allows unknown code to run in the AppDomain, and this is a potential security vulnerability.</p>
<p>To discover attributes without allowing attribute class code to execute, you use the <b>System.Reflection.CustomAttributeData </b>class. This class defines one static method for retrieving the attributes associated with a target: <b>GetCustomAttributes </b>. This method has four overloads: one that takes an <b>Assembly, </b>one that takes a <b>Module, </b>one that takes a <b>ParameterInfo, </b>and one that takes a <b>MemberInfo </b>. This class is defined in the <b>System.Reflection </b>namespace, which is discussed in Chapter 23. Typically, you'll use the <b>CustomAttributeData </b>class to analyze attributes in metadata for an assembly that is loaded via <b>Assembly</b>'s static <b>ReflectionOnlyLoad </b>method (also discussed in Chapter 23). Briefly, <b>ReflectionOnlyLoad </b>loads an assembly in such a way that prevents the CLR from executing any code in it; this includes type constructors.</p>
<p><b>CustomAttributeData</b>'s <b>GetCustomAttributes </b>method acts as a factory. That is, when you call it, it returns a collection of <b>CustomAttributeData </b>objects in an object of type <b>IList&lt;CustomAttributeData&gt;. </b>The collection contains one element per custom attribute applied to the specified target. For each <b>CustomAttributeData </b>object, you can query some read-only properties to determine how the attribute object would be constructed and initialized. Specifically, the <b>Constructor </b>property indicates which constructor method would be called, the <b>ConstructorArguments </b>property returns the arguments that would be passed to this constructor as an instance of <b>IList&lt;CustomAttributeTypedArgument&gt;, </b>and the <b>NamedArguments </b>property returns the fields/properties that would be set as an instance of <b>IList&lt;CustomAttributeNamedArgument&gt; </b>. Notice that I say &quot;would be&quot; in the previous sentences because the constructor and set accessor methods will not actually be called謡e get the added security by preventing any attribute class methods from executing.</p>
<p>Here's a modified version of a previous code sample that uses the <b>CustomAttributeData </b>class to securely obtain the attributes applied to various targets:</p>
<p><code>using.System;<br/>
using.System.Diagnostics;<br/>
using.System.Reflection;<br/>
using.System.Collections.Generic;<br/>
[assembly: ClSCompliant(true)]<br/>
[Serializable]<br/>
[DefaultMemberAttribute(&quot;Main&quot;)]<br/>
[DebuggerDisplayAttribute(&quot;Richter&quot;, Name=&quot;Jeff&quot;, Target=typeof(Program))] public sealed class Program {<br/>
[Conditional(&quot;Debug&quot;)]<br/>
[Conditional(&quot;Release&quot;)]<br/>
public void DoSomething() { }<br/>
public Program() { }<br/>
[ClSCompliant(true)]<br/>
[STAThread]<br/>
public static void Main() {<br/>
// Show the set of attributes applied to this type ShowAttributes(typeof(Program));<br/>
// Cet the set of methods associated with the type MemberInfo[] members = typeof(Program).FindMembers(<br/>
MemberTypes.Constructor | MemberTypes.Method,<br/>
BindingFlags.DeclaredOnly | BindingFlags.Instance |<br/>
BindingFlags.Public | BindingFlags.Static,<br/>
Type.FilterName, &quot;*&quot;);<br/>
foreach (MemberInfo member in members) {<br/>
// Show the set of attributes applied to this member ShowAttributes(member);<br/>
}<br/>
}<br/>
private static void ShowAttributes(MemberInfo attributeTarget) { IList&lt;CustomAttributeData&gt; attributes =<br/>
CustomAttributeData.CetCustomAttributes(attributeTarget);<br/>
Console.WriteLine(&quot;Attributes applied to {0}: {1}&quot;,<br/>
attributeTarget.Name, (attributes.Count == 0 ? &quot;None&quot; : String.Empty));<br/>
foreach (CustomAttributeData attribute in attributes) { // Display the type of each applied attribute Type t = attribute.Constructor.DeclaringType; Console.WriteLine(&quot;   {0}&quot;, t.ToString<b>O);</b><br/>
Console.WriteLine(&quot;      Constructor called={0}&quot;, attribute.Constructor);<br/>
IList&lt;CustomAttributeTypedArgument&gt; posArgs = attribute.ConstructorArguments; Console.WriteLine(&quot;      Positional arguments passed to constructor:&quot; +<br/>
((posArgs.Count == 0) ? &quot; None&quot; : String.Empty)); foreach (CustomAttributeTypedArgument pa in posArgs) {<br/>
Console.WriteLine(&quot;.Type={0}, Value={1}&quot;, pa.ArgumentType, pa.Value);<br/>
}<br/>
IList&lt;CustomAttributeNamedArgument&gt; namedArgs = attribute.NamedArguments; Console.WriteLine(&quot;      Named arguments set after construction:&quot; +<br/>
((namedArgs.Count == 0) ? &quot; None&quot; : String.Empty)); foreach(CustomAttributeNamedArgument na in namedArgs) {<br/>
Console.WriteLine(&quot;        Name={0}, Type={1}, Value={2}&quot;,<br/>
na.MemberInfo.Name, na.TypedValue.ArgumentType, na.TypedValue.Value);<br/>
}<br/>
Console.WriteLine<b>O;</b><br/>
}<br/>
Console.WriteLine<b>O;</b><br/>
}<br/>
}</code></p>
<p>Building and running this application yields the following output:</p>
<p><code>Attributes applied to Program: System.SerializableAttribute Constructor called=Void.ctor() Positional arguments passed to constructor: None<br/>
Named arguments set after construction: None<br/>
System.Diagnostics.DebuggerDisplayAttribute Constructor called=Void.ctor(System.String) Positional arguments passed to constructor:<br/>
Type=System.String, Value=Richter Named arguments set after construction: Name=Name, Type=System.String, Value=Jeff Name=Target, Type=System.Type, Value=Program<br/>
System.Reflection.DefaultMemberAttribute<br/>
Constructor called=Void.ctor(System.String) Positional arguments passed to constructor:<br/>
Type=System.String, Value=Main Named arguments set after construction: None<br/>
Attributes applied to DoSomething:<br/>
System.Diagnostics.ConditionalAttribute<br/>
Constructor called=Void.ctor(System.String) Positional arguments passed to constructor:<br/>
Type=System.String, Value=Release Named arguments set after construction: None<br/>
System.Diagnostics.ConditionalAttribute<br/>
Constructor called=Void.ctor(System.String) Positional arguments passed to constructor:<br/>
Type=System.String, Value=Debug Named arguments set after construction: None<br/>
Attributes applied to Main: System.CLSCompliantAttribute<br/>
Constructor called=Void.ctor(Boolean) Positional arguments passed to constructor:<br/>
Type=System.Boolean, Value=True Named arguments set after construction: None<br/>
System.STAThreadAttribute<br/>
Constructor called=Void.ctor()<br/>
Positional arguments passed to constructor: None<br/>
Named arguments set after construction: None<br/>
Attributes applied to.ctor: None</code></p>
<a name="b454"/><h2>Conditional Attribute Classes</h2>
<p>Over time, the ease of defining, applying, and reflecting over attributes has caused developers to use them more and more. Using attributes is also a very easy way to annotate your code while simultaneously implementing rich features. Lately, developers have been using attributes to assist them with design time and debugging For example,</p>
<p>the Microsoft Visual Studio code analysis tool (FxCopCmd.exe) offers a <b>System.Diagnostics.CodeAnalysis.SuppressMessageAttribute </b>which you can apply to types and members in order to suppress the reporting of a specific static analysis tool rule violation. This attribute is only looked for by the code analysis utility; the attribute is never looked for when the program is running normally. When not using code analysis, having <b>SuppressMessage </b>attributes sitting in the metadata just bloats the metadata, which makes your file bigger, increases your process's working set, and hurts your application's performance. It would be great if there were an easy way to have the compiler emit the <b>SuppressMessage </b>attributes only when you intend to use the code analysis tool. Fortunately, there is a way to do this by using conditional attribute classes.</p>
<p>An attribute class that has the <b>System.Diagnostics.ConditionalAttribute </b>applied to it is called a conditional attribute class. Here is an example:</p>
<p><code>//#define TEST #define VERIFY<br/>
using System;<br/>
using System.Diagnostics;<br/>
[Conditional(&quot;TEST&quot;)][Conditional(&quot;VERIFY&quot;)]<br/>
public sealed class CondAttribute : Attribute {<br/>
}<br/>
[Cond]<br/>
public sealed class Program { public static void Main() {<br/>
Console.WriteLine(&quot;CondAttribute is {0}applied to Program type.&quot;, Attribute.IsDefined(typeof(Program),<br/>
typeof(CondAttribute)) ? &quot;&quot; : &quot;not &quot;);<br/>
}<br/>
}</code></p>
<p>When a compiler sees an instance of the <b>CondAttribute </b>being applied to a target, the compiler will emit the attribute information into the metadata only if the <b>TEST </b>or <b>VERIFY </b>symbol is defined when the code containing the target is compiled. However, the attribute class definition metadata and implementation is still present in the assembly.</p>
<mbp:pagebreak/>
<a name="Chapter19"/>
<h1>Chapter 19: Nullable Value Types</h1>
<p><b>In this chapter:</b></p>
<a href="#b459">C#'s Support for Nullable Value Types</a><br/>
<a href="#b462">C#'s Null-Coalescing Operator</a><br/>
<a href="#b463">The CLR Has Special Support for Nullable Value Types</a><br/>
<p>As you know, a variable of a value type can never be <b>null; </b>it always contains the value type's value itself. In fact, this is why they call these types value types. Unfortunately, there are some scenarios in which this is a problem. For example, when designing a database, it's possible to define a column's data type to be a 32-bit integer that would map to the <b>Int32 </b>data type of the Framework Class Library (FCL). But a column in a database can indicate that the value is nullable. That is, it is OK to have no value in the row's column. Working with database data by using the Microsoft .NET Framework can be quite difficult because in the common language runtime (CLR), there is no way to represent an <b>Int32 </b>value as <b>null.</b></p>
<hr/>
<blockquote><b>Note </b>Microsoft ADO.NET's table adapters do support nullable types. But unfortunately, the types in the <b>System.Data.SqlTypes </b>namespace are not replaced by nullable types, partially because there isn't a one-to-one correspondence between types. For example, the <b>SqlDecimal </b>type has a maximum of 38 digits, whereas the regular <b>Decimal </b>type can reach only 29 In addition, the <b>SqlString </b>type supports its own locale and compare options, which are not supported by the normal <b>String </b>type.</blockquote>
<hr/>
<p>Here is another example: in Java, the <b>java.util.Date </b>class is a reference type, and therefore, a variable of this type can be set to <b>null. </b>However, in the CLR, a <b>System.DateTime </b>is a value type, and a <b>DateTime </b>variable can never be <b>null. </b>If an application written in Java wants to communicate a date/time to a Web service running the CLR, there is a problem if the Java application sends <b>null </b>because the CLR has no way to represent this and operate on it.</p>
<p>To improve this situation, Microsoft added the concept of nullable value types to the CLR. To understand how they work, we first need to look at the <b>System.Nullable&lt;T&gt; </b>class, which is defined in the FCL. Here is the logical representation of how the <b>System.Nullable&lt;T&gt; </b>type is defined:</p>
<p><code>[Serializable, StructLayout(LayoutKind.Sequential)] public struct Nullable&lt;T&gt; where T : struct {<br/>
// These 2 fields represent the state<br/>
private Boolean hasValue = false; // Assume null<br/>
internal T value = default(T);      // Assume all bits zero<br/>
public Nullable(T value) { this.value = value; this.hasValue = true;<br/>
}<br/>
public Boolean HasValue { get { return hasValue; } } public T Value {<br/>
get {<br/>
if (IhasValue) {<br/>
throw new InvalidOperationException(<br/>
&quot;Nullable object must have a value.&quot;);<br/>
}<br/>
return value;<br/>
}<br/>
}<br/>
public T GetValueOrDefault() { return value; }<br/>
public T GetValueOrDefault(T defaultValue) { if (IHasValue) return defaultValue; return value;<br/>
}<br/>
public override Boolean Equals(Object other) { if (IHasValue) return (other == null); if (other == null) return false; return value.Equals(other);<br/>
}<br/>
public override int GetHashCode() { if (IHasValue) return 0; return value.GetHashCode();<br/>
}<br/>
public override string ToString() { if (IHasValue) return &quot;&quot;; return value.ToString();<br/>
}<br/>
public static implicit operator Nullable&lt;T&gt;(T value) { return new Nullable&lt;T&gt;(value);<br/>
}<br/>
public static explicit operator T(Nullable&lt;T&gt; value) { return value.Value;<br/>
}<br/>
}</code></p>
<p>As you can see, this class encapsulates the notion of a value type that can also be <b>null </b>Since <b>Nullable&lt;T&gt; </b>is itself a value type, instances of it are still fairly lightweight. That is, instances can still be on the stack, and an instance is the same size as the original value type plus the size of a <b>Boolean </b>field. Notice that <b>Nullable</b>'s type parameter, <b>T, </b>is constrained to <b>struct </b>. This was done because reference type variables can already be <b>null.</b></p>
<p><code>Nullable&lt;Int32&gt; x = 5; Nullable&lt;Int32&gt; y = null;<br/>
Console.WriteLine(&quot;x: HasValue={0}, Value={1}&quot;,   x.HasValue, x.Value); Console.WriteLine(&quot;y: HasValue={0}, Value={1}&quot;,   y.HasValue, y.GetValueOrDefault());</code></p>
<p>When I compile and run this code, I get the following output:</p>
<p><code>x: HasValue=True, Value=5 y: HasValue=False, Value=0</code></p>
<a name="b459"/><h2>C#'s Support for Nullable Value Types</h2>
<p>Notice in the code that C# allows you to use fairly simple syntax to initialize the two <b>Nullable&lt;Int32&gt; </b>variables, <b>x </b>and <b>y. </b>In fact, the C# team wants to integrate nullable value types into the C# language, making them first-class citizens. To that end, C# offers an (arguably) cleaner syntax for working with nullable value types C# allows the code to declare and initialize the <b>x </b>and <b>y </b>variables to be written using question-mark notation:</p>
<p><code>Int32? x = 5; Int32? y = null;</code></p>
<p>In C#, <b>Int32? </b>is a synonym notation for <b>Nullable&lt;Int32&gt;. </b>But C# takes this further. C# allows you to perform conversions and casts on nullable instances And C# also supports applying operators to nullable instances The following code shows examples of these:</p>
<p><code>private static void ConversionsAndCasting() {<br/>
// Implicit conversion from non-nullable Int32 to Nullable&lt;Int32&gt; Int32? a = 5;<br/>
// Implicit conversion from 'null' to Nullable&lt;Int32&gt; Int32? b = null;<br/>
// Explicit conversion from Nullable&lt;Int32&gt; to non-nullable Int32 Int32 c = (Int32) a;<br/>
// Casting between nullable primitive types<br/>
Double? d = 5; // Int32-&gt;Double?   (d is 5.0 as a double)<br/>
Double? e = b; // Int32?-&gt;Double? (e is null)<br/>
}</code></p>
<p>C# also allows you to apply operators to nullable instances. The following code shows examples of this:</p>
<p><code>private static void Operators() { Int32? a = 5; Int32? b = null;<br/>
// Unary operators (+   ++   -       I ~) a++;      // a = 6 b = -b; // b = null<br/>
// Binary operators (+   -   *   /   %   &amp;   |   a   &lt;&lt; &gt;&gt;) a = a + 3;   // a = 9 b = b * 3;   // b = null;<br/>
// Equality operators (==.!=)<br/>
if (a == null) { /* no   */.} else{ /* yes */.}<br/>
if (b == null) { /* yes */.} else{ /* no   */.}<br/>
if (a != b)       { /* yes */.} else{ /* no   */.}<br/>
// Comparison operators (&lt;&gt;   &lt;= &gt;=)<br/>
if (a &lt; b)      { /* no */ } else { /* yes */ }<br/>
}</code></p>
<p>Here is how C# interprets the operators:</p>
<p><b>&#9632; Unary operators (+++</b>, <b>-</b>, <b>--</b>, <b>! </b>, <b>~)   </b>If the operand is <b>null, </b>the result is <b>null.</b></p>
<p><b>&#9632; Binary operators (+</b>, <b>-</b>, <b>*</b>, <b>/</b>, <b>%</b>, <b>&amp;</b>, <b>|</b>, <b>a</b><b>, &lt;&lt;, &gt;&gt;)   </b>If either operand is <b>null, </b>the result is <b>null. </b>However, an exception is made when the <b>&amp; </b>and <b>| </b>operators are operating on <b>Boolean? </b>operands so that the behavior of these two operators gives the same behavior as demonstrated by SQL's three-valued logic. For these two operators, if neither operand is <b>null, </b>the operator performs as expected, and if both operands are <b>null, </b>the result is <b>null. </b>The special behavior comes into play when just one of the operands is <b>null</b>. The table below lists the results produced by these two operators for all combinations of <b>true, false, </b>and <b>null:</b></p>
<table border="1">
<tr>
<td>
<p><b>Operandi </b><b></b></p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td>
<p><b>Operand2 </b><b>J,</b></p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>l</p>
</td>
</tr>
<tr>
<td>
<p></p>
</td>
<td>
<p><b>&amp; = true</b></p>
</td>
<td>
<p><b>&amp; = false</b></p>
</td>
<td>
<p><b>&amp; = null</b></p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p><b>| = true</b></p>
</td>
<td>
<p><b>| = true</b></p>
</td>
<td>
<p><b>| = true</b></p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p><b>&amp; = false</b></p>
</td>
<td>
<p><b>&amp; = false</b></p>
</td>
<td>
<p><b>&amp; = false</b></p>
</td>
</tr>
<tr>
<td>
<p></p>
</td>
<td>
<p><b>| = true</b></p>
</td>
<td>
<p><b>| = false</b></p>
</td>
<td>
<p><b>| = null</b></p>
</td>
</tr>
<tr>
<td>
<p>l</p>
</td>
<td>
<p><b>&amp; = null</b></p>
</td>
<td>
<p><b>&amp; = false</b></p>
</td>
<td>
<p><b>&amp; = null</b></p>
</td>
</tr>
<tr>
<td>
<p></p>
</td>
<td>
<p><b>| = true</b></p>
</td>
<td>
<p><b>| = null</b></p>
</td>
<td>
<p><b>| = null</b></p>
</td>
</tr>
</table>
<p><b>&#9632; Equality operators (==, !=)   </b>If both operands are <b>null, </b>they are equal. If one operand is <b>null, </b>they are not equal. If neither operand is <b>null, </b>compare the values to determine if they are equal.</p>
<p><b>&#9632; Relational operators (&lt;, &gt;, &lt;=, &gt;=)   </b>If either operand is <b>null, </b>the result is <b>false. </b>If neither operand is <b>null, </b>compare the values.</p>
<p>You should be aware that manipulating nullable instances does generate a lot of code For example, see the following method:</p>
<p><code>private static Int32? NullableCodeSize(Int32? a, Int32? b) { return a + b;<br/>
}</code></p>
<p>When I compile this method, there is quite a bit of resulting Intermediate Language (IL) code, which also makes performing operations on nullable types slower than performing the same operation on non-nullable types. Here is the C# equivalent of the compiler-produced IL code:</p>
<p><code>private static Nullable&lt;Int32&gt; NullableCodeSize(Nullable&lt;Int32&gt; a, Nullable&lt;Int32&gt; b) {<br/>
Nullable&lt;Int32&gt; nullablel = a; Nullable&lt;Int32&gt; nullable2 = b;<br/>
if (I(nullable1.HasValue &amp; nullable2.HasValue)) { return new Nullable&lt;Int32&gt;();<br/>
}<br/>
return new Nullable&lt;Int32&gt;(nullable1.CetValueOrDefault() + nullable2.CetValueOrDefault());<br/>
}</code></p>
<p>Finally, let me point out that you can define your own value types that overload the various operators mentioned above. I discuss how to do this in the &quot;Operator Overload Methods&quot; section in Chapter 8, &quot;Methods.&quot; If you then use a nullable instance of your own value type, the compiler does the right thing and invokes your overloaded operator For example, suppose that you have a <b>Point </b>value type that defines overloads for the <b>== </b>and <b>!= </b>operators as follows:</p>
<p><code>using System;<br/>
internal struct Point { private Int32 m_x, m_y;<br/>
public Point(Int32 x, Int32 y) { m_x = x; m_y = y; }<br/>
public static Boolean operator==(Point pl, Point p2) { return (p1.m_x == p2.m_x) &amp;&amp; (p1.m_y == p2.m_y);<br/>
}<br/>
public static Boolean operator!=(Point p1, Point p2) { return I(p1 == p2);<br/>
}<br/>
}</code></p>
<p>At this point, you can use nullable instances of the <b>Point </b>type and the compiler will invoke your overloaded operators:</p>
<p><code>internal static class Program { public static void Main() { Point? p1 = new Point(1, 1); Point? p2 = new Point(2, 2);<br/>
Console.Writel_ine(&quot;Are points equal? &quot; + (p1 == p2).ToString()); Console.Writel_ine(&quot;Are points not equal? &quot; + (p1 I= p2).ToString());<br/>
}<br/>
}</code></p>
<p>When I build and run the code above, I get the following output:</p>
<p><code>Are points equal? False Are points not equal? True</code></p>
<a name="b462"/><h2>C#'s Null-Coalescing Operator</h2>
<p>C# has an operator called the null-coalescing operator (<b>??</b>), which takes two operands. If the operand on the left is not <b>null, </b>the operand's value is returned. If the operand on the left is <b>null, </b>the value of the right operand is returned. The null-coalescing operator offers a very convenient way to set a variable's default value.</p>
<p>A cool feature of the null-coalescing operator is that it can be used with reference types as well as nullable value types. Here is some code that demonstrates the use of the null-coalescing operator:</p>
<p><code>private static void NullCoalescingOperator() { Int32? b = null;<br/>
// The line below is equivalent to: // x = (b.HasValue) ? b.Value : 123 Int32 x = b ?? 123; Console.WriteLine(x);   // &quot;123&quot;<br/>
// The line below is equivalent to:<br/>
// String temp = CetFilename();<br/>
// filename = (temp != null) ? temp : &quot;Untitled&quot;;<br/>
String filename = CetFilename() ?? &quot;Untitled&quot;;<br/>
}</code></p>
<p>Some people argue that the null-coalescing operator is simply syntactic sugar for the <b>?: </b>operator, and that the C# compiler team should not have added this operator to the language. However, the null-coalescing operator offers two significant syntactic improvements. The first is that the <b>?? </b>operator works better with expressions:</p>
<p><code>Func&lt;String&gt; f = () =&gt; SomeMethod() ?? &quot;Untitled&quot;;</code></p>
<p>This code is much easier to read and understand than the line below, which requires variable assignments and multiple statements:</p>
<p><code>Func&lt;String&gt; f = () =&gt; { var temp = SomeMethod(); return temp != null ? temp : &quot;Untitled&quot;;};</code></p>
<p>The second improvement is that <b>?? </b>works better in composition scenarios For example, the single line</p>
<p><code>String s = SomeMethod1() ?? SomeMethod2() ?? &quot;Untitled&quot;; is far easier to read and understand than this chunk of code: String s;<br/>
var sm1 = SomeMethod1(); if (sm1 != null) s = sm1; else {<br/>
var sm2 = SomeMethod2(); if (sm2 != null) s = sm2; else s = &quot;Untitled&quot;;<br/>
}</code></p>
<a name="b463"/><h2>The CLR Has Special Support for Nullable Value Types</h2>
<p>The CLR has built-in support for nullable value types. This special support is provided for boxing, unboxing, calling <b>GetType, </b>and calling interface methods, and it is given to nullable types to make them fit more seamlessly into the CLR. This also makes them behave more naturally and as most developers would expect. Let's take a closer look at the CLR's special support for nullable types.</p>
<h3>Boxing Nullable Value Types</h3>
<p>Imagine a <b>Nullable&lt;Int32&gt; </b>variable that is logically set to <b>null</b>. If this variable is passed to a method prototyped as expecting an <b>Object, </b>the variable must be boxed, and a reference to the boxed <b>Nullable&lt;Int32&gt; </b>is passed to the method. This is not ideal because the method is now being passed a non<b>-null </b>value even though the <b>Nullable&lt;Int32&gt; </b>variable logically contained the value of <b>null. </b>To fix this, the CLR executes some special code when boxing a nullable variable to keep up the illusion that nullable types are first-class citizens in the environment.</p>
<p>Specifically, when the CLR is boxing a <b>Nullable&lt;T&gt; </b>instance, it checks to see if it is <b>null, </b>and if so, the CLR doesn't actually box anything, and <b>null </b>is returned. If the nullable instance is not <b>null, </b>the CLR takes the value out of the nullable instance and boxes it. In other words, a <b>Nullable&lt;Int32&gt; </b>with a value of <b>5 </b>is boxed into a boxed<b>-Int32 </b>with a value of <b>5. </b>Here is some code that demonstrates this behavior:</p>
<p><code>// Boxing Nullable&lt;T&gt; is null or boxed T<br/>
Int32? n = null;<br/>
Object o = n;   // o is null<br/>
Console.WriteLine(&quot;o is null={0}&quot;, o == null);   // &quot;True&quot; n = 5;<br/>
o = n;     // o refers to a boxed Int32<br/>
Console.WriteLine(&quot;o's type={0}&quot;, o.GetType()); // &quot;System.Int32&quot;</code></p>
<h3>Unboxing Nullable Value Types</h3>
<p>The CLR allows a boxed value type <b>T </b>to be unboxed into a <b>T </b>or a <b>Nullable&lt;T&gt;. </b>If the reference to the boxed value type is <b>null, </b>and you are unboxing it to a <b>Nullable&lt;T&gt;, </b>the CLR sets <b>Nullable&lt;T</b>&gt;'s value to <b>null. </b>Here is some code to demonstrate this behavior:</p>
<p><code>// Create a boxed Int32 Object o = 5;<br/>
// Unbox it into a Nullable&lt;Int32&gt; and into an Int32 Int32? a = (Int32?) o;   // a = 5 Int32   b = (Int32)   o;   // b = 5<br/>
// Create a reference initialized to null o = null;<br/>
// &quot;Unbox&quot; it into a Nullable&lt;Int32&gt; and into an Int32<br/>
a = (Int32?) o;// a = null<br/>
b = (Int32)   o;// NullReferenceException</code></p>
<h3>Calling GetType via a Nullable Value Type</h3>
<p>When calling <b>GetType </b>on a <b>Nullable&lt;T&gt; </b>object, the CLR actually lies and returns the type <b>T </b>instead of the type <b>Nullable&lt;T&gt; </b>. Here is some code that demonstrates this behavior:</p>
<p><code>Int32? x = 5;<br/>
// The line below displays &quot;System.Int32&quot;; not &quot;System.Nullable&lt;Int32&gt;&quot; Console.WriteLine(x.CetType());</code></p>
<h3>Calling Interface Methods via a Nullable Value Type</h3>
<p>In the code below, I'm casting <b>n, </b>a <b>Nullable&lt;Int32&gt;, </b>to <b>IComparable&lt;Int32&gt;, </b>an interface type. However, the <b>Nullable&lt;T&gt; </b>type does not implement the <b>IComparable&lt;Int32&gt; </b>interface as <b>Int32 </b>does The C# compiler allows this code to compile anyway, and the CLR's verifier considers this code verifiable to allow you a more convenient syntax.</p>
<p><code>Int32? n = 5;<br/>
Int32 result = ((IComparable) n).CompareTo(5);   // Compiles &amp; runs OK Console.WriteLine(result);// 0</code></p>
<p>If the CLR didn't provide this special support, it would be more cumbersome for you to write code to call an interface method on a nullable value type. You'd have to cast the unboxed value type first before casting to the interface to make the call:</p>
<p><code>Int32 result = ((IComparable) <b>(Int32) </b>n).CompareTo(5);   // Cumbersome</code></p>
<mbp:pagebreak/>
<a name="Chapter20"/>
<h1>Chapter 20: Exceptions and State Management</h1>
<p><b>In this chapter:</b></p>
<a href="#b466">Defining &quot;Exception&quot;</a><br/>
<a href="#b467">Exception-Handling Mechanics</a><br/>
<a href="#b474">The System.Exception Class</a><br/>
<a href="#b478">FCL-Defined Exception Classes</a><br/>
<a href="#b480">Throwing an Exception</a><br/>
<a href="#b481">Defining Your Own Exception Class</a><br/>
<a href="#b484">Trading Reliability for Productivity</a><br/>
<a href="#b492">Guidelines and Best Practices</a><br/>
<a href="#b500">Unhandled Exceptions</a><br/>
<a href="#b504">Debugging Exceptions</a><br/>
<a href="#b506">Exception-Handling Performance Considerations</a><br/>
<a href="#b509">Constrained Execution Regions (CERs)</a><br/>
<a href="#b512">Code Contracts</a><br/>
<p>This chapter is all about error handling. But it's not just about that. There are several parts to error handling. First, we'll define what an error actually is. Then, we'll talk about how to discover when your code is experiencing an error and about how to recover from this error At this point, state becomes an issue because errors tend to come at inopportune times. It is likely that your code will be in the middle of mutating some state when it experiences the error, and your code likely will have to restore some state back to what it was prior to attempting to mutate it. Of course, we'll also talk about how your code can notify its callers that it has detected an error.</p>
<p>In my opinion, exception handling is the weakest area of the common language runtime (CLR) and therefore causes many problems for developers writing managed code. Over the years, Microsoft has made some significant improvements to help developers deal with errors, but I believe that there is much more that must be done before we can really have a good, reliable system. I will talk a lot about the various enhancements that have been made when dealing with unhandled exceptions, constrained execution regions, code contracts, runtime wrapped exceptions, uncatchable exceptions, and so on.</p>
<a name="b466"/><h2>Defining &quot;Exception&quot;</h2>
<p>When designing a type, you first imagine the various situations in which the type will be used. The type name is usually a noun, such as <b>FileStream </b>or <b>StringBuilder </b>. Then you define the properties, methods, events, and so on for the type. The way you define these members (property data types, method parameters, return values, and so forth) becomes the programmatic interface for your type These members indicate actions that can be performed by the type itself or on an instance of the type. These action members are usually verbs such as <b>Read, Write, Flush, Append, Insert, Remove, </b>etc. When an action member cannot complete its task, the member should throw an exception.</p>
<hr/>
<blockquote><b>Important </b>An exception is when a member fails to complete the task it is supposed to perform as indicated by its name.</blockquote>
<hr/>
<p>Look at the following class definition:</p>
<p><code>internal sealed class Account {<br/>
public static void Transfer(Account from, Account to, Decimal amount) { from -= amount; to += amount;<br/>
}<br/>
}</code></p>
<p>The <b>Transfer </b>method accepts two <b>Account </b>objects and a <b>Decimal </b>value that identifies an amount of money to transfer between accounts. Obviously, the goal of the <b>Transfer </b>method is to subtract money from one account and add money to another. The <b>Transfer </b>method could fail for many reasons: the <b>from </b>or <b>to </b>argument might be <b>null; </b>the <b>from </b>or <b>to </b>argument might not refer to an open account; the <b>from </b>account might have insufficient funds; the <b>to </b>account might have so much money in it that adding more would cause it to overflow; or the amount argument might be <b>0, </b>negative, or have more than two digits after the decimal place.</p>
<p>When the <b>Transfer </b>method is called, its code must check for all of these possibilities, and if any of them are detected, it cannot transfer the money and should notify the caller that it failed by throwing an exception In fact, notice that the <b>Transfer </b>method's return type is <b>void </b>. This is because the <b>Transfer </b>method has no meaningful value to return; if it returns at all, it was successful. If it fails, it throws a meaningful exception.</p>
<p>Object-oriented programming allows developers to be very productive because you get to write code like this:</p>
<p><code>Boolean f = &quot;Jeff&quot;.Substring(1, 1).ToUpper().EndsWith(&quot;E&quot;); // true</code></p>
<p>Here I'm composing my intent by chaining several operations together. <sup>1</sup> This code was easy for me to write and is easy for others to read and maintain because the intent is obvious: Take a string, grab a portion of it, uppercase that portion, and see if it ends with an &quot;E.&quot; This is great, but there is a big assumption being made here: no operation fails But, of course, errors are always possible, so we need a way to handle those errors. In fact, there are many object-oriented constructs幼onstructors, getting/setting a property, adding/removing an event, calling an operator overload, calling a conversion operator葉hat have no way to return error codes, but these constructs must still be able to report an error The mechanism provided by the Microsoft .NET Framework and all programming languages that support it is called exception handling.</p>
<hr/>
<blockquote><b>Important </b>Many developers incorrectly believe that an exception is related to how frequently something happens. For example, a developer designing a file <b>Read </b>method is likely to say the following: &quot;When reading from a file, you will eventually reach the end of its data. Since reaching the end will always happen, I'll design my <b>Read </b>method so that it reports the end by returning a special value; I won't have it throw an exception.&quot; The problem with this statement is that it is being made by the developer designing the <b>Read </b>method, not by the developer calling the <b>Read </b>method.</blockquote>
<hr/>
<p>When designing the <b>Read </b>method, it is impossible for the developer to know all of the possible situations in which the method gets called Therefore, the developer can't possibly know how often the caller of the <b>Read </b>method will attempt to read past the end of the file. In fact, since most files contain structured data, attempting to read past the end of a file is something that rarely happens.</p>
<a name="b467"/><h2>Exception-Handling Mechanics</h2>
<p>In this section, I'll introduce the mechanics and C# constructs needed in order to use exception handling, but it's not my intention to explain them in great detail. The purpose of this chapter is to offer useful guidelines for when and how to use exception handling in your code. If you want more information about the mechanics and language constructs for using exception handling, see the .NET Framework documentation and the C# language specification. Also, the .NET Framework exception-handling mechanism is built using the Structured Exception Handling (SEH) mechanism offered by Microsoft Windows. SEH has been discussed in many resources, including my own book, Windows via C/C++, 5th ed. (Microsoft Press, 2007), which contains three chapters devoted to SEH.</p>
<p>The following C# code shows a standard usage of the exception-handling mechanism This code gives you an idea of what exception-handling blocks look like and what their purpose is. In the subsections after the code, I'll formally describe the <b>try, catch, </b>and <b>finally </b>blocks and their purpose and provide some notes about their use.</p>
<p>In fact, C#'s extension method feature exists in the language to allow you to chain more methods together that would not have been chainable otherwise.</p>
<p><code>private void SomeMethod() { try {<br/>
// Put code requiring graceful recovery and/or cleanup operations here...<br/>
}<br/>
catch (InvalidOperationException) {<br/>
// Put code that recovers from an InvalidOperationException here...<br/>
}<br/>
catch (IOException) {<br/>
// Put code that recovers from an IOException here...<br/>
}<br/>
catch {<br/>
// Put code that recovers from any kind of exception other than those above here...<br/>
// When catching any exception, you usually re-throw the exception.<br/>
// I explain re-throwing later in this chapter.<br/>
throw;<br/>
}<br/>
finally {<br/>
// Put code that cleans up any operations started within the try block here...<br/>
// The code in here ALWAYS executes, regardless of whether an exception is thrown.<br/>
}<br/>
// Code below the finally block executes if no exception is thrown within the try block // or if a catch block catches the exception and doesn't throw or re-throw an exception.<br/>
}</code></p>
<p>This code demonstrates one possible way to use exception-handling blocks. Don't let the code scare you洋ost methods have simply a <b>try </b>block matched with a single <b>finally </b>block or a <b>try </b>block matched with a single <b>catch </b>block. It's unusual to have as many <b>catch </b>blocks as in this example. I put them there for illustration purposes.</p>
<h3>The try Block</h3>
<p>A <b>try </b>block contains code that requires common cleanup operations, exception-recovery operations, or both. The cleanup code should be placed in a single <b>finally </b>block. A <b>try </b>block can also contain code that might potentially throw an exception. The exception-recovery code should be placed in one or more <b>catch </b>blocks. You create one <b>catch </b>block for each kind of exception that your application can safely recover from. A <b>try </b>block must be associated with at least one <b>catch </b>or <b>finally </b>block; it makes no sense to have a <b>try </b>block that stands by itself, and C# will prevent you from doing this.</p>
<hr/>
<blockquote><b>Important </b>Sometimes developers ask how much code they should put inside a single try block The answer to this depends on state management If, inside a try block, you execute multiple operations that could all throw the same exception type and the way that you'd recover this exception type is different depending on the operation, then you should put each operation in its own try block so that you can recover your state correctly</blockquote>
<hr/>
<h3>The catch Block</h3>
<p>A <b>catch </b>block contains code to execute in response to an exception. A <b>try </b>block can have zero or more <b>catch </b>blocks associated with it. If the code in a <b>try </b>block doesn't cause an exception to be thrown, the CLR will never execute the code contained within any of its <b>catch </b>blocks. The thread will simply skip over all of the <b>catch </b>blocks and execute the code in the <b>finally </b>block (if one exists). After the code in the <b>finally </b>block executes, execution continues with the statement following the <b>finally </b>block.</p>
<p>The parenthetical expression appearing after the <b>catch </b>keyword is called the catch type. In C#, you must specify a catch type of <b>System.Exception </b>or a type derived from <b>System.Exception. </b>For example, the previous code contains <b>catch </b>blocks for handling an <b>InvalidOperationException </b>(or any exception derived from it) and an <b>IOException </b>(or any exception derived from it). The last <b>catch </b>block (which doesn't specify a catch type) handles any exception at all except for the exception type specified by earlier <b>catch </b>blocks; this is equivalent to having a <b>catch </b>block that specifies a catch type of <b>System.Exception </b>except that you cannot access the exception information via code inside the <b>catch </b>block's braces.</p>
<hr/>
<blockquote><b>Note </b>When debugging through a <b>catch </b>block by using Microsoft Visual Studio, you can see the currently thrown exception object by adding the special $exception variable name to a watch window.</blockquote>
<hr/>
<p>The CLR searches from top to bottom for a matching <b>catch </b>type, and therefore you should place the more specific exception types at the top. The most-derived exception types should appear first, followed by their base types (if any), down to <b>System.Exception </b>(or an exception block that doesn't specify a catch type). In fact, the C# compiler generates an error if more specific <b>catch </b>blocks appear closer to the bottom because the <b>catch </b>block would be unreachable.</p>
<p>If an exception is thrown by code executing within the <b>try </b>block (or any method called from within the <b>try </b>block), the CLR starts searching for <b>catch </b>blocks whose catch type is the same type as or a base type of the thrown exception If none of the catch types matches the exception, the CLR continues searching up the call stack looking for a catch type that matches the exception. If after reaching the top of the call stack, no <b>catch </b>block is found with a matching catch type, an unhandled exception occurs. I'll talk more about unhandled exceptions later in this chapter.</p>
<p>Once the CLR locates a <b>catch </b>block with a matching catch type, it executes the code in all inner <b>finally </b>blocks, starting from within the <b>try </b>block whose code threw the exception and stopping with the <b>catch </b>block that matched the exception. Note that any <b>finally </b>block associated with the <b>catch </b>block that matched the exception is not executed yet The code in this <b>finally </b>block won't execute until after the code in the handling <b>catch </b>block has executed.</p>
<p>After all the code in the inner <b>finally </b>blocks has executed, the code in the handling <b>catch </b>block executes. This code typically performs some operations to deal with the exception. At the end of the <b>catch </b>block, you have three choices:</p>
<p>&#9632; Re-throw the same exception, notifying code higher up in the call stack of the exception.</p>
<p>&#9632; Throw a different exception, giving richer exception information to code higher up in the call stack.</p>
<p>&#9632; Let the thread fall out of the bottom of the <b>catch </b>block.</p>
<p>Later in this chapter, I'll offer some guidelines for when you should use each of these techniques. If you choose either of the first two techniques, you're throwing an exception, and the CLR behaves just as it did before: It walks up the call stack looking for a <b>catch </b>block whose type matches the type of the exception thrown.</p>
<p>If you pick the last technique, when the thread falls out of the bottom of the <b>catch </b>block, it immediately starts executing code contained in the <b>finally </b>block (if one exists). After all of the code in the <b>finally </b>block executes, the thread drops out of the <b>finally </b>block and starts executing the statements immediately following the <b>finally </b>block. If no <b>finally </b>block exists, the thread continues execution at the statement following the last <b>catch </b>block.</p>
<p>In C#, you can specify a variable name after a catch type When an exception is caught, this variable refers to the <b>System.Exception</b>-derived object that was thrown. The <b>catch </b>block's code can reference this variable to access information specific to the exception (such as the stack trace leading up to the exception). Although it's possible to modify this object, you shouldn't; consider the object to be read-only. I'll explain the <b>Exception </b>type and what you can do with it later in this chapter.</p>
<hr/>
<blockquote><b>Note </b>Your code can register with <b>AppDomain </b>s <b>FirstChanceException </b>event to receive notifications as soon as an exception occurs within an AppDomain. This notification occurs before the CLR searches for any <b>catch </b>blocks. For more information about this event, see Chapter 22, &quot;CLR Hosting and AppDomains.&quot;</blockquote>
<hr/>
<h3>The finally Block</h3>
<p>A <b>finally </b>block contains code that's guaranteed to execute. <sup>2</sup> Typically, the code in a <b>finally </b>block performs the cleanup operations required by actions taken in the <b>try </b>block.</p>
<p>Aborting a thread or unloading an AppDomain causes the CLR to throw a <b>ThreadAbortException, </b>which allows the <b>finally </b>block to execute. If a thread is simply killed via the Win32 <b>TerminateThread </b>function, or if the process is killed via the Win32 <b>TerminateProcess </b>function or <b>System.Environment</b>'s <b>FailFast </b>method, then the <b>finally </b>block will not execute. Of course Windows cleans up all resources that a process was using when a process terminates.</p>
<p>block:</p>
<p><code>private void ReadData(String pathname) {<br/>
FileStream fs = null; try {<br/>
fs = new FileStreamCpathname, FileMode.Open); // Process the data in the file...<br/>
}<br/>
catch (lOException) {<br/>
// Put code that recovers from an IOException here...<br/>
}<br/>
finally {<br/>
// Make sure that the file gets closed. if (fs != null) fs.CloseC);<br/>
}<br/>
}</code></p>
<p>If the code in the <b>try </b>block executes without throwing an exception, the file is guaranteed to be closed If the code in the <b>try </b>block does throw an exception, the code in the <b>finally </b>block still executes, and the file is guaranteed to be closed, regardless of whether the exception is caught. It's improper to put the statement to close the file after the <b>finally </b>block; the statement wouldn't execute if an exception were thrown and not caught, which would result in the file being left open (until the next garbage collection).</p>
<p>A <b>try </b>block doesn't require a <b>finally </b>block associated with it; sometimes the code in a <b>try </b>block just doesn't require any cleanup code. However, if you do have a <b>finally </b>block, it must appear after any and all <b>catch </b>blocks. A <b>try </b>block can have no more than one <b>finally </b>block associated with it.</p>
<p>When a thread reaches the end of the code contained in a <b>finally </b>block, the thread simply starts executing the statements immediately following the <b>finally </b>block. Remember that the code in the <b>finally </b>block is cleanup code. This code should execute only what is necessary to clean up operations initiated in the <b>try </b>block. The code inside <b>catch </b>and <b>finally </b>blocks should be very short and should have a high likelihood of succeeding without itself throwing an exception. Usually the code in these blocks is just one or two lines of code.</p>
<p>It is always possible that exception-recovery code or cleanup code could fail and throw an exception. While possible, it is unlikely and if it does happen it usually means that there is something very wrong somewhere. Most likely some state has gotten corrupted somewhere. If an exception is inadvertently thrown within a <b>catch </b>or <b>finally </b>block, the world will not come to an end葉he CLR's exception mechanism will execute as though the exception were thrown after the <b>finally </b>block. However, the CLR does not keep track of the first exception that was thrown in the corresponding <b>try </b>block (if any), and you will lose any and all information (such as the stack trace) available about the first exception. Probably (and hopefully), this new exception will not be handled by your code and the exception will turn into an unhandled exception. The CLR will then terminate your process, which is good because all the corrupted state will now be destroyed. This is much better than having your application continue to run with unpredictable results and possible security holes.</p>
<p>Personally, I think the C# team should have chosen different language keywords for the exception-handling mechanism. What programmers want to do is try to execute some piece of code And then, if something fails, either recover from the failure and move on or compensate to undo some state change and continue to report the failure up to a caller Programmers also want to have guaranteed cleanup no matter what happens. The code on the left is what you have to write to make the C# compiler happy, but the code on the right is the way I prefer to think about it:</p>
<p><b>CLS and Non-CLS Exceptions</b></p>
<p>All programming languages for the CLR must support the throwing of <b>Exception-</b>derived objects because the Common Language Specification (CLS) mandates this. However, the CLR actually allows an instance of any type to be thrown, and some programming languages will allow code to throw non-CLS-compliant exception objects such as a <b>String, Int32, </b>or <b>DateTime. </b>The C# compiler allows code to throw only <b>Exception</b>-derived objects, whereas code written in some other languages allow code to throw <b>Exception</b>-derived objects as well as objects that are not derived from <b>Exception </b>.</p>
<p>Many programmers are not aware that the CLR allows any object to be thrown to report an exception. Most developers believe that only <b>Exception</b>-derived objects can be thrown. Prior to version 2.0 of the CLR, when programmers wrote <b>catch </b>blocks to catch exceptions, they were catching CLS-compliant exceptions only. If a C# method</p>
<img src="50.jpg"/>
<p>called a method written in another language, and that method threw a non-CLS-compliant exception, the C# code would not catch this exception at all, leading to some security vulnerabilities.</p>
<p>In version 2. 0 of the CLR, Microsoft introduced a new <b>RuntimeWrappedException </b>class (defined in the <b>System.Runtime.CompilerServices </b>namespace). This class is derived from <b>Exception, </b>so it is a CLS-compliant exception type. The <b>RuntimeWrappedException </b>class contains a private field of type <b>Object </b>(which can be accessed by using <b>RuntimeWrappedException</b>'s <b>WrappedException </b>read-only property) In version 2 0 of the CLR, when a non-CLS-compliant exception is thrown, the CLR automatically constructs an instance of the <b>RuntimeWrappedException </b>class and initializes its private field to refer to the object that was actually thrown. In effect, the CLR now turns all non-CLS-compliant exceptions into CLS-compliant exceptions Any code that now catches an <b>Exception </b>type will catch non-CLS-compliant exceptions, which fixes the potential security vulnerability problem.</p>
<p>Although the C# compiler allows developers to throw <b>Exception</b>-derived objects only, prior to C# version 2 0, the C# compiler did allow developers to catch non-CLS-compli-ant exceptions by using code like this:</p>
<p><code>private void SomeMethod() { try {<br/>
// Put code requiring graceful recovery and/or cleanup operations here...<br/>
}<br/>
catch (Exception e) { <b>I.</b>// Before C# 2.0, this block catches CLS-compliant exceptions only<br/>
// Now, this block catches CLS- &amp; non-CLS-compliant exceptions<br/>
throw; // Re-throws whatever got caught<br/>
}<br/>
catch {<br/>
// In all versions of C#, this block catches CLS- &amp; non-CLS-compliant exceptions<br/>
throw; // Re-throws whatever got caught<br/>
}<br/>
}</code></p>
<p>Now, some developers were aware that the CLR supports both CLS- and non-CLS-compliant exceptions, and these developers might have written the two <b>catch </b>blocks (shown above) in order to catch both kinds of exceptions If the above code is recompiled for CLR 2 0 or later, the second <b>catch </b>block will never execute, and the C# compiler will indicate this by issuing a warning: <b>&quot;CS1058: A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.&quot;</b></p>
<p>There are two ways for developers to migrate code from a version of the .NET Framework prior to version 2. 0. First, you can merge the code from the two <b>catch </b>blocks into a single <b>catch </b>block and delete one of the <b>catch </b>blocks This is the recommended approach Alternatively, you can tell the CLR that the code in your assembly wants to play by the old rules. That is, tell the CLR that your <b>catch (Exception) </b>blocks should not catch an instance of the new <b>RuntimeWrappedException </b>class. And instead, the CLR should unwrap the non-CLS-compliant object and call your code only if you have a <b>catch </b>block that doesn't specify any type at all. You tell the CLR that you want the old behavior by applying an instance of the <b>RuntimeCompatibilityAttribute </b>to your assembly like this:</p>
<p><code>using System.Runtime.CompilerServices;<br/>
[assembly:RuntimeCompatibility(WrapNonExceptionThrows = false)]</code></p>
<hr/>
<blockquote><b>Note </b>This attribute has an assembly-wide impact. There is no way to mix wrapped and <b>I   </b>unwrapped exception styles in the same assembly. Be careful when adding new code (that</blockquote>
<hr/>
<p>expects the CLR to wrap exceptions) to an assembly containing old code (in which the CLR <b>I   </b>didn't wrap exceptions).</p>
<a name="b474"/><h2>The System.Exception Class</h2>
<p>The CLR allows an instance of any type to be thrown for an exception庸rom an <b>Int32 </b>to a <b>String </b>and beyond. However, Microsoft decided against forcing all programming languages to throw and catch exceptions of any type, so they defined the <b>System.Exception </b>type and decreed that all CLS-compliant programming languages must be able to throw and catch exceptions whose type is derived from this type Exception types that are derived from <b>System.Exception </b>are said to be CLS-compliant. C# and many other language compilers allow your code to throw only CLS-compliant exceptions.</p>
<p>The <b>System.Exception </b>type is a very simple type that contains the properties described in Table 20-1. Usually, you will not write any code to query or access these properties in any way. Instead, when your application terminates due to an unhandled exception, you will look at these properties in the debugger or in a report that gets generated and written out to the Windows Application event log or crash dump.</p>
<p><b>table </b><b>20-1 Public Properties of the System.Exception Type</b></p>
<table border="1">
<tr>
<td>
<p>y</p>
</td>
<td>
<p>s</p>
</td>
<td>
<p><b><sup>Type</sup></b></p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Read-only</p>
</td>
<td>
<p>g</p>
</td>
<td>
<p>Contains helpful text indicating why the exception was thrown The message is typically written to a log when a thrown exception is unhandled Since end users do not see this message, the message should be as technical as possible so that developers viewing the log can use the information in the message to fix the code when producing a new version.</p>
</td>
</tr>
</table>
<table border="1">
<tr>
<td>
<p>y</p>
</td>
<td>
<p>s</p>
</td>
<td>
<p><b><sup>Type</sup></b></p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>a</p>
</td>
<td>
<p>Read-only</p>
</td>
<td>
<p>y</p>
</td>
<td>
<p>A reference to a collection of key-value pairs. Usually, the code throwing the exception adds entries to this collection prior to throwing it; code that catches the exception can query the entries and use the information in its exception-recovery processing.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Read/write</p>
</td>
<td>
<p>g</p>
</td>
<td>
<p>Contains the name of the assembly that generated the exception.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Read-only</p>
</td>
<td>
<p>g</p>
</td>
<td>
<p>Contains the names and signatures of methods called that led up to the exception being thrown This property is invaluable for debug<sup>ging</sup>-</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>Read-only</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>Contains the method that threw the exception.</p>
</td>
</tr>
<tr>
<td>
<p>k</p>
</td>
<td>
<p>Read-only</p>
</td>
<td>
<p>g</p>
</td>
<td>
<p>Contains a URL (such as <span>file://C:\MyApp\Help</span>.htm#MyExceptionHelp) to documentation that can help a user understand the exception. Keep in mind that sound programming and security practices prevent users from ever being able to see raw unhandled exceptions, so unless you are trying to convey information to other programmers, this property is seldom used.</p>
</td>
</tr>
<tr>
<td>
<p>n</p>
</td>
<td>
<p>Read-only</p>
</td>
<td>
<p>n</p>
</td>
<td>
<p>Indicates the previous exception if the current exception were raised while handling an exception This read-only property is usually <b>null. </b>The <b>Exception </b>type also offers a public <b>GetBaseException </b>method that traverses the linked list of inner exceptions and returns the originally thrown exception.</p>
</td>
</tr>
</table>
<p>I'd like to say a few words about <b>System.Exception</b>'s read-only <b>StackTrace </b>property. A <b>catch </b>block can read this property to obtain the stack trace indicating what methods were called that led up to the exception. This information can be extremely valuable when you're trying to detect the cause of an exception so that you can correct your code When you access this property, you're actually calling into code in the CLR; the property doesn't simply return a string. When you construct a new object of an <b>Exception</b>-derived type, the <b>StackTrace </b>property is initialized to <b>null. </b>If you were to read the property, you wouldn't get back a stack trace; you would get back <b>null</b>.</p>
<p>When an exception is thrown, the CLR internally records where the <b>throw </b>instruction occurred When a <b>catch </b>block accepts the exception, the CLR records where the exception was caught. If, inside a <b>catch </b>block, you now access the thrown exception object's <b>StackTrace </b>property, the code that implements the property calls into the CLR, which builds a string identifying all of the methods between the place where the exception was thrown and the filter that caught the exception.</p>
<hr/>
<blockquote><b>Important </b>When you throw an exception, the CLR resets the starting point for the exception; that is, the CLR remembers only the location where the most recent exception object was thrown.</blockquote>
<hr/>
<p>The following code throws the same exception object that it caught and causes the CLR to reset its starting point for the exception:</p>
<p><code>private void SomeMethod() { try {... } catch (Exception e) {<br/>
throw e;   // CLR thinks this is where exception originated. // FxCop reports this as an error<br/>
}<br/>
}</code></p>
<p>In contrast, if you re-throw an exception object by using the <b>throw </b>keyword by itself, the CLR doesn't reset the stack's starting point The following code re-throws the same exception object that it caught, causing the CLR to not reset its starting point for the exception:</p>
<p><code>private void SomeMethod() {<br/>
try {... }<br/>
catch (Exception e) {<br/>
throw;   // This has no effect on where the CLR thinks the exception // originated. FxCop does NOT report this as an error<br/>
}<br/>
}</code></p>
<p>In fact, the only difference between these two code fragments is what the CLR thinks is the original location where the exception was thrown. Unfortunately, when you throw or rethrow an exception, Windows does reset the stack's starting point So if the exception becomes unhandled, the stack location that gets reported to Windows Error Reporting is the location of the last throw or re-throw, even though the CLR knows the stack location where the original exception was thrown This is unfortunate because it makes debugging applications that have failed in the field much more difficult. Some developers have found this so intolerable that they have chosen a different way to implement their code to ensure that the stack trace truly reflects the location where an exception was originally thrown:</p>
<p><code>private void SomeMethod() { Boolean trySucceeds = false;<br/>
try {<br/>
trySucceeds = true;<br/>
}<br/>
finally {<br/>
if (!trySucceeds) { /* catch code goes in here */ }<br/>
}<br/>
}</code></p>
<p>The string returned from the <b>StackTrace </b>property doesn't include any of the methods in the call stack that are above the point where the <b>catch </b>block accepted the exception object If you want the complete stack trace from the start of the thread up to the exception handler, you can use the <b>System.Diagnostics.StackTrace </b>type. This type defines some properties and methods that allow a developer to programmatically manipulate a stack trace and the frames that make up the stack trace.</p>
<p>You can construct a <b>StackTrace </b>object by using several different constructors. Some constructors build the frames from the start of the thread to the point where the <b>StackTrace </b>object is constructed. Other constructors initialize the frames of the <b>StackTrace </b>object by using an <b>Exception</b>-derived object passed as an argument.</p>
<p>If the CLR can find debug symbols (located in the.pdb files) for your assemblies, the string returned by <b>System.Exception</b>'s <b>StackTrace </b>property or <b>System.Diagnostics. StackTrace</b>'s <b>ToString </b>method will include source code file paths and line numbers. This information is incredibly useful for debugging.</p>
<p>Whenever you obtain a stack trace, you might find that some methods in the actual call stack don't appear in the stack trace string. There are two reasons for this. First, the stack is really a record of where the thread should return to, not where the thread has come from Second, the just-in-time (JIT) compiler can inline methods to avoid the overhead of calling and returning from a separate method. Many compilers (including the C# compiler) offer a <b>/debug </b>command-line switch When this switch is used, these compilers embed information into the resulting assembly to tell the JIT compiler not to inline any of the assembly's methods, making stack traces more complete and meaningful to the developer debugging the code.</p>
<hr/>
<blockquote><b>Note </b>The JIT compiler examines the <b>System.Diagnostics.DebuggableAttribute </b>custom attribute applied to the assembly The C# compiler applies this attribute automatically If this attribute has the <b>DisableOptimizations </b>flag specified, the JIT compiler won't inline the assembly's methods. Using the C# compiler's <b>/debug </b>switch sets this flag. By applying the <b>System.Runtime.CompilerServices.MethodImplAttribute </b>custom attribute to a method, you can forbid the JIT compiler from inlining the method for both debug and release builds The following method definition shows how to forbid the method from being inlined:</blockquote>
<hr/>
<p><code>using System;<br/>
using System.Runtime.CompilerServices;<br/>
internal sealed class SomeType {<br/>
[MethodImpl(MethodImplOptions.NoInlining)] public void SomeMethod() {<br/>
}<br/>
}</code></p>
<a name="b478"/><h2>FCL-Defined Exception Classes</h2>
<p>The Framework Class Library (FCL) defines many exception types (all ultimately derived from <b>System.Exception). </b>The following hierarchy shows the exception types defined in the MSCorLib.dll assembly; other assemblies define even more exception types. (The application used to obtain this hierarchy is shown in Chapter 23, &quot;Assembly Loading and Reflection.&quot;)</p>
<p><code>System.Exception<br/>
System.AggregateException System.ApplicationException<br/>
System.Reflection.InvalidFilterCriteriaException<br/>
System.Reflection.TargetException<br/>
System.Reflection.TargetlnvocationException<br/>
System.Reflection.TargetParameterCountException<br/>
System.Threading.WaitHandleCannotBeOpenedException System.InvalidTimeZoneException<br/>
System.IO.IsolatedStorage.IsolatedStorageException<br/>
System.Runtime.CompilerServices.RuntimeWrappedException<br/>
System.SystemException<br/>
System.AccessViolationException<br/>
System.AppDomainUnloadedException<br/>
System.ArgumentException<br/>
System.ArgumentNullException<br/>
System.ArgumentOutOfRangeException<br/>
System.DuplicateWaitObjectException<br/>
System.Clobalization.CultureNotFoundException<br/>
System.Text.DecoderFallbackException<br/>
System.Text.EncoderFallbackException System.ArithmeticException<br/>
System.DivideByZeroException<br/>
System.NotFiniteNumberException<br/>
System.OverflowException System.ArrayTypeMismatchException System.BadImageFormatException System.CannotUnloadAppDomainException System.Collections.Ceneric.KeyNotFoundException System.ContextMarshalException System.DataMisalignedException System.ExecutionEngineException System.FormatException<br/>
System.Reflection.CustomAttributeFormatException System.IndexOutOfRangeException System.InsufficientExecutionStackException System.InvalidCastException System.InvalidOperationException<br/>
System.ObjectDisposedException System.InvalidProgramException System.IO.IOException<br/>
System.IO.DirectoryNotFoundException<br/>
System.IO.DriveNotFoundException<br/>
System.IO.EndOfStreamException<br/>
System.IO.FileLoadException<br/>
System.IO.FileNotFoundException<br/>
System.IO.PathTooLongException System.MemberAccessException<br/>
System.FieldAccessException<br/>
System.MethodAccessException<br/>
System.MissingMemberException System.MissingFieldException System.MissingMethodException System.MulticastNotSupportedException System.NotImplementedException System.NotSupportedException<br/>
System.PlatformNotSupportedException System.NullReferenceException System.OperationCanceledException<br/>
System.Threading.Tasks.TaskCanceledException System.OutOfMemoryException<br/>
System.InsufficientMemoryException System.RankException<br/>
System.Reflection.AmbiguousMatchException<br/>
System.Reflection.ReflectionTypeLoadException<br/>
System.Resources.MissingManifestResourceException<br/>
System.Resources.MissingSatelliteAssemblyException<br/>
System.Runtime.InteropServices.ExternalException<br/>
System.Runtime.InteropServices.COMException<br/>
System.Runtime.InteropServices.SEHException System.Runtime.InteropServices.InvalidComObjectException System.Runtime.InteropServices.InvalidOleVariantTypeException System.Runtime.InteropServices.MarshalDirectiveException System.Runtime.InteropServices.SafeArrayRankMismatchException System.Runtime.InteropServices.SafeArrayTypeMismatchException System.Runtime.Remoting.RemotingException<br/>
System.Runtime.Remoting.RemotingTimeoutException System.Runtime.Remoting.ServerException System.Runtime.Serialization.SerializationException System.Security.Cryptography.CryptographicException<br/>
System.Security.Cryptography.CryptographicUnexpectedOperationException System.Security.HostProtectionException System.Security.Policy.PolicyException System.Security.Principal.IdentityNotMappedException System.Security.SecurityException System.Security.VerificationException System.Security.XmlSyntaxException System.StackOverflowException System.Threading.AbandonedMutexException System.Threading.SemaphoreFullException System.Threading.SynchronizationLockException System.Threading.ThreadAbortException System.Threading.ThreadInterruptedException System.Threading.ThreadStartException System.Threading.ThreadStateException System.TimeoutException System.TypeInitializationException System.TypeLoadException<br/>
System.DllNotFoundException<br/>
System.EntryPointNotFoundException System.TypeUnloadedException System.UnauthorizedAccessException<br/>
System.Security.AccessControl.PrivilegeNotHeldException System.Threading.LockRecursionException System.Threading.Tasks.TaskSchedulerException System.TimeZoneNotFoundException</code></p>
<p>Microsoft's original idea was that <b>System.Exception </b>would be the base type for all exceptions and that two other types, <b>System.SystemException </b>and <b>System. ApplicationException, </b>would be the only two types immediately derived from <b>Exception. </b>Furthermore, exceptions thrown by the CLR would be derived from <b>SystemException, </b>and all application-thrown exceptions would be derived from <b>ApplicationException. </b>This way, developers could write a <b>catch </b>block that catches all CLR-thrown exceptions or all application-thrown exceptions.</p>
<p>However, as you can see, this rule was not followed very well; some exception types are immediately derived from <b>Exception (IsolatedStorageException), </b>some CLR-thrown exceptions are derived from <b>ApplicationException (TargetlnvocationException), </b>and some application-thrown exceptions are derived from <b>SystemException (FormatException) </b>. So it is all a big mess, and the result is that the <b>SystemException </b>and <b>ApplicationException </b>types have no special meaning at all. At this point, Microsoft would like to remove them from the exception class hierarchy, but they can't because it would break any code that already references these two types.</p>
<a name="b480"/><h2>Throwing an Exception</h2>
<p>When implementing your own methods, you should throw an exception when the method cannot complete its task as indicated by its name. When you want to throw an exception, there are two issues that you really need to think about and consider.</p>
<p>The first issue is about deciding what <b>Exception</b>-derived type are you going to throw. You really want to select a type that is meaningful here. Consider the code that is higher up the call stack and how that code might want to determine that a method failed in order to execute some graceful recovery code. You can use a type that is already defined in the FCL, but there may not be one in the FCL that matches your exact semantics. So you'll probably need to define your own type, ultimately derived from <b>System.Exception.</b></p>
<p>If you want to define an exception type hierarchy, it is highly recommended that the hierarchy be shallow and wide in order to create as few base classes as possible. The reason is that base classes act as a way of treating lots of errors as one error, and this is usually dangerous. Along these lines, you should never throw a <b>System.Exception </b>object,<sup>3</sup> and you should use extreme caution if you throw any other base class exception type.</p>
<p>In fact, the <b>System.Exception </b>class should have been marked as <b>abstract, </b>which would forbid code that tried to throw it from even compiling</p>
<hr/>
<blockquote><b>Important </b>There are versioning ramifications here, too. If you define a new exception type derived from an existing exception type, then all code that catches the existing base type will now catch your new type as well In some scenarios this may be desired and in some scenarios, it may not be desired The problem is that it really depends on how code that catches the base class responds to the exception type and types derived from it Code that never anticipated the new exception may now behave unpredictably and open security holes. The person defining the new exception type can't know about all the places where the base exception is caught and how it is handled. And so, in practice, it is impossible to make a good intelligent decision here.</blockquote>
<hr/>
<p>The second issue is about deciding what string message are you going to pass to the exception type's constructor. When you throw an exception, you should include a string message with detailed information indicating why the method couldn't complete its task. If the exception is caught and handled, this string message is not seen. However, if the exception becomes an unhandled exception, this message is usually logged. An unhandled exception indicates a true bug in the application, and a developer must get involved to fix the bug. An end user will not have the source code or the ability to fix the code and recompile it. In fact, this string message should not be shown to an end user. So these string messages can be very technically detailed and as geeky as is necessary to help developers fix their code.</p>
<p>Furthermore, since all developers have to speak English (at least to some degree, since programming languages and the FCL classes and methods are in English), there is usually no need to localize exception string messages. However, you may want to localize the strings if you are building a class library that will be used by developers who speak different languages. Microsoft localizes the exception messages thrown by the FCL, since developers all over the world will be using this class library.</p>
<a name="b481"/><h2>Defining Your Own Exception Class</h2>
<p>Unfortunately, designing your own exception is tedious and error prone The main reason for this is because all <b>Exception</b>-derived types should be serializable so that they can cross an AppDomain boundary or be written to a log or database. There are many issues related to serialization and they are discussed in Chapter 24, &quot;Runtime Serialization.&quot; So, in an effort to simplify things, I made my own generic <b>Exception&lt;TExceptionArgs&gt; </b>class, which is defined as follows:</p>
<p><code>[Serializable]<br/>
public sealed class Exception&lt;TExceptionArgs&gt; : Exception, ISerializable where TExceptionArgs : ExceptionArgs {<br/>
private const String c_args = &quot;Args&quot;;   // For (de)serialization private readonly TExceptionArgs m_args;<br/>
public   TExceptionArgs Args { get { return m_args; } }<br/>
public Exception(String message = null, Exception innerException = null) : thisCnull, message, innerException) { }<br/>
public ExceptionCTExceptionArgs args, String message = null,<br/>
Exception innerException = null): base(message, innerException) { m_args = args; }<br/>
// The constructor is for deserialization; since the class is sealed, the constructor is // private. If this class were not sealed, this constructor should be protected [SecurityPermissionCSecurityAction.LinkDemand,<br/>
Flags=SecurityPermissionFlag.SerializationFormatter)] private Exception(SerializationInfo info, StreamingContext context)<br/>
: baseCinfo, context) {<br/>
m_args = (TExceptionArgs)info.GetValue(c_args, typeof(TExceptionArgs));<br/>
}<br/>
// The method for serialization; it's public because of the ISerializable interface [SecurityPermissionCSecurityAction.LinkDemand,<br/>
Flags=SecurityPermissionFlag.SerializationFormatter)] public override void GetObjectData(SerializationInfo info, StreamingContext context) {<br/>
info.AddValue(c_args, m_args);<br/>
base.CetObjectDataCinfo, context);<br/>
}<br/>
public override String Message {<br/>
get {<br/>
String baseMsg = base.Message;<br/>
return (m_args == null) ? baseMsg : baseMsg + &quot; C&quot; + m_args.Message + &quot;)&quot;;<br/>
}<br/>
}<br/>
public override Boolean Equals(Object obj) {<br/>
Exception&lt;TExceptionArgs&gt; other = obj as Exception&lt;TExceptionArgs&gt;; if (obj == null) return false;<br/>
return Object.Equals(m_args, other.m_args) &amp;&amp; base.Equals(obj);<br/>
}<br/>
public override int CetHashCodeC) { return base.CetHashCodeC); }<br/>
}</code></p>
<p>And the <b>ExceptionArgs </b>base class that <b>TExceptionArgs </b>is constrained to is very simple and looks like this:</p>
<p><code>[Serializable]<br/>
public abstract class ExceptionArgs {<br/>
public virtual String Message { get { return String.Empty; } }<br/>
}</code></p>
<p>Now, with these two classes defined, I can trivially define more exception classes when I need to. To define an exception type indicating the disk is full, I simply do this:</p>
<p><code>[Serializable]<br/>
public sealed class DiskFullExceptionArgs : ExceptionArgs {<br/>
private readonly String m_diskpath; // private field set at construction time<br/>
public DiskFullExceptionArgsCString diskpath) { m_diskpath = diskpath; }<br/>
// Public read-only property that returns the field public String DiskPath { get { return m_diskpath; } }<br/>
// Override the Message property to include our field Cif set) public override String Message {<br/>
get {<br/>
return Cm_diskpath == null) ? base.Message : &quot;DiskPath=&quot; + m_diskpath;<br/>
}<br/>
}<br/>
}</code></p>
<p>And, if I have no additional data that I want to put inside the class, it gets as simple as this: [Serializable]</p>
<p><code>public sealed class DiskFullExceptionArgs : ExceptionArgs { }</code></p>
<p>And now I can write code like this, which throws and catches one of these:</p>
<p><code>public static void TextExceptionC) {<br/>
try {<br/>
throw new Exception&lt;DiskFullExceptionArgs&gt;C<br/>
new DiskFullExceptionArgsC@&quot;C:\&quot;), &quot;The disk is full&quot;);<br/>
}<br/>
catch CException&lt;DiskFullExceptionArgs&gt; e) { Console.WriteLineCe.Message);<br/>
}<br/>
}</code></p>
<hr/>
<blockquote><b>Note </b>There are two issues to note about my <b>Exception&lt;TExceptionArgs&gt; </b>class. The first issue is that any exception type you define with it is always derived from <b>System.Exception </b>. In most scenarios, this is not a problem at all and, in fact, having a shallow and wide exception type hierarchy is preferred. The second issue is that Visual Studio's unhandled exception dialog box doesn't display <b>Exception&lt;T&gt; </b>type's generic type parameter, as you can see here:</blockquote>
<hr/>
<img src="51.jpg"/>
<a name="b484"/><h2>Trading Reliability for Productivity</h2>
<p>I started writing software in 1975. I did a fair amount of BASIC programming, and as I got more interested in hardware, I switched to assembly language. Over time, I switched to the C programming language because it allowed me access to hardware with a much higher level of abstraction, making my programming easier. My background is in writing operating systems code and platform/library code, so I always work hard to make my code as small and as fast as possible since applications can only be as good as the OS and libraries they consume.</p>
<p>In addition to creating small and fast code, I always focused on error recovery When allocating memory (by using C++'s <b>new </b>operator or by calling <b>malloc, HeapAlloc, VirtualAlloc, </b>etc.), I would always check the return value to ensure that the memory I requested was actually given to me. And, if the memory request failed, I always had an alternate code path ensuring that the rest of the program's state was unaffected and would let any of my callers know that I failed so that the calling code can take corrective measures too.</p>
<p>For some reason that I can't quite explain, this attention to detail is not done when writing code for the .NET Framework. Getting an out-of-memory situation is always possible and yet I almost never see any code containing a <b>catch </b>block to recover from an <b>OutOfMemoryException </b>. In fact, I've even had some developers tell me that the CLR doesn't let a program catch an <b>OutOfMemoryException </b>. For the record, this is absolutely not true; you can catch this exception. In fact, there are many errors that are possible when executing managed code and I hardly ever see developers write code that attempts to recover from these potential failures. In this section, I'd like to point out some of the potential failures and why it has become culturally acceptable to ignore them. I'd also like to point out some of the significant problems that can occur when ignoring these failures and suggest some ways to help mitigate these problems.</p>
<p>Object-oriented programming allows developers to be very productive. A big part of this is composability which makes it easy to write, read and maintain code. Take this line of code, for example:</p>
<p><code>Boolean f = &quot;Jeff'.SubstringCl, 1).ToUpperC).EndsWithC&quot;E&quot;);</code></p>
<p>There is a big assumption being made with the code above: no errors occur But, of course, errors are always possible, and so we need a way to handle those errors. This is what the exception handling constructs and mechanisms are all about and why we need them as opposed to having methods that return <b>true/false </b>to indicate success/failure the way that Win32 and COM functions do.</p>
<p>In addition to code composability, we are productive due to all kinds of great features provided by our compilers For example, the compiler implicitly:</p>
<p>&#9632; Inserts optional parameters when calling a method</p>
<p>&#9632; Boxes value type instances</p>
<p>&#9632; Constructs/initializes parameter arrays</p>
<p>&#9632; Binds to members of <b>dynamic </b>variables and expressions</p>
<p>&#9632; Binds to extension methods</p>
<p>&#9632; Binds/invokes overloaded operators</p>
<p>&#9632; Constructs delegate objects</p>
<p>&#9632; Infers types when calling generic methods, declaring a local variable, and using a lambda expression</p>
<p>&#9632; Defines/constructs closure classes for lambda expressions and iterators</p>
<p>&#9632; Defines/constructs/initializes anonymous types and instances of them</p>
<p>&#9632; Rewrites code to support Language Integrated Queries (LINQs; query expressions and expression trees)</p>
<p>And, the CLR itself does all kinds of great things for developers to make our lives even easier For example, the CLR implicitly:</p>
<p>&#9632; Invokes virtual methods and interface methods</p>
<p>&#9632; Loads assemblies and JIT-compiles methods which can potentially throw <b>FileLoadException, BadlmageFormatException, InvalidProgramException, FieldAccessException, MethodAccessException, MissingFieldException, MissingMethodException,</b>and <b>VerificationException</b></p>
<p>&#9632; Transitions across AppDomain boundaries when accessing an object of a <b>MarshalByRefObject</b>-derived type which can potentially throw <b>AppDomainUnloadedException</b></p>
<p>&#9632; Serializes and deserializes objects when crossing an AppDomain boundary</p>
<p>&#9632; Causes thread(s) to throw a <b>ThreadAbortException </b>when <b>Thread.Abort </b>or <b>AppDomain.Unload </b>is called</p>
<p>&#9632; Invokes <b>Finalize </b>methods after a garbage collection before objects have their memory reclaimed</p>
<p>&#9632; Creates type objects in the loader heap when using generic types</p>
<p>&#9632; Invokes a type's static constructor potential throwing of <b>TypeInitializationException</b></p>
<p>&#9632; Throws various exceptions, including <b>OutOfMemoryException, DivideByZeroException, NullReferenceException, RuntimeWrappedException, TargetInvocationException, OverflowException, NotFiniteNumberException, ArrayTypeMismatchException, DataMisalignedException, IndexOutOfRangeException, InvalidCastException, RankException, SecurityException, </b>and more</p>
<p>And, of course, the .NET Framework ships with a massive class library which contains tens of thousands of types each type encapsulating common, reusable functionality There are types for building Web form applications, Web services, rich GUI applications, working with security, manipulation of images, speech recognition, and the list goes on and on Any of this code could throw an exception, indicating failure And, future versions could introduce new exception types derived from existing exception types and now your <b>catch </b>blocks catch exception types that never existed before.</p>
<p>All of this stuff熔bject-oriented programming, compiler features, CLR features, and the enormous class library擁s what makes the .NET Framework such a compelling software development platform.<sup>4</sup> My point is that all of this stuff introduces points of failure into your code which you have little control over. As long as everything is working great, all is well: we write code easily, the code is easy to read and maintain. But, when something goes wrong, it is nearly impossible to fully understand what went wrong and why. Here is an example that should really help get my point across:</p>
<p><code>private static Object OneStatement(Stream stream, Char charToFind) {<br/>
return (charToFind + &quot;: &quot; + stream.GetType() + String.Empty + (stream.Position + 512M)).Where(c=&gt;c == charToFind).ToArray();<br/>
}</code></p>
<p>This slightly contrived method contains just one C# statement in it, but this statement does an awful lot of work. In fact, here is the Intermediate Language (IL) the C# compiler produced for this method (I've put some lines in boldface italics that are potential points of failure due to implicit operations that are occurring.</p>
<p><code>.method private hidebysig static object OneStatement(<br/>
class [mscorlib]System.IO.Stream stream, char charToFind) cil managed {.maxstack 5.locals init (<br/>
[0] class Program/&lt;&gt;c_DisplayClass1 CS$&lt;&gt;8_locals2,<br/>
[1] object[] CS$0$0000)</code></p>
<p><b>L_0000: newobj instance void Program/&lt;&gt;c_DisplayClass1::.ctor()</b></p>
<p><code>L_0005: stloc.0 L_0006: ldloc.0 L_0007: ldarg.1<br/>
L_0008: stfld char Program/&lt;&gt;c_DisplayClass1::charToFind<br/>
L_000d: ldc.i4.5 <b>L_000e: newarr object </b>L_0013: stloc.1 L_0014: ldloc.1 L_0015: ldc.i4.0 L_0016: ldloc.0<br/>
L_0017: ldfld char Program/&lt;&gt;c_DisplayClass1::charToFind</code></p>
<p>I should also add that Visual Studio's editor, IntelliSense support, code snippet support, templates, extensibility system, debugging system, and various other tools also contribute to making the platform compelling for developers However, I leave this out of the main discussion because it has no impact on the behavior of the code at runtime.</p>
<p><b>L_001c:.box char</b></p>
<p><code>L_0021:.stelem.ref<br/>
L_0022:.ldloc.1<br/>
L_0023:.ldc.i4.1<br/>
L_0024:.ldstr &quot;: &quot;<br/>
L_0029:.stelem.ref<br/>
L_002a:.ldloc.1<br/>
L_002b:.ldc.i4.2<br/>
L_002c:.ldarg.0<br/>
L_002d:.callvirt instance class [mscorlib]System.Type [mscorlib]System.Object::CetType()<br/>
L_0032:.stelem.ref<br/>
L_0033:.ldloc.1<br/>
L_0034:.ldc.i4.3<br/>
L_0035:.ldsfld string [mscorlib]System.String::Empty<br/>
L_003a:.stelem.ref<br/>
L_003b: ldloc.1 L_003c: ldc.i4.4 L_003d: ldc.i4 0x200</code></p>
<p><b>L_0042: newobj instance void [mscorlibJSystem.Decimal::.ctor(int32)</b></p>
<p><code>L_0047: ldarg.0</code></p>
<p><b>L_0048: callvirt instance int64 [mscorlib]System.IO.Stream::get_Position() L_004d: call valuetype [mscorlib]System.Decimal</b></p>
<p><b>[mscorlib]System.Decimal::op_Implicit(int64) L_0052: call valuetype [mscorlib]System.Decimal [mscorlib]System.Decimal::op_Addition</b></p>
<p><b>(valuetype [mscorlib]System.Decimal, valuetype [mscorlibJSystem.Decimal) L_0057: box [mscorlibJSystem.Decimal </b>L_005c: stelem.ref L_005d: ldloc.1</p>
<p><b>L_005e: call string [mscorlibJSystem.String::Concat(object[J)</b></p>
<p><code>L_0063: ldloc.0<br/>
L_0064: ldftn instance bool Program/&lt;&gt;c_DisplayClass1::&lt;M&gt;b_0(char)</code></p>
<p><b>L_006a: newobj instance</b></p>
<p><b>void [mscorlibJSystem.Func2&lt;char, bool&gt;::.ctor(object, native int) L_006f: call class [mscorlibJSystem.Collections.Generic.IEnumerable1&lt;!!0&gt; [System.CoreJSystem.Linq.Enumerable::Where&lt;char&gt;(</b></p>
<p><b>class [mscorlibJSystem.Collections.Generic.IEnumerable1&lt;!!0&gt;, class [mscorlibJSystem.Func2&lt;!!0, bool&gt;) L_0074: call !!0[J [System.CoreJSystem.Linq.Enumerable::ToArray&lt;char&gt;</b></p>
<p><b>(class [mscorlibJSystem.Collections.Generic.IEnumerable1&lt;!!0&gt;)</b></p>
<p><code>L_0079: ret<br/>
}</code></p>
<p>As you can see, an <b>OutOfMemoryException </b>is possible when constructing the</p>
<p><b>&lt;&gt;c__DisplayClass1 </b>class (a compiler-generated type), the <b>Object[] </b>array, the <b>Func</b></p>
<p>delegate, and boxing the <b>char </b>and <b>Decimal. </b>Memory is also allocated internally when <b>Concat, Where, </b>and <b>ToArray </b>are called. Constructing the <b>Decimal </b>instance could cause its type constructor to be invoked resulting in a <b>TypeInitializationException.</b><sup>5</sup> And then, there are the implicit calls to <b>Decimal</b>'s <b>op_Implicit </b>operator and its <b>op_Addition </b>operator methods, which could do anything including throwing an <b>OverflowException </b>.</p>
<p>By the way, <b>System.Char, System.String, System.Type, </b>and <b>System.IO.Stream </b>all define class constructors which could all potentially cause a <b>TypeInitializationException </b>to be thrown at some point in this application.</p>
<p>Querying <b>Stream</b>'s <b>Position </b>property is interesting. First, it is a virtual property and so my <b>OneStatement </b>method has no idea what code will actually execute which could throw any exception at all. Second, <b>Stream </b>is derived from <b>MarshalByRefObject </b>and so the stream argument could actually refer to a proxy object which itself refers to an object in another AppDomain The other AppDomain could be unloaded and so an <b>AppDomainUnloadedException </b>could also be thrown here.</p>
<p>Of course, all the methods that are being called are methods that I personally have no control over since they are produced by Microsoft. And it's entirely possible that Microsoft might change how these methods are implemented in the future, so they could throw new exception types that I could not possibly know about on the day I wrote the <b>OneStatement </b>method. How can I possibly write my <b>OneStatement </b>method to be completely robust against all possible failures? By the way, the opposite is also a problem: a <b>catch </b>block could catch an exception type derived from the specified exception type and now I'm executing recovery code for a different kind of failure.</p>
<p>So now that you have a sense of all the possible failures, you can probably see why it has become culturally acceptable to not write truly robust and reliable code: it is simply impractical. Moreover, one could argue that it is actually impossible. The fact that errors do not occur frequently is another reason why it has become culturally acceptable. Since errors (like <b>OutOfMemoryException) </b>occur very infrequently, the community has decided to trade truly reliable code for programmer productivity.</p>
<p>One of the nice things about exceptions is that an unhandled one causes your application to terminate. This is nice because during testing, you will discover problems quickly and the information you get with an unhandled exception (error message and stack trace) are usually enough to allow you to fix your code. Of course, a lot of companies don't want their application to just terminate after it has been tested and deployed and so a lot of developers insert code to catch <b>System.Exception, </b>the base class of all exception types. However, the problem with catching <b>System.Exception </b>and allowing the application to continue running is that state may be corrupted.</p>
<p>Earlier in this chapter, I showed an <b>Account </b>class that defines a <b>Transfer </b>method whose job is to transfer money from one account to another account. What if, when this <b>Transfer </b>method is called, it successfully subtracts money from the <b>from </b>account and then throws an exception before it adds money to the <b>to </b>account? If calling code catches <b>System. Exception </b>and continues running, then the state of the application is corrupted: both the <b>from </b>and <b>to </b>accounts have less money in them then they should. Since we are talking about money here, this state corruption wouldn't just be considered a simple bug, it would definitely be considered a security bug If the application continues running, it will attempt to perform more transfers to and from various accounts and now state corruption is running rampant within the application.</p>
<p>One could say that the <b>Transfer </b>method itself should catch <b>System.Exception </b>and restore money back into the <b>from </b>account. And this might actually work out OK if the <b>Transfer </b>method is simple enough. But if the <b>Transfer </b>method produces an audit record of the withdrawn money or if other threads are manipulating the same account at the same time, then attempting to undo the operation could fail as well, producing yet another thrown exception And now, state corruption is getting worse, not better.</p>
<hr/>
<blockquote><b>Note </b>One could argue that knowing where something went wrong is more useful than knowing what error occurred. For example, it might be more useful to know that transferring money out of an account failed instead of knowing that <b>Transfer </b>failed due to a <b>SecurityException </b>or <b>OutOfMemoryException, </b>etc. In fact, the Win32 error model works this way: methods return <b>true/false </b>to indicate success/failure so you know which method failed. Then, if your program cares about why it failed, it calls the Win32 <b>GetLastError </b>method. <b>System.Exception </b>does have a <b>Source </b>property that tells you the method that failed. But this property is a <b>String </b>that you'd have to parse, and if two methods internally call the same method, you can't tell from the <b>Source </b>property alone which method your code called that failed. Instead, you'd have to parse the <b>String </b>returned from <b>Exception</b>'s <b>StackTrace </b>property to get this information. Since this is so difficult, I've never seen anyone actually write code to do it.</blockquote>
<hr/>
<p>There are several things you can do to help mitigate state corruption:</p>
<p>&#9632; The CLR doesn't allow a thread to be aborted when executing code inside a <b>catch </b>or <b>finally </b>block. So, we could make the <b>Transfer </b>method more robust simply by doing this:</p>
<p><code>public static void Transfer(Account from, Account to, Decimal amount) { try { /* do nothing in here */ } finally {<br/>
from -= amount;<br/>
// Now, a thread abort (due to Thread.Abort/AppDomain.Unload) can't happen here to += amount;<br/>
}<br/>
}</code></p>
<p>However, it is absolutely not recommended that you write all your code in <b>finally </b>blocks! You should only use this technique for modifying extremely sensitive state.</p>
<p>&#9632; You can use the <b>System.Diagnostics.Contracts.Contract </b>class to apply code contracts to your methods. Code contracts give you a way to validate arguments and other variables before you attempt to modify state using these arguments/variables. If the arguments/variables meet the contract, then the chance of corrupted state is minimized (not completely eliminated). If a contract fails, then an exception is thrown before any state has been modified. I will talk about code contracts later in this chapter.</p>
<p>&#9632; You can use constrained execution regions (CERs), which give you a way to take some CLR uncertainty out of the picture. For example, before entering a <b>try </b>block, you can have the CLR load any assemblies needed by code in any associated <b>catch</b></p>
<p>and <b>finally </b>blocks. In addition, the CLR will compile all the code in the <b>catch </b>and <b>finally </b>blocks including all the methods called from within those blocks. This will eliminate a bunch of potential exceptions (including <b>FileLoadException, BadImageFormatException, InvalidProgramException, FieldAccessException, MethodAccessException, MissingFieldException, </b>and <b>MissingMethodException) </b>from occurring when trying to execute error recovery code (in <b>catch </b>blocks) or cleanup code (in the <b>finally </b>block). It will also reduce the potential for <b>OutOfMemoryException </b>and some other exceptions as well. I talk about CERs later in this chapter.</p>
<p>&#9632; Depending on where the state lives, you can use transactions which ensure that all state is modified or no state is modified. If the data is in a database, for example, transactions work well. Windows also now supports transacted registry and file operations (on an NTFS volume only) and so you might be able to use this; however the .NET Framework doesn't expose this functionality directly today. You will have to P/Invoke to native code to leverage it. See the <b>System.Transactions.TransactionScope </b>class for more details about this.</p>
<p>&#9632; You can design your methods to be more explicit. For example, the <b>Monitor </b>class is typically used for taking/releasing a thread synchronization lock as follows:</p>
<p><code>public static class SomeType {<br/>
private static Object s_myLockObject = new Object();<br/>
public static void SomeMethod () {<br/>
Monitor.Enter(s_myLockObject);   // If this throws, did the lock get taken or<br/>
// not? If it did, then it won't get released!<br/>
try {<br/>
// Do thread-safe operation here...<br/>
}<br/>
finally {<br/>
Monitor.Exit(s_myLockObject);<br/>
}<br/>
}<br/>
//...<br/>
}</code></p>
<p>Due to the problem shown above, the overload of <b>Monitor</b>'s <b>Enter </b>method used above is now discouraged, and it is recommended that you rewrite the above code as follows:</p>
<p><code>public static class SomeType {<br/>
private static Object s_myLockObject = new Object();<br/>
public static void SomeMethod () {<br/>
Boolean lockTaken = false;   // Assume the lock was not taken<br/>
try {<br/>
// This works whether an exception is thrown or not! Monitor.Enter(s_myLockObject, ref lockTaken);<br/>
// Do thread-safe operation here...<br/>
}<br/>
finally {<br/>
// If the lock was taken, release it<br/>
if (lockTaken) Monitor.Exit(s_myLockObject);<br/>
}<br/>
}<br/>
//...<br/>
}</code></p>
<p>While the explicitness in this code is an improvement, in the case of thread synchronization locks, the recommendation now is to not use them with exception handling at all. See Chapter 29, &quot;Hybrid Thread Synchronization Constructs,&quot; for more details about this.</p>
<p>If, in your code, you have determined that state has already been corrupted beyond repair, then you should destroy any corrupted state so that it can cause no additional harm. Then, restart your application so your state initializes itself to a good condition and hopefully, the state corruption will not happen again Since managed state cannot leak outside of an AppDomain, you can destroy any corrupted state that lives within an AppDomain by unloading the entire AppDomain by calling <b>AppDomain</b>'s <b>Unload </b>method (see Chapter 22 for details).</p>
<p>And, if you feel that your state is so bad that the whole process should be terminated, then you can call <b>Environment</b>'s static <b>FailFast </b>method:</p>
<p><code>public static void FailFast(String message);<br/>
public static void FailFast(String message, Exception exception);</code></p>
<p>This method terminates the process without running any active <b>try/finally </b>blocks or <b>Finalize </b>methods This is good because executing more code while state is corrupted could easily make matters worse. However, <b>FailFast </b>will allow any <b>CriticalFinalizerObject-</b>derived objects, discussed in Chapter 21, &quot;Automatic Memory Management (Garbage Collection), a chance to clean up. This is usually OK because they tend to just close native resources, and Windows state is probably fine even if the CLR's state or your application's state is corrupted. The <b>FailFast </b>method writes the message string and optional exception (usually the exception captured in a <b>catch </b>block) to the Windows Application event log, produces a Windows error report, creates a memory dump of your application, and then terminates the current process.</p>
<hr/>
<blockquote><b>Important </b>Most of Microsoft's FCL code does not ensure that state remains good in the case of an unexpected exception. If your code catches an exception that passes through FCL code and then continues to use FCL objects, there is a chance that these objects will behave unpredictably It's a shame that more FCL objects don't maintain their state better in the face of unexpected exceptions or call <b>FailFast </b>if their state cannot be restored.</blockquote>
<hr/>
<p>The point of this discussion is to make you aware of the potential problems related to using the CLR's exception-handling mechanism. Most applications cannot tolerate running with a corrupted state because it leads to incorrect data and possible security holes. If you are writing an application that cannot tolerate terminating (like an operating system or database engine), then managed code is not a good technology to use. And while Microsoft Exchange Server is largely written in managed code, it uses a native database to store e-mail messages. The native database is called the Extensible Storage Engine, it ships with Windows, and can usually be found at <span>C:\Windows\System32\EseNT</span>.dll. Your applications can also use this engine if you'd like; search for &quot;Extensible Storage Engine&quot; on Microsoft's MSDN Web site.</p>
<p>Managed code is a good choice for applications that can tolerate an application terminating when state corruption has possibly occurred. There are many applications that fall into this category. Also, it takes significantly more resources and skills to write a robust native class library or application; for many applications, managed code is the better choice because it greatly enhances programmer productivity.</p>
<a name="b492"/><h2>Guidelines and Best Practices</h2>
<p>Understanding the exception mechanism is certainly important. It is equally important to understand how to use exceptions wisely. All too often, I see library developers catching all kinds of exceptions, preventing the application developer from knowing that a problem occurred. In this section, I offer some guidelines for developers to be aware of when using exceptions.</p>
<p><b>i-</b></p>
<hr/>
<blockquote><b>Important </b>If you're a class library developer developing types that will be used by other developers, take these guidelines very seriously You have a huge responsibility: You're trying to design the type in your class library so that it makes sense for a wide variety of applications Remember that you don't have intimate knowledge of the code that you're calling back (via delegates, virtual methods, or interface methods). And you don't know which code is calling you. It's not feasible to anticipate every situation in which your type will be used, so don't make any policy decisions Your code must not decide what conditions constitute an error; let the caller make that decision.</blockquote>
<hr/>
<p>In addition, watch state very closely and try not to corrupt it. Verify arguments passed to your method by using code contracts (discussed later in this chapter) Try not to modify state at all If you do modify state, then be ready for a failure and then try to restore state. If you follow the guidelines in this chapter, application developers will not have a difficult time using the types in your class library.</p>
<p>If you're an application developer, define whatever policy you think is appropriate. Following the design guidelines in this chapter will help you discover problems in your code before it is released, allowing you to fix them and make your application more robust. However, feel free to diverge from these guidelines after careful consideration. You get to set the policy. For example, application code can get more aggressive about catching exceptions than class library code.</p>
<h3>Use finally Blocks Liberally</h3>
<p>I think <b>finally </b>blocks are awesome! They allow you to specify a block of code that's guaranteed to execute no matter what kind of exception the thread throws You should use <b>finally </b>blocks to clean up from any operation that successfully started before returning to your call-</p>
<p>er or allowing code following the <b>finally </b>block to execute. You also frequently use <b>finally </b>blocks to explicitly dispose of any objects to avoid resource leaking. Here's an example that has all cleanup code (closing the file) in a <b>finally </b>block:</p>
<p><code>using System; using System.IO;<br/>
public sealed class SomeType { private void SomeMethod() {<br/>
FileStream fs = new FileStream(@&quot;C:\Data.bin &quot;, FileMode.Open);<br/>
try {<br/>
// Display 100 divided by the first byte in the file. Console.Writel_ine(100 / fs.ReadByte());<br/>
}<br/>
finally {<br/>
// Put cleanup code in a finally block to ensure that the file gets closed regardless // of whether or not an exception occurs (for example, the first byte was 0). if (fs != null) fs.Dispose();<br/>
}<br/>
}<br/>
}</code></p>
<p>Ensuring that cleanup code always executes is so important that many programming languages offer constructs that make writing cleanup code easier For example, the C# language automatically emits <b>try/finally </b>blocks whenever you use the <b>lock, using, </b>and <b>foreach </b>statements. The C# compiler also emits <b>try/finally </b>blocks whenever you override a class's destructor (the <b>Finalize </b>method). When using these constructs, the compiler puts the code you've written inside the <b>try </b>block and automatically puts the cleanup code inside the <b>finally </b>block. Specifically,</p>
<p>&#9632; When you use the <b>lock </b>statement, the lock is released inside a <b>finally </b>block.</p>
<p>&#9632; When you use the <b>using </b>statement, the object has its <b>Dispose </b>method called inside a <b>finally </b>block.</p>
<p>&#9632; When you use the <b>foreach </b>statement, the <b>IEnumerator </b>object has its <b>Dispose </b>method called inside a <b>finally </b>block.</p>
<p>&#9632; When you define a destructor method, the base class's <b>Finalize </b>method is called inside a <b>finally </b>block.</p>
<p>For example, the following C# code takes advantage of the <b>using </b>statement This code is shorter than the code shown in the previous example, but the code that the compiler generates is identical to the code generated in the previous example.</p>
<p><code>using System; using System.IO;<br/>
internal sealed class SomeType { private void SomeMethod() {<br/>
using (FileStream fs = new FileStream(@&quot;C:\Data.bin&quot;, FileMode.Open)) {<br/>
// Display 100 divided by the first byte in the file. Console.Writel_ine(100 / fs.ReadByte());<br/>
}<br/>
}<br/>
}</code></p>
<p>For more about the <b>using </b>statement, see Chapter 21; and for more about the <b>lock </b>statement, see Chapter 29, &quot;Hybrid Thread Synchronization Constructs.&quot;</p>
<h3>Don't Catch Everything</h3>
<p>A ubiquitous mistake made by developers who have not been properly trained on the proper use of exceptions is to use <b>catch </b>blocks too often and improperly When you catch an exception, you're stating that you expected this exception, you understand why it occurred, and you know how to deal with it. In other words, you're defining a policy for the application. This all goes back to the &quot;Trading Reliability for Productivity&quot; section earlier in this chapter.</p>
<p>All too often, I see code like this:</p>
<p><code>try {<br/>
// try to execute code that the programmer knows might fail...<br/>
}<br/>
catch (Exception) {<br/>
}</code></p>
<p>This code indicates that it was expecting any and all exceptions and knows how to recover from any and all situations. How can this possibly be? A type that's part of a class library should never, ever, under any circumstance catch and swallow all exceptions because there is no way for the type to know exactly how the application intends to respond to an exception. In addition, the type will frequently call out to application code via a delegate, virtual method, or interface method If the application code throws an exception, another part of the application is probably expecting to catch this exception. The exception should be allowed to filter its way up the call stack and let the application code handle the exception as it sees fit.</p>
<p>If the exception is unhandled, the CLR terminates the process. I'll discuss unhandled exceptions later in this chapter. Most unhandled exceptions will be discovered during testing of your code. To fix these unhandled exceptions, you will either modify the code to look for a specific exception, or you will rewrite the code to eliminate the conditions that cause the exception to be thrown. The final version of the code that will be running in a production environment should see very few unhandled exceptions and will be extremely robust.</p>
<p><b>I-</b></p>
<hr/>
<blockquote><b>Note </b>In some cases, a method that can't complete its task will detect that some object's state</blockquote>
<hr/>
<p>has been corrupted and cannot be restored Allowing the application to continue running might result in unpredictable behavior or security vulnerabilities When this situation is detected, that method should not throw an exception; instead, it should force the process to terminate immediately by calling <b>System.Environment</b>'s <b>FailFast </b>method.</p>
<p>By the way, it is OK to catch <b>System.Exception </b>and execute some code inside the <b>catch </b>block's braces as long as you re-throw the exception at the bottom of that code Catching <b>System.Exception </b>and swallowing the exception (not re-throwing it) should never be done because it hides failures that allow the application to run with unpredictable results and potential security vulnerabilities. Visual Studio's code analysis tool (FxCopCmd.exe) will flag any code that contains a <b>catch (Exception) </b>block unless there is a <b>throw </b>statement included in the block's code. The &quot;Backing Out of a Partially Completed Operation When an Unrecoverable Exception Occurs柚aintaining State&quot; section, coming shortly in this chapter, will discuss this pattern.</p>
<p>Finally, it is OK to catch an exception occurring in one thread and re-throw the exception in another thread. The Asynchronous Programming Model (discussed in Chapter 27, &quot;I/O-Bound Asynchronous Operations&quot;) supports this For example, if a thread pool thread executes code that throws an exception, the CLR catches and swallows the exception and allows the thread to return to the thread pool. Later, some thread should call an <b>EndXxx </b>method to determine the result of the asynchronous operation The <b>EndXxx </b>method will throw the same exception object that was thrown by the thread pool thread that did the actual work. In this scenario, the exception is being swallowed by the first thread; however, the exception is being re-thrown by the thread that called the <b>EndXxx </b>method, so it is not being hidden from the application.</p>
<h3>Recovering Gracefully from an Exception</h3>
<p>Sometimes you call a method knowing in advance some of the exceptions that the method might throw Because you expect these exceptions, you might want to have some code that allows your application to recover gracefully from the situation and continue running. Here's an example in pseudocode:</p>
<p><code>public String CalculateSpreadsheetCe11(Int32 row, Int32 column) { String result;<br/>
try {<br/>
result = /* Code to calculate value of a spreadsheet's cell */<br/>
}<br/>
catch (DivideByZeroException) {<br/>
result = &quot;Can't show value: Divide by zero&quot;;<br/>
}<br/>
catch (OverflowException) {<br/>
result = &quot;Can't show value: Too big&quot;;<br/>
}<br/>
return result;<br/>
}</code></p>
<p>This pseudocode calculates the contents of a cell in a spreadsheet and returns a string representing the value to the caller so that the caller can display the string in the application's window. However, a cell's contents might be the result of dividing one cell by another cell. If the cell containing the denominator contains 0, the CLR will throw a <b>DivideByZeroException </b>object. In this case, the method catches this specific exception and returns a special string that will be displayed to the user. Similarly, a cell's contents might be the result of multiplying one cell by another. If the multiplied value doesn't fit in the number of bits allowed, the CLR will throw an <b>OverflowException </b>object, and again, a special string will be displayed to the user.</p>
<p>When you catch specific exceptions, fully understand the circumstances that cause the exception to be thrown, and know what exception types are derived from the exception type you're catching. Don't catch and handle <b>System.Exception </b>(without re-throwing) because it's not feasible for you to know all of the possible exceptions that could be thrown within your <b>try </b>block (especially if you consider the <b>OutOfMemoryException </b>or the <b>StackOverflowException, </b>to name two).</p>
<h3>Backing Out of a Partially Completed Operation When an Unrecoverable Exception Occurs柚aintaining State</h3>
<p>Usually, methods call several other methods to perform a single abstract operation Some of the individual methods might complete successfully, and some might not For example, let's say that you're serializing a set of objects to a disk file. After serializing 10 objects, an exception is thrown. (Perhaps the disk is full or the next object to be serialized isn't marked with the <b>Serializable </b>custom attribute.) At this point, the exception should filter up to the caller, but what about the state of the disk file? The file is now corrupted because it contains a partially serialized object graph. It would be great if the application could back out of the partially completed operation so that the file would be in the state it was in before any objects were serialized into it. The following code demonstrates the correct way to implement this:</p>
<p><code>public void SerializeObjectGraph(FileStream fs, IFormatter formatter, Object rootObj) {<br/>
// Save the current position of the file. Int64 beforeSerialization = fs.Position;<br/>
try {<br/>
// Attempt to serialize the object graph to the file. formatter.Serialize(fs, rootObj);<br/>
}<br/>
catch {   // Catch any and all exceptions.<br/>
// If ANYTHING goes wrong, reset the file back to a good state. fs.Position = beforeSerialization;<br/>
// Truncate the file. fs.SetLength(fs.Position);<br/>
// NOTE: The preceding code isn't in a finally block because // the stream should be reset only when serialization fails.<br/>
// Let the caller(s) know what happened by re-throwing the SAME exception. throw;<br/>
}<br/>
}</code></p>
<p>To properly back out of the partially completed operation, write code that catches all exceptions. Yes, catch all exceptions here because you don't care what kind of error occurred;</p>
<p>you need to put your data structures back into a consistent state After you've caught and handled the exception, don't swallow it様et the caller know that the exception occurred. You do this by re-throwing the same exception. In fact, C# and many other languages make this easy. Just use C#'s <b>throw </b>keyword without specifying anything after <b>throw, </b>as shown in the previous code.</p>
<p>Notice that the <b>catch </b>block in the previous example doesn't specify any exception type because I want to catch any and all exceptions. In addition, the code in the <b>catch </b>block doesn't need to know exactly what kind of exception was thrown, just that something went wrong. Fortunately, C# lets me do this easily just by not specifying any exception type and by making the <b>throw </b>statement re-throw whatever object is caught.</p>
<h3>Hiding an Implementation Detail to Maintain a &quot;Contract&quot;</h3>
<p>In some situations, you might find it useful to catch one exception and re-throw a different exception. The only reason to do this is to maintain the meaning of a method's contract. Also, the new exception type that you throw should be a specific exception (an exception that's not used as the base type of any other exception type). Imagine a <b>PhoneBook </b>type that defines a method that looks up a phone number from a name, as shown in the following pseudocode:</p>
<p><code>internal sealed class PhoneBook {<br/>
private String m_pathname;   // path name of file containing the address book<br/>
// Other methods go here.<br/>
public String CetPhoneNumber(String name) { String phone; FileStream fs = null;<br/>
try {<br/>
fs = new FileStream(m_pathname, FileMode.Open);<br/>
// Code to read from fs until name is found goes here<br/>
phone = /* the phone # found */<br/>
}<br/>
catch (FileNotFoundException e) {<br/>
// Throw a different exception containing the name, and // set the originating exception as the inner exception. throw new NameNotFoundException(name, e);<br/>
}<br/>
catch (IOException e) {<br/>
// Throw a different exception containing the name, and // set the originating exception as the inner exception. throw new NameNotFoundException(name, e);<br/>
}<br/>
finally {<br/>
if (fs != null) fs.Close();<br/>
}<br/>
return phone;<br/>
}<br/>
}</code></p>
<p>The phone book data is obtained from a file (versus a network connection or database). However, the user of the <b>PhoneBook </b>type doesn't know this because this is an implementation detail that could change in the future. So if the file isn't found or can't be read for any reason, the caller would see a <b>FileNotFoundException </b>or <b>IOException, </b>which wouldn't be anticipated. In other words, the file's existence and ability to be read is not part of the method's implied contract: There is no way the caller could have guessed this So the <b>GetPhoneNumber </b>method catches these two exception types and throws a new <b>NameNotFoundException </b>.</p>
<p>When using this technique, you should catch specific exceptions that you fully understand the circumstances that cause the exception to be thrown And, you should also know what exception types are derived from the exception type you're catching.</p>
<p>Throwing an exception still lets the caller know that the method cannot complete its task, and the <b>NameNotFoundException </b>type gives the caller an abstracted view as to why. Setting the inner exception to <b>FileNotFoundException </b>or <b>IOException </b>is important so that the real cause of the exception isn't lost. Besides, knowing what caused the exception could be useful to the developer of the <b>PhoneBook </b>type and possibly to a developer using the <b>PhoneBook </b>type.</p>
<hr/>
<blockquote><b>Important </b>When you use this technique, you are lying to callers about two things. First, you are lying about what actually went wrong. In my example, a file was not found but I'm reporting that a name was not found. Second, you are lying about where the failure occurred. If the <b>FileNotFoundException </b>were allowed to propagate up the call stack, its <b>StackTrace </b>property would reflect that the error occurred inside <b>FileStream</b>'s constructor. But when I swallow this exception and throw a new <b>NameNotFoundException, </b>the stack trace will indicate that the error occurred inside the <b>catch </b>block, several lines away from where the real exception was thrown This can make debugging very difficult, so this technique should be used with great care.</blockquote>
<hr/>
<p>Now let's say that the <b>PhoneBook </b>type was implemented a little differently. Assume that the type offers a public <b>PhoneBookPathname </b>property that allows the user to set or get the path name of the file in which to look up a phone number Because the user is aware of the fact that the phone book data comes from a file, I would modify the <b>GetPhoneNumber </b>method so that it doesn't catch any exceptions; instead, I let whatever exception is thrown propagate out of the method. Note that I'm not changing any parameters of the <b>GetPhoneNumber </b>method, but I am changing how it's abstracted to users of the <b>PhoneBook </b>type. Users now expect a path to be part of the <b>PhoneBook</b>'s contract.</p>
<p>Sometimes developers catch one exception and throw a new exception in order to add additional data or context to an exception. However, if this is all you want to do, you should just catch the exception type you want, add data to the exception object's <b>Data </b>property collection, and then re-throw the same exception object:</p>
<p><code>private static void SomeMethod(String filename) {<br/>
try {<br/>
// Do whatevere here...<br/>
}<br/>
catch (IOException e) {<br/>
// Add the filename to the IOException object e.Data.AddC'Filename&quot;, filename);<br/>
throw;     // re-throw the same exception object that now has additional data in it<br/>
}<br/>
}</code></p>
<p>Here is a good use of this technique: When a type constructor throws an exception that is not caught within the type constructor method, the CLR internally catches that exception and throws a new <b>TypeInitializationException </b>instead. This is useful because the CLR emits code within your methods to implicitly call type constructors. <sup>6</sup> If the type constructor threw a <b>DivideByZeroException, </b>your code might try to catch it and recover from it but you didn't even know you were invoking the type constructor So the CLR converts the <b>DivideByZeroException </b>into a <b>TypeInitializationException </b>so that you know clearly that the exception occurred due to a type constructor failing; the problem wasn't with your code.</p>
<p>On the other hand, here is a bad use of this technique: When you invoke a method via reflection, the CLR internally catches any exception thrown by the method and converts it to a <b>TargetInvocationException </b>. This is incredibly annoying as you must now catch the <b>TargetInvocationException </b>object and look at its <b>InnerException </b>property to discern the real reason for the failure. In fact, when using reflection, it is common to see code that looks like this:</p>
<p><code>private static void Reflection(Object o) {<br/>
try {<br/>
// Invoke a DoSomething method on this object var mi = o.GetTypeO.GetMethodC'DoSomething&quot;);<br/>
mi.Invoke(o, null);   // The DoSomething method might throw an exception<br/>
}<br/>
catch (System.Reflection.TargetInvocationException e) {<br/>
// The CLR converts reflection-produced exceptions to TargetInvocationException throw e.InnerException; // Re-throw what was originally thrown<br/>
}<br/>
}</code></p>
<p>I have good news though: If you use C#'s <b>dynamic </b>primitive type (discussed in Chapter 5, &quot;Primitive, Reference, and Value Types&quot;) to invoke a member, the compiler-generated code does not catch any and all exceptions and throw a <b>TargetInvocationException </b>object; the originally thrown exception object simply walks up the stack For many developers, this is a good reason to prefer using C#'s <b>dynamic </b>primitive type rather than reflection.</p>
<p>For more information about this, see the &quot;Type Constructors&quot; section in Chapter 8, &quot;Methods.&quot;</p>
<a name="b500"/><h2>Unhandled Exceptions</h2>
<p>When an exception is thrown, the CLR climbs up the call stack looking for <b>catch </b>blocks that match the type of the exception object being thrown. If no <b>catch </b>block matches the thrown exception type, an unhandled exception occurs. When the CLR detects that any thread in the process has had an unhandled exception, the CLR terminates the process An unhandled exception identifies a situation that the application didn't anticipate and is considered to be a true bug in the application At this point, the bug should be reported back to the company that publishes the application. Hopefully, the publisher will fix the bug and distribute a new version of the application.</p>
<p>Class library developers should not even think about unhandled exceptions. Only application developers need to concern themselves with unhandled exceptions, and the application should have a policy in place for dealing with unhandled exceptions. Microsoft actually recommends that application developers just accept the CLR's default policy That is, when an application gets an unhandled exception, Windows writes an entry to the system's event log. You can see this entry by opening the Event Viewer application and then looking under Windows Logs -&gt; Application node in the tree, as shown in Figure 20-1.</p>
<img src="52.jpg"/>
<p><b>Figure 20-1 </b>Windows Event log showing an application that terminated due to an unhandled exception</p>
<p>However, you can get more interesting details about the problem by using the Windows Action Center applet. To start the Action Center, click on the flag icon in the system tray, select Open Action Center, expand the Maintenance box, and then select the &quot;View reliability history&quot; link. From here, you can see the applications that have terminated due to an unhandled exception in the bottom pane, as shown in Figure 20-2.</p>
<img src="53.jpg"/>
<p><b>Figure 20-2 </b>Reliability Monitor showing an application that terminated due to an unhandled exception</p>
<p>To see more details about the terminated application, double-click on a terminated application in Reliability Monitor. The details will look something like Figure 20-3 and the meaning of the problem signatures are described in Table 20-2 All unhandled exceptions produced by managed applications are placed in the CLR20r3 bucket.</p>
<p><b>Figure 20-3 </b>Reliability Monitor showing more details about the failed application</p>
<img src="54.jpg"/>
<p><b>table </b><b>20-2 </b><b>Problem Signatures</b></p>
<table border="1">
<tr>
<td>
<p>Problem Signature</p>
</td>
<td>
<p>Description*</p>
</td>
</tr>
<tr>
<td>
<p>01</p>
</td>
<td>
<p>EXE file's name (32-character limit)</p>
</td>
</tr>
<tr>
<td>
<p>02</p>
</td>
<td>
<p>EXE file's assembly version number</p>
</td>
</tr>
<tr>
<td>
<p>03</p>
</td>
<td>
<p>EXE file's timestamp</p>
</td>
</tr>
<tr>
<td>
<p>04</p>
</td>
<td>
<p>EXE file's full assembly name (64-character limit)</p>
</td>
</tr>
<tr>
<td>
<p>05</p>
</td>
<td>
<p>Faulting assembly's version</p>
</td>
</tr>
<tr>
<td>
<p>06</p>
</td>
<td>
<p>Faulting assembly's timestamp</p>
</td>
</tr>
<tr>
<td>
<p>07</p>
</td>
<td>
<p>Faulting assembly's type and method. This value is a MethodDef metadata token (after stripping off the 0x06 high byte) identifying the method that threw the exception. From this value, you can use ILDasm.exe to determine the offending type and method.</p>
</td>
</tr>
<tr>
<td>
<p>08</p>
</td>
<td>
<p>Faulting method's IL instruction This value is an offset within the faulting method of the IL instruction that threw the exception. From this value, you can use ILDasm.exe to determine the offending instruction.</p>
</td>
</tr>
<tr>
<td>
<p>09</p>
</td>
<td>
<p>Exception type thrown (32-character limit)</p>
</td>
</tr>
</table>
<p>* If a string is beyond the allowed limit, then some intelligent truncations are performed, like removing &quot;Exception&quot; from the exception type or &quot;.dll&quot; from a file name. If the resulting string is still too long, then the CLR will create a value by hashing or base-64-encoding the string.</p>
<p>After recording information about the failing application, Windows displays the message box allowing the end user to send information about the failing application to Microsoft's servers.<sup>7 </sup>This is called Windows Error Reporting, and more information about it can be found at the Windows Quality Web site (<a href="http://WinQual.Microsoft.com">http://WinQual.Microsoft.com</a>).</p>
<p>Companies can optionally sign up with Microsoft to view this information about their own applications and components. Signing up is free, but it does require that your assemblies be signed with a VeriSign ID (also called a Software Publisher's Digital ID for Authenticode).</p>
<p>Naturally, you could also develop your own system for getting unhandled exception information back to you so that you can fix bugs in your code. When your application initializes, you can inform the CLR that you have a method that you want to be called whenever any thread in your application experiences an unhandled exception.</p>
<p>Unfortunately, every application model Microsoft produces has its own way of tapping into unhandled exceptions. The members that you want to look up in the FCL documentation are:</p>
<p>&#9632; For any application, look at <b>System.AppDomain</b>'s <b>UnhandledException </b>event. Silverlight applications do not execute with enough security to register with this event.</p>
<p>&#9632; For a Windows Forms application, look at <b>System.Windows.Forms.NativeWindow</b>'s <b>OnThreadException </b>virtual method, <b>System.Windows.Forms.Application</b>'s <b>OnThreadException </b>virtual method, and <b>System.Windows.Forms.Application</b>'s <b>ThreadException </b>event.</p>
<p>You can actually disable this message box by using P/Invoke to call Win32's <b>SetErrorMode </b>function, passing in <b>SEM_NOGPFAULTERRORBOX.</b></p>
<p>&#9632; For a Windows Presentation Foundation (WPF) application, look at <b>System.Windows. Application</b>'s <b>DispatcherUnhandledException </b>event and <b>System.Windows. Threading.Dispatcher</b>'s <b>UnhandledException </b>and <b>UnhandledExceptionFilter</b></p>
<p>events.</p>
<p>&#9632; For Silverlight, look at <b>System.Windows.Application</b>'s <b>UnhandledException </b>event.</p>
<p>&#9632; For an ASP.NET Web Form application, look at <b>System.Web.UI.TemplateControl</b>'s <b>Error </b>event. <b>TemplateControl </b>is the base class of the <b>System.Web.UI.Page</b></p>
<p>and <b>System.Web.UI.UserControl </b>classes Furthermore, you should also look at <b>System.Web.HttpApplication</b>'s <b>Error </b>event.</p>
<p>&#9632; For a Windows Communication Foundation application, look at <b>System. ServiceModel.Dispatcher.ChannelDispatcher</b>'s <b>ErrorHandlers </b>property.</p>
<p>Before I leave this section, I'd like to say a few words about unhandled exceptions that could occur in a distributed application such as a Web site or Web service In an ideal world, a server application that experiences an unhandled exception should log it, send some kind of notification back to the client indicating that the requested operation could not complete, and then the server should terminate Unfortunately, we don't live in an ideal world, and therefore, it may not be possible to send a failure notification back to the client. For some stateful servers (such as Microsoft SQL Server), it may not be practical to terminate the server and start a brand new instance.</p>
<p>For a server application, information about the unhandled exception should not be returned to the client because there is little a client could do about it, especially if the client is implemented by a different company. Furthermore, the server should divulge as little information about itself as possible to its clients to reduce that potential of the server being hacked.</p>
<hr/>
<blockquote><b>Note </b>The CLR considers some exceptions thrown by native code as corrupted state exceptions (CSEs) because they are usually the result of a bug in the CLR itself or in some native code for which the managed developer has no control over. By default, the CLR will not let managed code catch these exceptions and <b>finally </b>blocks will not execute. Here is the list of native Win32 exceptions that are considered CSEs:</blockquote>
<hr/>
<p><b>EXCEPTION_ACCESS_VIOLATION EXCEPTION_STACK_OVERFLOW EXCEPTION_ILLEGAL_INSTRUCTION EXCEPTION_IN_PAGE_ERROR EXCEPTION_INVALID_DISPOSITION EXCEPTION_NONCONTINUABLE_EXCEPTION EXCEPTION_PRIV_INSTRUCTION.STATUS_UNWIND_CONSOLIDATE </b>.</p>
<p>Individual managed methods can override the default and catch these exceptions by applying the <b>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute </b>to the method. In addition, the method must have the <b>System.Security. SecurityCriticalAttribute </b>applied to it. You can also override the default for an entire process by setting the <b>legacyCorruptedStateExceptionPolicy </b>element in the application's Extensible Markup Language (XML) configuration file to <b>true. </b>The CLR converts most of these to a <b>System.Runtime.InteropServices.SEHException </b>object except for <b>EXCEPTION_ ACCESS_VIOLATION, </b>which is converted to a <b>System.AccessViolationException </b>object, and <b>EXCEPTION_STACK_OVERFLOW, </b>which is converted to a <b>System.StackOverflowException </b>object.</p>
<hr/>
<blockquote><b>Note </b>Just before invoking a method, you could check for ample stack space by calling the <b>RuntimeHelper </b>class's <b>EnsureSufficientExecutionStack </b>method. This method checks if the calling thread has enough stack space available to execute the average method (which is not well defined). If there is insufficient stack space, the method throws an <b>InsufficientExecutionStackException </b>which you can catch The <b>EnsureSufficientExecutionStack </b>method takes no arguments and returns <b>void. </b>This method is typically used by recursive methods.</blockquote>
<hr/>
<a name="b504"/><h2>Debugging Exceptions</h2>
<p>The Visual Studio debugger offers special support for exceptions With a solution open, choose Exceptions from the Debug menu, and you'll see the dialog box shown in Figure 20-4.</p>
<img src="55.jpg"/>
<p><b>Figure 20-4 </b>The Exceptions dialog box, showing the different kinds of exceptions</p>
<p>This dialog box shows the different kinds of exceptions that Visual Studio is aware of For Common Language Runtime Exceptions, expanding the corresponding branch in the dialog box, as in Figure 20-5, shows the set of namespaces that the Visual Studio debugger is aware of</p>
<img src="56.jpg"/>
<p><b>FIGuRE </b><b>20-5 </b>The Exceptions dialog box, showing CLR exceptions by namespace</p>
<p>If you expand a namespace, you'll see all of the <b>System.Exception</b>-derived types defined within that namespace. For example, Figure 20-6 shows what you'll see if you open the <b>System </b>namespace.</p>
<img src="57.jpg"/>
<p><b>Figure 20-6 </b>The Exceptions dialog box, showing CLR exceptions defined in the <b>System </b>namespace</p>
<p>For any exception type, if its Thrown check box is selected, the debugger will break as soon as that exception is thrown. At this point, the CLR has not tried to find any matching <b>catch </b>blocks This is useful if you want to debug your code that catches and handles an exception It is also useful when you suspect that a component or library may be swallowing or rethrowing exceptions, and you are uncertain where exactly to set a break point to catch it in the act.</p>
<p>If an exception type's Thrown check box is not selected, the debugger will also break where the exception was thrown, but only if the exception type was not handled. Developers usually leave the Thrown check box cleared because a handled exception indicates that the application anticipated the situation and dealt with it; the application continues running normally.</p>
<p>If you define your own exception types, you can add them to this dialog box by clicking Add. This causes the dialog box in Figure 20-7 to appear.</p>
<img src="58.jpg"/>
<p><b>Figure 20-7 </b>Making Visual Studio aware of your own exception type: the New Exception dialog box</p>
<p>In this dialog box, you first select the type of exception to be Common Language Runtime Exceptions, and then, you can enter the fully qualified name of your own exception type. Note that the type you enter doesn't have to be a type derived from <b>System.Exception; </b>non-CLS-compliant types are fully supported. If you have two or more types with the same name but in different assemblies, there is no way to distinguish the types from one another. Fortunately, this situation rarely happens.</p>
<p>If your assembly defines several exception types, you must add them one at a time. In the future, I'd like to see this dialog box allow me to browse for an assembly and automatically import all <b>Exception</b>-derived types into Visual Studio's debugger Each type could then be identified by assembly as well, which would fix the problem of having two types with the same name in different assemblies.</p>
<a name="b506"/><h2>Exception-Handling Performance Considerations</h2>
<p>The developer community actively debates the performance of exception handling. Some people claim that exception handling performance is so bad that they refuse to even use exception handling However, I contend that in an object-oriented platform, exception handling is not an option; it is mandatory. And besides, if you didn't use it, what would you use instead? Would you have your methods return <b>true/false </b>to indicate success/failure or perhaps some error code <b>enum </b>type? Well, if you did this, then you have the worst of both worlds: The CLR and the class library code will throw exceptions and your code will return error codes. You'd have to now deal with both of these in your code.</p>
<p>It's difficult to compare performance between exception handling and the more conventional means of reporting exceptions (such as <b>HRESULT</b>s, special return codes, and so forth) If you write code to check the return value of every method call and filter the return value up to your own callers, your application's performance will be seriously affected. But performance aside, the amount of additional coding you must do and the potential for mistakes is incredibly high when you write code to check the return value of every method. Exception handling is a much better alternative.</p>
<p>However, exception handling has a price: Unmanaged C++ compilers must generate code to track which objects have been constructed successfully The compiler must also generate code that, when an exception is caught, calls the destructor of each successfully constructed object. It's great that the compiler takes on this burden, but it generates a lot of bookkeeping code in your application, adversely affecting code size and execution time.</p>
<p>On the other hand, managed compilers have it much easier because managed objects are allocated in the managed heap, which is monitored by the garbage collector If an object is successfully constructed and an exception is thrown, the garbage collector will eventually free the object's memory. Compilers don't need to emit any bookkeeping code to track which objects are constructed successfully and don't need to ensure that a destructor has been called. Compared to unmanaged C++, this means that less code is generated by the compiler, and less code has to execute at runtime, resulting in better performance for your application.</p>
<p>Over the years, I've used exception handling in different programming languages, different operating systems, and different CPU architectures. In each case, exception handling is implemented differently with each implementation having its pros and cons with respect to performance. Some implementations compile exception handling constructs directly into a method, whereas other implementations store information related to exception handling in a data table associated with the method葉his table is accessed only if an exception is thrown. Some compilers can't inline methods that contain exception handlers, and some compilers won't enregister variables if the method contains exception handlers.</p>
<p>The point is that you can't determine how much additional overhead is added to an application when using exception handling. In the managed world, it's even more difficult to tell because your assembly's code can run on any platform that supports the .NET Framework. So the code produced by the JIT compiler to manage exception handling when your assembly is running on an x86 machine will be very different from the code produced by the JIT compiler when your code is running on an x64 or IA64 processor Also, JIT compilers associated with other CLR implementations (such as Microsoft's.NET Compact Framework or the open-source Mono project) are likely to produce different code.</p>
<p>Actually, I've been able to test some of my own code with a few different JIT compilers that Microsoft has internally, and the difference in performance that I've observed has been quite dramatic and surprising. The point is that you must test your code on the various platforms that you expect your users to run on, and make changes accordingly. Again, I wouldn't worry about the performance of using exception handling; because the benefits typically far outweigh any negative performance impact.</p>
<p>If you're interested in seeing how exception handling impacts the performance of your code, you can use the Performance Monitor tool that comes with Windows. The screen in Figure 20-8 shows the exception-related counters that are installed along with the .NET Framework.</p>
<img src="59.jpg"/>
<p><b>Figure 20-8 </b>Performance Monitor showing the .NET CLR Exceptions counters</p>
<p>Occasionally, you come across a method that you call frequently that has a high failure rate. In this situation, the performance hit of having exceptions thrown can be intolerable. For example, Microsoft heard back from several customers who were calling <b>Int32</b>'s <b>Parse </b>method, frequently passing in data entered from an end user that could not be parsed. Since <b>Parse </b>was called frequently, the performance hit of throwing and catching the exceptions was taking a large toll on the application's overall performance.</p>
<p>To address customers' concerns and to satisfy all the guidelines described in this chapter, Microsoft added a new method to the <b>Int32 </b>class. This new method is called <b>TryParse, </b>and it has two overloads that look like this:</p>
<p><code>public static Boolean TryParse(String s, out Int32 result); public static Boolean TryParse(String s, NumberStyles styles, IFormatProvider, provider, out Int32 result);</code></p>
<p>You'll notice that these methods return a <b>Boolean </b>that indicates whether the <b>String </b>passed in contains characters that can be parsed into an <b>Int32 </b>These methods also return an output parameter named <b>result </b>. If the methods return <b>true, result </b>will contain the result of parsing the string into a 32-bit integer. If the methods return <b>false, result </b>will contain <b>0, </b>but you really shouldn't execute any code that looks at it anyway.</p>
<p>One thing I want to make absolutely clear: A <b>TryXxx </b>method's <b>Boolean </b>return value returns <b>false </b>to indicate one and only one type of failure. The method should still throw exceptions for any other type of failure. For example, <b>Int32</b>'s <b>TryParse </b>throws an <b>ArgumentException </b>if the style's argument is not valid, and it is certainly still possible to have an <b>OutOfMemoryException </b>thrown when calling <b>TryParse </b>.</p>
<p>I also want to make it clear that object-oriented programming allows programmers to be productive One way that it does this is by not exposing error codes in a type's members In other words, constructors, methods, properties, etc.are all defined with the idea that calling them won't fail. And, if defined correctly, for most uses of a member, it will not fail, and there will be no performance hit because an exception will not be thrown.</p>
<p>When defining types and their members, you should define the members so that it is unlikely that they will fail for the common scenarios in which you expect your types to be used. If you later hear from users that they are dissatisfied with the performance due to exceptions being thrown, then and only then should you consider adding <b>TryXxx </b>methods. In other words, you should produce the best object model first and then, if users push back, add some <b>TryXxx </b>methods to your type so that the users who experience performance trouble can benefit. Users who are not experiencing performance trouble should continue to use the non<b>-TryXxx </b>versions of the methods because this is the better object model.</p>
<a name="b509"/><h2>Constrained Execution Regions (CERs)</h2>
<p>Many applications don't need to be robust and recover from any and all kinds of failures. This is true of many client applications like Notepad, exe and Calc.exe. And, of course, many of us have seen Microsoft Office applications like WinWord, exe, Excel, exe, and Outlook, exe terminate due to unhandled exceptions. Also, many server-side applications, like Web servers, are stateless and are automatically restarted if they fail due to an unhandled exception. Of course some servers, like SQL Server, are all about state management and having data lost due to an unhandled exception is potentially much more disastrous.</p>
<p>In the CLR, we have AppDomains (discussed in Chapter 22), which contain state. When an AppDomain is unloaded, all its state is unloaded. And so, if a thread in an AppDomain experiences an unhandled exception, it is OK to unload the AppDomain (which destroys all its state) without terminating the whole process <sup>8</sup></p>
<p>By definition, a CER is a block of code that must be resilient to failure. Since AppDomains can be unloaded, destroying their state, CERs are typically used to manipulate any state that is shared by multiple AppDomains or processes. CERs are useful when trying to maintain state in the face of exceptions that get thrown unexpectedly. Sometimes we refer to these kinds of exceptions as asynchronous exceptions. For example, when calling a method, the CLR has to load an assembly, create a type object in the AppDomain's loader heap, call the type's static constructor, JIT IL into native code, and so on. Any of these operations could fail, and the CLR reports the failure by throwing an exception.</p>
<p>If any of these operations fail within a <b>catch </b>or <b>finally </b>block, then your error recovery or cleanup code won't execute in its entirety. Here is an example of code that exhibits the potential problem:</p>
<p><code>private static void Demo1() {<br/>
try {<br/>
Console.WriteLine(&quot;In try&quot;);<br/>
}<br/>
finally {<br/>
// Typel's static constructor is implicitly called in here Typel.MO;<br/>
}<br/>
}<br/>
private sealed class Typel { static Type1() {<br/>
// if this throws an exception, M won't get called Console.WriteLineC'Typel's static ctor called&quot;);<br/>
}<br/>
public static void M() { }<br/>
}</code></p>
<p>This is definitely true if the thread lives its whole life inside a single AppDomain (like in the ASP.NET and managed</p>
<p>SQL Server stored procedure scenarios) But you might have to terminate the whole process if a thread crosses AppDomain boundaries during its lifetime.</p>
<p>When I run the code above, I get the following output:</p>
<p><code>In try<br/>
Typel's static ctor called</code></p>
<p>What we want is to not even start executing the code in the <b>try </b>block above unless we know that the code in the associated <b>catch </b>and <b>finally </b>blocks is guaranteed (or as close as we can get to guaranteed) to execute. We can accomplish this by modifying the code as follows:</p>
<p><code>private static void Demo2() {<br/>
// Force the code in the finally to be eagerly prepared<br/>
RuntimeHelpers.PrepareConstrainedRegionsO;   // System.Runtime.CompilerServices namespace<br/>
try {<br/>
Console.WriteLineC'In try&quot;);<br/>
}<br/>
finally {<br/>
// Type2's static constructor is implicitly called in here Type2.M();<br/>
}<br/>
}<br/>
public class Type2 { static Type2() {<br/>
Console.WriteLine(&quot;Type2's static ctor called&quot;);<br/>
}<br/>
// Use this attribute defined in the System.Runtime.ConstrainedExecution namespace [ReliabilityContractCConsistency.WillNotCorruptState, Cer.Success)] public static void M() { }<br/>
}</code></p>
<p>Now, when I run this version of the code, I get the following output:</p>
<p><code>Type2's static ctor called In try</code></p>
<p>The <b>PrepareConstrainedRegions </b>method is a very special method. When the JIT compiler sees this method being called immediately before a <b>try </b>block, it will eagerly compile the code in the <b>try</b>'s <b>catch </b>and <b>finally </b>blocks. The JIT compiler will load any assemblies, create any type objects, invoke any static constructors, and JIT any methods. If any of these operations result in an exception, then the exception occurs before the thread enters the <b>try </b>block.</p>
<p>When the JIT compiler eagerly prepares methods, it also walks the entire call graph eagerly preparing called methods. However, the JIT compiler only prepares methods that have the <b>ReliabilityContractAttribute </b>applied to them with either <b>Consistency. WillNotCorruptState </b>or <b>Consistency.MayCorruptInstance </b>because the CLR can't make any guarantees about methods that might corrupt AppDomain or process state. Inside a <b>catch </b>or <b>finally </b>block that you are protecting with a call to <b>PrepareConstrainedRegions, </b>you want to make sure that you only call methods with the <b>ReliabillityContractAttribute </b>set as I've just described.</p>
<p><code>public sealed class ReliabilityContractAttribute : Attribute {<br/>
public ReliabilityContractAttribute(Consistency consistencyCuarantee, Cer cer); public Cer Cer { get; }<br/>
public Consistency ConsistencyCuarantee { get; }<br/>
}</code></p>
<p>This attribute lets a developer document the reliability contract of a particular method<sup>9</sup> to the method's potential callers. Both the <b>Cer </b>and <b>Consistency </b>types are enumerated types defined as follows:</p>
<p><code>enum Consistency {<br/>
MayCorruptProcess, MayCorruptAppDomain, MayCorruptInstance, WillNotCorruptState<br/>
}<br/>
enum Cer { None, MayFail, Success }</code></p>
<p>If the method you are writing promises not to corrupt any state, use <b>Consistency. WillNotCorruptState </b>. Otherwise, document what your method does by using one of the other three possible values that match whatever state your method might corrupt If the method that you are writing promises not to fail, use <b>Cer.Success </b>Otherwise, use <b>Cer. MayFail. </b>Any method that does not have the <b>ReliabiiltyContractAttribute </b>applied to it is equivalent to being marked like this:</p>
<p><code>[ReliabilityContractCConsistency.MayCorruptProcess, Cer.None)]</code></p>
<p>The <b>Cer.None </b>value indicates that the method makes no CER guarantees In other words, it wasn't written with CERs in mind; therefore, it may fail and it may or may not report that it failed. Remember that most of these settings are giving a method a way to document what it offers to potential callers so that they know what to expect. The CLR and JIT compiler do not use this information.</p>
<p>When you want to write a reliable method, make it small and constrain what it does. Make sure that it doesn't allocate any objects (no boxing, for example), don't call any virtual methods or interface methods, use any delegates, or use reflection because the JIT compiler can't tell what method will actually be called. However, you can manually prepare these methods by calling one of these methods defined by the <b>RuntimeHelpers</b>'s class:</p>
<p><code>public static void PrepareMethod(RuntimeMethodHandle method) public static void PrepareMethod(RuntimeMethodHandle method,<br/>
RuntimeTypeHandle[] instantiation) public static void PrepareDelegate(Delegate d); public static void PrepareContractedDelegate(Delegate d);</code></p>
<p>You can also apply this attribute to an interface, a constructor, a structure, a class, or an assembly to affect the members inside it.</p>
<p>Note that the compiler and the CLR do nothing to verify that you've written your method to actually live up to the guarantees you document via the <b>ReliabiltyContractAttribute. </b>If you do something wrong, then state corruption is possible.</p>
<hr/>
<blockquote><b>Note </b>Even if all the methods are eagerly prepared, a method call could still result in a <b>StackOverflowException </b>. When the CLR is not being hosted, a <b>StackOverflowException </b>causes the process to terminate immediately by the CLR internally calling <b>Environment. FailFast </b>. When hosted, the <b>PreparedConstrainedRegions </b>method checks the stack to see if there is approximately 48KB of stack space remaining. If there is limited stack space, the <b>StackOverflowException </b>occurs before entering the <b>try </b>block</blockquote>
<hr/>
<p>You should also look at <b>RuntimeHelper</b>s <b>ExecuteCodeWithGuaranteedCleanup </b>method which is another way to execute code with guaranteed cleanup:</p>
<p><code>public static void ExecuteCodeWithCuaranteedCleanup(TryCode code, CleanupCode backoutCode, Object userData);</code></p>
<p>When calling this method, you pass the body of the <b>try </b>and <b>finally </b>block as callback methods whose prototypes match these two delegates respectively:</p>
<p><code>public delegate void TryCode(Object userData);<br/>
public delegate void CleanupCode(Object userData, Boolean exceptionThrown);</code></p>
<p>And finally, another way to get guaranteed code execution is to use the <b>CriticalFinalizerObject </b>class which is explained in great detail in Chapter 21.</p>
<a name="b512"/><h2>Code Contracts</h2>
<p>Code contracts provide a way for you to declaratively document design decisions that you've made about your code within the code itself The contracts take the form of</p>
<p><b>&#9632; Preconditions   </b>Typically used to validate arguments.</p>
<p><b>&#9632; Postconditions   </b>Used to validate state when a method terminates either due to a normal return or due to throwing an exception.</p>
<p><b>&#9632; Object Invariants   </b>Used to ensure an object's fields remain in a good state through an object's entire lifetime.</p>
<p>Code contracts facilitate code usage, understanding, evolution, testing<sup>10</sup>, documentation, and early error detection. You can think of preconditions, postconditions, and object invariants as parts of a method's signature As such, you can loosen a contract with a new version of your code, but you cannot make a contract stricter with a new version without breaking backward compatibility.</p>
<p>To help with automated testing, see the Pex tool created by Microsoft Research: <a href="http://research.microsoft.com">http://research.microsoft.com</a> /en-us/projects/pex/.</p>
<p>At the heart of the code contracts is the static <b>System.Diagnostics.Contracts.Contract</b></p>
<p>class:</p>
<p><code>public static class Contract {<br/>
// Precondition methods: [Conditiona1(&quot;CONTRACTS_FULL&quot;)] public static void Requires(Boolean condition); public static void EndContractBlock();<br/>
// Preconditions: Always<br/>
public static void Requires&lt;TException&gt;(Boolean condition) where TException : Exception;<br/>
// Postcondition methods: [Conditiona1(&quot;CONTRACTS_FULL&quot;)] public static void Ensures(Boolean condition); public static void EnsuresOnThrow&lt;TException&gt;(Boolean condition) where TException : Exception;<br/>
// Special Postcondition methods: Always<br/>
public static T Result&lt;T&gt;();<br/>
public static T OldValue&lt;T&gt;(T value);<br/>
public static T ValueAtReturn&lt;T&gt;(out T value);<br/>
// Object Invariant methods: [Conditiona1(&quot;CONTRACTS_FULL&quot;)] public static void Invariant(Boolean condition);<br/>
// Quantifier methods: Always<br/>
public static Boolean Exists&lt;T&gt;(IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate); public static Boolean Exists(Int32 fromInclusive, Int32 toExclusive,<br/>
Predicate&lt;Int32&gt; predicate); public static Boolean ForA11&lt;T&gt;(IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate); public static Boolean ForA11(Int32 fromInclusive, Int32 toExclusive,<br/>
Predicate&lt;Int32&gt; predicate); // Helper methods: [Conditiona1(&quot;CONTRACTS_FULL&quot;)] or [Conditiona1(&quot;DEBUC&quot;)] public static void Assert(Boolean condition); public static void Assume(Boolean condition);<br/>
// Infrastructure event: usually your code will not use this event public static event EventHandler&lt;ContractFailedEventArgs&gt; ContractFailed;<br/>
}</code></p>
<p>As indicated above, many of these static methods have the <b>[Conditional(&quot;CONTRACTS_ FULL&quot;)] </b>attribute applied to them. Some of the helper methods also have the <b>[Conditional(&quot;DEBUG&quot;)] </b>attribute applied to them. This means that the compiler will ignore any code you write that calls these methods unless the appropriate symbol is defined when compiling your code. Any methods marked with &quot;Always&quot; mean that the compiler always emits code to call the method. Also, the <b>Requires, Requires&lt;TException&gt;, Ensures, EnsuresOnThrow, Invariant, Assert, </b>and <b>Assume </b>methods have an additional overload (not shown) that takes a <b>String </b>message argument so you can explicitly specify a string message that should appear when the contract is violated.</p>
<p>By default, contracts merely serve as documentation as you would not define the <b>CONTRACTS_FULL </b>symbol when you build your project In order to get some additional value out of using contracts, you must download additional tools and a Visual Studio property pane from <a href="http://msdn.microsoft.com/en-us/devlabs/dd491992.aspx">http://msdn.microsoft.com/en-us/devlabs/dd491992.aspx</a>. The reason why all the code contract tools are not included with Visual Studio is because this technology is relatively new and is being improved rapidly. Microsoft's DevLabs Web site can offer new versions and improvements more quickly than Visual Studio itself. After downloading and installing the additional tools, you will see your projects have a new property pane available to them, as shown in Figure 20-9.</p>
<img src="60.jpg"/>
<p><b>Figure 20-9 </b>The Code Contracts pane for a Visual Studio project</p>
<p>To turn on code contract features, select the Perform Runtime Contract Checking check box and select Full from the combo box next to it. This defines the <b>CONTRACTS_FULL </b>symbol when you build your project and invokes the appropriate tools (described shortly) after building your project. Now, at runtime, when a contract is violated, <b>Contract</b>'s <b>ContractFailed </b>event is raised. Usually, developers do not register any methods with this event, but if you do, then any methods you register will receive a <b>ContractFailedEventArgs </b>object that looks like this:</p>
<p><code>public sealed class ContractFailedEventArgs : EventArgs {<br/>
public ContractFailedEventArgs(ContractFailureKind failureKind, String message, String condition, Exception originalException);<br/>
public ContractFailureKind FailureKind{ get; }<br/>
public String.Message{ get; }<br/>
public String.Condition{ get; }<br/>
public Exception.OriginalException { get; }<br/>
public Boolean Handled { get; }     // true if any handler called SetHhandled<br/>
public void SetHandled();// Call to ignore the violation; sets Handled to true<br/>
public Boolean Unwind { get; }      // true if any handler called SetUnwind or threw public void SetUnwind();// Call to force ContractException; set Unwind to true<br/>
}</code></p>
<p>Multiple event handler methods can be registered with this event Each method can process the contract violation any way it chooses. For example, a handler can log the violation, ignore the violation (by calling <b>SetHandled), </b>or terminate the process. If any method calls <b>SetHandled, </b>then the violation will be considered handled and, after all the handler methods return, the application code is allowed to continue running unless any handler calls <b>SetUnwind. </b>If a handler calls <b>SetUnwind, </b>then, after all the handler methods have completed running, a <b>System.Diagnostics.Contracts.ContractException </b>is thrown. Note that this type is internal to MSCorLib dll and therefore you cannot write a <b>catch </b>block to catch it explicitly. Also note that if any handler method throws an unhandled exception, then the remaining handler methods are invoked and then a <b>ContractException </b>is thrown.</p>
<p>If there are no event handlers or if none of them call <b>SetHandled, SetUnwind, </b>or throw an unhandled exception, then default processing of the contract violation happens next If the CLR is being hosted, then the host is notified that a contract failed. If the CLR is running an application on a non-interactive window station (which would be the case for a Windows service application), then <b>Environment.FailFast </b>is called to instantly terminate the process. If you compile with the Assert On Contract Failure option checked, then an assert dialog box will appear allowing you to connect a debugger to your application If this option is not checked, then a <b>ContractException </b>is thrown.</p>
<p>Let's look at a sample class that is using code contracts:</p>
<p><code>public sealed class Item { /*... */ }<br/>
public sealed class ShoppingCart {<br/>
private List&lt;Item&gt; m_cart.= new List&lt;Item&gt;();<br/>
private Decimal      m_totalCost = 0;<br/>
public ShoppingCart() { }<br/>
public void AddItem(Item item) {<br/>
AddItemHelper(m_cart, item, ref m_totalCost);<br/>
}<br/>
private static void AddItemHelper(List&lt;Item&gt; m_cart, Item newItem, ref Decimal totalCost) {<br/>
// Preconditions:<br/>
Contract.Requires(newItem != null);<br/>
Contract.Requires(Contract.ForAll(m_cart, s =&gt; s != newItem)); // Postconditions:<br/>
Contract.Ensures(Contract.Exists(m_cart, s =&gt; s == newItem)); Contract.Ensures(totalCost &gt;= Contract.OldValue(totalCost));<br/>
Contract.EnsuresOnThrow&lt;IOException&gt;(totalCost == Contract.OldValue(totalCost));<br/>
// Do some stuff (which could throw an IOException)...<br/>
m_cart.Add(newItem);<br/>
totalCost += 1.00M;<br/>
}<br/>
// Object invariant [ContractInvariantMethod] private void ObjectInvariant() {<br/>
Contract.Invariant(m_totalCost &gt;= 0);<br/>
}<br/>
}</code></p>
<p>The <b>AddItemHelper </b>method defines a bunch of code contracts. The preconditions indicate that <b>newItem </b>must not be <b>null </b>and that the item being added to the cart is not already in the cart The postconditions indicate that the new item must be in the cart and that the total cost must be at least as much as it was before the item was added to the cart The postconditions also indicate that if <b>AddItemHelper </b>were to throw an <b>IOException </b>for some reason, then <b>totalCost </b>is unchanged from what it was when the method started to execute. The <b>ObjectInvariant </b>method is just a private method that, when called, makes sure that the object's <b>m_totalCost </b>field never contains a negative value.</p>
<hr/>
<blockquote><b>Important </b>All members referenced in a precondition, postcondition, or invariant test must be side-effect free This is required because testing conditions should not change the state of the object itself In addition, all members referenced in a precondition test must be at least as accessible as the method defining the precondition. This is required because callers of the method should be able to verify that they have met all the preconditions prior to invoking the method On the other hand, members referenced in a postcondition or invariant test can have any accessibility as long as the code can compile The reason why accessibility isn't important here is because postcondition and invariant tests do not affect the callers' ability to invoke the method correctly.</blockquote>
<hr/>
<p>I-</p>
<hr/>
<blockquote><b>Important </b>In regard to inheritance, a derived type cannot override and change the preconditions of a virtual member defined in a base type. Similarly, a type implementing an interface member cannot change the preconditions defined by that interface member. If a member does not have an explicit contract defined for it, then the member has an implicit contract that logically looks like this:</blockquote>
<hr/>
<p><code>Contract.Requires(true);</code></p>
<p>And since a contract cannot be made stricter with new versions (without breaking compatibility), you should carefully consider preconditions when introducing a new virtual, abstract, or interface member. For postconditions and object invariants, contracts can be added and removed at will as the conditions expressed in the virtual/abstract/interface member and the conditions expressed in the overriding member are just logically AND-ed together.</p>
<p>So now you see how to declare contracts. Let's now talk about how they function at runtime. You get to declare all your precondition and postcondition contracts at the top of your methods where they are easy to find. Of course, the precondition contracts will validate their tests when the method is invoked. However, we don't want the postcondition contracts to validate their tests until the method returns. In order to get the desired behavior, the assembly produced by the C# compiler must be processed by the Code Contract Rewriter tool (CCRewrite.exe, found in <span>C:\Program</span> Files (x86)\Microsoft\Contracts\Bin), which produces a</p>
<p>modified version of the assembly. After you select the Perform Runtime Contract Checking check box for your project, Visual Studio will invoke this tool for you automatically whenever you build the project. This tool analyzes the IL in all your methods and it rewrites the IL so that any postcondition contracts are executed at the end of each method If your method has multiple return points inside it, then the CCRewrite.exe tool modifies the method's IL code so that all return points execute the postcondition code prior to the method returning.</p>
<p>The CCRewrite.exe tool looks in the type for any method marked with the <b>[ContractInvariantMethod] </b>attribute. The method can have any name but, by convention, people usually name the method <b>ObjectInvariant </b>and mark the method as <b>private </b>(as I've done above). The method must accept no arguments and have a <b>void </b>return type. When the CCRewrite exe tool sees a method marked with this attribute, it inserts IL code at the end of every <b>public </b>instance method to call the <b>ObjectInvariant </b>method. This way, the object's state is checked as each method returns to ensure that no method has violated the contract. Note that the CCRewrite.exe tool does not modify a <b>Finalize </b>method or an <b>IDisposable</b>'s <b>Dispose </b>method to call the <b>ObjectInvariant </b>method because it is OK for an object's state to be altered if it is considered to be destroyed or disposed Also note that a single type can define multiple methods with the <b>[ContractInvariantMethod] </b>attribute; this is useful when working with partial types. The CCRewrite.exe tool will modify the IL to call all of these methods (in an undefined order) at the end of each public method.</p>
<p>The <b>Assert </b>and <b>Assume </b>methods are unlike the other methods. First, you should not consider them to be part of the method's signature, and you do not have to put them at the beginning of a method. At runtime, these two methods perform identically: They just verify that the condition passed to them is true and throw an exception if it is not. However, there is another tool, the Code Contract Checker (CCCheck.exe) which analyzes the IL produced by the C# compiler in an attempt to statically verify that no code in the method violates a contract. This tool will attempt to prove that any condition passed to <b>Assert </b>is <b>true, </b>but it will just assume that any condition passed to <b>Assume </b>is <b>true </b>and the tool will add the expression to its body of facts known to be true Usually, you will use <b>Assert </b>and then change an <b>Assert </b>to an <b>Assume </b>if the CCCheck.exe tool can't statically prove that the expression is true.</p>
<p>Let's walk through an example. Assume that I have the following type definition:</p>
<p><code>internal sealed class SomeType {<br/>
private static String s_name = &quot;Jeffrey&quot;;<br/>
public static void ShowFirstLetter() {<br/>
Console.WriteLine(s_name[0]);     // warning: requires unproven: index &lt; this.Length<br/>
}<br/>
}</code></p>
<p>When I build this code with the Perform Static Contract Checking function turned on, the CCCheck exe tool produces the warning shown as a comment above This warning is notifying me that querying the first letter of <b>s_name </b>may fail and throw an exception because it is unproven that <b>s_name </b>always refers to a string consisting of at least one character.</p>
<p>Therefore, what we'd like to do is add an assertion to the <b>ShowFirstLetter </b>method:</p>
<p><code>public static void ShowFirstLetter() {<br/>
Contract.Assert(s_name.Length &gt;= 1);     // warning: assert unproven Console.WriteLine(s_name[0]);<br/>
}</code></p>
<p>Unfortunately, when the CCCheck exe tool analyzes this code, it is still unable to validate that <b>s_name </b>always refers to a string containing at least one letter, so the tool produces a similar warning Sometimes the tool is unable to validate assertions due to limitations in the tool; future versions of the tool will be able to perform a more complete analysis.</p>
<p>To override shortcomings in the tool or to claim that something is true that the tool would never be able to prove, we can change <b>Assert </b>to <b>Assume. </b>If we know for a fact that no other code will modify <b>s_name, </b>then we can change <b>ShowFirstLetter </b>to this:</p>
<p><code>public static void ShowFirstLetter() {<br/>
Contract.Assume(s_name.Length &gt;= 1);     // No warning at all now! Console.WriteLine(s_name[0]);<br/>
}</code></p>
<p>With this version of the code, the CCCheck exe tool just takes our word for it and concludes that <b>s_name </b>always refers to a string containing at least one letter This version of the <b>ShowFirstLetter </b>method passes the code contract static checker without any warnings at all.</p>
<p>Now, let's talk about the Code Contract Reference Assembly Generator tool (CCRefGen.exe). Running the CCRewrite.exe tool to enable contract checking helps you find bugs more quickly, but all the code emitted during contract checking makes your assembly bigger and hurts its runtime performance. To improve this situation, you use the CCRefGen.exe tool to create a separate contract reference assembly. Visual Studio invokes this tool for you automatically if you set the Contract Reference Assembly combo box to Build. Contract assemblies are usually named AssemName. Contracts.dll (for example, MSCorLib. Contracts.dll), and these assemblies contain only metadata and the IL that describes the contracts溶othing else. You can identify a contract reference assembly because it will have the <b>System.Diagnostics. Contracts.ContractReferenceAssemblyAttribute </b>applied to the assembly's assembly definition metadata table. The CCRewrite.exe tool and the CCCheck.exe tool can use contract reference assemblies as input when these tools are performing their instrumentation and analysis.</p>
<p>The last tool, the Code Contract Document Generator tool (CCDocGen exe), adds contract information to the XML documentation files already produced by the C# compiler when you use the compiler's <b>/doc:file </b>switch. This XML file, enhanced by the CCDocGen.exe tool, can be processed by Microsoft's Sandcastle tool to produce MSDN-style documentation that will now include contract information.</p>
<mbp:pagebreak/>
<a name="Chapter21"/>
<h1>Chapter 21: Automatic Memory Management (Garbage Collection)</h1>
<p><b>In this chapter:</b></p>
<a href="#b520">Understanding the Basics of Working in a Garbage-Collected Platform</a><br/>
<a href="#b523">The Garbage Collection Algorithm</a><br/>
<a href="#b527">Garbage Collections and Debugging</a><br/>
<a href="#b530">Using Finalization to Release Native Resources</a><br/>
<a href="#b537">Using Finalization with Managed Resources</a><br/>
<a href="#b540">What Causes Finalize Methods to Be Called?</a><br/>
<a href="#b544">The Dispose Pattern: Forcing an Object to Clean Up</a><br/>
<a href="#b548">Using a Type That Implements the Dispose Pattern</a><br/>
<a href="#b551">C#'s using Statement</a><br/>
<a href="#b554">An Interesting Dependency Issue</a><br/>
<a href="#b555">Monitoring and Controlling the Lifetime of Objects Manually</a><br/>
<a href="#b566">Resurrection</a><br/>
<a href="#b568">Generations</a><br/>
<a href="#b574">Other Garbage Collection Features for Use with Native Resources</a><br/>
<a href="#b578">Predicting the Success of an Operation that Requires a Lot of Memory</a><br/>
<a href="#b580">Programmatic Control of the Garbage Collector</a><br/>
<a href="#b583">Thread Hijacking</a><br/>
<a href="#b585">Garbage Collection Modes</a><br/>
<a href="#b588">Large Objects</a><br/>
<a href="#b589">Monitoring Garbage Collections</a><br/>
<p>In this chapter, I'll discuss how managed applications construct new objects, how the managed heap controls the lifetime of these objects, and how the memory for these objects gets reclaimed In short, I'll explain how the garbage collector in the common language runtime (CLR) works, and I'll explain various performance issues related to it. I'll also discuss how to design applications so that they use memory most efficiently.</p>
<a name="b520"/><h2>Understanding the Basics of Working in a Garbage-Collected Platform</h2>
<p>Every program uses resources of one sort or another, be they files, memory buffers, screen space, network connections, database resources, and so on In fact, in an object-oriented environment, every type identifies some resource available for a program's use. To use any of these resources requires memory to be allocated to represent the type. The following steps are required to access a resource:</p>
<p><b>1. </b>Allocate memory for the type that represents the resource by calling the Intermediate Language's (IL) <b>newobj </b>instruction, which is emitted when you use the <b>new </b>operator in C#</p>
<p><b>2. </b>Initialize the memory to set the initial state of the resource and to make the resource usable. The type's instance constructor is responsible for setting this initial state.</p>
<p><b>3. </b>Use the resource by accessing the type's members (repeating as necessary).</p>
<p><b>4. </b>Tear down the state of a resource to clean up. I'll address this topic in the section &quot;The Dispose Pattern: Forcing an Object to Clean Up&quot; later in this chapter.</p>
<p><b>5. </b>Free the memory. The garbage collector is solely responsible for this step.</p>
<p>This seemingly simple paradigm has been one of the major sources of programming errors. How many times have programmers forgotten to free memory when it is no longer needed? How many times have programmers attempted to use memory after it had already been freed?</p>
<p>In the native programming world, these two application bugs are worse than most others because you usually can't predict the consequences or the timing of them. For other bugs, when you see your application misbehaving, you just fix the problem. But these two bugs cause resource leaks (memory consumption) and object corruption (destabilization), making the application perform unpredictably. In fact, there are many tools (such as Microsoft's Windows Task Manager, Process Explorer, and Performance Monitor, and Rational's Purify) that are specifically designed to help developers locate these types of bugs.</p>
<p>Proper resource management is very difficult and quite tedious. It distracts developers from concentrating on the real problems that they're trying to solve. It would be wonderful if some mechanism existed that simplified the mind-numbing memory-management task for developers. Fortunately, there is: garbage collection.</p>
<p>Garbage collection completely absolves the developer from having to track memory usage and know when to free memory. However, the garbage collector doesn't know anything about the resource represented by the type in memory, which means that a garbage collector can't know how to perform step 4 in the preceding list: tear down the state of a resource to clean up. To get a resource to clean up properly, the developer must write code that knows how to properly clean up a resource. The developer writes this code in the <b>Finalize, Dispose, </b>and <b>Close </b>methods, as described later in this chapter. However, as you'll see, the garbage collector can offer some assistance here too, allowing developers to skip step 4 in many circumstances.</p>
<p>Also, most types, including value types (including all enumeration types), collection types, <b>String, Attribute, Delegate, </b>and <b>Exception, </b>represent resources that don't require any special cleanup. For example, a <b>String </b>resource can be completely cleaned up simply by destroying the character array maintained in the object's memory.</p>
<p>On the other hand, a type that represents (or wraps) an unmanaged or native resource, such as a file, a database connection, a socket, a mutex, a bitmap, an icon, and so on, always requires the execution of some cleanup code when the object is about to have its memory reclaimed. In this chapter, I'll explain how to properly define types that require explicit cleanup, and I'll show you how to properly use types that offer this explicit cleanup. For now, let's examine how memory is allocated and how resources are initialized.</p>
<h3>Allocating Resources from the Managed Heap</h3>
<p>The CLR requires that all resources be allocated from a heap called the managed heap. This heap is similar to a C-runtime heap, except that you never delete objects from the managed heap熔bjects are automatically deleted when the application no longer needs them. This, of course, raises the question, &quot;How does the managed heap know when the application is no longer using an object?&quot; I'll address this question shortly.</p>
<p>Several garbage collection algorithms are in use today. Each algorithm is fine-tuned for a particular environment to provide the best performance. In this chapter, I'll concentrate on the garbage collection algorithm used by the Microsoft .NET Framework's CLR. Let's start off with the basic concepts.</p>
<p>When a process is initialized, the CLR reserves a contiguous region of address space that initially contains no backing storage. This address space region is the managed heap. The heap also maintains a pointer, which I'll call <b>NextObjPtr </b>. This pointer indicates where the next object is to be allocated within the heap Initially, <b>NextObjPtr </b>is set to the base address of the reserved address space region <sup>1</sup></p>
<p>During initialization, the CLR reserves two segments of virtual address space: one for the normal heap and one for the large object heap (discussed in the section &quot;Large Objects&quot; later in this chapter). The size of each segment varies. For a client application, each segment is approximately 16 MB, and for a server application, each segment is approximately 64 MB. However, there are other things that affect the segment size, such as if you are running on a 32-bit or 64-bit operating system, and also the number of CPUs in the machine (the segment size gets smaller on a machine with more CPUs). As segments fill with non-garbage objects, the CLR allocates more segments. It will continue to do this until the whole process's address space is full. So, your application's memory is limited by the process's virtual address space. You can allocate a lot more memory in a 64-bit process than you can in a 32-bit process.</p>
<p>The <b>newobj </b>IL instruction creates an object. Many languages (including C#, C++/CLI, and Microsoft Visual Basic) offer a <b>new </b>operator that causes the compiler to emit a <b>newobj </b>instruction into the method's IL code The <b>newobj </b>instruction causes the CLR to perform the following steps:</p>
<p><b>1. </b>Calculate the number of bytes required for the type's (and all of its base type's) fields.</p>
<p><b>2. </b>Add the bytes required for an object's overhead. Each object has two overhead fields: a type object pointer and a sync block index. For a 32-bit application, each of these fields requires 32 bits, adding 8 bytes to each object. For a 64-bit application, each field is 64 bits, adding 16 bytes to each object.</p>
<p><b>3. </b>The CLR then checks that the bytes required to allocate the object are available in the reserved region (committing storage if necessary). If there is enough free space in the managed heap, the object will fit, starting at the address pointed to by <b>NextObjPtr, </b>and these bytes are zeroed out The type's constructor is called (passing <b>NextObjPtr </b>for the <b>this </b>parameter), and the <b>newobj </b>IL instruction (or C#'s <b>new </b>operator) returns the address of the object. Just before the address is returned, <b>NextObjPtr </b>is advanced past the object and now points to the address where the next object will be placed in the heap.</p>
<p>Figure 21-1 shows a managed heap consisting of three objects: A, B, and C If a new object were to be allocated, it would be placed where <b>NextObjPtr </b>points to (immediately after object C).</p>
<img src="61.jpg"/>
<p><b>FIGuRE </b><b>21-1 </b>Newly initialized managed heap with three objects constructed in it</p>
<p>By contrast, let's look at how the C-runtime heap allocates memory. In a C-runtime heap, allocating memory for an object requires walking through a linked list of data structures. Once a large enough block is found, that block is split, and pointers in the linked-list nodes are modified to keep everything intact. For the managed heap, allocating an object simply means adding a value to a pointer葉his is blazingly fast by comparison. In fact, allocating an object from the managed heap is nearly as fast as allocating memory from a thread's stack! In addition, most heaps (such as the C-runtime heap) allocate objects wherever they find free space Therefore, if I create several objects consecutively, it's quite possible for these objects to be separated by megabytes of address space. In the managed heap, however, allocating several objects consecutively ensures that the objects are contiguous in memory.</p>
<p>In many applications, objects allocated around the same time tend to have strong relationships to each other and are frequently accessed around the same time. For example, it's very common to allocate a <b>FileStream </b>object immediately before a <b>BinaryWriter </b>object is created. Then the application would use the <b>BinaryWriter </b>object, which internally uses the <b>FileStream </b>object. In a garbage-collected environment, new objects are allocated contiguously in memory, providing performance gains resulting from locality of reference. Specifically, this means that your process's working set will be smaller than a similar application running in a non-managed environment. It's also likely that the objects that your code is using can all reside in the CPU's cache Your application will access these objects with phenomenal speed because the CPU will be able to perform most of its manipulations without having cache misses that would force slower access to RAM.</p>
<p>So far, it sounds as if the managed heap is far superior to the C-runtime heap because of its simplicity of implementation and speed. But there's one little detail you should know about before getting too excited. The managed heap gains these advantages because it makes one really big assumption: that address space and storage are infinite. Obviously, this assumption is ridiculous, and the managed heap must employ a mechanism to allow it to make this assumption. This mechanism is the garbage collector. Here's how it works:</p>
<p>When an application calls the <b>new </b>operator to create an object, there might not be enough address space left in the region to allocate to the object The heap detects this lack of space by adding the bytes that the object requires to the address in <b>NextObjPtr. </b>If the resulting value is beyond the end of the address space region, the heap is full, and a garbage collection must be performed.</p>
<p><b>i-</b></p>
<hr/>
<blockquote><b>Important </b>What I've just said is an oversimplification. In reality, a garbage collection occurs when generation 0 is full. Some garbage collectors use generations, a mechanism whose sole purpose is to improve performance. The idea is that newly created objects are part of a young generation and objects created early in the application's lifecycle are in an old generation Objects in generation 0 are objects that have recently been allocated and have never been examined by the garbage collector algorithm Objects that survive a collection are promoted to another generation (such as generation 1) Separating objects into generations allows the garbage collector to collect specific generations instead of collecting all of the objects in the managed heap. I'll explain generations in more detail later in this chapter. Until then, it's easiest for you to think that a garbage collection occurs when the heap is full.</blockquote>
<hr/>
<a name="b523"/><h2>The Garbage Collection Algorithm</h2>
<p>The garbage collector checks to see if any objects in the heap are no longer being used by the application. If such objects exist, the memory used by these objects can be reclaimed. (If no more memory is available in the heap after a garbage collection, <b>new </b>throws an <b>OutOfMemoryException </b>.) How does the garbage collector know whether the application is using an object? As you might imagine, this isn't a simple question to answer.</p>
<p>Every application has a set of roots A single root is a storage location containing a memory pointer to a reference type object This pointer either refers to an object in the managed heap or is set to <b>null. </b>For example, a static field (defined within a type) is considered a root. In addition, any method parameter or local variable is considered a root. Only variables that are of a reference type are considered roots; value type variables are never considered roots. Now, let's look at a concrete example starting with the following class definition:</p>
<p><code>internal sealed class SomeType { private TextWriter m_textWriter;<br/>
public SomeType(TextWriter tw) { m_textWriter = tw;<br/>
}<br/>
public void WriteBytes(Byte[] bytes) {<br/>
for (Int32 x = 0; x &lt; bytes.Length; x++) { m_textWriter.Write(bytes[x]);<br/>
}<br/>
}<br/>
}</code></p>
<p>The first time the <b>WriteBytes </b>method is called, the just-in-time (JIT) compiler converts the method's IL code into native CPU instructions. Let's say the CLR is running on an x86 CPU, and the JIT compiler compiles the <b>WriteBytes </b>method into the CPU instructions shown in Figure 21-2. (I added comments on the right to help you understand how the native code maps back to the original source code.</p>
<img src="62.png"/>
<p><b>FIGuRE </b><b>21-2 </b>Native code produced by the JIT compiler with ranges of roots shown</p>
<p>As the JIT compiler produces the native code, it also creates an internal table. Logically, each entry in the table indicates a range of byte offsets in the method's native CPU instructions, and for each range, a set of memory addresses and CPU registers that contain roots.</p>
<p>For the <b>WriteBytes </b>method, this table reflects that the EBX register starts being a root at offset 0x00000003, the ESI register starts being a root at offset 0x00000005, and the ECX register starts being a root at offset 0x0000000f All three of these registers stop being roots at the end of the loop (offset 0x00000028). Also note that the EAX register is a root from 0x0000001c to 0x0000001e. The EDI register is used to hold the <b>Int32 </b>value represented by the variable <b>x </b>in the original source code Since <b>Int32 </b>is a value type, the JIT compiler doesn't consider the EDI register to be a root.</p>
<p>The <b>WriteBytes </b>method is a fairly simple method, and all of the variables that it uses can be enregistered A more complex method could use all of the available CPU registers, and some roots would be in memory locations relative to the method's stack frame. Also note that on an x86 architecture, the CLR passes the first two arguments to a method via the ECX and EDX registers. For instance methods, the first argument is the <b>this </b>pointer, which is always passed in the ECX register. For the <b>WriteBytes </b>method, this is how I know that the <b>this </b>pointer is passed in the ECX register and stored in the EBX register right after the method prolog. This is also how I know that the <b>bytes </b>argument is passed in the EDX register and stored in the ESI register after the prolog.</p>
<p>If a garbage collection were to start while code was executing at offset 0x00000017 in the <b>WriteBytes </b>method, the garbage collector would know that the objects referred to by the EBX <b>(this </b>argument), ESI <b>(bytes </b>argument), and ECX (the <b>m_textWriter </b>field) registers were all roots and refer to objects in the heap that shouldn't be considered garbage In addition, the garbage collector can walk up the thread's call stack and determine the roots for all of the calling methods by examining each method's internal table. The garbage collector iterates through all the type objects to obtain the set of roots stored in static fields.</p>
<p>When a garbage collection starts, it assumes that all objects in the heap are garbage. In other words, it is assumed that the thread's stack contains no variables that refer to objects in the heap, that no CPU registers refer to objects in the heap, and that no static fields refer to objects in the heap. The garbage collector starts what is called the marking phase of the collection This is when the collector walks up the thread's stack checking all of the roots If a root is found to refer to an object, a bit will be turned on in the object's sync block index field葉his is how the object is marked. For example, the garbage collector might locate a local variable that points to an object in the heap Figure 21-3 shows a heap containing several allocated objects, and the application's roots refer directly to objects A, C, D, and F All of these objects are marked. When marking object D, the garbage collector notices that this object contains a field that refers to object H, causing object H to be marked as well. The garbage collector continues to walk through all reachable objects recursively.</p>
<p><b>Figure 21-3 </b>Managed heap before a collection</p>
<p>After a root and the objects referenced by its fields are marked, the garbage collector checks the next root and continues marking objects. If the garbage collector is going to mark an object that it previously marked, it can stop walking down that path. This behavior serves two purposes. First, performance is enhanced significantly because the garbage collector doesn't walk through a set of objects more than once. Second, infinite loops are prevented if you have any circular linked lists of objects.</p>
<p>Once all of the roots have been checked, the heap contains a set of marked and unmarked objects The marked objects are reachable via the application's code, and the unmarked objects are unreachable The unreachable objects are considered garbage, and the memory that they occupy can be reclaimed. The garbage collector now starts what is called the compact phase of the collection. This is when the collector traverses the heap linearly looking for contiguous blocks of unmarked (garbage) objects.</p>
<p>If small blocks are found, the garbage collector leaves the blocks alone. If large free contiguous blocks are found, however, the garbage collector shifts the nongarbage objects down in memory to compact the heap.</p>
<p>Naturally, moving the objects in memory invalidates all variables and CPU registers that contain pointers to the objects So the garbage collector must revisit all of the application's roots and modify them so that each root's value points to the objects' new memory location. In addition, if any object contains a field that refers to another moved object, the garbage collector is responsible for correcting these fields as well. After the heap memory is compacted, the managed heap's <b>NextObjPtr </b>pointer is set to point to a location just after the last non-garbage object. Figure 21-4 shows the managed heap after a collection.</p>
<p>As you can see, a garbage collection generates a considerable performance hit, which is the major downside of using a managed heap. But keep in mind that garbage collections occur only when generation 0 is full, and until then, the managed heap is significantly faster than a C-runtime heap. Finally, the CLR's garbage collector offers some optimizations that greatly improve the performance of garbage collection. I'll discuss these optimizations later in this chapter, in the &quot;Generations&quot; and &quot;Other Garbage Collection Features for Use with Native Resources&quot; sections.</p>
<img src="63.jpg"/>
<p><b>Figure 21-4 </b>Managed heap after a collection</p>
<p>As a programmer, you should take away a couple of important points from this discussion. To start, you no longer have to implement any code to manage the lifetime of objects your application uses. And notice how the two bugs described at the beginning of this chapter no longer exist. First, it's not possible to leak objects because any object not accessible from your application's roots can be collected at some point. Second, it's not possible to access an object that is freed because the object won't be freed if it is reachable, and if it's not reachable, your application has no way to access it. Also, since a collection causes memory compaction, it is not possible for managed objects to fragment your process's virtual address space This would sometimes be a severe problem with unmanaged heaps but is no longer an issue when using the managed heap. Using large objects (discussed later in this chapter) is an exception to this, and fragmentation of the large object heap is possible.</p>
<hr/>
<blockquote><b>Important </b>A type's static field roots whatever object it refers to forever or until the AppDomain that the types are loaded into is unloaded. A common way to leak memory is to have a static field refer to a collection object and then to keep adding items to the collection object. The static field keeps the collection object alive and the collection object keeps all its items alive. For this reason, it is best to avoid static fields whenever possible.</blockquote>
<hr/>
<img src="64.jpg"/>
<a name="b527"/><h2>Garbage Collections and Debugging</h2>
<p>In Figure 21-2, notice that the method's <b>bytes </b>argument (stored in the ESI register) isn't referred to after the CPU instruction at offset 0x00000028. This means that the <b>Byte </b>array object that the <b>bytes </b>argument refers to can be collected any time after the instruction at offset 0x00000028 executes (assuming that there are no other roots in the application that also refer to this array object). In other words, as soon as an object becomes unreachable, it is a candidate for collection熔bjects aren't guaranteed to live throughout a method's lifetime. This can have an interesting impact on your application For example, examine the following code:</p>
<p><code>using System;<br/>
using System.Threading;<br/>
public static class Program { public static void Main() {<br/>
// Create a Timer object that knows to call our TimerCallback<br/>
// method once every 2000 milliseconds.<br/>
Timer t = new Timer(TimerCallback, null, 0, 2000);<br/>
// Wait for the user to hit &lt;Enter&gt; Console.ReadLineO;<br/>
}<br/>
private static void TimerCallback(Object o) {<br/>
// Display the date/time when this method got called. Console.WriteLineC'In TimerCallback: &quot; + DateTime.Now);<br/>
// Force a garbage collection to occur for this demo. GC.CollectO;<br/>
}<br/>
}</code></p>
<p>Compile this code from the command prompt without using any special compiler switches. When you run the resulting executable file, you'll see that the <b>TimerCallback </b>method is called just once!</p>
<p>From examining the code above, you'd think that the <b>TimerCallback </b>method would get called once every 2,000 milliseconds. After all, a <b>Timer </b>object is created, and the variable <b>t </b>refers to this object. As long as the timer object exists, the timer should keep firing. But you'll notice in the <b>TimerCallback </b>method that I force a garbage collection to occur by calling <b>GC.CollectO.</b></p>
<p>When the collection starts, it first assumes that all objects in the heap are unreachable (garbage); this includes the <b>Timer </b>object. Then, the collector examines the application's roots and sees that <b>Main </b>doesn't use the <b>t </b>variable after the initial assignment to it. Therefore, the application has no variable referring to the <b>Timer </b>object, and the garbage collection reclaims the memory for it; this stops the timer and explains why the <b>TimerCallback </b>method is called just once.</p>
<p>Let's say that you're using a debugger to step through <b>Main, </b>and a garbage collection just happens to occur just after <b>t </b>is assigned the address of the new <b>Timer </b>object. Then, let's say that you try to view the object that <b>t </b>refers to by using the debugger's Quick Watch window. What do you think will happen? The debugger can't show you the object because it was just garbage collected. This behavior would be considered very unexpected and undesirable by most developers, so Microsoft has come up with a solution.</p>
<p>When the JIT compiler compiles the IL for a method into native code, it checks to see if the assembly defining the method was compiled without optimizations and if the process is currently being executed under a debugger. If both are true, the JIT compiler generates the method's internal root table in such a way as to artificially extend the lifetime of all of the variables to the end of the method. In other words, the JIT compiler will trick itself into believing that the <b>t </b>variable in <b>Main </b>must live until the end of the method. So, if a garbage collection were to occur, the garbage collector now thinks that <b>t </b>is still a root and that the <b>Timer </b>object that <b>t </b>refers to will continue to be reachable. The <b>Timer </b>object will survive the collection, and the <b>TimerCallback </b>method will get called repeatedly until <b>Console. ReadLine </b>returns and <b>Main </b>exits. This is easy to see. Just run the same executable file under a debugger, and you'll see that the <b>TimerCallback </b>method is called repeatedly!</p>
<p>Now, recompile the program from a command prompt, but this time, specify the C# compiler's <b>/debug+ </b>compiler-line switch. When you run the resulting executable file, you'll now see that the <b>TimerCallback </b>method is called repeatedly容ven if you don't run this program under a debugger! What is happening here?</p>
<p>Well, when the JIT compiler compiles a method, the JIT compiler looks to see if the assembly that defines the method contains the <b>System.Diagnostics.DebuggableAttribute </b>attribute with its <b>DebuggingModes' DisableOptimizations </b>flag set. If the JIT compiler sees this flag set, it also compiles the method, artificially extending the lifetime of all variables until the end of the method. When you specify the <b>/debug+ </b>compiler switch, the C# compiler emits this attribute and flag into the resulting assembly for you. Note, the C# compiler's <b>/optimize+ </b>compiler switch can turn optimizations back on so this compiler switch should not be specified when performing this experiment.</p>
<p>The JIT compiler does this to help you with JIT debugging. You may now start your application normally (without a debugger), and if the method is called, the JIT compiler will artificially extend the lifetime of the variables to the end of the method. Later, if you decide to attach a debugger to the process, you can put a breakpoint in a previously compiled method and examine the variables.</p>
<p>So now you know how to build a program that works in a debug build but doesn't work correctly when you make a release build! Since no developer wants a program that works only when debugging it, there should be something we can do to the program so that it works all of the time regardless of the type of build.</p>
<p>You could try modifying the <b>Main </b>method to this:</p>
<p><code>public static void Main() {<br/>
// Create a Timer object that knows to call our TimerCallback<br/>
// method once every 2000 milliseconds.<br/>
Timer t = new Timer(TimerCallback, null, 0, 2000);<br/>
// Wait for the user to hit &lt;Enter&gt; Console.ReadLineO;<br/>
// Refer to t after ReadLine (this gets optimized away) t = null;<br/>
}</code></p>
<p>However, if you compile this (without the <b>/debug+ </b>switch) and run the resulting executable file (not under the debugger), you'll see that the <b>TimerCallback </b>method is still called just once. The problem here is that the JIT compiler is an optimizing compiler, and setting a local variable or parameter variable to <b>null </b>is the same as not referencing the variable at all. In other words, the JIT compiler optimizes the <b>t = null; </b>line out of the code completely, and therefore, the program still does not work as we desire. The correct way to modify the <b>Main </b>method is as follows:</p>
<p><code>public static void Main() {<br/>
// Create a Timer object that knows to call our TimerCallback<br/>
// method once every 2000 milliseconds.<br/>
Timer t = new Timer(TimerCallback, null, 0, 2000);<br/>
// Wait for the user to hit &lt;Enter&gt; Console.ReadLineO;<br/>
// Refer to t after ReadLine (t will survive GCs until Dispose returns) t.Dispose ();<br/>
}</code></p>
<p>Now, if you compile this code (without the <b>/debug+ </b>switch) and run the resulting executable file (not under the debugger), you'll see that the <b>TimerCallback </b>method is called multiple times, and the program is fixed. What's happening here is that the object <b>t </b>refers to is required to stay alive so that the <b>Dispose </b>instance method can be called on it (the value in <b>t </b>needs to be passed as the <b>this </b>argument to <b>Dispose) </b>.</p>
<hr/>
<blockquote><b>Note </b>Please don't read this whole discussion and then worry about your own objects being garbage collected prematurely. I use the <b>Timer </b>class in this discussion because it has special behavior that no other class exhibits. The &quot;problem/feature&quot; of <b>Timer </b>is that the existence of a <b>Timer </b>object in the heap causes something else to happen: A thread pool thread invokes a method periodically No other type exhibits this behavior For example, the existence of a <b>String </b>object in memory doesn't cause anything else to happen; the string just sits there So, I use <b>Timer </b>to show how roots work and how object-lifetime works as related to the debugger, but the discussion is not really about how to keep objects alive. All non<b>-Timer </b>objects will live as needed by the application automatically.</blockquote>
<hr/>
<a name="b530"/><h2>Using Finalization to Release Native Resources</h2>
<p>At this point, you should have a basic understanding of garbage collection and the managed heap, including how the garbage collector reclaims an object's memory. Fortunately for us, most types need only memory to operate. However, some types require more than just memory to be useful; some types require the use of a native resource in addition to memory.</p>
<p>The <b>System.IO.FileStream </b>type, for example, needs to open a file (a native resource) and store the file's handle. Then the type's <b>Read </b>and <b>Write </b>methods use this handle to manipulate the file. Similarly, the <b>System.Threading.Mutex </b>type opens a Windows mutex kernel object (a native resource) and stores its handle, using it when the <b>Mutex</b>'s methods are called.</p>
<p>Finalization is a mechanism offered by the CLR that allows an object to perform some graceful cleanup prior to the garbage collector reclaiming the object's memory. Any type that wraps a native resource, such as a file, network connection, socket, mutex, or other type, must support finalization. Basically, the type implements a method named <b>Finalize. </b>When the garbage collector determines that an object is garbage, it calls the object's <b>Finalize </b>method (if it exists). I think of it this way: Any type that implements the <b>Finalize </b>method is in effect stating that all of its objects want a last meal before they are killed.</p>
<p>Microsoft's C# team felt that <b>Finalize </b>methods were a special kind of method requiring special syntax in the programming language (similar to how C# requires special syntax to define a constructor). So, in C#, you must define a <b>Finalize </b>method by placing a tilde symbol (<b>~</b>) in front of the class name, as shown in the following code sample:</p>
<p><code>internal sealed class SomeType { // This is the Finalize method ~SomeType() {<br/>
// The code here is inside the Finalize method<br/>
}<br/>
}</code></p>
<p>If you were to compile this code and examine the resulting assembly with ILDasm.exe, you'd see that the C# compiler did, in fact, emit a <b>protected override </b>method named <b>Finalize </b>into the module's metadata. If you examined the <b>Finalize </b>method's IL code, you'd also see that the code inside the method's body is emitted into a <b>try </b>block, and that a call to <b>base. Finalize </b>is emitted into a <b>finally </b>block.</p>
<hr/>
<blockquote><b>Important </b>If you're familiar with C++, you'll notice that the special syntax C# requires for defining a <b>Finalize </b>method looks just like the syntax you'd use to define a C++ destructor. In fact, the C# Programming Language Specification calls this method a destructor. However, a <b>Finalize </b>method doesn't work like an unmanaged C++ destructor at all, and this has caused a great deal of confusion for developers migrating from one language to another.</blockquote>
<hr/>
<p>The problem is that developers mistakenly believe that using the C# destructor syntax means that the type's objects will be deterministically destructed, just as they would be in C++. However, the CLR doesn't support deterministic destruction, preventing C# from providing this mechanism.</p>
<p>A <b>Finalize </b>method is usually implemented to call the Win32 <b>CloseHandle </b>function, passing in the handle of the native resource. The <b>FileStream </b>type defines a file handle field, which identifies the native resource. The <b>FileStream </b>type also defines a <b>Finalize </b>method, which internally calls <b>CloseHandle, </b>passing it the file handle field; this ensures that the native file handle is closed when the managed <b>FileStream </b>object is determined to be garbage. If a type that wraps a native resource fails to define a <b>Finalize </b>method, the native resource won't be closed and will cause a resource leak that will exist until the process terminates, at which time the operating system will reclaim the native resources.</p>
<h3>Guaranteed Finalization Using CriticalFinalizerObject Types</h3>
<p>To make things simpler for developers, the <b>System.Runtime.ConstrainedExecution </b>namespace defines a <b>CriticalFinalizerObject </b>class that looks like this:</p>
<p><code>public abstract class CriticalFinalizerObject {<br/>
protected CriticalFinalizerObject() { /* there is no code in here */ }<br/>
// This is the Finalize method<br/>
-CriticalFinalizerObjectO { /* there is no code in here */ }<br/>
}</code></p>
<p>I know that you're thinking that this class doesn't look too exciting, but the CLR treats this class and classes derived from it in a very special manner. In particular, the CLR endows this class with three cool features:</p>
<p>&#9632; The first time an object of any <b>CriticalFinalizerObject</b>-derived type is constructed, the CLR immediately JIT-compiles all of the <b>Finalize </b>methods in the inheritance hierarchy Compiling these methods upon object construction guarantees that the native resource will be released when the object is determined to be garbage Without this eager compiling of the <b>Finalize </b>method, it would be possible to allocate the native resource and use it, but not to get rid of it. Under low memory conditions, the CLR might not be able to find enough memory to compile the <b>Finalize </b>method, which would prevent it from executing, causing the native resource to leak. Or the resource might not be freed if the <b>Finalize </b>method contained code that referred to a type in another assembly, and the CLR failed to locate this other assembly.</p>
<p>&#9632; The CLR calls the <b>Finalize </b>method of <b>CriticalFinalizerObject</b>-derived types after calling the <b>Finalize </b>methods of non<b>-CriticalFinalizerObject</b>-derived types. This ensures that managed resource classes that have a <b>Finalize </b>method can access <b>CriticalFinalizerObject</b>-derived objects within their <b>Finalize </b>methods successfully. For example, the <b>FileStream </b>class's <b>Finalize </b>method can flush data from a memory buffer to an underlying disk with confidence that the disk file has not been closed yet.</p>
<p>&#9632; The CLR calls the <b>Finalize </b>method of <b>CriticalFinalizerObject</b>-derived types if an AppDomain is rudely aborted by a host application (such as Microsoft SQL Server or Microsoft ASP.NET). This also is part of ensuring that the native resource is released even in a case in which a host application no longer trusts the managed code running inside of it.</p>
<h3>SafeHandle and Its Derived Types</h3>
<p>Now, Microsoft realizes that the most-used native resources are those resources provided by Windows. And Microsoft also realizes that most Windows resources are manipulated with handles (32-bit values on a 32-bit system and 64-bit values on a 64-bit system). Again,</p>
<p>to make life easier and safer for developers, the <b>System.Runtime.InteropServices </b>namespace includes a class called <b>SafeHandle, </b>which looks like this (I've added comments in the methods to indicate what they do):</p>
<p><code>public abstract class SafeHandle : CriticalFinalizerObject, IDisposable { // This is the handle to the native resource protected IntPtr handle;<br/>
protected SafeHandle(IntPtr invalidHandleValue, Boolean ownsHandle) { this.handle = invalidHandleValue;<br/>
// If ownsHandle is true, then the native resource is closed when // this SafeHandle-derived object is collected<br/>
}<br/>
protected void SetHandle(IntPtr handle) { this.handle = handle;<br/>
}<br/>
// You can explicitly release the resource by calling Dispose or Close public void Dispose() { Dispose(true); } public void Close()     { Dispose(true); }<br/>
// The default Dispose implementation (shown here) is exactly what you want. // Overriding this method is strongly discouraged. protected virtual void Dispose(Boolean disposing) {<br/>
// The default implementation ignores the disposing argument.<br/>
// If resource was already released, just return<br/>
// If ownsHandle is false, return<br/>
// Set flag indicating that this resource has been released // Call the virtual ReleaseHandle method<br/>
// Call CC.SuppressFinalize(this) to prevent Finalize from being called // If ReleaseHandle returned true, return<br/>
// Fire the ReleaseHandleFailed Managed Debugging Assistant (MDA)<br/>
}<br/>
// The default Finalize implementation (shown here) is exactly what you want. // Overriding this method is very strongly discouraged. ~SafeHandle() { Dispose(false); }<br/>
// A derived class overrides this method to implement the code that releases the resource protected abstract Boolean ReleaseHandle();<br/>
public void SetHandleAsInvalid() {<br/>
// Set flag indicating that this resource has been released<br/>
// Call CC.SuppressFinalize(this) to prevent Finalize from being called<br/>
}<br/>
public Boolean IsClosed {<br/>
get {<br/>
// Returns flag indicating whether resource was released<br/>
}<br/>
}<br/>
public abstract Boolean IsInvalid {<br/>
get {<br/>
// A derived class overrides this property.<br/>
// The implementation should return true if the handle's value doesn't // represent a resource (this usually means that the handle is 0 or -1)<br/>
}<br/>
}<br/>
// These three methods have to do with security and reference counting; // I'll talk about them at the end of this section public void     DangerousAddRef(ref Boolean success) {... } public IntPtr DangerousCetHandle() {... } public void     DangerousRelease() {... }<br/>
}</code></p>
<p>The first thing to notice about the <b>SafeHandle </b>class is that it is derived from <b>CriticalFinalizerObject; </b>this ensures it gets the CLR's special treatment. The second thing to notice is that the class is abstract; it is expected that another class will be derived from <b>SafeHandle, </b>and this class will override the protected constructor, the abstract method <b>ReleaseHandle, </b>and the abstract <b>IsInvalid </b>property <b>get </b>accessor method.</p>
<p>In Windows, most handles are invalid if they have a value of <b>0 </b>or <b>-1 </b>. The <b>Microsoft.Win32.SafeHandles </b>namespace contains another helper class called <b>SafeHandleZeroOrMinusOneIsInvalid, </b>which looks like this:</p>
<p><code>public abstract class SafeHandleZeroOrMinusOneIsInvalid : SafeHandle { protected SafeHandleZeroOrMinusOneIsInvalid(Boolean ownsHandle) : base(IntPtr.Zero, ownsHandle) {<br/>
}<br/>
public override Boolean IsInvalid {<br/>
get {<br/>
if (base.handle == IntPtr.Zero) return true; if (base.handle == (IntPtr) (-1)) return true; return false;<br/>
}<br/>
}<br/>
}</code></p>
<p>Again, you'll notice that the <b>SafeHandleZeroOrMinusOneIsInvalid </b>class is abstract, and therefore, another class must be derived from this one to override the protected constructor and the abstract method <b>ReleaseHandle. </b>The .NET Framework provides just a few public classes derived from <b>SafeHandleZeroOrMinusOneIsInvalid, </b>including <b>SafeFileHandle, SafeRegistryHandle, SafeWaitHandle, </b>and <b>SafeBuffer </b>Here is what the <b>SafeFileHandle </b>class looks like:</p>
<p><code>public sealed class SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid { public SafeFileHandle(IntPtr preexistingHandle, Boolean ownsHandle) : base(ownsHandle) { base.SetHandle(preexistingHandle);<br/>
}<br/>
protected override Boolean ReleaseHandle() {<br/>
// Tell Windows that we want the native resource closed. return Win32Native.CloseHandle(base.handle);<br/>
}<br/>
}</code></p>
<p>The <b>SafeWaitHandle </b>class is implemented similarly to the <b>SafeFileHandle </b>class shown above. The only reason why there are different classes with similar implementations is to achieve type safety; the compiler won't let you use a file handle as an argument to a method that expects a wait handle, and vice versa. The <b>SafeRegistryHandle </b>class's <b>ReleaseHandle </b>method calls the Win32 <b>RegCloseKey </b>function.</p>
<p>It would be nice if the .NET Framework included additional classes that wrap various native resources. For example, one could imagine classes such as <b>SafeProcessHandle, SafeThreadHandle, SafeTokenHandle, SafeFileMappingHandle, SafeViewOfFileHandle </b>(its <b>ReleaseHandle </b>method would call the Win32 <b>UnmapViewOfFile </b>function), <b>SafeLibraryHandle </b>(its <b>ReleaseHandle </b>method would call the Win32 <b>FreeLibrary </b>function), <b>SafeLocalAllocHandle </b>(its <b>ReleaseHandle </b>method would call the Win32 <b>LocalFree </b>function), and so on.</p>
<p>All of the classes just listed (and more) actually do ship with the Framework Class Library (FCL). However, these classes are not publicly exposed; they are all internal to MSCorLib.dll or System, dll. Microsoft didn't expose these classes publicly because they didn't want to do full testing of them, and they didn't want to have to take the time to document them. However, if you need any of these classes for your own work, I'd recommend that you use a tool such as ILDasm.exe or some IL decompiler tool to extract the code for these classes and integrate that code into your own project's source code. All of these classes are trivial to implement, and writing them yourself from scratch would also be quite easy.</p>
<h3>Interoperating with Unmanaged Code by Using SafeHandle Types</h3>
<p>As already shown, the <b>SafeHandle</b>-derived classes are extremely useful because they ensure that the native resource is freed when a garbage collection occurs In addition to what we've already discussed, <b>SafeHandle </b>offers two more capabilities First, the CLR gives <b>SafeHandle-</b>derived types special treatment when used in scenarios in which you are interoperating with unmanaged code For example, let's examine the following code:</p>
<p><code>using System;<br/>
using System.Runtime.InteropServices; using Microsoft.Win32.SafeHandles;<br/>
internal static class SomeType {<br/>
[DllImport(&quot;Kerne132&quot;, CharSet=CharSet.Unicode, EntryPoint=&quot;CreateEvent&quot;)]<br/>
// This prototype is not robust<br/>
private static extern IntPtr CreateEventBad(<br/>
IntPtr pSecurityAttributes, Boolean manualReset, Boolean initialState, String name);<br/>
// This prototype is robust<br/>
[DllImport(&quot;Kerne132&quot;, CharSet=CharSet.Unicode, EntryPoint=&quot;CreateEvent&quot;)] private static extern SafeWaitHandle CreateEventCood(<br/>
IntPtr pSecurityAttributes, Boolean manualReset, Boolean initialState, String name);<br/>
public static void SomeMethod() {<br/>
IntPtr.handle = CreateEventBad(IntPtr.Zero, false, false, null);<br/>
SafeWaitHandle swh      = CreateEventCood(IntPtr.Zero, false, false, null);<br/>
}<br/>
}</code></p>
<p>You'll notice that the <b>CreateEventBad </b>method is prototyped as returning an <b>IntPtr. </b>Prior to version 2. 0 of the .NET Framework, the <b>SafeHandle </b>class didn't exist, and you'd have to use the <b>IntPtr </b>type to represent handles What Microsoft's CLR team discovered was that this code was not robust You see, after <b>CreateEventBad </b>was called (which creates the native event resource), it was possible that a <b>ThreadAbortException </b>could be thrown prior to the handle being assigned to the <b>handle </b>variable. In the rare cases when this would happen, the managed code would be leaking the native resource. The only way to get the event closed would be to terminate the process.</p>
<p>Now, with version 2.0 and later of the .NET Framework, we can use the <b>SafeHandle </b>class to fix this potential resource leak. Notice that the <b>CreateEventGood </b>method is prototyped as returning a <b>SafeWaitHandle </b>(instead of an <b>IntPtr). </b>When <b>CreateEventGood </b>is called, the CLR calls the Win32 <b>CreateEvent </b>function As the <b>CreateEvent </b>function returns to managed code, the CLR knows that <b>SafeWaitHandle </b>is derived from <b>SafeHandle, </b>causing the CLR to automatically construct an instance of the <b>SafeWaitHandle </b>class, passing in the handle value returned from <b>CreateEvent </b>. The <b>new</b>ing up of the <b>SafeWaitHandle </b>object and the assignment of the handle happen in unmanaged code, which cannot be interrupted by a <b>ThreadAbortException </b>. Now, it is impossible for managed code to leak this native resource. Eventually, the <b>SafeWaitHandle </b>object will be garbage collected and its <b>Finalize </b>method will be called, ensuring that the resource is released.</p>
<p>One last feature of <b>SafeHandle</b>-derived classes is that they prevent someone from trying to exploit a potential security hole. The problem is that one thread could be trying to use a native resource while another thread tries to free the resource. This could manifest itself as a handle-recycling exploit. The <b>SafeHandle </b>class prevents this security vulnerability by using reference counting. Internally, the <b>SafeHandle </b>class defines a private field that maintains a count. When a <b>SafeHandle</b>-derived object is set to a valid handle, the count is set to 1. Whenever a <b>SafeHandle</b>-derived object is passed as an argument to an unmanaged method, the CLR knows to automatically increment the counter. Likewise, when the unmanaged method returns to managed code, the CLR knows to decrement the counter For example, you would prototype the Win32 <b>SetEvent </b>function as follows:</p>
<p><code>[DllImport(&quot;Kerne132&quot;, ExactSpelling=true)]<br/>
private static extern Boolean SetEvent(SafeWaitHandle swh);</code></p>
<p>Now when you call this method passing in a reference to a <b>SafeWaitHandle </b>object, the CLR will increment the counter just before the call and decrement the counter just after the call Of course, the manipulation of the counter is performed in a thread-safe fashion. How does this improve security? Well, if another thread tries to release the native resource wrapped by the <b>SafeHandle </b>object, the CLR knows that it cannot actually release it because the resource is being used by an unmanaged function. When the unmanaged function returns, the counter is decremented to 0, and the resource will be released.</p>
<p>If you are writing or calling code to manipulate a handle as an <b>IntPtr, </b>you can access it out of a <b>SafeHandle </b>object, but you should manipulate the reference counting explicitly. You accomplish this via <b>SafeHandle</b>'s <b>DangerousAddRef </b>and <b>DangerousRelease </b>methods. You gain access to the raw handle via the <b>DangerousGetHandle </b>method.</p>
<p>I would be remiss if I didn't mention that the <b>System.Runtime.InteropServices </b>namespace also defines a <b>CriticalHandle </b>class. This class works exactly as the <b>SafeHandle </b>class in all ways except that it does not offer the reference-counting feature The <b>CriticalHandle </b>class and the classes derived from it sacrifice security for better performance when you use it (since counters don't get manipulated) As does <b>SafeHandle, </b>the <b>CriticalHandle </b>class has two types derived from it: <b>CriticalHandleMinusOneIsInvalid </b>and <b>CriticalHandleZeroOrMinusOneIsInvalid. </b>Since Microsoft favors a more secure system over a faster system, the class library includes no types derived from either of these two classes. For your own work, I would recommend that you use <b>CriticalHandle</b>-derived types only if performance is an issue. If you can justify reducing security, you can switch to a <b>CriticalHandle</b>-derived type.</p>
<a name="b537"/><h2>Using Finalization with Managed Resources</h2>
<hr/>
<blockquote><b>Important </b>There are some people who are of the mindset that you should never use finaliza-tion with managed resources For the most part, I agree with these people Therefore, you may want to skip this section entirely. Using finalization with managed resources is a super-advanced way of coding and should be used only in very rare circumstances. You must have complete and intimate knowledge of the code you are calling from within a <b>Finalize </b>method. Furthermore, you must know that the behavior of code you are calling will not change with future versions Specifically, you must know that any code you call from within a <b>Finalize </b>method does not use any other object that could have already been finalized.</blockquote>
<hr/>
<p>While finalization is almost exclusively used to release a native resource, it can occasionally be useful with managed resources too. Here's a class that causes the computer to beep every time the garbage collector performs a collection:</p>
<p><code>internal sealed class CCBeep {<br/>
~CCBeep() { // This is the Finalize method Console.BeepO;<br/>
// If the AppDomain isn't unloading and if the process isn't shutting down, // create a new object that will get finalized at the next collection. i f (!AppDomain.CurrentDomain.IsFi nalizi ngForUnload() &amp;&amp;!Envi ronment.HasShutdownStarted) new CCBeep();<br/>
}<br/>
}</code></p>
<p>To use this class, you need just to construct one instance of the class Then whenever a garbage collection occurs, the object's <b>Finalize </b>method is called, which calls <b>Beep </b>and constructs a new <b>GCBeep </b>object. This new <b>GCBeep </b>object will have its <b>Finalize </b>method called when the next garbage collection occurs Here's a sample program that demonstrates the <b>GCBeep </b>class:</p>
<p><code>public static class Program { public static void Main() {<br/>
// Constructing a single CCBeep object causes a beep to occur every time a CC starts. new CCBeep();<br/>
// Construct a lot of 100-byte objects. for (Int32 x = 0; x &lt; 10000; x++) {<br/>
Console.WriteLine(x);<br/>
Byte[] b = new Byte[100];<br/>
}<br/>
}<br/>
}</code></p>
<hr/>
<blockquote><b>Note </b>While the <b>GCBeep </b>class is useful, I provide a much more useful <b>GCNotification </b>class that allows you to instrument your application, thereby providing you a way to learn more about your application's memory usage. You'll find this class presented at the end of the &quot;Generations&quot; section later in this chapter.</blockquote>
<hr/>
<p>Also be aware that a type's <b>Finalize </b>method is called even if the type's instance constructor throws an exception. So your <b>Finalize </b>method shouldn't assume that the object is in a good, consistent state The following code demonstrates this:</p>
<p><code>internal sealed class TempFile { private String m_filename = null; private FileStream m_fs;<br/>
public TempFile(String filename) {<br/>
// The following line might throw an exception. m_fs = new FileStreamCfilename, FileMode.Create);<br/>
// Save the name of this file. m_filename = filename;<br/>
}<br/>
-TempFileO {// This is the Finalize method<br/>
// The right thing to do here is to test filename against null because // you can't be sure that filename was initialized in the constructor. if (m_filename != null) File.Delete(m_filename);<br/>
}<br/>
}</code></p>
<p>You could write the following code instead:</p>
<p><code>internal sealed class TempFile { private String m_filename; private FileStream m_fs;<br/>
public TempFile(String filename) {<br/>
try {<br/>
// The following line might throw an exception. m_fs = new FileStream(filename, FileMode.Create);<br/>
// Save the name of this file. m_filename = filename;<br/>
}<br/>
catch {<br/>
// If anything goes wrong, tell the GC not to call the Finalize method. // I'll discuss SuppressFinalize later in this chapter. GC.SuppressFinalize(this);<br/>
// Let the caller know something failed. throw;<br/>
}<br/>
}<br/>
-TempFileO { // This is the Finalize method<br/>
// No if statement because this   executes only if the constructor ran successfully. File.Delete(m_filename);<br/>
}<br/>
}</code></p>
<p>When designing a type, it's best if you avoid using a <b>Finalize </b>method for several reasons all related to performance:</p>
<p>&#9632; Finalizable objects take longer to allocate because pointers to them must be placed on the finalization list (which I'll discuss in the &quot;Finalization Internals&quot; section a little later in this chapter).</p>
<p>&#9632; Finalizable objects get promoted to older generations, which increases memory pressure and prevents the object's memory from being collected at the time the garbage collector determines that the object is garbage In addition, all objects referred to directly or indirectly by this object get promoted as well. (I'll discuss promotions and generations in more detail in the &quot;Generations&quot; section later in this chapter.)</p>
<p>&#9632; Finalizable objects cause your application to run slower since extra processing must occur for each object when collected.</p>
<p>Furthermore, be aware of the fact that you have no control over when the <b>Finalize </b>method will execute. <b>Finalize </b>methods run when a garbage collection occurs, which may happen when your application requests more memory. Also, the CLR doesn't make any guarantees as to the order in which <b>Finalize </b>methods are called, so you should avoid writing a <b>Finalize </b>method that accesses other objects whose type defines a <b>Finalize </b>method; those other objects could have been finalized already. However, it is perfectly OK to access value type instances or reference type objects that do not define a <b>Finalize </b>method. You also need to be careful when calling static methods because these methods can internally access objects that have been finalized, causing the behavior of the static method to become unpredictable.</p>
<a name="b540"/><h2>What Causes Finalize Methods to Be Called?</h2>
<p><b>Finalize </b>methods are called at the completion of a garbage collection, which is started by one of the following five events:</p>
<p>&#9632; Generation 0 is full   When generation 0 is full, a garbage collection starts. This event is by far the most common way for <b>Finalize </b>methods to be called because it occurs naturally as the application code runs, allocating new objects.</p>
<p>&#9632; Code explicitly calls <b>System.GC</b>'s static <b>Collect </b>method   Code can explicitly request that the CLR perform a collection. Although Microsoft strongly discourages such requests, at times it might make sense for an application to force a collection</p>
<p>&#9632; Windows is reporting low memory conditions  The CLR internally uses the Win32 <b>CreateMemoryResourceNotification </b>and <b>QueryMemoryResourceNotification</b></p>
<p>functions to monitor system memory overall. If Windows reports low memory, the CLR will force a garbage collection in an effort to free up dead objects to reduce the size of a process's working set.</p>
<p>&#9632; The CLR is unloading an AppDomain   When an AppDomain unloads, the CLR considers nothing in the AppDomain to be a root, and a garbage collection consisting of all generations is performed. I'll discuss AppDomains in Chapter 22, &quot;CLR Hosting and AppDomains &quot;</p>
<p>&#9632; The CLR is shutting down   The CLR shuts down when a process terminates normally (as opposed to an external shutdown via Task Manager, for example) During this shutdown, the CLR considers nothing in the process to be a root and calls the <b>Finalize </b>method for all objects in the managed heap. Note that the CLR does not attempt to compact or free memory here because the whole process is terminating, and Windows will reclaim all of the processes' memory.</p>
<p>The CLR uses a special, dedicated thread to call <b>Finalize </b>methods. For the first four events, if a <b>Finalize </b>method enters an infinite loop, this special thread is blocked, and no more <b>Finalize </b>methods can be called. This is a very bad situation because the application will never be able to reclaim the memory occupied by the finalizable objects葉he application will leak memory as long as it runs.</p>
<p>For the fifth event, each <b>Finalize </b>method is given approximately 2 seconds to return. If a <b>Finalize </b>method doesn't return within 2 seconds, the CLR just kills the process溶o more <b>Finalize </b>methods are called. Also, if it takes more than 40 seconds to call all objects' <b>Finalize </b>methods, again, the CLR just kills the process.</p>
<p><b>'</b><b>-</b><b>1</b></p>
<hr/>
<blockquote><b>Note </b>These timeout values were correct at the time I wrote this text, but Microsoft might</blockquote>
<hr/>
<p>change them in the future. Code in a <b>Finalize </b>method can construct new objects. If this hap-</p>
<p>Ipens during CLR shutdown, the CLR continues collecting objects and calling their <b>Finalize </b>methods until no more objects exist or until the 40 seconds have elapsed.</p>
<p>Recall the <b>GCBeep </b>type presented earlier in this chapter. If a <b>GCBeep </b>object is being finalized because of the first, second, or third garbage collection reason, a new <b>GCBeep </b>object is constructed. This is OK because the application continues to run, assuming that more collections will occur in the future. However, if a <b>GCBeep </b>object is being finalized because of the fourth or fifth garbage collection reason, a new <b>GCBeep </b>object shouldn't be constructed because this object would be created while the AppDomain is unloading or the CLR is shutting down. If these new objects are created, the CLR will have a bunch of useless work to do because it will continue to call <b>Finalize </b>methods.</p>
<p>To prevent the construction of new <b>GCBeep </b>objects, <b>GCBeep</b>'s <b>Finalize </b>method calls <b>AppDomain</b>s <b>IsFinalizingForUnload </b>method and also queries <b>System.Environment</b>'s <b>HasShutdownStarted </b>property. The <b>IsFinalizingForUnload </b>method returns <b>true </b>if the object's <b>Finalize </b>method is being called because the AppDomain is unloading. The <b>HasShutdownStarted </b>property returns <b>true </b>if the object's <b>Finalize </b>method is being called because the process is terminating.</p>
<h2>Finalization Internals</h2>
<p>On the surface, finalization seems pretty straightforward: you create an object and its <b>Finalize </b>method is called when it is collected. But once you dig in, finalization is more complicated than this.</p>
<p>When an application creates a new object, the <b>new </b>operator allocates the memory from the heap. If the object's type defines a <b>Finalize </b>method, a pointer to the object is placed on the finalization list just before the type's instance constructor is called. The finalization list is an internal data structure controlled by the garbage collector. Each entry in the list points to an object that should have its <b>Finalize </b>method called before the object's memory can be reclaimed.</p>
<p>Figure 21-5 shows a heap containing several objects. Some of these objects are reachable from the application's roots, and some are not. When objects C, E, F, I, and J were created, the system detected that these objects' types defined a <b>Finalize </b>method and so added pointers to these objects in the finalization list.</p>
<p><b>Figure 21-5 </b>The managed heap showing pointers in its finalization list</p>
<hr/>
<blockquote><b>Note </b>Even though <b>System.Object </b>defines a <b>Finalize </b>method, the CLR knows to ignore it; that is, when constructing an instance of a type, if the type's <b>Finalize </b>method is the one inherited from <b>System.Object, </b>the object isn't considered finalizable. One of the derived types must override <b>Object</b>'s <b>Finalize </b>method.</blockquote>
<hr/>
<p>When a garbage collection occurs, objects B, E, G, H, I, and J are determined to be garbage. The garbage collector scans the finalization list looking for pointers to these objects. When a pointer is found, the pointer is removed from the finalization list and appended to the freachable queue. The freachable queue (pronounced &quot;F-reachable&quot;) is another of the garbage collector's internal data structures. Each pointer in the freachable queue identifies an object that is ready to have its <b>Finalize </b>method called. After the collection, the managed heap looks like Figure 21-6.</p>
<p>In this figure, you see that the memory occupied by objects B, G, and H has been reclaimed because these objects didn't have a <b>Finalize </b>method. However, the memory occupied by objects E, I, and J couldn't be reclaimed because their <b>Finalize </b>methods haven't been called yet.</p>
<p>A special high-priority CLR thread is dedicated to calling <b>Finalize </b>methods. A dedicated thread is used to avoid potential thread synchronization situations that could arise if one of the application's normal-priority threads were used instead. When the freachable queue is empty (the usual case), this thread sleeps. But when entries appear, this thread wakes, removes each entry from the queue, and then calls each object's <b>Finalize </b>method. Because of the way this thread works, you shouldn't execute any code in a <b>Finalize </b>method that makes any assumptions about the thread that's executing the code. For example, avoid accessing thread-local storage in the <b>Finalize </b>method.</p>
<img src="65.jpg"/>
<img src="66.jpg"/>
<p><b>Figure 21-6 </b>The managed heap showing pointers that moved from the finalization list to the freachable queue</p>
<p>In the future, the CLR may use multiple finalizer threads. So you should avoid writing any code that assumes that <b>Finalize </b>methods will be called serially. In other words, you will need to use thread synchronization locks if code in a <b>Finalize </b>method touches shared state. With just one finalizer thread, there could be performance and scalability issues in the scenario in which you have multiple CPUs allocating finalizable objects but only one thread executing <b>Finalize </b>methods葉he one thread might not be able to keep up with the allocations.</p>
<p>The interaction between the finalization list and the freachable queue is fascinating. First I'll tell you how the freachable queue got its name Well, the &quot;f&quot; is obvious and stands for finalization; every entry in the freachable queue is a reference to an object in the managed heap that should have its <b>Finalize </b>method called. But the reachable part of the name means that the objects are reachable To put it another way, the freachable queue is considered a root, just as static fields are roots. So if an object is in the freachable queue, the object is reachable and is not garbage.</p>
<p>In short, when an object isn't reachable, the garbage collector considers the object to be garbage. Then when the garbage collector moves an object's reference from the finalization list to the freachable queue, the object is no longer considered garbage and its memory can't be reclaimed. As freachable objects are marked, objects referred to by their reference type fields are also marked recursively; all these objects must survive the collection. At this point, the garbage collector has finished identifying garbage. Some of the objects identified as garbage have been reclassified as not garbage擁n a sense, the object has become resurrected. The garbage collector compacts the reclaimable memory, and the special CLR thread empties the freachable queue, executing each object's <b>Finalize </b>method.</p>
<p>The next time the garbage collector is invoked, it will see that the finalized objects are truly garbage because the application's roots don't point to it and the freachable queue no longer points to it either. The memory for the object is simply reclaimed. The important point to get from all of this is that two garbage collections are required to reclaim memory used by objects that require finalization. In reality, more than two collections will be necessary because the objects get promoted to another generation (which I'll explain later). Figure 21-7 shows what the managed heap looks like after the second garbage collection.</p>
<p><b>FIGURE 21-7 </b>Status of the managed heap after second garbage collection</p>
<a name="b544"/><h2>The Dispose Pattern: Forcing an Object to Clean Up</h2>
<p>The <b>Finalize </b>method is incredibly useful because it ensures that native resources aren't leaked when managed objects have their memory reclaimed. However, the problem with the <b>Finalize </b>method is there is no guarantee of when it will be called, and because it isn't a public method, a user of the class can't call it explicitly.</p>
<p>The capability to deterministically dispose of or close an object is frequently useful when you're working with managed types that wrap native resources such as files, database connections, and bitmaps For example, you might want to open a database connection, query some records, and close the database connection遥ou wouldn't want the database connection to stay open until the next garbage collection occurs, especially because the next garbage collection could occur hours or even days after you retrieve the database records.</p>
<p>Types that offer the capability to be deterministically disposed of or closed implement what is known as the dispose pattern. The dispose pattern defines conventions a developer should adhere to when defining a type that wants to offer explicit cleanup to a user of the type. In addition, if a type implements the dispose pattern, a developer using the type knows exactly how to explicitly dispose of the object when it's no longer needed.</p>
<img src="67.jpg"/>
<hr/>
<blockquote><b>Note </b>Any type that defines a <b>Finalize </b>method should also implement the dispose pattern as described in this section so that users of the type have a lot of control over the lifetime of the resource. However, a type can implement the dispose pattern and not define a <b>Finalize </b>method. For example, the <b>System.IO.BinaryWriter </b>class falls into this category. I'll explain the reason for this exception in the section &quot;An Interesting Dependency Issue&quot; later in this chapter.</blockquote>
<hr/>
<p>Earlier I showed you the <b>SafeHandle </b>class. This class implements a <b>Finalize </b>method that ensures that a native resource wrapped by the object is closed (or released) when the object is collected. However, a developer using a <b>SafeHandle </b>object has a way to explicitly close the native resource because the <b>SafeHandle </b>class implements the <b>IDisposable </b>interface.</p>
<p>Let's take another look at the <b>SafeHandle </b>class. But for brevity, let's just focus on the parts that have to do with the dispose pattern:</p>
<p><code>// Implementing the IDisposable interface signals users of // this class that it offers the dispose pattern.<br/>
public abstract class SafeHandle : CriticalFinalizerObject, IDisposable {<br/>
// This public method can be called to deterministically close // the resource. This method implements IDisposable's Dispose. public void Dispose() {<br/>
// Call the method that actually does the cleanup.<br/>
Dispose(true);<br/>
}<br/>
// This public method can be called instead of Dispose. public void Close() { Dispose(true);<br/>
}<br/>
// When garbage collected, this Finalize method runs to close the resource ~SafeHandle() {<br/>
// Call the method that actually does the cleanup.<br/>
Dispose(false);<br/>
}<br/>
// This is the common method that does the actual cleanup. // Finalize, Dispose, and Close call this method.<br/>
// Because this class isn't sealed, this method is protected &amp; virtual. // If this class were sealed, this method should be private. protected virtual void Dispose(Boolean disposing) { if (disposing) {<br/>
// The object is being explicitly disposed/closed, not<br/>
// finalized. It is therefore safe for code in this if<br/>
// statement to access fields that reference other<br/>
// objects because the Finalize method of these other objects<br/>
// hasn't yet been called.<br/>
// For the SafeHandle class, there is nothing to do in here.<br/>
// The object is being disposed/closed or finalized, do the following: // If resource was already released, just return // If ownsHandle is false, return<br/>
// Set flag indicating that this resource has been released // Call the virtual ReleaseHandle method<br/>
// Call GC.SuppressFinalize(this) to prevent Finalize from being called<br/>
}<br/>
}</code></p>
<p>Implementing the dispose pattern is hardly trivial. Now let me explain what all this code does. First, the <b>SafeHandle </b>class implements the <b>System.IDisposable </b>interface. This interface is defined in the FCL as follows:</p>
<p><code>public interface IDisposable { void Dispose();<br/>
}</code></p>
<p>Any type that implements this interface is stating that it adheres to the dispose pattern Simply put, this means that the type offers a public, parameterless <b>Dispose </b>method that can be explicitly called to release the resource wrapped by the object. Note that the memory for the object itself is not freed from the managed heap's memory; the garbage collector is still responsible for freeing the object's memory, and there's no telling exactly when this will happen. The parameterless <b>Dispose </b>and <b>Close </b>methods should be both public and nonvirtual.</p>
<hr/>
<blockquote><b>Note </b>You might notice that this <b>SafeHandle </b>class also offers a public <b>Close </b>method. This method simply calls <b>Dispose. </b>Some classes that offer the dispose pattern also offer a <b>Close </b>method for convenience; but the dispose pattern doesn't require this method For example, the <b>System.IO.FileStream </b>class offers the dispose pattern, and this class also offers a <b>Close </b>method. Programmers find it more natural to close a file rather than dispose of a file. However, the <b>System.Threading.Timer </b>class doesn't offer a <b>Close </b>method even though it adheres to the dispose pattern.</blockquote>
<hr/>
<hr/>
<blockquote><b>Important </b>If a class defines a field in which the field's type implements the dispose pattern, the class itself should also implement the dispose pattern. The <b>Dispose </b>method should dispose of the object referred to by the field. This allows someone using the class to call <b>Dispose </b>on it, which in turn releases the resources used by the object itself In fact, this is one of the main reasons why types might implement the dispose pattern but not implement the <b>Finalize </b>method.</blockquote>
<hr/>
<p>For example, the <b>BinaryWriter </b>class implements the dispose pattern. When <b>Dispose </b>is called on a <b>BinaryWriter </b>object, <b>BinaryWriter</b>'s <b>Dispose </b>method calls <b>Dispose </b>on the stream object maintained as a field inside the <b>BinaryWriter </b>object. So when the <b>BinaryWriter </b>object is disposed, the underlying stream is disposed, which, in turn, releases the native stream resource.</p>
<p>So now you know three ways to clean up a <b>SafeHandle </b>object: a programmer can write code to call <b>Dispose, </b>a programmer can write code to call <b>Close, </b>or the garbage collector can call the object's <b>Finalize </b>method. The cleanup code is placed in a separate, protected, virtual method, which is also called <b>Dispose, </b>but this <b>Dispose </b>method takes a <b>Boolean </b>parameter named <b>disposing.</b></p>
<p>This <b>Dispose </b>method is where you put all of the cleanup code. In the <b>SafeHandle </b>example, the method sets a flag indicating that the resource has been released and then calls the virtual <b>ReleaseHandle </b>method to actually perform the releasing of the resource. Note that the dispose pattern states that a single object can have <b>Dispose </b>or <b>Close </b>called on it multiple times; the first time, the resource should be released; for future calls, the method should just return (no exception should be thrown).</p>
<hr/>
<blockquote><b>Note </b>It is possible to have multiple threads call <b>Dispose/Close </b>on a single object simultaneously. However, the dispose pattern states that thread synchronization is not required. The reason is because code should be calling <b>Dispose/Close </b>only if the code knows for a fact that no other thread is using the object. If you don't know if an object is still in use at a certain point in your code, you should not be calling <b>Dispose/Close. </b>Instead, wait for a garbage collection to kick in so that it can determine if the object is no longer being used, and then release the resource.</blockquote>
<hr/>
<p>When an object's <b>Finalize </b>method is called by the CLR, the <b>Dispose </b>method's <b>disposing </b>parameter is set to <b>false. </b>This tells the <b>Dispose </b>method that it shouldn't execute any code that references other managed objects whose classes implement a <b>Finalize </b>method. Imagine that the CLR is shutting down, and inside a <b>Finalize </b>method, you attempt to write to a <b>FileStream </b>. This might not work because the <b>FileStream </b>might have already had its <b>Finalize </b>method called, closing the underlying disk file.</p>
<p>On the other hand, when you call <b>Dispose </b>or <b>Close </b>in your code, the <b>Dispose </b>method's <b>disposing </b>parameter must be set to <b>true </b>This indicates that the object is being explicitly disposed of, not finalized. In this case, the <b>Dispose </b>method is allowed to execute code that references another object (such as a <b>FileStream); </b>because you have control over the program's logic, you know that the <b>FileStream </b>object is still open.</p>
<p>By the way, if the <b>SafeHandle </b>class were sealed, the <b>Dispose </b>method that takes a <b>Boolean </b>should be implemented as a private method instead of a protected virtual method. But since the <b>SafeHandle </b>class is not sealed, any class that derives from <b>SafeHandle </b>can override the <b>Dispose </b>method that takes a <b>Boolean </b>in order to override the cleanup code. The derived class wouldn't implement the parameterless <b>Dispose </b>or <b>Close </b>methods, and it wouldn't override the <b>Finalize </b>method. The derived class would simply inherit the implementation of all of these methods. Note that the derived class's override of the <b>Dispose </b>method that takes a <b>Boolean </b>should call the base class's version of the <b>Dispose </b>method that takes a <b>Boolean, </b>allowing the base class to perform whatever cleanup it needs to do This is exactly the case of the <b>FileStream </b>type that I used as an example: it derives from <b>Stream </b>that implements the <b>Close </b>and the parameterless <b>IDisposable.Dispose </b>method. <b>FileStream </b>simply overrides the <b>Dispose </b>method, which takes a <b>Boolean </b>parameter to dispose of the <b>SafeHandle </b>field wrapping the unmanaged file resource.</p>
<hr/>
<blockquote><b>Important </b>You need to be aware of some versioning issues here. If in version 1, a base type doesn't implement the <b>IDisposable </b>interface, it can never implement this interface in a later version. If the base type were to add the <b>IDisposable </b>interface in the future, all of the derived types wouldn't know to call the base type's methods, and the base type wouldn't get a chance to clean itself up properly. On the other hand, if in version 1 a base type implements the <b>IDisposable </b>interface, it can never remove this interface in a later version because the derived type would try to call methods that no longer exist in the base type.</blockquote>
<hr/>
<p>Another noteworthy part of this code is the call to <b>GC</b>'s static <b>SuppressFinalize </b>method inside the <b>Dispose </b>method that takes a <b>Boolean </b>. You see, if code using a <b>SafeHandle </b>object explicitly calls <b>Dispose </b>or <b>Close, </b>there is no need for the object's <b>Finalize </b>method to execute, because if <b>Finalize </b>did execute, there would be an unnecessary attempt to release the resource a second time. The call to <b>GC</b>'s <b>SuppressFinalize </b>turns on a bit flag associated with the object referred to by its single <b>this </b>parameter. When this flag is on, the CLR knows not to move this object's pointer from the finalization list to the freachable queue, preventing the object's <b>Finalize </b>method from being called and ensuring that the object doesn't live until the next garbage collection Note that the <b>SafeHandle </b>class calls <b>SuppressFinalize </b>even when the object is being finalized. This has no ill effect because the object is already in the process of being finalized.</p>
<a name="b548"/><h2>Using a Type That Implements the Dispose Pattern</h2>
<p>Now that you know how a type implements the dispose pattern, let's take a look at how a developer uses a type that offers the dispose pattern. Instead of talking about the <b>SafeHandle </b>class, let's talk about the more common <b>System.IO.FileStream </b>class. The <b>FileStream </b>class offers the ability to open a file, read bytes from the file, write bytes to the file, and close the file. When a <b>FileStream </b>object is constructed, the Win32 <b>CreateFile </b>function is called, the returned handle is saved in a <b>SafeFileHandle </b>object, and a reference to this object is maintained via a private field in the <b>FileStream </b>object. The <b>FileStream </b>class also offers several additional properties (such as <b>Length, Position, CanRead) </b>and methods (such as <b>Read, Write, Flush) </b>.</p>
<p>Let's say that you want to write some code that creates a temporary file, writes some bytes to the file, and then deletes the file. You might start writing the code like this:</p>
<p><code>using System; using System.IO;<br/>
public static class Program { public static void Main() {<br/>
// Create the bytes to write to the temporary file. Byte[] bytesToWrite = new Byte[] { 1, 2, 3, 4, 5 };<br/>
// Create the temporary file.<br/>
FileStream fs = new FileStreamC'Temp.dat&quot;, FileMode.Create);<br/>
// Write the bytes to the temporary file. fs.Write(bytesToWrite, 0, bytesToWrite.Length);<br/>
// Delete the temporary file.<br/>
File.Delete(&quot;Temp.dat&quot;);   // Throws an IOException<br/>
}<br/>
}</code></p>
<p>Unfortunately, if you build and run this code, it might work, but most likely it won't. The problem is that the call to <b>File</b>'s static <b>Delete </b>method requests that Windows delete a file while it is still open. And so <b>Delete </b>throws a <b>System.IO.IOException </b>exception with the following string message: <b>&quot;The process cannot access the file &quot;Temp.dat&quot; because it is being used by another process.&quot;</b></p>
<p>Be aware that in some cases, the file might actually be deleted! If another thread somehow caused a garbage collection to start after the call to <b>Write </b>and before the call to <b>Delete, </b>the <b>FileStream</b>'s <b>SafeFileHandle </b>field would have its <b>Finalize </b>method called, which would close the file and allow <b>Delete </b>to work. The likelihood of this situation is extremely rare, however, and therefore the previous code will fail more than 99 percent of the time.</p>
<p>Fortunately, the <b>FileStream </b>class implements the dispose pattern, allowing you to modify the source code to explicitly close the file. Here's the corrected source code:</p>
<p><code>using System; using System.IO;<br/>
public static class Program { public static void Main() {<br/>
// Create the bytes to write to the temporary file. Byte[] bytesToWrite = new Byte[] { 1, 2, 3, 4, 5 };<br/>
// Create the temporary file.<br/>
FileStream fs = new FileStream(&quot;Temp.dat&quot;, FileMode.Create);<br/>
// Write the bytes to the temporary file. fs.Write(bytesToWrite, 0, bytesToWrite.Length);<br/>
// Explicitly close the file when finished writing to it. fs.Dispose();<br/>
// Delete the temporary file.<br/>
File.Delete(&quot;Temp.dat&quot;);   // This always works now.<br/>
}<br/>
}</code></p>
<p>The only difference here is that I've added a call to <b>FileStream</b>'s <b>Dispose </b>method. The <b>Dispose </b>method calls the <b>Dispose </b>method that takes a <b>Boolean </b>as parameter, which calls <b>Dispose </b>on the <b>SafeFileHandle </b>object, which ends up calling the Win32 <b>CloseHandle </b>function, which causes Windows to close the file. Now, when <b>File</b>'s <b>Delete </b>method is called, Windows sees that the file isn't open and successfully deletes it.</p>
<p>Because the <b>FileStream </b>class also offers a public <b>Close </b>method, the earlier code could be written as follows with identical results:</p>
<p><code>using System; using System.IO;<br/>
public static class Program { public static void Main() {<br/>
// Create the bytes to write to the temporary file. Byte[] bytesToWrite = new Byte[] { 1, 2, 3, 4, 5 };<br/>
// Create the temporary file.<br/>
FileStream fs = new FileStreamC'Temp.dat&quot;, FileMode.Create);<br/>
// Write the bytes to the temporary file. fs.Write(bytesToWrite, 0, bytesToWrite.Length);<br/>
// Explicitly close the file when finished writing to it. fs.CloseO;<br/>
// Delete the temporary file.<br/>
File.Delete(&quot;Temp.dat&quot;);   // This always works now.<br/>
}<br/>
}</code></p>
<hr/>
<blockquote><b>Note </b>Again, remember that the <b>Close </b>method isn't officially part of the dispose pattern; some types will offer it and some won't.</blockquote>
<hr/>
<p>Keep in mind that calling <b>Dispose </b>or <b>Close </b>simply gives the programmer a way to force the object to do its cleanup at a deterministic time; these methods have no control over the lifetime of the memory used by the object in the managed heap This means you can still call methods on the object even though it has been cleaned up The following code calls the <b>Write </b>method after the file is closed, attempting to write more bytes to the file. Obviously, the bytes can't be written, and when the code executes, the second call to the <b>Write </b>method throws a <b>System.ObjectDisposedException </b>exception with the following string message: <b>&quot;Cannot access a closed file.&quot;</b></p>
<p><code>using System;<br/>
using System.IO;<br/>
public static class Program { public static void Main() {<br/>
// Create the bytes to write to the temporary file. Byte[] bytesToWrite = new Byte[] { 1, 2, 3, 4, 5 };<br/>
// Create the temporary file.<br/>
FileStream fs = new FileStream(&quot;Temp.dat&quot;, FileMode.Create); // Write the bytes to the temporary file.<br/>
fs.Write(bytesToWrite, 0, bytesToWrite.Length);<br/>
// Explicitly close the file when finished writing to it.<br/>
fs.Close();<br/>
// Try to write to the file after closing it.<br/>
// The following line throws an ObjectDisposedException.<br/>
fs.Write(bytesToWrite, 0, bytesToWrite.Length);<br/>
// Delete the temporary file. File.Delete(&quot;Temp.dat&quot;);<br/>
}<br/>
}</code></p>
<p>No memory corruption has occurred here because the memory for the <b>FileStream </b>object still exists; it's just that the object can't successfully execute its methods after it is explicitly disposed.</p>
<hr/>
<blockquote><b>Important </b>When defining your own type that implements the dispose pattern, be sure to write code in all of your methods and properties to throw a <b>System.ObjectDisposedException </b>if the object has been explicitly cleaned up. The <b>Dispose </b>and <b>Close </b>methods should never throw an <b>ObjectDisposedException </b>if called multiple times, though; these methods should just return.</blockquote>
<hr/>
<hr/>
<blockquote><b>Important </b>In general, I strongly discourage calling a <b>Dispose </b>or <b>Close </b>method. The reason is that the CLR's garbage collector is well written, and you should let it do its job. The garbage collector knows when an object is no longer accessible from application code, and only then will it collect the object When application code calls <b>Dispose </b>or <b>Close, </b>it is effectively saying that it knows when the application no longer has a need for the object For many applications, it is impossible to know for sure when an object is no longer required.</blockquote>
<hr/>
<p>For example, if you have code that constructs a new object, and you then pass a reference to this object to another method, the other method could save a reference to the object in some internal field variable (a root). There is no way for the calling method to know that this has happened. Sure, the calling method can call <b>Dispose </b>or <b>Close, </b>but later, some other code might try to access the object, causing an <b>ObjectDisposedException </b>to be thrown.</p>
<p>I recommend that you call <b>Dispose </b>or <b>Close </b>either at a place in your code where you know you must clean up the resource (as in the case of attempting to delete an open file) or at a place where you know it is safe to call one of the methods and you want to improve performance by removing the object from the finalization list, thus preventing object promotion.</p>
<a name="b551"/><h2>C#'s using Statement</h2>
<p>The previous code examples show how to explicitly call a type's <b>Dispose </b>or <b>Close </b>method. If you decide to call either of these methods explicitly, I highly recommend that you place the call in an exception-handling <b>finally </b>block. This way, the cleanup code is guaranteed to execute So it would be better to write the previous code example as follows:</p>
<p><code>using System; using System.IO;<br/>
public static class Program { public static void Main() {<br/>
// Create the bytes to write to the temporary file. Byte[] bytesToWrite = new Byte[] { 1, 2, 3, 4, 5 };<br/>
// Create the temporary file.<br/>
FileStream fs = new FileStream(&quot;Temp.dat&quot;, FileMode.Create);<br/>
try {<br/>
// Write the bytes to the temporary file. fs.Write(bytesToWrite, 0, bytesToWrite.Length);<br/>
}<br/>
finally {<br/>
// Explicitly close the file when finished writing to it.<br/>
if (fs != null) fs.Dispose();<br/>
}<br/>
// Delete the temporary file. File.Delete(&quot;Temp.dat&quot;);<br/>
}<br/>
}</code></p>
<p>Adding the exception-handling code is the right thing to do, and you must have the diligence to do it. Fortunately, the C# language provides a <b>using </b>statement, which offers a simplified syntax that produces code identical to the code just shown. Here's how the preceding code would be rewritten using C#'s <b>using </b>statement:</p>
<p><code>using System; using System.IO;<br/>
public static class Program { public static void Main() {<br/>
// Create the bytes to write to the temporary file. Byte[] bytesToWrite = new Byte[] { 1, 2, 3, 4, 5 };<br/>
// Create the temporary file.<br/>
using (FileStream fs = new FileStream(&quot;Temp.dat&quot;, FileMode.Create)) { // Write the bytes to the temporary file. fs.Write(bytesToWrite, 0, bytesToWrite.Length);<br/>
}<br/>
// Delete the temporary file. File.Delete(&quot;Temp.dat&quot;);<br/>
}<br/>
}</code></p>
<p>In the <b>using </b>statement, you initialize an object and save its reference in a variable. Then you access the variable via code contained inside <b>using</b>'s braces. When you compile this code, the compiler automatically emits the <b>try </b>and <b>finally </b>blocks. Inside the <b>finally </b>block, the compiler emits code to cast the object to an <b>IDisposable </b>and calls the <b>Dispose </b>method. Obviously, the compiler allows the <b>using </b>statement to be used only with types that implement the <b>IDisposable </b>interface.</p>
<hr/>
<blockquote><b>Note </b>C#'s <b>using </b>statement supports the capability to initialize multiple variables as long as the variables are all of the same type. It also supports the capability to use just an already initialized variable. For more information about this topic, refer to the &quot;using Statements&quot; topic in the C# Programmer's Reference.</blockquote>
<hr/>
<p>The <b>using </b>statement also works with value types that implement the <b>IDisposable </b>interface. This allows you to create an extremely efficient and useful mechanism to encapsulate the code necessary to begin and end an operation. For example, let's say that you want to lock a block of code by using a <b>Mutex </b>object. The <b>Mutex </b>class does implement the <b>IDisposable </b>interface, but calling <b>Dispose </b>on it releases the native resource; it has nothing to do with the lock itself To get simplified syntax to lock and unlock a <b>Mutex, </b>you can define a value type that encapsulates the locking and unlocking of a <b>Mutex </b>object. The <b>MutexLock </b>structure below is an example of this, and the <b>Main </b>method following it demonstrates how to use the <b>MutexLock </b>effectively:</p>
<p><code>using System;<br/>
using System.Threading;<br/>
// This value type encapsulates mutex locking and unlocking internal struct MutexLock : IDisposable { private readonly Mutex m_mutex;<br/>
// This constructor acquires a lock on the mutex public MutexLock(Mutex m) {<br/>
m_mutex = m;<br/>
m_mutex.WaitOne();<br/>
}<br/>
// This Dispose method releases the lock on the mutex public void Dispose() { m_mutex.ReleaseMutex();<br/>
}<br/>
}<br/>
public static class Program {<br/>
// This method demonstrates how to use the MutexLock effectively public static void Main() {<br/>
// Construct a mutex object<br/>
Mutex m = new Mutex();<br/>
// Lock the mutex, do something, and unlock the mutex using (new MutexLock(m)) {<br/>
// Perform some thread-safe operation in here...<br/>
}<br/>
}<br/>
}</code></p>
<a name="b554"/><h2>An Interesting Dependency Issue</h2>
<p>The <b>System.IO.FileStream </b>type allows the user to open a file for reading and writing. To improve performance, the type's implementation makes use of a memory buffer. Only when the buffer fills does the type flush the contents of the buffer to the file. A <b>FileStream </b>supports the writing of bytes only If you want to write characters and strings, you can use a <b>System.IO.StreamWriter, </b>as is demonstrated in the following code:</p>
<p><code>FileStream fs = new FileStreamCDataFile.dat&quot;, FileMode.Create); StreamWriter sw = new StreamWriter(fs); sw.Write(&quot;Hi there&quot;);<br/>
// The following call to Close is what you should do. sw.Close();<br/>
// NOTE: StreamWriter.Close closes the FileStream;<br/>
// the FileStream doesn't have to be explicitly closed.</code></p>
<p>Notice that the <b>StreamWriter</b>'s constructor takes a reference to a <b>Stream </b>object as a parameter, allowing a reference to a <b>FileStream </b>object to be passed as an argument. Internally, the <b>StreamWriter </b>object saves the <b>Stream</b>'s reference. When you write to a <b>StreamWriter </b>object, it internally buffers the data in its own memory buffer. When the buffer is full, the <b>StreamWriter </b>object writes the data to the <b>Stream </b>.</p>
<p>When you're finished writing data via the <b>StreamWriter </b>object, you should call <b>Dispose </b>or <b>Close. </b>(Because the <b>StreamWriter </b>type implements the dispose pattern, you can also use it with C#'s <b>using </b>statement.) Both of these methods do exactly the same thing: cause the <b>StreamWriter </b>object to flush its data to the <b>Stream </b>object and close the <b>Stream </b>object. In my example, when the <b>FileStream </b>object is closed, it flushes its buffer to disk just prior to calling the Win32 <b>CloseHandle </b>function.</p>
<hr/>
<blockquote><b>Note </b>You don't have to explicitly call <b>Dispose </b>or <b>Close </b>on the <b>FileStream </b>object because the <b>StreamWriter </b>calls it for you. However, if you do call <b>Dispose/Close </b>explicitly, the <b>FileStream </b>will see that the object has already been cleaned up葉he methods do nothing and just return.</blockquote>
<hr/>
<p>What do you think would happen if there were no code to explicitly call <b>Dispose </b>or <b>Close? </b>Well, at some point, the garbage collector would correctly detect that the objects were garbage and finalize them. But the garbage collector doesn't guarantee the order in which the <b>Finalize </b>methods are called. So if the <b>FileStream </b>object were finalized first, it would close the file. Then when the <b>StreamWriter </b>object was finalized, it would attempt to write data to the closed file, throwing an exception. If, on the other hand, the <b>StreamWriter </b>object were finalized first, the data would be safely written to the file.</p>
<p>How was Microsoft to solve this problem? Making the garbage collector finalize objects in a specific order would have been impossible because objects could contain references to each other, and there would be no way for the garbage collector to correctly guess the order in which to finalize these objects. Here is Microsoft's solution: the <b>StreamWriter </b>type does not implement a <b>Finalize </b>method, missing the opportunity to flush the data in its buffer to the underlying <b>FileStream </b>object. This means that if you forget to explicitly close the <b>StreamWriter </b>object, data is guaranteed to be lost. Microsoft expects developers to see this consistent loss of data and fix the code by inserting an explicit call to <b>Close/Dispose.</b></p>
<hr/>
<blockquote><b>Note </b>The .NET Framework offers a feature called Managed Debugging Assistants (MDAs). When an MDA is enabled, the .NET Framework looks for certain common programmer errors and fires a corresponding MDA. In the debugger, it looks like an exception has been thrown. There is an MDA available to detect when a <b>StreamWriter </b>object is garbage collected without having prior been explicitly closed. To enable this MDA in Microsoft Visual Studio, open your project and select the Debug.Exceptions menu item. In the Exceptions dialog box, expand the Managed Debugging Assistants node and scroll to the bottom There you will see the StreamWriterBufferredDataLost MDA. Select the Thrown check box to have the Visual Studio debugger stop whenever a <b>StreamWriter </b>object's data is lost.</blockquote>
<hr/>
<a name="b555"/><h2>Monitoring and Controlling the Lifetime of Objects Manually</h2>
<p>The CLR provides each AppDomain with a GC handle table. This table allows an application to monitor the lifetime of an object or manually control the lifetime of an object When an AppDomain is created, the table is empty. Each entry on the table consists of a pointer to an object on the managed heap and a flag indicating how you want to monitor or control the object. An application adds and removes entries from the table via the <b>System.Runtime. InteropServices.GCHandle </b>type shown below. Since the GC handle table is used mostly in scenarios when you are interoperating with unmanaged code, most of GCHandle's members have the <b>[SecurityCritical] </b>attribute applied to them.</p>
<p><code>// This type is defined in the System.Runtime.InteropServices namespace public struct GCHandle {<br/>
// Static methods that create an entry in the table<br/>
public static GCHandle Alloc(object value);<br/>
public static GCHandle Alloc(object value, GCHandleType type);<br/>
// Static methods that convert a GCHandle to an IntPtr public static explicit operator IntPtr(GCHandle value); public static IntPtr ToIntPtr(GCHandle value);<br/>
// Static methods that convert an IntPtr to a GCHandle public static explicit operator GCHandle(IntPtr value); public static GCHandle FromIntPtr(IntPtr value);<br/>
// Static methods that compare two GCHandles<br/>
public static Boolean operator ==(GCHandle a, GCHandle b);<br/>
public static Boolean operator !=(GCHandle a, GCHandle b);<br/>
// Instance method to free the entry in the table (index is set to 0) public void Free();<br/>
// Instance property to get/set the entry's object reference public object Target { get; set; }<br/>
// Instance property that returns true if index is not 0 public Boolean IsAllocated { get; }<br/>
// For a pinned entry, this returns the address of the object public IntPtr AddrOfPinnedObject();<br/>
public override Int32 GetHashCode(); public override Boolean Equals(object o);<br/>
}</code></p>
<p>Basically, to control or monitor an object's lifetime, you call <b>GCHandle</b>'s static <b>Alloc </b>method, passing a reference to the object that you want to monitor/control, and a <b>GCHandleType, </b>which is a flag indicating how you want to monitor/control the object. The <b>GCHandleType </b>type is an enumerated type defined as follows:</p>
<p><code>public enum GCHandleType {<br/>
Weak = 0,// Used for monitoring an object's existence<br/>
WeakTrackResurrection =.1, // Used for monitoring an object's existence<br/>
Normal = 2,// Used for controlling an object's lifetime<br/>
Pinned = 3// Used for controlling an object's lifetime<br/>
}</code></p>
<p>Now, here's what each flag means:</p>
<p><b>&#9632; Weak  </b>This flag allows you to monitor the lifetime of an object. Specifically, you can detect when the garbage collector has determined this object to be unreachable from application code. Note that the object's <b>Finalize </b>method may or may not have executed yet and therefore, the object may still be in memory.</p>
<p><b>&#9632; WeakTrackResurrection   </b>This flag allows you to monitor the lifetime of an object. Specifically, you can detect when the garbage collector has determined that this object is unreachable from application code. Note that the object's <b>Finalize </b>method (if it exists) has definitely executed, and the object's memory has been reclaimed.</p>
<p><b>&#9632; Normal   </b>This flag allows you to control the lifetime of an object. Specifically, you are telling the garbage collector that this object must remain in memory even though there may be no variables (roots) in the application that refer to this object When</p>
<p>a garbage collection runs, the memory for this object can be compacted (moved). The <b>Alloc </b>method that doesn't take a <b>GCHandleType </b>flag assumes that <b>GCHandleType.Normal </b>is specified.</p>
<p><b>&#9632; Pinned   </b>This flag allows you to control the lifetime of an object. Specifically, you are telling the garbage collector that this object must remain in memory even though there might be no variables (roots) in the application that refer to this object When a</p>
<p>garbage collection runs, the memory for this object cannot be compacted (moved). This is typically useful when you want to hand the address of the memory out to unmanaged code. The unmanaged code can write to this memory in the managed heap knowing that the location of the managed object will not be moved due to a garbage collection.</p>
<p>When you call <b>GCHandle</b>'s static <b>Alloc </b>method, it scans the AppDomain's GC handle table, looking for an available entry where the address of the object you passed to <b>Alloc </b>is stored, and a flag is set to whatever you passed for the <b>GCHandleType </b>argument. Then, <b>Alloc </b>returns a <b>GCHandle </b>instance back to you. A <b>GCHandle </b>is a lightweight value type that contains a single instance field, an <b>IntPtr, </b>which refers to the index of the entry in the table. When you want to free this entry in the GC handle table, you take the <b>GCHandle </b>instance and call the <b>Free </b>method (which also invalidates the instance by setting the <b>IntPtr </b>field to zero).</p>
<p>Here's how the garbage collector uses the GC handle table. When a garbage collection occurs:</p>
<p><b>1. </b>The garbage collector marks all of the reachable objects (as described at the beginning of this chapter). Then, the garbage collector scans the GC handle table; all <b>Normal </b>or <b>Pinned </b>objects are considered roots, and these objects are marked as well (including any objects that these objects refer to via their fields).</p>
<p><b>2. </b>The garbage collector scans the GC handle table looking for all of the <b>Weak </b>entries. If a <b>Weak </b>entry refers to an object that isn't marked, the pointer identifies an unreachable object (garbage), and the entry has its pointer value changed to <b>null.</b></p>
<p><b>3. </b>The garbage collector scans the finalization list. If a pointer in the list refers to an unmarked object, the pointer identifies an unreachable object, and the pointer is moved from the finalization list to the freachable queue. At this point, the object is marked because the object is now considered reachable.</p>
<p><b>4. </b>The garbage collector scans the GC handle table looking for all of the <b>WeakTrackResurrection </b>entries. If a <b>WeakTrackResurrection </b>entry refers to an object that isn't marked (which now is an object pointed to by an entry in the freach-able queue), the pointer identifies an unreachable object (garbage), and the entry has its pointer value changed to <b>null.</b></p>
<p><b>5. </b>The garbage collector compacts the memory, squeezing out the holes left by the unreachable objects. Note that the garbage collector sometimes decides not to compact memory if it determines that the amount of fragmentation isn't worth the time to compact. <b>Pinned </b>objects are not compacted (moved); the garbage collector will move other objects around them.</p>
<p>Now that you have an understanding of the mechanism, let's take a look at when you'd use them. The easiest flags to understand are the <b>Normal </b>and <b>Pinned </b>flags, so let's start with these two. Both of these flags are typically used when interoperating with unmanaged code.</p>
<p>The <b>Normal </b>flag is used when you need to hand a reference to a managed object to unmanaged code because, at some point in the future, the unmanaged code is going to call back into managed code, passing it the reference. You can't actually pass a pointer to a managed object out to unmanaged code because if a garbage collection occurs, the object could move in memory, invalidating the pointer. So to work around this, you would call <b>GCHandle</b>'s <b>Alloc </b>method, passing in a reference to the object and the <b>Normal </b>flag. Then you'd cast the returned <b>GCHandle </b>instance to an <b>IntPtr </b>and pass the <b>IntPtr </b>into the unmanaged code. When the unmanaged code calls back into managed code, the managed code would cast the passed <b>IntPtr </b>back to a <b>GCHandle </b>and then query the <b>Target </b>property to get the reference (or current address) of the managed object When the unmanaged code no longer needs the reference, you'd call <b>GCHandle</b>'s <b>Free </b>method, which will allow a future garbage collection to free the object (assuming no other root exists to this object).</p>
<p>Notice that in this scenario, the unmanaged code is not actually using the managed object itself; the unmanaged code wants a way just to reference the object. In some scenarios, the unmanaged code needs to actually use the managed object. In these scenarios, the managed object must be pinned. Pinning prevents the garbage collector from moving/compacting the object. A common example is when you want to pass a managed <b>String </b>object to a Win32 function. In this case, the <b>String </b>object must be pinned because you can't pass the reference of a managed object to unmanaged code and then have the garbage collector move the object in memory. If the <b>String </b>object were moved, the unmanaged code would either be reading or writing to memory that no longer contained the <b>String </b>object's characters this will surely cause the application to run unpredictably.</p>
<p>When you use the CLR's P/Invoke mechanism to call a method, the CLR pins the arguments for you automatically and unpins them when the unmanaged method returns. So, in most cases, you never have to use the <b>GCHandle </b>type to explicitly pin any managed objects yourself You do have to use the <b>GCHandle </b>type explicitly when you need to pass the address of a managed object to unmanaged code and then, the unmanaged function returns, but un-managed code might still need to use the object later The most common example of this is when performing asynchronous I/O operations.</p>
<p>Let's say that you allocate a byte array that should be filled as data comes in from a socket. Then, you would call <b>GCHandle</b>'s <b>Alloc </b>method, passing in a reference to the array object and the <b>Pinned </b>flag. Then, using the returned <b>GCHandle </b>instance, you call the <b>AddrOfPinnedObject </b>method. This returns an <b>IntPtr </b>that is the actual address of the pinned object in the managed heap; you'd then pass this address into the unmanaged function, which will return back to managed code immediately While the data is coming from the socket, this byte array buffer should not move in memory; preventing this buffer from moving is accomplished by using the <b>Pinned </b>flag. When the asynchronous I/O operation has completed, you'd call <b>GCHandle</b>'s <b>Free </b>method, which will allow a future garbage collection to move the buffer Your managed code should still have a reference to the buffer so that you can access the data, and this reference will prevent a garbage collection from freeing the buffer from memory completely.</p>
<p>It is also worth mentioning that C# offers a <b>fixed </b>statement that effectively pins an object over a block of code. Here is some code that demonstrates its use:</p>
<p><code>unsafe public static void Go() {<br/>
// Allocate a bunch of objects that immediately become garbage for (Int32 x = 0; x &lt; 10000; x++) new Object();<br/>
IntPtr originalMemoryAddress;<br/>
Byte[] bytes = new Byte[1000];     // Allocate this array after the garbage objects // Get the address in memory of the Byte[]<br/>
fixed (Byte* pbytes = bytes) { originalMemoryAddress = (IntPtr) pbytes; }<br/>
// Force a collection; the garbage objects will go away &amp; the Byte[] might be compacted GC.CollectO;<br/>
// Get the address in memory of the Byte[] now &amp; compare it to the first address fixed (Byte* pbytes = bytes) {<br/>
Console.WriteLineC'The Byte[] did{0} move during the GC&quot;,<br/>
(originalMemoryAddress == (IntPtr) pbytes) ? &quot; not&quot; : null);<br/>
}<br/>
}</code></p>
<p>Using C#'s <b>fixed </b>statement is more efficient that allocating a pinned GC handle. What happens is that the C# compiler emits a special &quot;pinned&quot; flag on the <b>pbytes </b>local variable. During a garbage collection, the garbage collector examines the contents of this root, and if the root is not <b>null, </b>it knows not to move the object referred to by the variable during the compaction phase The C# compiler emits IL to initialize the <b>pbytes </b>local variable to the address of the object at the start of a <b>fixed </b>block, and the compiler emits an IL instruction to set the <b>pbytes </b>local variable back to <b>null </b>at the end of the <b>fixed </b>block so that the variable doesn't refer to any object, allowing the object to move when the next garbage collection occurs.</p>
<p>Now, let's talk about the next two flags, <b>Weak </b>and <b>WeakTrackResurrection </b>. These two flags can be used in scenarios when interoperating with unmanaged code, but they can also be used in scenarios that use only managed code. The <b>Weak </b>flag lets you know when an object has been determined to be garbage but the object's memory is not guaranteed to be reclaimed yet. The <b>WeakTrackResurrection </b>flag lets you know when an object's memory has been reclaimed. Of the two flags, the <b>Weak </b>flag is much more commonly used than the <b>WeakTrackResurrection </b>flag. In fact, I've never seen anyone use the <b>WeakTrackResurrection </b>flag in a real application.</p>
<p>Let's say that <b>Object-A </b>periodically calls a method on <b>Object-B. </b>However, the fact that <b>Object-A </b>has a reference to <b>Object-B </b>forbids <b>Object-B </b>from being garbage collected, and in some rare scenarios, this may not be desired; instead, we might want <b>Object-A </b>to call <b>Object-B</b>'s method if <b>Object-B </b>is still alive in the managed heap. To accomplish this scenario, <b>Object-A </b>would call <b>GCHandle</b>'s <b>Alloc </b>method, passing in the reference to <b>Object-B </b>and the <b>Weak </b>flag. <b>Object-A </b>would now just save the returned <b>GCHandle </b>instance instead of the reference to <b>Object-B.</b></p>
<p>At this point, <b>Object-B </b>can be garbage collected if no other roots are keeping it alive. When <b>Object-A </b>wants to call <b>Object-B</b>'s method, it would query <b>GCHandle</b>'s read-only <b>Target </b>property. If this property returns a non<b>-null </b>value, then <b>Object-B </b>is still alive. <b>Object-A</b>'s code would then cast the returned reference to <b>Object-B</b>'s type and call the method If the <b>Target </b>property returns <b>null, </b>then <b>Object-B </b>has been collected and <b>Object-A </b>would not attempt to call the method. At this point, <b>Object-A</b>'s code would probably also call <b>GCHandle</b>'s <b>Free </b>method to relinquish the <b>GCHandle </b>instance.</p>
<p>Since working with the <b>GCHandle </b>type can be a bit cumbersome and because it requires elevated security to keep or pin an object in memory, the <b>System </b>namespace includes a <b>WeakReference </b>class to help you This class is really just an object-oriented wrapper around a <b>GCHandle </b>instance: logically, its constructor calls <b>GCHandle</b>'s <b>Alloc, </b>its <b>Target </b>property calls <b>GCHandle</b>'s <b>Target </b>property, and its <b>Finalize </b>method calls <b>GCHandle</b>'s <b>Free </b>method. In addition, no special permissions are required for code to use the <b>WeakReference </b>class because the class supports only weak references; it doesn't support the behavior provided by <b>GCHandle </b>instances allocated with a <b>GCHandleType </b>of <b>Normal </b>or <b>Pinned </b>.</p>
<p>The downside of the <b>WeakReference </b>class is that its object must be allocated on the heap So the <b>WeakReference </b>class is a heavier-weight object than a <b>GCHandle </b>instance. Also, the <b>WeakReference </b>class doesn't implement the dispose pattern (which is a bug), so there is no way for you to free the <b>GCHandle </b>table entry explicitly; you have to wait for a garbage collection to kick in so that its <b>Finalize </b>method is called. The <b>WeakReference </b>class was introduced in version 1. 0 of the .NET Framework; therefore, it is not generic (generics were introduced in version 2. 0). So, I have created a little, lightweight structure that I sometimes use to put a compile-time type-safe wrapper around the <b>WeakReference </b>class:</p>
<p><code>internal struct WeakReference&lt;T&gt; : IDisposable where T : class { private WeakReference m_weakReference;<br/>
public WeakReference(T target) { m_weakReference = new WeakReference(target); } public T Target { get { return (T)m_weakReference.Target; } } public void Dispose() { m_weakReference = null; }<br/>
}</code></p>
<p>Occasionally, developers ask me if there is a way to create a weak delegate where one object will register a callback delegate with some other object's event but the developer doesn't want the registering of the event to forcibly keep the object alive For example, let's say that we have a class called <b>DoNotLiveJustForTheEvent </b>. We want to create an instance of this class and have it register a callback method with a <b>Button </b>object's <b>Click </b>event. However, we don't want the <b>Button </b>object's event to keep the <b>DoNotLiveJustForTheEvent </b>object alive. If the <b>DoNotLiveJustForTheEvent </b>object has no other reason to live, then we want it to get garbage collected, and it will just not receive a notification the next time the <b>Button </b>object raises its <b>Click </b>event. Let me show you how you might accomplish this:</p>
<p>First, here is the definition of the <b>DoNotLiveJustForTheEvent </b>class:</p>
<p><code>internal sealed class DoNotLiveJustForTheEvent { public void Clicked(Object sender, EventArgs e) {<br/>
MessageBox.ShowC'Test got notified of button click.&quot;);<br/>
}<br/>
}</code></p>
<p>Now, here is the code that creates a <b>Form </b>and two <b>Button </b>controls. The first <b>Button </b>control fills the left half of the <b>Form</b>'s client area and the second <b>Button </b>control fills the right half of the <b>Form</b>'s client area. Then, on the first <b>Button </b>control, I construct an instance of the <b>DoNotLiveJustForTheEvent </b>class and register this object's <b>Clicked </b>method as the event handler for this <b>Button </b>control's <b>Click </b>event. However, I do this by using my <b>WeakEventHandler </b>class, which turns an <b>EventHandler </b>delegate into a weak version of itself I'll show how this class is implemented shortly. On the second <b>Button </b>control's <b>Click </b>event, I register a callback that will force a garbage collection to occur; I click this button to test that everything is working OK. Finally, I add the controls to the form's control collection, resize the form's client area, and then show the form:</p>
<p><code>public static void Go() { var form = new Form() {<br/>
Text = &quot;Weak Delegate Test&quot;, FormBorderStyle = FormBorderStyle.FixedSingle<br/>
};<br/>
var btnTest = new Button() { Text = &quot;Click me&quot;, Width = form.Width / 2<br/>
};<br/>
var btnGC = new Button() { Text = &quot;Force GC&quot;, Left = btnTest.Width, Width = btnTest.Width<br/>
};<br/>
// WeakEventHandler turns an EventHandler delegate into a weak version of itself btnTest.Click += new WeakEventHandler(new DoNotLiveJustForTheEvent().Clicked) { RemoveDelegateCode = eh =&gt; btnTest.Click -= eh };<br/>
btnGC.Click += (sender, e) =&gt; { GC.CollectO; MessageBox.ShowC'GC complete.&quot;); };<br/>
form.Controls.Add(btnTest); form.Controls.Add(btnGC);<br/>
form.ClientSize = new Size(btnTest.Width * 2, btnTest.Height); form.ShowDialogO;<br/>
}</code></p>
<p>Since I do not store the reference to the <b>DoNotLiveJustForEvent </b>object in a root variable, the object will be considered garbage when the next garbage collection runs. But, until then, I can click the left button multiple times and see that the <b>DoNotLiveJustForEvent </b>object's <b>Clicked </b>method is getting called. However, once I click the right button in the form, the <b>DoNotLiveJustForEvent </b>object is garbage collected. Now, when I click the left button, the</p>
<p><b>WeakEventHandler </b>object determines that the <b>DoNotLiveJustForEvent </b>object is gone, and it unregisters itself with the <b>Button</b>'s <b>Click </b>event so that it never gets called again. Of course, the <b>WeakEventHandler </b>object will have its memory reclaimed during the next garbage collection.</p>
<p>To understand my <b>WeakEventHandler </b>class, you need to first understand its base class. <b>WeakEventHandler </b>is derived from my abstract generic <b>WeakDelegate </b>class:</p>
<p><code>public abstract class WeakDelegate&lt;TDelegate&gt; where TDelegate : class /* MulticastDelegate */ { private WeakReference&lt;TDelegate&gt; m_weakDelegate; private Action&lt;TDelegate&gt; m_removeDelegateCode;<br/>
public WeakDelegate(TDelegate @delegate) {<br/>
var md = (MulticastDelegate)(Object)@delegate; if (md.Target == null)<br/>
throw new ArgumentException(<br/>
&quot;There is no reason to make a WeakDelegate to a static method.&quot;);<br/>
// Save a WeakReference to the delegate<br/>
m_weakDelegate = new WeakReference&lt;TDelegate&gt;(@delegate);<br/>
}<br/>
public Action&lt;TDelegate&gt; RemoveDelegateCode { set {<br/>
// Save the delegate that refers to code that knows how to remove the // WeakDelegate object when the non-weak delegate object is GC'd m_removeDelegateCode = value;<br/>
}<br/>
}<br/>
protected TDelegate GetRealDelegate() {<br/>
// If the real delegate hasn't been GC'd yet, just return it TDelegate realDelegate = m_weakDelegate.Target; if (realDelegate != null) return realDelegate;<br/>
// The real delegate was GC'd, we don't need our // WeakReference to it anymore (it can be GC'd) m_weakDelegate.Dispose();<br/>
// Remove the delegate from the chain (if the user told us how) if (m_removeDelegateCode != null) { m_removeDelegateCode(GetDelegate());<br/>
m_removeDelegateCode = null;   // Let the remove handler delegate be GC'd<br/>
}<br/>
return null;     // The real delegate was GC'd and can't be called<br/>
}<br/>
// All derived classes must return a delegate to // a private method matching the TDelegate type public abstract TDelegate GetDelegate();<br/>
// Implicit conversion operator to convert a WeakDelegate object to an actual delegate public static implicit operator TDelegate(WeakDelegate&lt;TDelegate&gt; @delegate) {<br/>
return @delegate.GetDelegate();<br/>
}<br/>
}</code></p>
<p>Now, we can look at my <b>WeakEventHandler </b>class:</p>
<p><code>// This class provides support for the non-generic EventHandler delegate public sealed class WeakEventHandler : WeakDelegate&lt;EventHandler&gt; {<br/>
public WeakEventHandler(EventHandler @delegate) : base(@delegate) { }<br/>
/// &lt;summary&gt;Returns a reference to the non-generic EventHandler delegate&lt;/summary&gt; public override EventHandler GetDelegate() { return Callback; }<br/>
// This private method must match the desired delegate's signature private void Callback(Object sender, EventArgs e) {<br/>
// If the target hasn't been GC'd invoke it<br/>
var eh = base.GetRealDelegateO;<br/>
if (eh != null) eh(sender, e);<br/>
}<br/>
}</code></p>
<p>Solving this weak delegate problem turned out to be much more challenging than I first expected it to be. The CLR and C# have a lot of limitations that I had to work around; this makes the code bigger and more complex than I would have liked. Here are some of the problems:</p>
<p>&#9632; I want my <b>WeakDelegate </b>class to have its <b>TDelegate </b>generic argument constrained to accept only delegate objects that are derived from <b>System.MulticastDelegate </b>. However, C# doesn't allow you to constrain a generic argument to <b>MulticastDelegate </b>or even <b>System.Delegate </b>(the base class of <b>MulticastDelegate) </b>. Therefore, the best I can do is constrain <b>TDelegate </b>to <b>class </b>(that is, any reference type).</p>
<p>&#9632; I wanted to have a <b>WeakDelegate </b>object automatically remove itself from the delegate chain that it is a member of when it sees that its target delegate has been garbage collected. However, a delegate has no way to know what chain it is a member of</p>
<p>&#9632; I also thought about passing an event (like the <b>Button</b>'s <b>Click </b>event) to <b>WeakDelegate</b>'s constructor. Then I could have code inside my <b>WeakDelegate </b>class that automatically removes the <b>WeakDelegate </b>object from the event, but there is no way to create a variable that refers to an event Therefore, the user of a <b>WeakDelegate </b>class can optionally set the <b>RemoveDelegateCode </b>property to some delegate referring to code that knows how to remove the delegate from a delegate chain or an event; at least I can pass the <b>WeakDelegate </b>object's delegate to remove into this code.</p>
<p>&#9632; The CLR treats each delegate type as different types and so you can't cast a reference to one delegate type to another delegate type even if the delegate types have the same signature. For example, I'd like to cast a reference to an <b>EventHandler </b>delegate to an <b>EventHandler&lt;EventArgs&gt; </b>delegate since these delegate signatures are actually identical. But the CLR treats these as different types, and the cast is not allowed.</p>
<p>Microsoft's CLR team knows about this delegate limitation and is considering ways to allow delegates with the same signature to be equivalent in a future version of the CLR. Due to this limitation, a different class has to be defined for each delegate's type.</p>
<p>I already showed you the <b>WeakEventHandler </b>type that corresponds to the <b>EventHandler </b>delegate. I also have a <b>WeakEventHandler&lt;TEventArgs&gt; </b>type that corresponds to the <b>EventHandler&lt;TEventArgs&gt; </b>delegate type:</p>
<p><code>// This WeakDelegate partial class provides support for the // generic EventHandler&lt;TEventArgs&gt; delegate public sealed class WeakEventHandler&lt;TEventArgs&gt; :<br/>
WeakDelegate&lt;EventHandler&lt;TEventArgs&gt;&gt; where TEventArgs : EventArgs {<br/>
public WeakEventHandler(EventHandler&lt;TEventArgs&gt; @delegate) : base(@delegate) { }<br/>
/// &lt;summary&gt;<br/>
/// Returns a reference to the generic<br/>
/// EventHandler&lt;typeparam name=&quot;TEventArgs&quot;/&gt; delegate<br/>
/// &lt;/summary&gt;<br/>
public override EventHandler&lt;TEventArgs&gt; GetDelegate() { return Callback; }<br/>
private void Callback(Object sender, TEventArgs e) { // If the target hasn't been GC'd invoke it var eh = base.GetRealDelegateO; if (eh != null) eh(sender, e);<br/>
}<br/>
}</code></p>
<p>If the CLR would treat delegate types that have the same signature as equivalent, I could use my <b>WeakEventHandler&lt;TEventArgs&gt; </b>type for non-generic <b>EventHandler </b>events, and I could delete my <b>WeakEventHandler </b>class entirely.</p>
<p>It would actually be pretty cool if the .NET Framework included a weak reference delegate mechanism, but no such thing exists today. However, it has been discussed by the CLR team at Microsoft, and it is likely that something like that will be part of a future version. If the CLR had first-class support for it, then they could easily work around all the limitations that I had to deal with, which would make the implementation easier to use and more efficient.</p>
<hr/>
<blockquote><b>Important </b>When developers start learning about weak references, they immediately start thinking that they are useful in caching scenarios. For example, they think it would be cool to construct a bunch of objects that contain a lot of data and then to create weak references to these objects When the program needs the data, the program checks the weak reference to see if the object that contains the data is still around, and if it is, the program just uses it; the program experiences high performance. However, if a garbage collection occurred, the objects that contain the data will be destroyed, and when the program has to re-create the data, the program experiences lower performance.</blockquote>
<hr/>
<p>The problem with this technique is the following: Garbage collections do not occur when memory is full or close to full. Instead, garbage collections occur whenever generation 0 is full, which occurs approximately after every 256 KB of memory is allocated. So objects are being tossed out of memory much more frequently than desired, and your application's performance suffers greatly.</p>
<p>Weak references can be used quite effectively in caching scenarios, but building a good cache algorithm that finds the right balance between memory consumption and speed is very complex. Basically, you want your cache to keep strong references to all of your objects and then, when you see that memory is getting tight, you start turning strong references into weak references. Currently, the CLR offers no mechanism to notify an application that memory is getting tight But some people have had much success by periodically calling the Win32 <b>GlobalMemoryStatusEx </b>function and checking the returned <b>MEMORYSTATUSEX </b>structure's <b>dwMemoryLoad </b>member. If this member reports a value above 80, memory is getting tight, and you can start converting strong references to weak references based on whether you want a least-recently used algorithm, a most-frequently used algorithm, a time-base algorithm, or whatever.</p>
<p>Developers frequently want to associate a piece of data with another entity For example, you can associate data with a thread or with an AppDomain. It is also possible to associate data with an individual object by using the <b>System.Runtime.CompilerServices. ConditionalWeakTable&lt;TKey,TValue&gt; </b>class, which looks like this:</p>
<p><code>public sealed class ConditionalWeakTable&lt;TKey, TValue&gt; where TKey : class where TValue : class { public ConditionalWeakTable(); public void      Add(TKey key, TValue value);<br/>
public TValue   GetValue(TKey key, CreateValueCallback&lt;TKey, TValue&gt; createValueCallback); public Boolean TryGetValue(TKey key, out TValue value); public TValue   GetOrCreateValue(TKey key); public Boolean Remove(TKey key);<br/>
public delegate TValue CreateValueCallback(TKey key);   // Nested delegate definition<br/>
}</code></p>
<p>If you want to associate some arbitrary data with one or more objects, you would first create an instance of this class Then, call the <b>Add </b>method passing in a reference to some object for the <b>key </b>parameter and the data you want to associate with the object in the <b>value </b>parameter If you attempt to add a reference to the same object more than once, the <b>Add </b>method throws an <b>ArgumentException; </b>to change the value associated with an object, you must remove the key and then add it back in with the new value. Note that this class is thread-safe so multiple threads can use it concurrently, although this means that the performance of the class is not stellar; you should test the performance of this class to see how well it works for your scenario. Also, there is no good reason why <b>TValue </b>is constrained to class (only reference types). In the future, the CLR team might remove the constraint on <b>TValue </b>so that you can associate value type instances with an object without having to box the value types.</p>
<p>Of course, a table object internally stores a <b>WeakReference </b>to the object passed in as the key; this ensures that the table doesn't forcibly keep the object alive But what makes the <b>ConditionalWeakTable </b>class so special is that it guarantees that the value remains in memory as long as the object identified by the key is in memory. So this is more than a normal <b>WeakReference </b>because if it were, the value could be garbage collected even though the key object continued to live. The <b>ConditionalWeakTable </b>class could be used to implement the dependency property mechanism of Silverlight and Windows Presentation Foundation</p>
<p>(WPF). It can also be used internally by dynamic languages to dynamically associate data with objects.</p>
<p>Here is some code that demonstrates the use of the <b>ConditionalWeakTable </b>class. It allows you to call the <b>GCWatch </b>extension method on any object passing in some <b>String </b>tag. Then it notifies you via the console window whenever that particular object gets garbage collected:</p>
<p><code>internal static class ConditionalWeakTableDemo { public static void Main() {<br/>
Object o = new Object().GCWatch(&quot;My Object created at &quot; + DateTime.Now); GC.CollectO;        // We will not see the GC notification here GC.KeepAlive(o);   // Make sure the object o refers to lives up to here o = null;// The object that o refers to can die now<br/>
GC.CollectO;        // We'll see the GC notification here<br/>
}<br/>
}<br/>
internal static class GCWatcher {<br/>
// NOTE: Be careful with Strings due to interning and MarshalByRefObject proxy objects private readonly static ConditionalWeakTable&lt;Object, NotifyWhenGCd&lt;String&gt;&gt; s_cwt = new ConditionalWeakTable&lt;Object, NotifyWhenGCd&lt;String&gt;&gt;();<br/>
private sealed class NotifyWhenGCd&lt;T&gt; { private readonly T m_value;<br/>
internal NotifyWhenGCd(T value) { m_value = value; }<br/>
public override string ToString() { return m_value.ToString(); }<br/>
~NotifyWhenGCd() { Console.WriteLineC'GC'd: &quot; + m_value); }<br/>
}<br/>
public static T GCWatch&lt;T&gt;(this T @object, String tag) where T : class { s_cwt.Add(@object, new NotifyWhenGCd&lt;String&gt;(tag)); return @object;<br/>
}<br/>
}</code></p>
<a name="b566"/><h2>Resurrection</h2>
<p>When we talked about finalization, you'll recall that when an object requiring finalization is considered dead, the garbage collector forces the object back to life so that its <b>Finalize </b>method can be called Then, after its <b>Finalize </b>method is called, the object is permanently dead. To summarize: An object requiring finalization dies, lives, and then dies again. Bringing a dead object back to life is called resurrection.</p>
<p>The act of preparing to call an object's <b>Finalize </b>method is a form of resurrection. When the garbage collector places a reference to the object on the freachable queue, the object is now reachable from a root and has come back to life This is required so that the code in the <b>Finalize </b>method can access the object's fields. Eventually, the object's <b>Finalize </b>method returns, no roots point to the object because it is removed from the freachable queue, and the object is dead forever after.</p>
<p>But what if an object's <b>Finalize </b>method executed code that placed a pointer to the object in a static field, as demonstrated in the following code?</p>
<p><code>internal sealed class SomeType { ~SomeType() {<br/>
Program.s_ObjHolder = this;<br/>
}<br/>
}<br/>
public static class Program {<br/>
public static Object s_ObjHolder;      // Defaults to null<br/>
}</code></p>
<p>In this case, when a <b>SomeType </b>object has its <b>Finalize </b>method called, a reference to the object is placed in a root, and the object is reachable from the application's code. This object is now resurrected, and the garbage collector won't consider the object to be garbage The application is free to use the object傭ut you must remember that the object has been finalized, so using it can cause unpredictable results. Also keep in mind that if <b>SomeType </b>contained fields that referenced other objects (either directly or indirectly), all objects would be resurrected because they are all reachable from the application's roots. However, be aware that some of these other objects might also have had their <b>Finalize </b>method called.</p>
<p>In general, resurrection is not considered a good thing, and you should avoid writing code that takes advantage of this &quot;feature&quot; of the CLR. The few scenarios in which resurrection can be useful are when an application's architecture requires use of the same object over and over again. When the object is finished being used, a garbage collection will occur. In the object's <b>Finalize </b>method, it assigns its <b>this </b>pointer to another root, preventing the object from dying But you'll want to tell the garbage collector to call the object's <b>Finalize </b>method again after the next usage To make this possible, the <b>GC </b>type offers a static method named <b>ReRegisterForFinalize. </b>This method takes a single parameter: a reference to an object. The following code demonstrates how to fix <b>SomeType</b>'s <b>Finalize </b>method so that the <b>Finalize </b>method is called after each use of the object:</p>
<p><code>internal sealed class SomeType { ~SomeType() {<br/>
Program.s_ObjHolder = this; GC.ReRegisterForFinalize(this);<br/>
}<br/>
}</code></p>
<p>When the <b>Finalize </b>method is called, it resurrects the object by making a root refer to the object. The <b>Finalize </b>method then calls <b>ReRegisterForFinalize, </b>which appends the address of the specified object <b>(this) </b>to the end of the finalization list. When the garbage collector determines that this object is unreachable (some time in the future when the static field is set to <b>null), </b>it will move the object's pointer from the finalization list to the freachable queue, and the <b>Finalize </b>method will be called again. Again, remember that resurrecting an object resurrects all of the objects it refers to; you may need to call <b>ReRegisterForFinalize</b></p>
<p>for all of these objects, and in many situations, this is impossible because you won't have access to the private fields of the other objects!</p>
<p>This example shows how to create an object that constantly resurrects itself and never dies but you don't usually want objects to do this. It's far more common to conditionally set a root to reference the object inside the <b>Finalize </b>method.</p>
<hr/>
<blockquote><b>Note </b>Make sure that you call <b>ReRegisterForFinalize </b>no more than once per resurrection, or the object will have its <b>Finalize </b>method called multiple times. The reason is that each call to <b>ReRegisterForFinalize </b>appends a new entry to the end of the finalization list When an object is determined to be garbage, all of these entries move from the finalization list to the freachable queue, making the object's <b>Finalize </b>method called multiple times.</blockquote>
<hr/>
<p>At the end of this chapter's &quot;Generations&quot; section, I present a <b>GCNotification </b>class that uses resurrection in a useful and meaningful way.</p>
<a name="b568"/><h2>Generations</h2>
<p>As I mentioned near the beginning of the chapter, generations are a mechanism within the CLR garbage collector whose sole reason for being is to improve an application's performance A generational garbage collector (also known as an ephemeral garbage collector, although I don't use the latter term in this book) makes the following assumptions:</p>
<p>&#9632; The newer an object is, the shorter its lifetime will be.</p>
<p>&#9632; The older an object is, the longer its lifetime will be.</p>
<p>&#9632; Collecting a portion of the heap is faster than collecting the whole heap.</p>
<p>Numerous studies have demonstrated the validity of these assumptions for a very large set of existing applications, and these assumptions have influenced how the garbage collector is implemented. In this section, I'll describe how generations work.</p>
<p>When initialized, the managed heap contains no objects. Objects added to the heap are said to be in generation 0. Stated simply, objects in generation 0 are newly constructed objects that the garbage collector has never examined. Figure 21-8 shows a newly started application with five objects allocated (A through E). After a while, objects C and E become unreachable.</p>
<img src="68.jpg"/>
<p><b>Figure 21-8 </b>A newly initialized heap containing some objects, all in generation 0. No collections have occurred yet.</p>
<p>When the CLR initializes, it selects a budget size for generation 0 of, say, 256 KB. (The exact size is subject to change.) So if allocating a new object causes generation 0 to surpass its budget, a garbage collection must start. Let's say that objects A through E occupy 256 KB. When object F is allocated, a garbage collection must start The garbage collector will determine that objects C and E are garbage and will compact object D, causing it to be adjacent to object B. Incidentally, generation 0's budget of 256 KB was chosen because it is likely that all of these objects will fit entirely into a CPU's L2 cache so that compacting memory happens incredibly fast. The objects that survive the garbage collection (objects A, B, and D) are said to be in generation 1. Objects in generation 1 have been examined by the garbage collector once. The heap now looks like Figure 21-9.</p>
<img src="70.jpg"/>
<p><b>Figure 21-9 </b>After one collection, generation 0 survivors are promoted to generation 1; generation 0 is empty</p>
<p>After a garbage collection, generation 0 contains no objects. As always, new objects will be allocated in generation 0. Figure 21-10 shows the application running and allocating objects F through K. In addition, while the application was running, objects B, H, and J became unreachable and should have their memory reclaimed at some point.</p>
<img src="69.jpg"/>
<p><b>Figure 21-10 </b>New objects are allocated in generation 0; generation 1 has some garbage</p>
<p>Now let's say that attempting to allocate object L would put generation 0 over its 256-KB budget Because generation 0 has reached its budget, a garbage collection must start When starting a garbage collection, the garbage collector must decide which generations to examine. Earlier, I said that when the CLR initializes, it selects a budget for generation 0. Well, it also selects a budget for generation 1. Let's say that the budget selected for generation 1 is 2 MB.</p>
<p>When starting a garbage collection, the garbage collector also sees how much memory is occupied by generation 1 In this case, generation 1 occupies much less than 2 MB, so the garbage collector examines only the objects in generation 0. Look again at the assumptions that the generational garbage collector makes. The first assumption is that newly created objects have a short lifetime. So generation 0 is likely to have a lot of garbage in it, and collecting generation 0 will therefore reclaim a lot of memory. The garbage collector will just ignore the objects in generation 1, which will speed up the garbage collection process.</p>
<p>Obviously, ignoring the objects in generation 1 improves the performance of the garbage collector. However, the garbage collector improves performance more because it doesn't traverse every object in the managed heap. If a root or an object refers to an object in an old generation, the garbage collector can ignore any of the older objects' inner references, decreasing the amount of time required to build the graph of reachable objects. Of course, it's possible that an old object's field refers to a new object. To ensure that the updated fields of these old objects are examined, the garbage collector uses a mechanism internal to the JIT compiler that sets a bit when an object's reference field changes. This support lets the garbage collector know which old objects (if any) have been written to since the last collection. Only old objects that have had fields change need to be examined to see whether they refer to any new object in generation 0 <sup>2</sup></p>
<hr/>
<blockquote><b>Note </b>Microsoft's performance tests show that it takes less than 1 millisecond to perform a garbage collection of generation 0. Microsoft's goal is to have garbage collections take no more time than an ordinary page fault.</blockquote>
<hr/>
<p>A generational garbage collector also assumes that objects that have lived a long time will continue to live So it's likely that the objects in generation 1 will continue to be reachable from the application Therefore, if the garbage collector were to examine the objects in generation 1, it probably wouldn't find a lot of garbage. As a result, it wouldn't be able to reclaim much memory. So it is likely that collecting generation 1 is a waste of time. If any garbage happens to be in generation 1, it just stays there. The heap now looks like Figure 21-11.</p>
<img src="71.jpg"/>
<p><b>Figure 21-11 </b>After two collections, generation 0 survivors are promoted to generation 1 (growing the size of generation 1); generation 0 is empty</p>
<p>As you can see, all of the generation 0 objects that survived the collection are now part of generation 1 Because the garbage collector didn't examine generation 1, object B didn't have its memory reclaimed even though it was unreachable at the time of the last garbage collection Again, after a collection, generation 0 contains no objects and is where new objects will be placed. In fact, let's say that the application continues running and allocates</p>
<p>For the curious, here are some more details about this. When the JIT compiler produces native code that modifies a reference field inside an object, the native code includes a call to a write barrier method. This write barrier method checks if the object whose field is being modified is in generation 1 or 2 and if it is, the write barrier code sets a bit in what is called the card table. The card table has 1 bit for every 128-byte range of data in the heap. When the next GC starts, it scans the card table to know which objects in generations 1 and 2 have had their fields changed since the last GC. If any of these modified objects refer to an object in generation 0, then the generation 0 objects survive the collection. After the GC, the card table is reset to all zeroes. The write barrier code causes a slight performance hit when writing to a reference field in an object (as opposed to a local variable or static field) and that performance hit is slightly worse if that object is in generation 1 or 2.</p>
<p>objects L through O. And while running, the application stops using objects G, L, and M, making them all unreachable. The heap now looks like Figure 21-12.</p>
<img src="72.jpg"/>
<p><b>Figure 21-12 </b>New objects are allocated in generation 0; generation 1 has more garbage</p>
<p>Let's say that allocating object P causes generation 0 to exceed its budget, causing a garbage collection to occur. Because the memory occupied by all of the objects in generation 1 is less than 2 MB, the garbage collector again decides to collect only generation 0, ignoring the unreachable objects in generation 1 (objects B and G). After the collection, the heap looks like Figure 21-13.</p>
<img src="73.jpg"/>
<p><b>Figure 21-13 </b>After three collections, generation 0 survivors are promoted to generation 1 (growing the size of generation 1 again); generation 0 is empty</p>
<p>In Figure 21-13, you see that generation 1 keeps growing slowly. In fact, let's say that generation 1 has now grown to the point in which all of the objects in it occupy 2 MB of memory. At this point, the application continues running (because a garbage collection just finished) and starts allocating objects P through S, which fill generation 0 up to its budget. The heap now looks like Figure 21-14.</p>
<img src="74.jpg"/>
<p><b>Figure 21-14 </b>New objects are allocated in generation 0; generation 1 has more garbage</p>
<p>When the application attempts to allocate object T, generation 0 is full, and a garbage collection must start. This time, however, the garbage collector sees that the objects in generation 1 are occupying so much memory that generation 1's 2-MB budget has been reached. Over the several generation 0 collections, it's likely that a number of objects in generation 1 have become unreachable (as in our example). So this time, the garbage collector decides to examine all of the objects in generation 1 and generation 0 After both generations have been garbage collected, the heap now looks like Figure 21-15.</p>
<img src="75.jpg"/>
<p><b>Figure 21-15 </b>After four collections: generation 1 survivors are promoted to generation 2, generation 0 survivors are promoted to generation 1, and generation 0 is empty</p>
<p>As before, any objects that were in generation 0 that survived the garbage collection are now in generation 1; any objects that were in generation 1 that survived the collection are now in generation 2. As always, generation 0 is empty immediately after a garbage collection and is where new objects will be allocated Objects in generation 2 are objects that the garbage collector has examined two or more times. There might have been several collections, but the objects in generation 1 are examined only when generation 1 reaches its budget, which usually requires several garbage collections of generation 0.</p>
<p>The managed heap supports only three generations: generation 0, generation 1, and generation 2; there is no generation 3 <sup>3</sup> When the CLR initializes, it selects budgets for all three generations As I mentioned earlier, the budget for generation 0 is about 256 KB, and the budget for generation 1 is about 2 MB. The budget for generation 2 is around 10 MB. Again, the budget sizes are selected to improve performance. The larger the budget, the less frequently a garbage collection will occur. And again, the performance improvement comes because of the initial assumptions: new objects have short lifetimes, and older objects are likely to live longer.</p>
<p>The CLR's garbage collector is a self-tuning collector. This means that the garbage collector learns about your application's behavior whenever it performs a garbage collection. For example, if your application constructs a lot of objects and uses them for a very short period of time, it's possible that garbage collecting generation 0 will reclaim a lot of memory. In fact, it's possible that the memory for all objects in generation 0 can be reclaimed.</p>
<p>If the garbage collector sees that there are very few surviving objects after collecting generation 0, it might decide to reduce the budget of generation 0 from 256 KB to 128 KB This reduction in the allotted space will mean that garbage collections occur more frequently but will require less work for the garbage collector, so your process's working set will be small. In fact, if all objects in generation 0 are garbage, a garbage collection doesn't have to compact any memory; it can simply set <b>NextObjPtr </b>back to the beginning of generation 0, and then the garbage collection is performed. Wow, this is a fast way to reclaim memory!</p>
<hr/>
<blockquote><b>Note </b>The garbage collector works extremely well for applications with threads that sit idle at the top of their stack most of the time Then, when the thread has something to do, it wakes up, creates a bunch of short-lived objects, returns, and then goes back to sleep Many applications follow this architecture, including Windows Forms, WPF, ASP.NET Web Forms, and XML Web service applications.</blockquote>
<hr/>
<p>The <b>System.GC </b>class's static <b>MaxGeneration </b>method returns 2.</p>
<p>For ASP.NET applications, a client request comes in, a bunch of new objects are constructed, the objects perform work on the client's behalf, and the result is sent back to the client At this point, all of the objects used to satisfy the client's request are garbage In other words, each ASP NET application request causes a lot of garbage to be created. Because these objects are unreachable almost immediately after they're created, each garbage collection reclaims a lot of memory This keeps the process's working set very low, and the garbage collector's performance is phenomenal.</p>
<p>In fact, most of an application's roots live on the thread's stack in arguments or local variables If a thread's stack is short, it takes very little time for the garbage collector to examine the roots and mark the reachable objects In other words, garbage collections go much faster if you avoid deeps stacks. One way to avoid a deep stack is to avoid using recursive methods.</p>
<p>On the other hand, if the garbage collector collects generation 0 and sees that there are a lot of surviving objects, not a lot of memory was reclaimed in the garbage collection. In this case, the garbage collector will grow generation 0's budget to maybe 512 KB. Now, fewer collections will occur, but when they do, a lot more memory should be reclaimed. By the way, if insufficient memory has been reclaimed after a collection, the garbage collector will perform a full collection before throwing an <b>OutOfMemoryException </b>.</p>
<p>Throughout this discussion, I've been talking about how the garbage collector dynamically modifies generation 0's budget after every collection. But the garbage collector also modifies the budgets of generation 1 and generation 2 by using similar heuristics. When these generations are garbage collected, the garbage collector again sees how much memory is reclaimed and how many objects survived. Based on the garbage collector's findings, it might grow or shrink the thresholds of these generations as well to improve the overall performance of the application. The end result is that the garbage collector fine-tunes itself automatically based on the memory load required by your application葉his is very cool!</p>
<p>The <b>GCNotification </b>class shown below is similar to the <b>GCBeep </b>program discussed in the &quot;Using Finalization with Managed Resources&quot; section earlier in this chapter. However, the <b>GCNotification </b>class raises an event whenever a generation 0 or generation 2 collection occurs With these events, you could have the computer beep whenever a collection or you calculate how much time passes between collections, how much memory is allocated between collections, and more. With this class, you could easily instrument your application to get a better understanding of how your application uses memory.</p>
<p><code>public static class GCNotification {<br/>
private static Action&lt;Int32&gt; s_gcDone = null;   // The event's field<br/>
public static event Action&lt;Int32&gt; GCDone {<br/>
add {<br/>
// If there were no registered delegates before, start reporting notifications now if (s_gcDone == null) { new GenObject(O); new GenObject(2); } s_gcDone += value;<br/>
}<br/>
remove { s_gcDone -= value; }<br/>
}<br/>
private sealed class GenObject { private Int32 regeneration;<br/>
public GenObject(Int32 generation) { regeneration = generation; } ~GenObject() { // This is the Finalize method<br/>
// If this object is in the generation we want (or higher), // notify the delegates that a GC just completed if (GC.GetGeneration(this) &gt;= regeneration) {<br/>
Action&lt;Int32&gt; temp = Interlocked.CompareExchange(ref s_gcDone, null, null); if (temp != null) temp(m_generation);<br/>
}<br/>
// Keep reporting notifications if there is at least one delegated registered, // the AppDomain isn't unloading, and the process isn't shutting down if ((s_gcDone != null)<br/>
&amp;&amp; !AppDomain.CurrentDomain.IsFinalizingForUnload()<br/>
&amp;&amp; !Environment.HasShutdownStarted) {<br/>
// For Gen 0, create a new object; for Gen 2, resurrect the object &amp; let // the GC call Finalize again the next time Gen 2 is GC'd if (m_generation == 0) new GenObject(O); else GC.ReRegisterForFinalize(this); } else { /* Let the objects go away */ }<br/>
}<br/>
}<br/>
}</code></p>
<a name="b574"/><h2>Other Garbage Collection Features for Use with Native Resources</h2>
<p>Sometimes, a native resource consumes a lot of memory, but the managed object wrapping that resource occupies very little memory. The quintessential example of this is the bitmap. A bitmap can occupy several megabytes of native memory, but the managed object is tiny because it contains only an <b>HBITMAP </b>(a 4- or 8-byte value). From the CLR's perspective, a process could allocate hundreds of bitmaps (using little managed memory) before performing a collection But if the process is manipulating many bitmaps, the process's memory consumption will grow at a phenomenal rate. To fix this situation, the <b>GC </b>class offers the following two static methods:</p>
<p><code>public static void AddMemoryPressure(Int64 bytesAllocated); public static void RemoveMemoryPressure(Int64 bytesAllocated);</code></p>
<p>A class that wraps a potentially large native resource should use these methods to give the garbage collector a hint as to how much memory is really being consumed Internally, the garbage collector monitors this pressure, and when it gets high, a garbage collection is forced.</p>
<p>There are some native resources that are fixed in number. For example, Windows formerly had a restriction that it could create only five device contexts. There had also been a restriction on the number of files that an application could open. Again, from the CLR's perspective, a process could allocate hundreds of objects (that use little memory) before performing a collection But if the number of these native resources is limited, attempting to use more than are available will typically result in exceptions being thrown. To fix this situation, the <b>System.Runtime.InteropServices </b>namespace offers the <b>HandleCollector </b>class:</p>
<p><code>public sealed class HandleCollector {<br/>
public HandleCollector(String name, Int32 initialThreshold);<br/>
public HandleCollector(String name, Int32 initialThreshold,   Int32 maximumThreshold); public void Add(); public void Remove();<br/>
public Int32 Count { get; } public Int32 InitialThreshold { get; } public Int32 MaximumThreshold { get; } public String Name { get; }<br/>
}</code></p>
<p>A class that wraps a native resource that has a limited quantity available should use an instance of this class to give the garbage collector a hint as to how many instances of the resource are really being consumed. Internally, this class object monitors the count, and when it gets high, a garbage collection is forced.</p>
<hr/>
<blockquote><b>Note </b>Internally, the <b>GC.AddMemoryPressure </b>and <b>HandleCollector.Add </b>methods call <b>GC.Collect, </b>forcing a garbage collection to start prior to generation 0 reaching its budget Normally, forcing a garbage collection to start is strongly discouraged because it usually has an adverse effect on your application's performance However, classes that call these methods are doing so in an effort to keep limited native resources available for the application If the native resources run out, the application will fail For most applications, it is better to work with reduced performance than to not be working at all.</blockquote>
<hr/>
<p>Here is some code that demonstrates the use and effect of the memory pressure methods and the <b>HandleCollector </b>class:</p>
<p><code>using System;<br/>
using System.Runtime.InteropServices;<br/>
public static class Program { public static void Main() {<br/>
MemoryPressureDemo(O);// 0      causes infrequent GCs<br/>
MemoryPressureDemo(10 * 1024 * 1024);   // 10MB causes frequent GCs<br/>
HandleCollectorDemo();<br/>
}<br/>
private static void MemoryPressureDemo(Int32 size) { Console.WriteLine<b>O;</b><br/>
Console.WriteLine(&quot;MemoryPressureDemo, size={0}&quot;, size); // Create a bunch of objects specifying their logical size for (Int32 count = 0; count &lt; 15; count++) { new BigNativeResource(size);<br/>
}<br/>
// For demo purposes, force everything to be cleaned-up GC.Collect<b>O;</b><br/>
GC.WaitForPendingFinalizers<b>O;</b><br/>
}<br/>
private sealed class BigNativeResource { private Int32 m_size;<br/>
public BigNativeResource(Int32 size) { m_size = size; if (m_size &gt; 0) {<br/>
// Make the GC think the object is physically bigger<br/>
GC.AddMemoryPressure(m_size);<br/>
}<br/>
Console.WriteLine(&quot;BigNativeResource create.&quot;);<br/>
}<br/>
~BigNativeResource() { if (m_size &gt; 0) {<br/>
// Make the GC think the object released more memory GC.RemoveMemoryPressure(m_size);<br/>
}<br/>
Console.WriteLine(&quot;BigNativeResource destroy.&quot;);<br/>
}<br/>
}<br/>
private static void HandleCollectorDemo() { Console.WriteLine<b>O;</b><br/>
Console.WriteLine(&quot;HandleCollectorDemo&quot;); for (Int32 count = 0; count &lt; 10; count++) { new LimitedResource();<br/>
}<br/>
// For demo purposes, force everything to be cleaned-up GC.Collect<b>O;</b><br/>
GC.WaitForPendingFinalizers<b>O;</b><br/>
}<br/>
private sealed class LimitedResource {<br/>
// Create a HandleCollector telling it that collections should // occur when two or more of these objects exist in the heap<br/>
private static HandleCollector s_hc = new HandleCollector(&quot;LimitedResource&quot;, 2);<br/>
public LimitedResource() {<br/>
// Tell the HandleCollector that 1 more LimitedResource<br/>
// object has been added to the heap<br/>
s_hc.Add();<br/>
Console.WriteLine(&quot;LimitedResource create.   Count={0}&quot;, s_hc.Count);<br/>
}<br/>
-LimitedResource<b>O </b>{<br/>
// Tell the HandleCollector that 1 less LimitedResource // object has been removed from the heap s_hc.Remove();<br/>
Console.WriteLine(&quot;LimitedResource destroy. Count={0}&quot;, s_hc.Count);<br/>
}<br/>
}<br/>
}<br/>
MemoryPressureDemo, size=0 BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy.<br/>
MemoryPressureDemo, size=10485760 BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource create. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource create. BigNativeResource create. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource destroy. BigNativeResource create. BigNativeResource create.</code></p>
<a name="b578"/><h2>Predicting the Success of an Operation that Requires a Lot of Memory</h2>
<p>Occasionally you find yourself implementing an algorithm that you know will require a number of objects that together will occupy a good bit of memory. You could start executing the algorithm, and, if you run out of memory, the CLR will throw an <b>OutOfMemoryException. </b>In that case, you have done a lot of work that now must be thrown away. Plus, you need to catch this exception and allow your program to recover gracefully.</p>
<p>In the <b>System.Runtime </b>namespace, there is a <b>MemoryFailPoint </b>class that offers you the ability to check for sufficient memory prior to starting a memory-hungry algorithm. Here is what the class looks like:</p>
<p><code>public sealed class MemoryFailPoint : CriticalFinalizerObject, IDisposable { public MemoryFailPoint(Int32 sizeInMegabytes); ~MemoryFailPoint(); public void Dispose();<br/>
}<br/>
BigNativeResource.create.<br/>
BigNativeResource.destroy.<br/>
BigNativeResource.destroy.<br/>
BigNativeResource.create.<br/>
BigNativeResource.create.<br/>
BigNativeResource.destroy.<br/>
BigNativeResource.destroy.<br/>
BigNativeResource.destroy.<br/>
BigNativeResource.destroy.<br/>
HandleCollectorDemo<br/>
LimitedResource.create. Count=1<br/>
LimitedResource.create. Count=2<br/>
LimitedResource.create. Count=3<br/>
LimitedResource.destroy. Count=3<br/>
LimitedResource.destroy. Count=2<br/>
LimitedResource.destroy. Count=1<br/>
LimitedResource.create. Count=1<br/>
LimitedResource.create. Count=2<br/>
LimitedResource.destroy. Count=2<br/>
LimitedResource.create. Count=2<br/>
LimitedResource.create. Count=3<br/>
LimitedResource.destroy. Count=3<br/>
LimitedResource.destroy. Count=2<br/>
LimitedResource.destroy. Count=1<br/>
LimitedResource.create. Count=1<br/>
LimitedResource.create. Count=2<br/>
LimitedResource.destroy. Count=2<br/>
LimitedResource.create. Count=2<br/>
LimitedResource.destroy. Count=1<br/>
LimitedResource.destroy. Count=0</code></p>
<p>The way you use this class is pretty simple. First, you construct an instance of it by passing in the number of megabytes that you think your algorithm is going to require (round up if you're not completely sure). Internally, the constructor performs the following checks that trigger actions in consequence:</p>
<p><b>1. </b>Is there enough available space in the system's paging file, and is there enough contiguous virtual address space in the process to satisfy the request? Note that the constructor subtracts any amount of memory that has been logically reserved by another call to <b>MemoryFailPoint</b>'s constructor.</p>
<p><b>2. </b>If there isn't enough space, a garbage collection is forced in an attempt to free up some space.</p>
<p><b>3. </b>If there is still not enough paging file space, an attempt is made to expand the paging file. If the paging file cannot grow enough, an <b>InsufficientMemoryException </b>is thrown.</p>
<p><b>4. </b>If there still isn't enough contiguous virtual address space, an <b>InsufficientMemoryException </b>is thrown.</p>
<p><b>5. </b>If enough paging file space and virtual address space has been found, the requested number of megabytes are reserved by adding the number of megabytes to a private static field defined within the <b>MemoryFailPoint </b>class. The addition is done in a thread-safe way so that multiple threads can construct an instance of this class simultaneously and be guaranteed that they have logically reserved the memory they requested as long as no exception is thrown in the constructor.</p>
<p>If <b>MemoryFailPoint</b>'s constructor throws an <b>InsufficientMemoryException, </b>your application can release some resources it is currently using, or it can reduce its performance (perform less caching of data) in order to reduce the chance of the CLR throwing an <b>OutOfMemoryException </b>in the future. By the way, <b>InsufficientMemoryException </b>is derived from <b>OutOfMemoryException.</b></p>
<hr/>
<blockquote><b>Important </b>If <b>MemoryFailPoint</b>'s constructor doesn't throw an exception, you have logically reserved the memory you have requested and you can execute your memory-hungry algorithm. However, be aware that you have not physically allocated this memory This means that it is just more likely for your algorithm to run successfully, getting the memory it needs. The <b>MemoryFailPoint </b>class cannot guarantee that your algorithm will get the memory it needs even if the constructor doesn't throw an exception. This class exists to help you make a more robust application.</blockquote>
<hr/>
<p>When you have completed executing the algorithm, you should call <b>Dispose </b>on the <b>MemoryFailPoint </b>object you constructed. Internally, <b>Dispose </b>just subtracts (in a thread-safe way) the number of megabytes you reserved from the <b>MemoryFailPoint</b>'s static field. The code below demonstrates the use of the <b>MemoryFailPoint </b>class:</p>
<p><code>using System;<br/>
using System.Runtime;<br/>
public static class Program { public static void Main() {<br/>
try {<br/>
// Logically reserve 1.5 GB of memory<br/>
using (MemoryFailPoint mfp = new MemoryFailPoint(1500)) { // Perform memory-hungry algorithm in here<br/>
} // Dispose will logically free the 1.5 GB of memory<br/>
}<br/>
catch (InsufficientMemoryException e) { // The memory could not be reserved Console.WriteLine(e);<br/>
}<br/>
}<br/>
}</code></p>
<a name="b580"/><h2>Programmatic Control of the Garbage Collector</h2>
<p>The <b>System.GC </b>type allows your application some direct control over the garbage collector For starters, you can query the maximum generation supported by the managed heap by reading the <b>GC.MaxGeneration </b>property; this property always returns 2.</p>
<p>You can also force the garbage collector to perform a collection by calling one of the following two static methods:</p>
<p><code>void GC.Collect(Int32 Generation) void GC.CollectO<br/>
void Collect(Int32 generation, GCCollectionMode mode)</code></p>
<p>The first method allows you to specify which generation(s) to collect. You can pass any integer from 0 to <b>GC.MaxGeneration </b>inclusive. Passing 0 causes generation 0 to be collected, passing 1 causes generations 1 and 0 to be collected, and passing 2 causes generations 2, 1, and 0 to be collected. The version of the <b>Collect </b>method that takes no parameters forces a full collection of all generations and is equivalent to calling:</p>
<p><code>GC.Collect(GC.MaxGeneration);</code></p>
<p>The third overload of <b>Collect </b>allows you to pass a generation and a <b>GCCollectionMode. </b>Table 21-1 describes the various GC collection mode symbols.</p>
<table border="1">
<tr>
<td>
<p>Symbol Name</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>The same as calling <b>GC.Collect </b>with no flag. Today, this is the same as passing <b>Forced, </b>but this may change in a future version of the CLR.</p>
</td>
</tr>
<tr>
<td>
<p>d</p>
</td>
<td>
<p>Forces a collection to occur immediately for all generations up to and including the specified generation.</p>
</td>
</tr>
<tr>
<td>
<p>d</p>
</td>
<td>
<p>The garbage collector will only perform a collection if the collection would be productive either by freeing a lot of memory or by reducing fragmentation. If the garbage collection would not be productive, then the call has no effect.</p>
</td>
</tr>
</table>
<p>Under most circumstances, you should avoid calling any of the <b>Collect </b>methods; it's best just to let the garbage collector run on its own accord and fine-tune its generation budgets based on actual application behavior However, if you're writing a console user interface (CUI) or graphical user interface (GUI) application, your application code owns the process and the CLR in that process. For these application types, you might want to suggest a garbage collection to occur at certain times using a <b>GCCollectionMode </b>of <b>Optimized. </b>Normally, modes of <b>Default </b>and <b>Forced </b>are used for debugging and testing.</p>
<p>For example, you might consider calling the <b>Collect </b>method if some non-recurring event has just occurred that has likely caused a lot of old objects to die. The reason that calling <b>Collect </b>in such a circumstance may not be so bad is that the garbage collector's predictions of the future based on the past are not likely to be accurate for non-recurring events.</p>
<p>For example, it might make sense for your application to force a full garbage collection of all generations after your application initializes or after the user saves a data file. When a Windows Form control is hosted on a Web page, a full collection is performed each time a page is unloaded. Don't explicitly call <b>Collect </b>to try to improve your application's response time; call it to reduce your process's working set.</p>
<p>The <b>GC </b>type also offers a <b>WaitForPendingFinalizers </b>method. This method simply suspends the calling thread until the thread processing the freachable queue has emptied the queue, calling each object's <b>Finalize </b>method. In most applications, it's unlikely that you'll ever have to call this method. Occasionally, though, I've seen code like this:</p>
<p><code>GC.Collect<b>O;</b><br/>
GC.WaitForPendingFinalizers<b>O; </b>GC.Collect<b>O;</b></code></p>
<p>This code forces a garbage collection. When the collection is complete, the memory for objects that don't require finalization is reclaimed. But the objects that do require finalization can't have their memory reclaimed yet. After the first call to <b>Collect </b>returns, the special, dedicated finalization thread is calling <b>Finalize </b>methods asynchronously. The call to <b>WaitForPendingFinalizers </b>puts the application's thread to sleep until all <b>Finalize </b>methods are called. When <b>WaitForPendingFinalizers </b>returns, all of the finalized objects are now</p>
<p><b>table </b><b>21-1 </b><b>Symbols Defined by the GCCollectionMode Enumerated Type</b></p>
<p>truly garbage. At this point, the second call to <b>Collect </b>forces another garbage collection, which reclaims all of the memory occupied by the now-finalized objects.</p>
<p>For some applications (especially server applications that tend to keep a lot of objects in memory), the time required for the garbage collector to do a full collection that includes generation 2 can be excessive. In fact, if the collection takes a very long time to complete, then client requests might time out. To help these kinds of applications, the <b>GC </b>class offers a <b>RegisterForFullGCNotification </b>method. Using this method and some additional helper methods <b>(WaitForFullGCApproach, WaitForFullGCComplete, </b>and <b>CancelFullGCNotification), </b>an application can now be notified when the garbage collector is getting close to performing a full collection. The application can then call <b>GC.Collect </b>to force a collection at a more opportune time, or the application could communicate with another server to better load balance the client requests For more information, examine these methods in the .NET Framework SDK documentation. Note that you should always call the <b>WaitForFullGCApproach </b>and <b>WaitForFullGCComplete </b>methods in pairs because the CLR handles them as pairs internally.</p>
<p>Finally, the <b>GC </b>class offers two static methods to allow you to determine which generation an object is currently in:</p>
<p><code>Int32 GetGeneration(Object obj) Int32 GetGeneration(WeakReference wr)</code></p>
<p>The first version of <b>GetGeneration </b>takes an object reference as a parameter, and the second version takes a <b>WeakReference </b>reference as a parameter The value returned will be between <b>0 </b>and <b>GC.MaxGeneration </b>inclusively.</p>
<p>The following code will help you understand how generations work. The code also demonstrates the use of the <b>GC </b>methods just discussed.</p>
<p><code>using System;<br/>
internal sealed class GenObj { ~GenObj() {<br/>
Console.WriteLine(&quot;In Finalize method&quot;);<br/>
}<br/>
}<br/>
public static class Program { public static void Main() {<br/>
Console.WriteLine(&quot;Maximum generations: &quot; + GC.MaxGeneration);<br/>
// Create a new GenObj in the heap. Object o = new GenObj();<br/>
// Because this object is newly created, it is in generation 0. Console.WriteLine(&quot;Gen &quot; + GC.GetGeneration(o)); // 0<br/>
// Performing a garbage collection promotes the object's generation. GC.CollectO;<br/>
Console.WriteLineC'Gen &quot; + GC.GetGeneration(o)); // 1 GC.CollectO;<br/>
Console.WriteLineC'Gen &quot; + GC.GetGeneration(o)); // 2 GC.CollectO;<br/>
Console.WriteLineC'Gen &quot; + GC.GetGeneration(o)); // 2 (max)<br/>
o = null; // Destroy the strong reference to this object. Console.WriteLineC'Collecting Gen 0&quot;);<br/>
GC.Collect(0);// Collect generation 0.<br/>
GC.WaitForPendingFinalizersO;      // Finalize is NOT called.<br/>
Console.WriteLineC'Collecting Gens 0, and 1&quot;);<br/>
GC.CollectO);// Collect generations 0 &amp; 1.<br/>
GC.WaitForPendingFinalizersO;      // Finalize is NOT called.<br/>
Console.WriteLineC'Collecting Gens 0, 1, and 2&quot;); GC.Collect(2);// Same as Collect()<br/>
GC.WaitForPendingFinalizersO;      // Finalize IS called.<br/>
}<br/>
}</code></p>
<p>Building and running this code yields the following output:</p>
<p><code>Maximum generations: 2 Gen 0 Gen 1 Gen 2 Gen 2<br/>
Collecting Gen 0 Collecting Gens 0, and 1 Collecting Gens 0, 1, and 2 In Finalize method</code></p>
<a name="b583"/><h2>Thread Hijacking</h2>
<p>Earlier in this chapter, I explained the garbage collection algorithm However, I made a big assumption during that discussion: that only one thread is running. In the real world, it's likely for multiple threads to be accessing the managed heap or at least manipulating objects allocated within the managed heap When one thread sparks a garbage collection, other threads must not access any objects (including object references on its own stack) because the garbage collector is likely to move these objects, changing their memory locations.</p>
<p>So when the garbage collector wants to start a garbage collection, all threads executing managed code must be suspended. The CLR has a few different mechanisms that it uses to safely suspend threads so that a garbage collection can be performed. The reason that there are multiple mechanisms is to keep threads running as long as possible and to reduce overhead as much as possible. I don't want to get into all of the details here, but suffice it to say that Microsoft has done a lot of work to reduce the overhead involved with a garbage collection. Microsoft will continue to modify these mechanisms over time to ensure efficient garbage collections in the future.</p>
<p>When the CLR wants to start a garbage collection, it immediately suspends all threads that are executing managed code The CLR then examines each thread's instruction pointer to determine where the thread is executing The instruction pointer address is then compared with the JIT compiler-produced tables in an effort to determine what code the thread is executing.</p>
<p>If the thread's instruction pointer is at an offset identified by a table, the thread is said to have reached a safe point. A safe point is a place where it's OK to leave a thread suspended until a garbage collection completes If the thread's instruction pointer isn't at an offset identified by an internal method table, the thread isn't at a safe point, and the CLR can't perform a garbage collection. In this case, the CLR hijacks the thread: the CLR modifies the thread's stack so that the return address points to a special function implemented inside the CLR The thread is then resumed. When the currently executing method returns, the special function will execute, suspending the thread.</p>
<p>However, the thread might not return from its method for quite some time. So after the thread resumes execution, the CLR waits about 250 milliseconds for the thread to be hijacked. After this time, the CLR suspends the thread again and checks its instruction pointer. If the thread has reached a safe point, the garbage collection can start. If the thread still hasn't reached a safe point, the CLR checks to see whether another method has been called; if one has, the CLR modifies the stack again so that the thread is hijacked when it returns from the most recently executing method. Then the CLR resumes the thread and waits another few milliseconds before trying again.</p>
<p>When all of the threads have reached a safe point or have been hijacked, garbage collection can begin When the garbage collection is completed, all threads are resumed, and the application continues running. The hijacked threads return to the method that originally called them.</p>
<p>This algorithm has one small twist. When the CLR wants to start a garbage collection, it suspends all threads that are executing managed code, but it does not suspend threads that are executing unmanaged code Once all of the threads that are executing managed code are at a safe point or are hijacked, the garbage collection is allowed to start The threads executing unmanaged code are allowed to continue running because any object that they are using should have been pinned. If a thread currently executing unmanaged code returns to managed code, the thread is immediately suspended until the garbage collection has completed.</p>
<p>As it turns out, the CLR uses hijacking most of the time rather than using the JIT compiler-produced tables to determine if the thread is at a safe point. The reason is the JIT compiler-</p>
<p>produced tables require a lot of memory and increase the working set, which in turn hurts performance significantly. So, the JIT compiler-produced tables contain information for sections of code having loops that do not call other methods. If the method has a loop that calls other methods or if there are no loops, the JIT compiler-produced tables do not have much information in them, and hijacking is used to suspend the threads.</p>
<a name="b585"/><h2>Garbage Collection Modes</h2>
<p>When the CLR starts, it selects a GC mode, and this mode cannot change during the lifetime of the process. There are two basic GC modes:</p>
<p>&#9632; Workstation   This mode fine-tunes the garbage collector for client-side applications. The garbage collector assumes that other applications are running on the machine and does not hog CPU resources. The Workstation mode can have two submodes: Workstation with the concurrent collector and Workstation without the concurrent collector. I'll describe the concurrent collector feature shortly.</p>
<p>&#9632; Server  This mode fine-tunes the garbage collector for server-side applications. The garbage collector assumes that no other applications (client or server) are running on the machine and it assumes that all the CPUs on the machine are available to do a garbage collection This GC mode causes the managed heap to be split into several sections, one per CPU When a garbage collection is initiated, the garbage collector has one thread per CPU; each thread collects its own section in parallel with the other threads Parallel collections work well for server applications in which the worker threads tend to exhibit uniform behavior This feature requires the application to be running on a computer with multiple CPUs so that the threads can truly be working simultaneously to attain a performance improvement.</p>
<p>By default, applications run with the Workstation GC mode, and the concurrent collector is turned on. However, a server application (such as ASP.NET or SQL Server) that hosts the CLR can request the CLR to load the Server GC. However, if the server application is running on a uniprocessor machine, then the CLR will load the Workstation GC mode without the concurrent collector.</p>
<p>An application that self-hosts the CLR can tell the CLR to use the server collector by creating a configuration file (as discussed in Chapter 2, &quot;Building, Packaging, Deploying, and Administering Applications and Types,&quot; and Chapter 3, &quot;Shared Assemblies and Strongly Named Assemblies&quot;) that contains a <b>gcServer </b>element for the application. Here's an example of a configuration file:</p>
<p><code>&lt;configuration&gt;<br/>
&lt;runtime&gt;<br/>
&lt;gcServer enabled=&quot;true&quot;/&gt;<br/>
&lt;/runtime&gt; &lt;/configuration&gt;</code></p>
<p>When an application is running, it can ask the CLR if it is running in the Server GC mode by querying the <b>GCSettings </b>class's <b>IsServerGC </b>read-only <b>Boolean </b>property:</p>
<p><code>using System;<br/>
using System.Runtime; // GCSettings is in this namespace<br/>
public static class Program { public static void Main() {<br/>
Console.WriteLineC'Application is running with server GC=&quot; + GCSettings.IsServerGC);<br/>
}<br/>
}</code></p>
<p>The Workstation GC mode can run in concurrent or non-concurrent mode In concurrent mode, the garbage collector has an additional background thread that collects objects concurrently while the application runs. When a thread allocates an object that pushes generation 0 over its budget, the garbage collector first suspends all threads and then determines which generations to collect. If the garbage collector needs to collect generation 0 or 1, it proceeds as normal. However, if generation 2 needs collecting, the size of generation 0 will be increased beyond its budget to allocate the new object, and then the application's threads are resumed.</p>
<p>While the application's threads are running, the garbage collector has a normal priority background thread that marks unreachable objects. This thread competes for CPU time with the application's threads, causing the application's tasks to execute more slowly. Once the objects are marked, the garbage collector suspends all threads again and decides whether to compact memory. If the garbage collector decides to compact memory, memory is compacted, root references are fixed up, and the application's threads are resumed. This garbage collection takes less time than usual because the set of unreachable objects has already been built. However, the garbage collector might decide not to compact memory; in fact, the garbage collector favors this approach. If you have a lot of free memory, the garbage collector won't compact the heap; this improves performance but grows your application's working set. When using the concurrent garbage collector, you'll typically find that your application is consuming more memory than it would with the non-concurrent garbage collector.</p>
<p>To summarize: Concurrent collection creates a better interactive experience for users and is therefore best for interactive CUI or GUI applications. For some applications, however, concurrent collection will actually hurt performance and will cause more memory to be used. When testing your application, you should experiment with and without concurrent collection and see which approach gives the best performance and memory usage for your application.</p>
<p>You can tell the CLR not to use the concurrent collector by creating a configuration file for the application (as discussed in Chapters 2 and 3) that contains a <b>gcConcurrent </b>element Here's an example of a configuration file:</p>
<p><code>&lt;configuration&gt;<br/>
&lt;runtime&gt;<br/>
&lt;gcConcurrent enabled=&quot;false&quot;/&gt;<br/>
&lt;/runtime&gt; &lt;/configuration&gt;</code></p>
<p>In addition to the modes just described, the garbage collector supports synchronization-free allocations. On a multiprocessor system, generation 0 of the managed heap is partitioned into multiple memory arenas, one arena per thread. This allows multiple threads to make allocations simultaneously so that exclusive access to the heap isn't required.</p>
<p>While the GC mode is configured for the process and it cannot change while the process runs, your application can have some control over the garbage collection by using the <b>GCSettings </b>class's <b>GCLatencyMode </b>property. This read/write property can be set to any of the values in the <b>GCLatencyMode </b>enumerated type, as shown in Table 21-2.</p>
<p><b>table </b><b>21-2 </b><b>Symbols Defined by the GCLatencyMode Enumerated Type</b></p>
<table border="1">
<tr>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>h</p>
<p>(default for the</p>
<p>Server GC mode)</p>
</td>
<td>
<p>In the Workstation GC mode, this latency mode turns off the concurrent GC. In the Server GC mode, this is the only valid latency mode.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
<p>(default for the Workstation GC mode)</p>
</td>
<td>
<p>In the Workstation GC mode, this latency mode turns on the concurrent GC. In the Server GC, this latency mode is not valid.</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>In the Workstation GC mode, you use this latency mode during short-term, time-sensitive operations (like drawing animations) where a generation 2 collection might be disruptive. In the Server GC, this latency mode is not valid.</p>
</td>
</tr>
</table>
<p>The <b>LowLatency </b>mode requires some additional explanation. Typically, you would set this mode, perform a short-term, time-sensitive operation, and then set the mode back to either <b>Batch </b>or <b>Interactive </b>. While the mode is set to <b>LowLatency, </b>the garbage collector will really avoid doing any generation 2 collections because these could take a long time. Of course, if you call <b>GC.Collect</b><b>O, </b>then generation 2 still gets collected. Also, the garbage collector will perform a generation 2 collection if Windows tells the CLR that system memory is low (see the &quot;What Causes <b>Finalize </b>Methods to Be Called&quot; section earlier in this chapter).</p>
<p>Under <b>LowLatency </b>mode, it is more likely that your application could get an <b>OutOfMemoryException </b>thrown. Therefore, stay in this mode for as short a time as possible, avoid allocating many objects, avoid allocating large objects, and set the mode back to <b>Batch </b>or <b>Interactive </b>using a constrained execution region (CER), as discussed in Chapter 20, &quot;Exceptions and State Management.&quot; Also, remember that the latency mode is a process-wide setting and threads may be running concurrently. These other threads could even change this setting while another thread is using it and so you may want to update some kind of counter (manipulated via <b>Interlocked </b>methods) when you have multiple threads manipulating this setting. Here is some code showing how to properly use the <b>LowLatency </b>mode:</p>
<p><code>private static void LowLatencyDemo() {<br/>
GCLatencyMode oldMode = GCSettings.LatencyMode;<br/>
System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsO;<br/>
try {<br/>
GCSettings.LatencyMode = GCLatencyMode.LowLatency; // Run your code here...<br/>
}<br/>
finally {<br/>
GCSettings.LatencyMode = oldMode;<br/>
}<br/>
}</code></p>
<a name="b588"/><h2>Large Objects</h2>
<p>There is one more performance improvement you might want to be aware of Any objects that are 85,000 bytes or more in size are considered to be large objects. Large objects are allocated from a special large object heap. Objects in this heap are finalized and freed just as the small objects I've been talking about However, large objects are never compacted because it would waste too much CPU time to shift 85,000-byte blocks of memory down in the heap. However, you should never write code that assumes that large objects do not move in memory because the size of large objects could change from 85,000 bytes to something else in the future To guarantee that an object doesn't move in memory, pin it as discussed in the &quot;Monitoring and Controlling the Lifetime of Objects Manually&quot; section earlier in this chapter.</p>
<p>Large objects are always considered part of generation 2, so you should create large objects only for resources that you need to keep alive for a long time. Allocating short-lived large objects will cause generation 2 to be collected more frequently, which will hurt performance. The following program proves that large objects are always allocated in generation 2:</p>
<p><code>using System;<br/>
public static class Program { public static void Main() { Object o = new Byte[85000];<br/>
Console.WriteLine(GC.GetGeneration(o));   // Displays 2; not 0<br/>
}<br/>
}</code></p>
<p>All of these mechanisms are transparent to your application code To you, the developer, it appears as if there is just one managed heap; these mechanisms exist simply to improve application performance.</p>
<a name="b589"/><h2>Monitoring Garbage Collections</h2>
<p>Within a process, there are a few methods that you can call to monitor the garbage collector Specifically, the <b>GC </b>class offers the following static methods, which you can call to see how many collections have occurred of a specific generation or how much memory is currently being used by objects in the managed heap:</p>
<p><code>Int64 GetTotalMemory(Boolean forceFullCollection); Int32 CollectionCount(Int32 generation);</code></p>
<p>To profile a particular code block, I have frequently written code to call these methods before and after the code block and then calculate the difference. This gives me a very good indication of how my code block has affected my process's working set and indicates how many garbage collections occurred while executing the code block If the numbers are high, I know to spend more time tuning the algorithms in my code block.</p>
<p>You can also see how much memory is being used by individual AppDomains as opposed to the whole process. For more information about this, see the &quot;AppDomain Monitoring&quot; section in Chapter 22.</p>
<p>When you install the .NET Framework, it installs a set of performance counters that offer a lot of real-time statistics about the CLR's operations These statistics are visible via the PerfMon exe tool or the System Monitor ActiveX control that ships with Windows. The easiest way to access the System Monitor control is to run PerfMon.exe and click the + toolbar button, which causes the Add Counters dialog box shown in Figure 21-16 to appear.</p>
<img src="76.jpg"/>
<p><b>Figure 21-16 </b>PerfMon.exe showing the .NET CLR Memory counters</p>
<p>To monitor the CLR's garbage collector, select the .NET CLR Memory performance object. Then select a specific application from the instance list box. Finally, select the set of counters that you're interested in monitoring, click Add, and then click OK. At this point, the System Monitor will graph the selected real-time statistics. For an explanation of a particular counter, select the desired counter and then select the Show Description check box.</p>
<p>Another great tool for monitoring your application's object allocations is the CLR Profiler. This tool offers call profiling, heap snapshots, and memory-use timelines. There is even an API that can be used from test code to start and stop profiling and inject comments into the logs. Also, the source code for this tool is available so that you can modify the tool for your own needs. The best way to acquire this tool is for you to search the Web for CLR profiler This tool is invaluable, and I highly recommend it.</p>
<p>Finally, you should look into using the SOS Debugging Extension (SOS dll), which can often offer great assistance when debugging memory problems and other CLR problems. For memory-related actions, the SOS Debugging Extension allows you to see how much memory is allocated within the process to the managed heap, displays all objects registered for finalization in the finalization queue, displays the entries in the GCHandle table per AppDomain or for the entire process, shows the roots that are keeping an object alive in the heap, and more.</p>
<mbp:pagebreak/>
<a name="Chapter22"/>
<h1>Chapter 22: CLR Hosting and AppDomains</h1>
<p><b>In this chapter:</b></p>
<a href="#b592">CLR Hosting</a><br/>
<a href="#b594">AppDomains</a><br/>
<a href="#b609">AppDomain Unloading</a><br/>
<a href="#b610">AppDomain Monitoring</a><br/>
<a href="#b612">AppDomain First-Chance Exception Notifications</a><br/>
<a href="#b612_">How Hosts Use AppDomains</a><br/>
<a href="#b615">Advanced Host Control</a><br/>
<p>In this chapter, I'll discuss two main topics that really show off the incredible value provided by the Microsoft .NET Framework: hosting and AppDomains. Hosting allows any application to utilize the features of the common language runtime (CLR). In particular, this allows existing applications to be at least partially written using managed code. Furthermore, hosting allows applications the ability to offer customization and extensibility via programming.</p>
<p>Allowing extensibility means that third-party code will be running inside your process. In Microsoft Windows, loading a third party's DLLs into a process has been fraught with peril The DLL could easily have code in it that could compromise the application's data structures and code. The DLL could also try to use the security context of the application to gain access to resources that it should not have access to The CLR's AppDomain feature solves all of these problems. AppDomains allow third-party untrusted code to run in an existing process, and the CLR guarantees that the data structures, code, and security context will not be exploited or compromised.</p>
<p>Programmers typically use hosting and AppDomains along with assembly loading and reflection. Using these four technologies together makes the CLR an incredibly rich and powerful platform. In this chapter, I'll focus on hosting and AppDomains. In the next chapter, I'll focus on assembly loading and reflection. When you learn and understand all of these technologies, you'll see how your investment in the .NET Framework today will certainly pay off down the line.</p>
<a name="b592"/><h2>CLR Hosting</h2>
<p>The .NET Framework runs on top of Microsoft Windows. This means that the .NET Framework must be built using technologies that Windows can interface with. For starters, all managed module and assembly files must use the Windows portable executable (PE) file format and be either a Windows executable (EXE) file or a DLL.</p>
<p>When developing the CLR, Microsoft implemented it as a COM server contained inside a DLL; that is, Microsoft defined a standard COM interface for the CLR and assigned GUIDs to this interface and the COM server. When you install the .NET Framework, the COM server representing the CLR is registered in the Windows registry just as any other COM server would. If you want more information about this topic, refer to the MetaHost. h C++ header file that ships with the .NET Framework SDK. This header file defines the GUIDs and the unmanaged <b>ICLRMetaHost </b>interface definition.</p>
<p>Any Windows application can host the CLR. However, you shouldn't create an instance of the CLR COM server by calling <b>CoCreateInstance; </b>instead, your unmanaged host should call the <b>CLRCreateInstance </b>function declared in MetaHost.h. The <b>CLRCreateInstance </b>function is implemented in the MSCorEE.dll file, which is usually found in the <span>C:\Windows\System32</span> directory. This DLL is affectionately referred to as the shim, and its job is to determine which version of the CLR to create; the shim DLL doesn't contain the CLR COM server itself</p>
<p>A single machine may have multiple versions of the CLR installed, but there will be only one version of the MSCorEE.dll file (the shim).<sup>1</sup> The version of MSCorEE.dll installed on the machine is the version that shipped with the latest version of the CLR installed on the machine. Therefore, this version of MSCorEE.dll knows how to find any previous versions of the CLR that may be installed.</p>
<p>The actual CLR code is contained in a file whose name has changed with different versions of the CLR. For versions 1. 0, 1.1, and 2.0, the CLR code is in a file called MSCorWks.dll, and for version 4. 0, the CLR code is in a file called Clr.dll. Since you can have multiple versions of the CLR installed on a single machine, these files are installed into different directories as follows <sup>2</sup></p>
<p>&#9632; Version 1. 0 is in <span>C:\Windows\Microsoft</span>.NET\Framework\v1.0.3705</p>
<p>&#9632; Version 1.1 is in <span>C:\Windows\Microsoft</span>.NET\Framework\v1.0.4322</p>
<p>&#9632; Version 2.0 is in <span>C:\Windows\Microsoft</span>.NET\Framework\v2.0. 50727</p>
<p>&#9632; Version 4. 0 is in <span>C:\Windows\Microsoft</span>.NET\Framework\v4. 0. 21006</p>
<p><sup>1</sup>.If you are using a 64-bit version of Windows, there are actually two versions of the MSCorEE.dll file installed. One version is the 32-bit x86 version, which will be in the <span>C:\Windows\SysWOW64</span> directory The other version is the 64-bit x64 or IA64 version (depending on your computer's CPU architecture), which will be in the <span>C:\Windows</span> <span>\System32</span> directory</p>
<p><sup>2</sup>.Note that versions 3.0 and 3.5 of the .NET Framework shipped with version 2.0 of the CLR; I do not show the directories for .NET Framework versions 3.0 and 3.5 because the CLR DLL loads from the v2.0.50727 directory</p>
<p>The <b>CLRCreateInstance </b>function can return an <b>ICLRMetaHost </b>interface A host application can call this interface's <b>GetRuntime </b>function, specifying the version of the CLR that the host would like to create. The shim then loads the desired version of the CLR into the host's process.</p>
<p>By default, when a managed executable starts, the shim examines the executable file and extracts the information indicating the version of the CLR that the application was built and tested with. However, an application can override this default behavior by placing <b>requiredRuntime </b>and <b>supportedRuntime </b>entries in its XML configuration file (described in Chapter 2, &quot;Building, Packaging, Deploying, and Administering Applications and Types,&quot; and Chapter 3, &quot;Shared Assemblies and Strongly Named Assemblies&quot;).</p>
<p>The <b>GetRuntime </b>function returns a pointer to the unmanaged <b>ICLRRuntimeInfo </b>interface from which the <b>ICLRRuntimeHost </b>interface is obtained via the <b>GetInterface </b>method. The hosting application can call methods defined by this interface to:</p>
<p>&#9632; Set Host managers. Tell the CLR that the host wants to be involved in making decisions related to memory allocations, thread scheduling/synchronization, assembly loading, and more. The host can also state that it wants notifications of garbage collection starts and stops and when certain operations time out.</p>
<p>&#9632; Get CLR managers. Tell the CLR to prevent the use of some classes/members. In addition, the host can tell which code can and can't be debugged and which methods in the host should be called when a special event耀uch as an AppDomain unload, CLR stop, or stack overflow exception熔ccurs.</p>
<p>&#9632; Initialize and start the CLR.</p>
<p>&#9632; Load an assembly and execute code in it.</p>
<p>&#9632; Stop the CLR, thus preventing any more managed code from running in the Windows process.</p>
<p>There are many reasons why hosting the CLR is useful. Hosting allows any application to offer CLR features and a programmability story and to be at least partially written in managed code. Any application that hosts the runtime offers many benefits to developers who are trying to extend the application. Here are some of the benefits:</p>
<p>&#9632; Programming can be done in any programming language.</p>
<p>&#9632; Code is just-in-time (JIT)-compiled for speed (versus being interpreted).</p>
<p>&#9632; Code uses garbage collection to avoid memory leaks and corruption.</p>
<p>&#9632; Code runs in a secure sandbox.</p>
<p>&#9632; The host doesn't need to worry about providing a rich development environment The host makes use of existing technologies: languages, compilers, editors, debuggers, profilers, and more.</p>
<p>If you are interesting in using the CLR for hosting scenarios, I highly recommend that you get Steven Pratschner's excellent book, Customizing the Microsoft .NET Framework Common Language Runtime (Microsoft Press 2005), even though it focuses on pre-4. 0 versions of the CLR.</p>
<hr/>
<blockquote><b>Note </b>Of course, a Windows process does not need to load the CLR at all. It needs to be loaded only if you want to execute managed code in a process. Prior to .NET Framework 4.0, the CLR allowed only one instance of itself to reside within a Windows process That is, a process could contain no CLR, v1. 0 of the CLR, v1.1 of the CLR, or v2.0 of the CLR. Allowing only one CLR version per process is a huge limitation. For example, Microsoft Office Outlook couldn't load two add-ins that were built and tested against different versions of the .NET Framework.</blockquote>
<hr/>
<p>However, with .NET Framework 4.0, Microsoft now supports the ability to load v2.0 and v4.0 in a single Windows process, allowing components written for NET Framework versions 2 0 and 4.0 to run side by side without experiencing any compatibility problems. This is a fantastic new feature, as it allows .NET Framework components to be used reliably in more scenarios than ever before. You can use the ClrVer.exe tool to see which CLR version(s) are loaded into any given process.</p>
<p>Once a CLR is loaded into a Windows process, it can never be unloaded; calling the <b>AddRef </b>and <b>Release </b>methods on the <b>ICLRRuntimeHost </b>interface has no effect The only way for the CLR to be unloaded from a process is for the process to terminate, causing Windows to clean up all resources used by the process.</p>
<a name="b594"/><h2>AppDomains</h2>
<p>When the CLR COM server initializes, it creates an AppDomain An AppDomain is a logical container for a set of assemblies. The first AppDomain created when the CLR is initialized is called the default AppDomain; this AppDomain is destroyed only when the Windows process terminates.</p>
<p>In addition to the default AppDomain, a host using either unmanaged COM interface methods or managed type methods can instruct the CLR to create additional AppDomains. The whole purpose of an AppDomain is to provide isolation. Here are the specific features offered by an AppDomain:</p>
<p>&#9632;   Objects created by code in one AppDomain cannot be accessed directly by code in</p>
<p>another AppDomain   When code in an AppDomain creates an object, that object is &quot;owned&quot; by that AppDomain. In other words, the object is not allowed to live beyond the lifetime of the AppDomain whose code constructed it Code in other AppDomains can access another AppDomain's object only by using marshal-by-reference or marshal-by-value semantics. This enforces a clean separation and boundary because code in one AppDomain can't have a direct reference to an object created by code in a different AppDomain. This isolation allows AppDomains to be easily unloaded from a process without affecting code running in other AppDomains.</p>
<p>&#9632; AppDomains can be unloaded The CLR doesn't support the ability to unload a single assembly from an AppDomain. However, you can tell the CLR to unload an AppDomain, which will cause all of the assemblies currently contained in it to be unloaded as well.</p>
<p>&#9632; AppDomains can be individually secured   When created, an AppDomain can have a permission set applied to it that determines the maximum rights granted to assemblies running in the AppDomain. This allows a host to load some code and be ensured that the code cannot corrupt or read important data structures used by the host itself</p>
<p>&#9632; AppDomains can be individually configured   When created, an AppDomain can have a bunch of configuration settings associated with it. These settings mostly affect how the CLR loads assemblies into the AppDomain. There are configuration settings related to search paths, version binding redirects, shadow copying, and loader optimizations.</p>
<hr/>
<blockquote><b>Important </b>A great feature of Windows is that it runs each application in its own process address space This ensures that code in one application cannot access code or data in use by another application. Process isolation prevents security holes, data corruption, and other unpredictable behaviors from occurring, making Windows and the applications running on it robust Unfortunately, creating processes in Windows is very expensive The Win32 CreateProcess function is very slow, and Windows requires a lot of memory to virtualize a process's address space.</blockquote>
<hr/>
<p>However, if an application consists entirely of managed code that is verifiably safe and doesn't call out into unmanaged code, there are no problems related to running multiple managed applications in a single Windows process And AppDomains provide the isolation required to secure, configure, and terminate each of these applications.</p>
<p>Figure 22-1 shows a single Windows process that has one CLR COM server running in it. This CLR is currently managing two AppDomains (although there is no hard-coded limit to the number of AppDomains that could be running in a single Windows process) Each AppDomain has its own loader heap, each of which maintains a record of which types have been accessed since the AppDomain was created These type objects were discussed in Chapter 4, &quot;Type Fundamentals&quot;; each type object in the loader heap has a method table, and each entry in the method table points to JIT-compiled native code if the method has been executed at least once.</p>
<img src="77.jpg"/>
<p><b>Figure 22-1 </b>A single Windows process hosting the CLR and two AppDomains</p>
<p>In addition, each AppDomain has some assemblies loaded into it. AppDomain #1 (the default AppDomain) has three assemblies: MyApp.exe, TypeLib.dll, and System, dll. AppDomain #2 has two assemblies loaded into it: Wintellect.dll and System, dll.</p>
<p>You'll notice that the System, dll assembly has been loaded into both AppDomains. If both AppDomains are using a single type from System dll, both AppDomains will have a type object for the same type allocated in each loader heap; the memory for the type object is not shared by all of the AppDomains. Furthermore, as code in an AppDomain calls methods defined by a type, the method's Intermediate Language (IL) code is JIT-compiled, and the resulting native code is associated with each AppDomain; the code for the method is not shared by all AppDomains that call it.</p>
<p>Not sharing the memory for the type objects or native code is wasteful. However, the whole purpose of AppDomains is to provide isolation; the CLR needs to be able to unload an AppDomain and free up all of its resources without adversely affecting any other AppDomain. Replicating the CLR data structures ensures that this is possible It also ensures that a type used by multiple AppDomains has a set of static fields for each AppDomain.</p>
<img src="78.jpg"/>
<p>Some assemblies are expected to be used by several AppDomains. The best example is MSCorLib.dll. This assembly contains <b>System.Object, System.Int32, </b>and all of the other types that are so integral to the .NET Framework. This assembly is automatically loaded when the CLR initializes, and all AppDomains share the types in this assembly To reduce resource usage, MSCorLib dll is loaded in an AppDomain-neutral fashion; that is, the CLR maintains a special loader heap for assemblies that are loaded in a domain-neutral fashion All type objects in this loader heap and all native code for methods of these types are shared by all AppDomains in the process. Unfortunately, the benefit gained by sharing these resources does come with a price: assemblies that are loaded domain-neutral can never be unloaded. The only way to reclaim the resources used by them is to terminate the Windows process to cause Windows to reclaim the resources.</p>
<h3>Accessing Objects Across AppDomain Boundaries</h3>
<p>Code in one AppDomain can communicate with types and objects contained in another AppDomain. However, access to these types and objects is allowed only through well-defined mechanisms. The Ch22-1-AppDomains sample application below demonstrates how to create a new AppDomain, load an assembly into it, and construct an instance of a type defined in that assembly. The code shows the different behaviors when constructing a type that is marshaled by reference, a type that is marshaled by value, and a type that can't be marshaled at all. The code also shows how these differently marshaled objects behave when the AppDomain that created them is unloaded. The Ch22-1-AppDomains sample application has very little code in it, but I have added a lot of comments. After the code listing, I'll walk through the code, explaining what the CLR is doing.</p>
<p><code>private static void MarshallingC) {<br/>
// Get a reference to the AppDomain that that calling thread is executing in AppDomain adCallingThreadDomain = Thread.GetDomainO;<br/>
// Every AppDomain is assigned a friendly string name (helpful for debugging) // Get this AppDomain's friendly string name and display it String callingDomainName = adCallingThreadDomain.FriendlyName; Console.WriteLineC'Default AppDomain's friendly name={0}&quot;, callingDomainName);<br/>
// Get &amp; display the assembly in our AppDomain that contains the 'Main' method String exeAssembly = Assembly.GetEntryAssemblyO.FullName; Console.WriteLineC'Main assembly={0}&quot;, exeAssembly);<br/>
// Define a local variable that can refer to an AppDomain AppDomain ad2 = null;<br/>
// *** DEMO 1: Cross-AppDomain Communication using Marshal-by-Reference *** Console.WriteLine(&quot;{0}Demo #1&quot;, Environment.NewLine);<br/>
// Create new AppDomain (security &amp; configuration match current AppDomain) ad2 = AppDomain.CreateDomain(&quot;AD #2&quot;, null, null); MarshalByRefType mbrt = null;<br/>
// Load our assembly into the new AppDomain, construct an object, marshal // it back to our AD (we really get a reference to a proxy) mbrt = (MarshalByRefType)<br/>
ad2.CreateInstanceAndUnwrap(exeAssembly, &quot;MarshalByRefType&quot;);<br/>
Console.WriteLine(&quot;Type={0}&quot;, mbrt.GetType());   // The CLR lies about the type<br/>
// Prove that we got a reference to a proxy object<br/>
Console.WriteLine(&quot;Is proxy={0}&quot;, RemotingServices.IsTransparentProxy(mbrt));<br/>
// This looks like we're calling a method on MarshalByRefType but, we're not. // We're calling a method on the proxy type. The proxy transitions the thread // to the AppDomain owning the object and calls this method on the real object. mbrt.SomeMethod();<br/>
// Unload the new AppDomain AppDomain.Unload(ad2);<br/>
// mbrt refers to a valid proxy object; the proxy object refers to an invalid AppDomain<br/>
try {<br/>
// We're calling a method on the proxy type. The AD is invalid, exception is thrown mbrt.SomeMethod();<br/>
Console.WriteLine(&quot;Successful call.&quot;);<br/>
}<br/>
catch (AppDomainUnloadedException) { Console.WriteLine(&quot;Failed call.&quot;);<br/>
}<br/>
// *** DEMO 2: Cross-AppDomain Communication using Marshal-by-Value *** Console.WriteLine(&quot;{0}Demo #2&quot;, Environment.NewLine);<br/>
// Create new AppDomain (security &amp; configuration match current AppDomain) ad2 = AppDomain.CreateDomainC'AD #2&quot;, null, null);<br/>
// Load our assembly into the new AppDomain, construct an object, marshal // it back to our AD (we really get a reference to a proxy) mbrt = (MarshalByRefType)<br/>
ad2.CreateInstanceAndUnwrap(exeAssembly, &quot;MarshalByRefType&quot;);<br/>
// The object's method returns a COPY of the returned object; // the object is marshaled by value (not be reference). MarshalByValType mbvt = mbrt.MethodWithReturn();<br/>
// Prove that we did NOT get a reference to a proxy object<br/>
Console.WriteLine(&quot;Is proxy={0}&quot;, RemotingServices.IsTransparentProxy(mbvt));<br/>
// This looks like we're calling a method on MarshalByValType and we are. Console.WriteLine(&quot;Returned object created &quot; + mbvt.ToString());<br/>
// Unload the new AppDomain AppDomain.Unload(ad2);<br/>
// mbvt refers to valid object; unloading the AppDomain has no impact.<br/>
try {<br/>
// We're calling a method on an object; no exception is thrown Console.WriteLineC'Returned object created &quot; + mbvt.ToStringO); Console.WriteLineC'Successful call.&quot;);<br/>
}<br/>
catch (AppDomainUnloadedException) { Console.WriteLineC'Failed call.&quot;);<br/>
}<br/>
// DEMO 3: Cross-AppDomain Communication using non-marshalable type *** Console.WriteLine(&quot;{0}Demo #3&quot;, Environment.NewLine);<br/>
// Create new AppDomain (security &amp; configuration match current AppDomain) ad2 = AppDomain.CreateDomainC'AD #2&quot;, null, null);<br/>
// Load our assembly into the new AppDomain, construct an object, marshal // it back to our AD (we really get a reference to a proxy) mbrt = (MarshalByRefType)<br/>
ad2.CreateInstanceAndUnwrap(exeAssembly, &quot;MarshalByRefType&quot;);<br/>
// The object's method returns an non-marshalable object; exception NonMarshalableType nmt = mbrt.MethodArgAndReturn(callingDomainName); // We won't get here...<br/>
}<br/>
// Instances can be marshaled-by-reference across AppDomain boundaries public sealed class MarshalByRefType : MarshalByRefObject { public MarshalByRefType() {<br/>
Console.WriteLine(&quot;{0} ctor running in {1}&quot;,<br/>
this.GetType().ToStringO, Thread.GetDomain().FriendlyName);<br/>
}<br/>
public void SomeMethod() {<br/>
Console.WriteLineC'Executing in &quot; + Thread.GetDomain().FriendlyName);<br/>
}<br/>
public MarshalByValType MethodWithReturn() {<br/>
Console.WriteLine(&quot;Executing in &quot; + Thread.GetDomain().FriendlyName); MarshalByValType t = new MarshalByValType(); return t;<br/>
}<br/>
public NonMarshalableType MethodArgAndReturn(String callingDomainName) { // NOTE: callingDomainName is [Serializable] Console.WriteLineC'Calling from '{0}' to '{1}'.&quot;,<br/>
callingDomainName, Thread.GetDomain().FriendlyName); NonMarshalableType t = new NonMarshalableType(); return t;<br/>
}<br/>
}<br/>
// Instances can be marshaled-by-value across AppDomain boundaries [Serializable]<br/>
public sealed class MarshalByValType : Object {<br/>
private DateTime m_creationTime = DateTime.Now; // NOTE: DateTime is [Serializable]<br/>
public MarshalByValType() {<br/>
Console.WriteLine(&quot;{0} ctor running in {1}, Created on {2:D}&quot;, this.GetType().ToString(), Thread.GetDomain().FriendlyName, m_creationTime);<br/>
}<br/>
public override String ToString() {<br/>
return m_creationTime.ToLongDateStringO;<br/>
}<br/>
}<br/>
// Instances cannot be marshaled across AppDomain boundaries // [Serializable]<br/>
public sealed class NonMarshalableType : Object { public NonMarshalableType() {<br/>
Console.WriteLine(&quot;Executing in &quot; + Thread.GetDomain().FriendlyName);<br/>
}<br/>
}</code></p>
<p>If you build and run the Ch22-1-AppDomains application, you get the following output: Default AppDomain's friendly name= Ch22-1-AppDomains.exe</p>
<p><code>Main assembly=Ch22-1-AppDomains, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null Demo #1<br/>
MarshalByRefType ctor running in AD #2<br/>
Type=MarshalByRefType<br/>
Is proxy=True<br/>
Executing in AD #2<br/>
Failed call.<br/>
Demo #2<br/>
MarshalByRefType ctor running in AD #2 Executing in AD #2<br/>
MarshalByValType ctor running in AD #2, Created on Friday, August 07, 2009 Is proxy=False<br/>
Returned object created Friday, August 07, 2009 Returned object created Friday, August 07, 2009 Successful call.<br/>
Demo #3<br/>
MarshalByRefType ctor running in AD #2<br/>
Calling from 'Ch22-1-AppDomains.exe' to 'AD #2'.<br/>
Executing in AD #2<br/>
Unhandled Exception: System.Runtime.Serialization.SerializationException:<br/>
Type 'NonMarshalableType' in assembly 'Ch22-1-AppDomains, Version=0.0.0.0,<br/>
Culture=neutral, PublicKeyToken=null' is not marked as serializable.<br/>
at MarshalByRefType.MethodArgAndReturn(String callingDomainName)<br/>
at Program.MarshallingO<br/>
at Program.MainO<br/>
is not marked as serializable.<br/>
at MarshalByRefType.MethodArgAndReturn(String callingDomainName) at Program.MarshallingO at Program.Main()</code></p>
<p>Now, I will discuss what this code and the CLR are doing.</p>
<p>Inside the <b>Marshalling </b>method, I first get a reference to an <b>AppDomain </b>object that identifies the AppDomain the calling thread is currently executing in. In Windows, a thread is always created in the context of one process, and the thread lives its entire lifetime in that process However, a one-to-one correspondence doesn't exist between threads and AppDomains. AppDomains are a CLR feature; Windows knows nothing about AppDomains. Since multiple AppDomains can be in a single Windows process, a thread can execute code in one AppDomain and then execute code in another AppDomain. From the CLR's perspective, a thread is executing code in one AppDomain at a time A thread can ask the CLR what AppDomain it is currently executing in by calling <b>System.Threading.Thread</b>'s static <b>GetDomain </b>method. The thread could also query <b>System.AppDomain</b>'s static, read-only <b>CurrentDomain </b>property to get the same information.</p>
<p>When an AppDomain is created, it can be assigned a friendly name. A friendly name is just a <b>String </b>that you can use to identify an AppDomain. This is typically useful in debugging scenarios. Since the CLR creates the default AppDomain before any of our code can run, the CLR uses the executable file's file name as the default AppDomain's friendly name. My <b>Marshalling </b>method queries the default AppDomain's friendly name by using <b>System.AppDomain</b>'s read-only <b>FriendlyName </b>property.</p>
<p>Next, my <b>Marshalling </b>method queries the strong-name identity of the assembly (loaded into the default AppDomain) that defines the entry point method <b>Main </b>that calls <b>Marshalling. </b>This assembly defines several types: <b>Program, MarshalByRefType, MarshalBy ValType, </b>and <b>NonMarshalableType </b>. At this point, we're ready to look at the three demos that are all pretty similar to each other.</p>
<h3>Demo #1: Cross-AppDomain Communication that Uses Marshal-by-Reference</h3>
<p>In Demo #1, <b>System.AppDomain</b>'s static <b>CreateDomain </b>method is called, instructing the CLR to create a new AppDomain in the same Windows process. The <b>AppDomain </b>type actually offers several overloads of the <b>CreateDomain </b>method; I encourage you to study them and select the version that is most appropriate when you are writing code to create a new AppDomain. The version of <b>CreateDomain </b>that I call accepts three arguments:</p>
<p><b>&#9632; A String identifying the friendly name I want assigned to the new AppDomain </b>I'm</p>
<p>passing in &quot;AD #2&quot; here.</p>
<p><b>&#9632; A System.Security.Policy.Evidence identifying the evidence that the CLR should use to calculate the AppDomain's permission set   </b>I'm passing <b>null </b>here so that the new AppDomain will inherit the same permission set as the AppDomain creating it</p>
<p>Usually, if you want to create a security boundary around code in an AppDomain, you'd construct a <b>System.Security.PermissionSet </b>object, add the desired permission objects to it (instances of types that implement the <b>IPermission </b>interface), and then pass the resulting <b>PermissionSet </b>object reference to the overloaded version of the <b>CreateDomain </b>method that accepts a <b>PermissionSet </b>.</p>
<p>&#9632;   A <b>System.AppDomainSetup </b>identifying the configuration settings the CLR should use for the new AppDomain   Again, I'm passing <b>null </b>here so that the new AppDomain will inherit the same configuration settings as the AppDomain creating it. If you want the AppDomain to have a special configuration, construct an <b>AppDomainSetup </b>object, set its various properties to whatever you desire such as the name of the configuration file for example, and then pass the resulting <b>AppDomainSetup </b>object reference to the <b>CreateDomain </b>method.</p>
<p>Internally, the <b>CreateDomain </b>method creates a new AppDomain in the process. This AppDomain will be assigned the specified friendly name, security, and configuration settings. The new AppDomain will have its very own loader heap, which will be empty because there are currently no assemblies loading into the new AppDomain. When you create an AppDomain, the CLR does not create any threads in this AppDomain; no code runs in the AppDomain unless you explicitly have a thread call code in the AppDomain.</p>
<p>Now to create an instance of an object in the new AppDomain, we must first load an assembly into the new AppDomain and then construct an instance of a type defined in this assembly. This is precisely what the call to <b>AppDomain</b>'s public, instance <b>CreateInstanceAndUnwrap </b>method does. When calling <b>CreateInstanceAndUnwrap, </b>I pass two arguments: a <b>String </b>identifying the assembly I want loaded into the new AppDomain (referenced by the <b>ad2 </b>variable) and another <b>String </b>identifying the name of the type that I want to construct an instance of Internally, <b>CreateInstanceAndUnwrap </b>causes the calling thread to transition from the current AppDomain into the new AppDomain. Now, the thread (which is inside the call to <b>CreateInstanceAndUnwrap) </b>loads the specified assembly into the new AppDomain and then scans the assembly's type definition metadata table, looking for the specified type (&quot;MarshalByRefType&quot;). After the type is found, the thread calls the <b>MarshalByRefType</b>'s parameterless constructor. Now the thread transitions back to the default AppDomain so that <b>CreateInstanceAndUnwrap </b>can return a reference to the new<b>MarshalByRefType </b>object.</p>
<hr/>
<blockquote><b>Note </b>There are overloaded versions of CreateInstanceAndUnwrap that allow you to call</blockquote>
<hr/>
<p>a type's constructor passing in arguments. <b>I_</b></p>
<p>While this sounds all fine and good, there is a problem: the CLR cannot allow a variable (root) living in one AppDomain to reference an object created in another AppDomain If <b>CreateInstanceAndUnwrap </b>simply returned the reference to the object, isolation would be broken, and isolation is the whole purpose of AppDomains! So just before <b>CreateInstanceAndUnwrap </b>returns the object reference, it performs some additional logic.</p>
<p>You'll notice that the <b>MarshalByRefType </b>type is derived from a very special base class: <b>System.MarshalByRefObject. </b>When <b>CreateInstanceAndUnwrap </b>sees that it is marshalling an object whose type is derived from <b>MarshalByRefObject, </b>the CLR will marshal the object by reference across the AppDomain boundaries. Here is what it means to marshal an object by reference from one AppDomain (the source AppDomain where the object is really created) to another AppDomain (the destination AppDomain from where <b>CreateInstanceAndUnwrap </b>is called).</p>
<p>When a source AppDomain wants to send or return the reference of an object to a destination AppDomain, the CLR defines a proxy type in the destination AppDomain's loader heap. This proxy type is defined using the original type's metadata, and therefore, it looks exactly like the original type; it has all of the same instance members (properties, events, and methods) The instance fields are not part of the type, but I'll talk more about this in a moment. This new type does have some instance fields defined inside of it, but these fields are not identical to that of the original data type. Instead, these fields indicate which AppDomain &quot;owns&quot; the real object and how to find the real object in the owning AppDomain. (Internally, the proxy object uses a <b>GCHandle </b>instance that refers to the real object. The <b>GCHandle </b>type is discussed in Chapter 21, &quot;Automatic Memory Management (Garbage Collection).&quot;</p>
<p>Once this type is defined in the destination AppDomain, <b>CreateInstanceAndUnwrap </b>creates an instance of this proxy type, initializes its fields to identify the source AppDomain and the real object, and returns a reference to this proxy object to the destination AppDomain. In my Ch22-1-AppDomains application, the <b>mbrt </b>variable will be set to refer to this proxy. Notice that the object returned from <b>CreateInstanceAndUnwrap </b>is actually not an instance of the <b>MarshalByRefType </b>type. The CLR will usually not allow you to cast an object of one type to an incompatible type. However, in this situation, the CLR does allow the cast because this new type has the same instance members as defined on the original type. In fact, if you use the proxy object to call <b>GetType, </b>it actually lies to you and says that it is a <b>MarshalByRefType </b>object.</p>
<p>However, it is possible to prove that the object returned from <b>CreateInstanceAndUnwrap </b>is actually a reference to a proxy object. To do this, my Ch22-1-AppDomains application calls <b>System.Runtime.Remoting.RemotingService</b>'s public, static <b>IsTransparentProxy </b>method passing in the reference returned from <b>CreateInstanceAndUnwrap </b>As you can see from the output, <b>IsTransparentProxy </b>returns <b>true, </b>indicating that the object is a proxy.</p>
<p>Now, my Ch22-1-AppDomains application uses the proxy to call the <b>SomeMethod </b>method. Since the <b>mbrt </b>variable refers to a proxy object, the proxy's implementation of this method is called. The proxy's implementation uses the information fields inside the proxy object to transition the calling thread from the default AppDomain to the new AppDomain. Any actions now performed by this thread run under the new AppDomain's security and configuration settings. Then, the thread uses the proxy object's <b>GCHandle </b>field to find the real object in the new AppDomain, and then it uses the real object to call the real <b>SomeMethod </b>method.</p>
<p>There are two ways to prove that the calling thread has transitioned from the default AppDomain to the new AppDomain. First, inside the <b>SomeMethod </b>method, I call <b>Thread.GetDomain</b><b>O</b><b>.FriendlyName </b>. This will return &quot;AD #2&quot; (as evidenced by the output) since the thread is now running in the new AppDomain created by using <b>AppDomain.CreateDomain </b>with &quot;AD #2&quot; as the friendly name parameter. Second, if you step through the code in a debugger and display the Call Stack window, the [AppDomain Transition] line marks where a thread has transitioned across an AppDomain boundary. See the Call Stack window near the bottom of Figure 22-2.</p>
<img src="79.jpg"/>
<p><b>Figure 22-2 </b>The Debugger's Call Stack window showing an AppDomain transition</p>
<p>When the real <b>SomeMethod </b>method returns, it returns to the proxy's <b>SomeMethod </b>method, which transitions the thread back to the default AppDomain, and then the thread continues executing code in the default AppDomain.</p>
<hr/>
<blockquote><b>Note </b>When a thread in one AppDomain calls a method in another AppDomain, the thread transitions between the two AppDomains. This means that method calls across AppDomain boundaries are executed synchronously. However, at any given time, a thread is considered to be in just one AppDomain, and it executes code using that AppDomain's security and configuration settings. If you want to execute code in multiple AppDomains concurrently, you should create additional threads and have them execute whatever code you desire in whatever AppDomains you desire.</blockquote>
<hr/>
<p>The next thing that my Ch22-1-AppDomains application does is call <b>AppDomain</b>'s public, static <b>Unload </b>method to force the CLR to unload the specified AppDomain including all of the assemblies loaded into it, and a garbage collection is forced to free up any objects that were created by code in the unloading AppDomain At this point, the default AppDomain's <b>mbrt </b>variable still refers to a valid proxy object; however, the proxy object no longer refers to a valid AppDomain (because it has been unloaded).</p>
<p>When the default AppDomain attempts to use the proxy object to call the <b>SomeMethod </b>method, the proxy's implementation of this method is called. The proxy's implementation determines that the AppDomain that contained the real object has been unloaded, and the proxy's <b>SomeMethod </b>method throws an <b>AppDomainUnloadedException </b>to let the caller know that the operation cannot complete.</p>
<p>Wow! The CLR team at Microsoft had to do a lot of work to ensure AppDomain isolation, but it is important work because these features are used heavily and are being used more and more by developers every day. Obviously, accessing objects across AppDomain boundaries by using marshal-by-reference semantics has some performance costs associated with it, so you typically want to keep the use of this feature to a minimum.</p>
<p>I promised you that I'd talk a little more about instance fields. A type derived from <b>MarshalByRefObject </b>can define instance fields. However, these instance fields are not defined as being part of the proxy type and are not contained inside a proxy object. When you write code that reads from or writes to an instance field of a type derived from <b>MarshalByRefObject, </b>the JIT compiler emits code that uses the proxy object (to find the real AppDomain/object) by calling <b>System.Object</b>'s <b>FieldGetter </b>or <b>FieldSetter </b>methods, respectively. These methods are private and undocumented; they are basically methods that use reflection to get and set the value in a field. So although you can access fields of a type derived from <b>MarshalByRefObject, </b>the performance is particularly bad because the CLR really ends up calling methods to perform the field access. In fact, the performance is bad even if the object that you are accessing is in your own AppDomain. <sup>3</sup></p>
<p>s</p>
<p>To demonstrate the significance of this performance hit, I wrote the following code:</p>
<p><code>private sealed class NonMBRO : Object{ public Int32 x; }<br/>
private sealed class MBRO      : MarshalByRefObject { public Int32 x; }<br/>
private static void FieldAccessTiming(){ const Int32 count = 10000000; NonMBRO nonMbro = new NonMBRO(); MBRO mbro = new MBRO();<br/>
Int64 time = Stopwatch.GetTimestamp<b>O;</b><br/>
for (Int32 c = 0; c &lt; count; c++) nonMbro.x++;<br/>
Console.WriteLine(&quot;{0:N0}&quot;, Stopwatch.GetTimestamp<b>O </b>- time);   // 134,174<br/>
time = Stopwatch.GetTimestamp<b>O;</b><br/>
for (Int32 c = 0; c &lt; count; c++) mbro.x++;<br/>
Console.WriteLine(&quot;{0:N0}&quot;, Stopwatch.GetTimestamp<b>O </b>- time);   // 1,533,886<br/>
}</code></p>
<p>If the CLR required that all fields be private (which is recommended for good data encapsulation), then the <b>FieldGetter </b>and <b>FieldSetter </b>methods wouldn't have to exist and accessing fields from methods could always have been direct, avoiding any performance penalty.</p>
<p>When I ran this code, it took 134,174 milliseconds to access the instance field of a <b>NonMBRO </b>class that is derived from <b>Object, </b>and it took 1,533,886 milliseconds to access the instance field of an <b>MBRO </b>class that is derived from <b>MarshalByRefObject </b>. So, accessing an instance field of a class derived from <b>MarshalByRefObject </b>takes more than 12 times longer!</p>
<p>From a usability standpoint, a type derived from <b>MarshalByRefObject </b>should really avoid defining any static members. The reason is that static members are always accessed in the context of the calling AppDomain No AppDomain transition can occur because a proxy object contains the information identifying which AppDomain to transition to, but there is no proxy object when calling a static member. Having a type's static members execute in one AppDomain while instance members execute in another AppDomain would make a very awkward programming model.</p>
<p>Since there are no roots in the second AppDomain, the original object referred to by the proxy could be garbage collected Of course, this is not ideal On the other hand, if the original object is held in memory indefinitely, then the proxy could go away and the original object would still live; this is also not ideal. The CLR solves this problem by using a lease manager. When a proxy for an object is created, the CLR keeps the object alive for 5 minutes. If no calls have been made through the proxy after 5 minutes, then the object is deactivated and will have its memory freed at the next garbage collection. After each call into the object, the lease manager renews the object's lease so that it is guaranteed to remain in memory for another 2 minutes before being deactivated If an application attempts to call into an object through a proxy after the object's lease has expired, the CLR throws a <b>System.Runtime. Remoting.RemotingException </b>.</p>
<p>It is possible to override the default lease times of 5 minutes and 2 minutes by overriding <b>MarshalByRefObject</b>'s virtual <b>InitializeLifetimeServices </b>method. For more information, see the section titled &quot;Lifetime Leases&quot; in the .NET Framework SDK documentation.</p>
<h3>Demo #2: Cross-AppDomain Communication Using Marshal-by-Value</h3>
<p>Demo #2 is very similar to Demo #1. Again, another AppDomain is created exactly as Demo #1 did it. Then, <b>CreateInstanceAndUnwrap </b>is called to load the same assembly into the new AppDomain and create an instance of a <b>MarshalByRefType </b>object in this new AppDomain. Next, the CLR creates a proxy to the object, and the <b>mbrt </b>variable (in the default AppDomain) is initialized referring to the proxy. Now, using the proxy, I call <b>MethodWithReturn. </b>This method, which takes no arguments, will execute in the new AppDomain to create an instance of the <b>MarshalByValType </b>type before returning a reference to the object to the default AppDomain.</p>
<p><b>MarshalByValType </b>is not derived from <b>System.MarshalByRefObject, </b>and therefore, the CLR cannot define a proxy type to create an instance from; the object can't be marshaled by reference across the AppDomain boundary.</p>
<p>However, since <b>MarshalByValType </b>is marked with the <b>[Serializable] </b>custom attribute, <b>MethodWithReturn </b>is allowed to marshal the object by value. The next paragraph describes what it means to marshal an object by value from one AppDomain (the source AppDomain) to another AppDomain (the destination AppDomain) For more information about the CLR&quot;s serialization and deserialization mechanisms, see Chapter 24, &quot;Runtime Serialization &quot;</p>
<p>When a source AppDomain wants to send or return a reference to an object to a destination AppDomain, the CLR serializes the object's instance fields into a byte array. This byte array is copied from the source AppDomain to the destination AppDomain Then, the CLR deserializes the byte array in the destination AppDomain This forces the CLR to load the assembly that defines the type being deserialized into the destination AppDomain if it is not already loaded. Then, the CLR creates an instance of the type and uses the values in the byte array to initialize the object's fields so that they have values identical to those they had in the original object. In other words, the CLR makes an exact duplicate of the source object in the destination's AppDomain. <b>MethodWithReturn </b>then returns a reference to this copy; the object has been marshaled by value across the AppDomain's boundary.</p>
<hr/>
<blockquote><b>Important </b>When loading the assembly, the CLR uses the destination AppDomain's policies and configuration settings (for example, the AppDomain can have a different AppBase directory or different version binding redirections). These policy differences might prevent the CLR from locating the assembly If the assembly cannot be loaded, an exception will be thrown, and the destination will not receive a reference to the object.</blockquote>
<hr/>
<p>At this point, the object in the source AppDomain and the object in the destination AppDomain live separate lifetimes, and their states can change independently of each other. If there are no roots in the source AppDomain keeping the original object alive (as in my Ch22-1-AppDomains application), its memory will be reclaimed at the next garbage collection.</p>
<p>To prove that the object returned from <b>MethodWithReturn </b>is not a reference to a proxy object, my Ch22-1-AppDomains application calls <b>System.Runtime.Remoting.RemotingService</b>'s public, static <b>IsTransparentProxy </b>method passing in the reference returned from <b>MethodWithReturn </b>. As you can see from the output, <b>IsTransparentProxy </b>returns <b>false, </b>indicating that the object is a real object, not a proxy.</p>
<p>Now, my program uses the real object to call the <b>ToString </b>method. Since the <b>mbvt </b>variable refers to a real object, the real implementation of this method is called, and no AppDomain transition occurs. This can be evidenced by examining the debugger's Call Stack window, which will not show an [Appdomain Transition] line.</p>
<p>To further prove that no proxy is involved, my Ch22-1-AppDomains application unloads the new AppDomain and then attempts to call the <b>ToString </b>method again. Unlike in Demo #1, the call succeeds this time because unloading the new AppDomain had no impact on objects &quot;owned&quot; by the default AppDomain, and this includes the object that was marshaled by value.</p>
<h3>Demo #3: Cross-AppDomain Communication Using Non-Marshalable Types</h3>
<p>Demo #3 starts out very similar to Demos #1 and #2. Just as in Demos #1 and #2, an AppDomain is created Then, <b>CreateInstanceAndUnwrap </b>is called to load the same assembly into the new AppDomain, create a <b>MarshalByValType </b>object in this new AppDomain, and have the <b>mbrt </b>variable refer to a proxy to this object.</p>
<p>Then, using this proxy, I call <b>MethodArgAndReturn, </b>which accepts an argument. Again, the CLR must maintain AppDomain isolation, so it cannot simply pass the reference to the argument into the new AppDomain. If the type of the object is derived from <b>MarshalByRefObject, </b>the CLR will make a proxy for it and marshal it by reference. If the object's type is marked as <b>[Serializable], </b>the CLR will serialize the object (and its children) to a byte array, marshal the byte array into the new AppDomain, and then deserialize the byte array into an object graph, passing the root of the object graph into the <b>MethodArgAndReturn </b>method.</p>
<p>In this particular demo, I am passing a <b>System.String </b>object across AppDomain boundaries. The <b>System.String </b>type is not derived from <b>MarshalByRefObject, </b>so the CLR cannot create a proxy. Fortunately, <b>System.String </b>is marked as <b>[Serializable], </b>and therefore the CLR can marshal it by value, which allows the code to work. Note that for <b>String </b>objects, the CLR performs a special optimization. When marshaling a <b>String </b>object across an AppDomain boundary, the CLR just passes the reference to the <b>String </b>object across the boundary; it does not make a copy of the <b>String </b>object. The CLR can offer this optimization because <b>String </b>objects are immutable; therefore, it is impossible for code in one AppDomain to corrupt a <b>String </b>object's characters. For more about <b>String </b>immutability, see Chapter 14, &quot;Chars, Strings, and Working with Text &quot;<sup>4</sup></p>
<p>Inside <b>MethodArgAndReturn, </b>I display the string passed into it to show that the string came across the AppDomain boundary, and then I create an instance of the <b>NonMarshalableType </b>type and return a reference to this object to the default AppDomain. Since <b>NonMarshalableType </b>is not derived from <b>System.MarshalByRefObject </b>and is also not marked with the <b>[Serializable] </b>custom attribute, <b>MethodArgAndReturn </b>is not allowed to marshal the object by reference or by value葉he object cannot be marshaled</p>
<p>By the way, this is why the <b>System.String </b>class is sealed. If the class were not sealed, then you could define your own class derived from <b>String </b>and add your own fields. If you did this, there is no way that the CLR could ensure that your &quot;string&quot; class was immutable.</p>
<p>across an AppDomain boundary at all! To report this, <b>MethodArgAndReturn </b>throws a <b>SerializationException </b>in the default AppDomain. Since my program doesn't catch this exception, the program just dies.</p>
<a name="b609"/><h2>AppDomain Unloading</h2>
<p>One of the great features of AppDomains is that you can unload them Unloading an AppDomain causes the CLR to unload all of the assemblies in the AppDomain, and the CLR frees the AppDomain's loader heap as well. To unload an AppDomain, you call <b>AppDomain</b>'s <b>Unload </b>static method (as the Ch22-1-AppDomains application does). This call causes the CLR to perform a lot of actions to gracefully unload the specified AppDomain:</p>
<p><b>1. </b>The CLR suspends all threads in the process that have ever executed managed code.</p>
<p><b>2. </b>The CLR examines all of the threads' stacks to see which threads are currently executing code in the AppDomain being unloaded or which threads might return at some point to code in the AppDomain that is being unloaded. The CLR forces any threads that have the unloading AppDomain on their stack to throw a <b>ThreadAbortException </b>(resuming the thread's execution) This causes the threads to unwind, executing any <b>finally </b>blocks on their way out so that cleanup code executes. If no code catches the <b>ThreadAbortException, </b>it will eventually become an unhandled exception that the CLR swallows; the thread dies, but the process is allowed to continue running This is unusual because for all other unhandled exceptions, the CLR kills the process.</p>
<hr/>
<blockquote><b>Important </b>The CLR will not immediately abort a thread that is currently executing code in a <b>finally </b>block, <b>catch </b>block, a class constructor, a critical execution region, or in unmanaged code. If the CLR allowed this, cleanup code, error recovery code, type initialization code, critical code, or arbitrary code that the CLR knows nothing about would not complete, resulting in the application behaving unpredictably and with potential security holes. An aborting thread is allowed to finish executing these code blocks and then, at the end of the code block, the CLR forces the thread to throw a <b>ThreadAbortException.</b></blockquote>
<hr/>
<p><b>3. </b>After all threads discovered in step #2 have left the AppDomain, the CLR then walks the heap and sets a flag in each proxy object that referred to an object created by the unloaded AppDomain. These proxy objects now know that the real object they referred to is gone. If any code now calls a method on an invalid proxy object, the method will throw an <b>AppDomainUnloadedException </b>.</p>
<p><b>4. </b>The CLR forces a garbage collection to occur, reclaiming the memory used by any objects that were created by the now unloaded AppDomain. The <b>Finalize </b>methods for these objects are called, giving the objects a chance to clean themselves up properly.</p>
<p><b>5. </b>The CLR resumes all of the remaining threads. The thread that called <b>AppDomain. Unload </b>will now continue running; calls to <b>AppDomain.Unload </b>occur synchronously.</p>
<p>My Ch22-1-AppDomains application uses just one thread to do all of the work. Whenever my code calls <b>AppDomain.Unload, </b>there are no threads in the unloading AppDomain, and therefore, the CLR doesn't have to throw any <b>ThreadAbortException </b>exceptions. I'll talk more about <b>ThreadAbortException </b>later in this chapter.</p>
<p>By the way, when a thread calls <b>AppDomain.Unload, </b>the CLR waits 10 seconds for the threads in the unloading AppDomain to leave it. If after 10 seconds, the thread that called <b>AppDomain.Unload </b>doesn't return, it will throw a <b>CannotUnloadAppDomainException, </b>and the AppDomain may or may not be unloaded in the future.</p>
<hr/>
<blockquote><b>Note </b>If a thread calling <b>AppDomain.Unload </b>is in the AppDomain being unloaded, the CLR creates another thread that attempts to unload the AppDomain. The first thread will forcibly throw the <b>ThreadAbortException </b>and unwind. The new thread will wait for the AppDomain to unload, and then the new thread terminates If the AppDomain fails to unload, the new thread will process a <b>CannotUnloadAppDomainException, </b>but since you did not write the code that this new thread executes, you can't catch this exception.</blockquote>
<hr/>
<a name="b610"/><h2>AppDomain Monitoring</h2>
<p>A host application can monitor the resources that an AppDomain consumes Some hosts will use this information to decide when to forcibly unload an AppDomain should its memory or CPU consumption rise above what the host considers reasonable. Monitoring can also be used to compare the resource consumption of different algorithms to determine which uses fewer resources. Because AppDomain monitoring incurs additional overhead, hosts must explicitly turn the monitoring on by setting <b>AppDomain</b>'s static <b>MonitoringEnabled </b>property to <b>true </b>This turns on monitoring for all AppDomains Once monitoring is turned on, it cannot be turned off; attempting to set the <b>MonitoringEnabled </b>property to <b>false </b>causes an <b>ArgumentException </b>to be thrown.</p>
<p>Once monitoring is turned on, your code can query the following four read-only properties offered by the AppDomain class:</p>
<p><b>&#9632; </b><a href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.AppDomain/property:MonitoringSurvivedProcessMemorySize:Int64"><b>MonitoringSurvivedProcessMemorySize</b></a><b>   </b>This static <b>Int64 </b>property returns the number of bytes that are currently in use by all AppDomains controlled by the current CLR instance The number is accurate as of the last garbage collection.</p>
<p><b>&#9632; MonitoringTotalAllocatedMemorySize   </b>This instance <b>Int64 </b>property returns the number of bytes that have been allocated by a specific AppDomain. The number is accurate as of the last garbage collection.</p>
<p><b>&#9632; MonitoringSurvivedMemorySize   </b>This instance <b>Int64 </b>property returns the number of bytes that are currently in use by a specific AppDomain. The number is accurate as of the last garbage collection.</p>
<p><b>&#9632;   MonitoringTotalProcessorTime   </b>This instance <b>TimeSpan </b>property returns the amount of CPU usage incurred by a specific AppDomain.</p>
<p>The following class shows how to use three of these properties to see what has changed within an AppDomain between two points in time:</p>
<p><code>private sealed class AppDomainMonitorDelta : IDisposable { private AppDomain m_appDomain; private TimeSpan m_thisADCpu; private Int64 m_thisADMemoryInUse; private Int64 m_thisADMemoryAllocated;<br/>
static AppDomainMonitorDelta() {<br/>
// Make sure that AppDomain monitoring is turned on AppDomain.MonitoringIsEnabled = true;<br/>
}<br/>
public AppDomainMonitorDelta(AppDomain ad) { m_appDomain = ad ?? AppDomain.CurrentDomain; m_thisADCpu = m_appDomain.MonitoringTotalProcessorTime; m_thisADMemoryInUse = m_appDomain.MonitoringSurvivedMemorySize; m_thisADMemoryAllocated = m_appDomain.MonitoringTotalA11ocatedMemorySize;<br/>
}<br/>
public void Dispose() { GC.CollectO;<br/>
Console.WriteLine(&quot;FriendlyName={0}, CPU={1}ms&quot;, m_appDomain.FriendlyName,<br/>
Cm_appDomain.MonitoringTotalProcessorTime - m_thisADCpu).TotalMilliseconds);<br/>
Console.WriteLineC&quot;     Allocated {0:N0} bytes of which {1:N0} survived GCs&quot;, m_appDomain.MonitoringTotalA11ocatedMemorySize - m_thisADMemoryAllocated, m_appDomain.MonitoringSurvivedMemorySize - m_thisADMemoryInUse);<br/>
}<br/>
}</code></p>
<p>The following code shows how to use the AppDomainMonitorDelta class:</p>
<p><code>private static void AppDomainResourceMonitoringO { using (new AppDomainMonitorDelta(null)) {<br/>
// Allocate about 10 million bytes that will survive collections var list = new List&lt;Object&gt;();<br/>
for (Int32 x = 0; x &lt; 1000; x++) 1ist.Add(new Byte[10000]);<br/>
// Allocate about 20 million bytes that will NOT survive collections for (Int32 x = 0; x &lt; 2000; x++) new Byte[10000].GetType();<br/>
// Spin the CPU for about 5 seconds<br/>
Int64 stop = Environment.TickCount + 5000;<br/>
while (Environment.TickCount &lt; stop).<br/>
}<br/>
}</code></p>
<p>When I execute this code, I get the following output:</p>
<p><code>FriendlyName=03-Ch22-1-AppDomains.exe, CPU=5031.2 5ms<br/>
Allocated 30,159,496 bytes of which 10,085,080 survived GCs</code></p>
<a name="b612"/><h2>AppDomain First-Chance Exception Notifications</h2>
<p>Each AppDomain can have associated with it a series of callback methods that get invoked when the CLR begins looking for <b>catch </b>blocks within an AppDomain. These methods can perform logging, or a host can use this mechanism to monitor exceptions being thrown within an AppDomain. The callbacks cannot handle the exception or swallow it in any way; they are just receiving a notification that the exception has occurred. To register a callback method, just add a delegate to AppDomain's instance <b>FirstChanceException </b>event.</p>
<p>Here is how the CLR processes an exception: When the exception is first thrown, the CLR invokes any <b>FirstChanceException </b>callback methods registered with the AppDomain that is throwing the exception. Then, the CLR looks for any <b>catch </b>blocks on the stack that are within the same AppDomain. If a <b>catch </b>block handles the exception, then processing of the exception is complete and execution continues as normal. If the AppDomain has no <b>catch </b>block to handle the exception, then the CLR walks up the stack to the calling AppDomain and throws the same exception object again (after serializing and deserializing it). At this point, it is as if a brand new exception is being thrown, and the CLR invokes any <b>FirstChanceException </b>callback methods registered with the now current AppDomain. This continues until the top of the thread's stack is reached. At that point, if the exception is not handled by any code, the CLR terminates the whole process.</p>
<a name="b612_"/><h2>How Hosts Use AppDomains</h2>
<p>So far, I've talked about hosts and how they load the CLR. I've also talked about how the hosts tell the CLR to create and unload AppDomains To make the discussion more concrete, I'll describe some common hosting and AppDomain scenarios In particular, I'll explain how different application types host the CLR and how they manage AppDomains.</p>
<h3>Executable Applications</h3>
<p>Console UI applications, NT Service applications, Windows Forms applications, and Windows Presentation Foundation (WPF) applications are all examples of self-hosted applications that have managed EXE files. When Windows initializes a process using a managed EXE file, Windows loads the shim and the shim examines the CLR header information contained in the application's assembly (the EXE file). The header information indicates the version of the CLR that was used to build and test the application The shim uses this information to determine which version of the CLR to load into the process After the CLR loads and initializes, it again examines the assembly's CLR header to determine which method is the application's entry point <b>(Main) </b>. The CLR invokes this method, and the application is now up and running.</p>
<p>As the code runs, it accesses other types When referencing a type contained in another assembly, the CLR locates the necessary assembly and loads it into the same AppDomain. Any additionally referenced assemblies also load into the same AppDomain. When the application's <b>Main </b>method returns, the Windows process terminates (destroying the default AppDomain and all other AppDomains).</p>
<hr/>
<blockquote><b>Note </b>By the way, you can call <b>System.Environment</b>'s static <b>Exit </b>method if you want to shut down the Windows process including all of its AppDomains. <b>Exit </b>is the most graceful way of terminating a process because it first calls the <b>Finalize </b>methods of all of the objects on the managed heap and then releases all of the unmanaged COM objects held by the CLR. Finally, <b>Exit </b>calls the Win32 <b>ExitProcess </b>function.</blockquote>
<hr/>
<p>It's possible for the application to tell the CLR to create additional AppDomains in the process's address space. In fact, this is what my Ch22-1-AppDomains application did.</p>
<h3>Microsoft Silverlight Rich Internet Applications</h3>
<p>Microsoft's Silverlight runtime technology uses a special CLR that is different from the normal desktop version of the NET Framework Once the Silverlight runtime is installed, navigating to a Web site that uses Silverlight causes the Silverlight CLR (CoreClr.dll) to load in your browser (which may or may not be Windows Internet Explorer遥ou may not even be using a Windows machine) Each Silverlight control on the page runs in its own AppDomain When the user closes a tab or navigates to another Web site, any Silverlight controls no longer in use have their AppDomains unloaded. The Silverlight code running in the AppDomain runs in a limited-security sandbox so that it cannot harm the user or the machine in any way.</p>
<h3>Microsoft ASP.NET Web Forms and XML Web Services Applications</h3>
<p>ASP.NET is implemented as an ISAPI DLL (implemented in ASPNetJSAPI.dll). The first time a client requests a URL handled by the ASP.NET ISAPI DLL, ASP.NET loads the CLR. When a client makes a request of a Web application, ASP.NET determines if this is the first time a request has been made. If it is, ASP.NET tells the CLR to create a new AppDomain for this Web application; each Web application is identified by its virtual root directory. ASP.NET then tells the CLR to load the assembly that contains the type exposed by the Web application into this new AppDomain, creates an instance of this type, and starts calling methods in it to satisfy the client's Web request If the code references more types, the CLR will load the required assemblies into the Web application's AppDomain.</p>
<p>When future clients make requests of an already running Web application, ASP.NET doesn't create a new AppDomain; instead, it uses the existing AppDomain, creates a new instance of the Web application's type, and starts calling methods. The methods will already be JIT-compiled into native code, so the performance of processing all subsequent client requests is excellent.</p>
<p>If a client makes a request of a different Web application, ASP.NET tells the CLR to create a new AppDomain. This new AppDomain is typically created inside the same worker process as the other AppDomains. This means that many Web applications run in a single Windows process, which improves the efficiency of the system overall. Again, the assemblies required by each Web application are loaded into an AppDomain created for the sole purpose of isolating that Web application's code and objects from other Web applications.</p>
<p>A fantastic feature of ASP.NET is that the code for a Web site can be changed on the fly without shutting down the Web server. When a Web site's file is changed on the hard disk, ASP. NET detects this, unloads the AppDomain that contains the old version of the files (when the last currently running request finishes), and then creates a new AppDomain, loading into it the new versions of the files. To make this happen, ASP.NET uses an AppDomain feature called shadow copying.</p>
<h3>Microsoft SQL Server</h3>
<p>Microsoft SQL Server is an unmanaged application because most of its code is still written in unmanaged C++. SQL Server allows developers to create stored procedures by using managed code. The first time a request comes in to the database to run a stored procedure written in managed code, SQL Server loads the CLR Stored procedures run in their own secured AppDomain, prohibiting the stored procedures from adversely affecting the database server.</p>
<p>This functionality is absolutely incredible! It means that developers will be able to write stored procedures in the programming language of their choice. The stored procedure can use strongly typed data objects in its code. The code will also be JIT-compiled into native code when executed instead of being interpreted And developers can take advantage of any types defined in the Framework Class Library (FCL) or in any other assembly. The result is that our job becomes much easier and our applications perform much better. What more could a developer ask for?!</p>
<h3>Your Own Imagination</h3>
<p>Productivity applications such as word processors and spreadsheets also allow users to write macros in any programming language they choose. These macros will have access to all of the assemblies and types that work with the CLR. They will be compiled, so they will execute fast, and, most important, these macros will run in a secure AppDomain so that users don't get hit with any unwanted surprises. Your own applications can use this ability, too, in any way you want.</p>
<a name="b615"/><h2>Advanced Host Control</h2>
<p>In this section, I'll mention some more advanced topics related to hosting the CLR. My intent is to give you a taste of what is possible, and this will help you to understand more of what the CLR is capable of. I encourage you to seek out other texts if you find this information particularly interesting.</p>
<h3>Managing the CLR by Using Managed Code</h3>
<p>The <b>System.AppDomainManager </b>class allows a host to override CLR default behavior by using managed code instead of using unmanaged code Of course, using managed code makes implementing a host easier. All you need to do is define your class and derive it from the <b>System.AppDomainManager </b>class, overriding any virtual methods where you want to take over control. Your class should then be built into its very own assembly and installed into the global assembly cache (GAC) because the assembly needs to be granted full-trust, and all assemblies in the GAC are always granted full-trust.</p>
<p>Then, you need to tell the CLR to use your <b>AppDomainManager</b>-derived class. In code, the best way to do this is to create an <b>AppDomainSetup </b>object initializing its <b>AppDomainManagerAssembly </b>and <b>AppDomainManagerType </b>properties, both of which are of type <b>String. </b>Set the <b>AppDomainManagerAssembly </b>property to the string identifying the strong-name identity of the assembly that defines your <b>AppDomainManager-</b>derived class, and then set the <b>AppDomainManagerType </b>property to the full name of your <b>AppDomainManager</b>-derived class. Alternatively, <b>AppDomainManager </b>can be set in your application's XML configuration file by using the <b>appDomainManagerAssembly </b>and <b>appDomain-ManagerType </b>elements. In addition, a native host could query for the <b>ICLRControl </b>interface and call this interface's <b>SetAppDomainManagerType </b>function, passing in the identity of the GAC-installed assembly and the name of the <b>AppDomainManager</b>-derived class. <sup>5</sup></p>
<p>Now, let's talk about what an <b>AppDomainManager</b>-derived class can do. The purpose of the <b>AppDomainManager</b>-derived class is to allow a host to maintain control even when an add-in tries to create AppDomains of its own When code in the process tries to create a new AppDomain, the <b>AppDomainManager</b>-derived object in that AppDomain can modify security and configuration settings. It can also decide to fail an AppDomain creation, or it can decide to return a reference to an existing AppDomain instead. When a new AppDomain is created, the CLR creates a new <b>AppDomainManager</b>-derived object in the AppDomain. This object can also modify configuration settings, how execution context is flowed between threads, and permissions granted to an assembly.</p>
<p>It is also possible to configure an <b>AppDomainManager </b>by using environment variables and registry settings, but these mechanisms are more cumbersome than the methods mentioned in the text and should be avoided except for some testing scenarios.</p>
<h3>Writing a Robust Host Application</h3>
<p>A host can tell the CLR what actions to take when a failure occurs in managed code Here are some examples (listed from least severe to most severe):</p>
<p>&#9632; The CLR can abort a thread if the thread is taking too long to execute and return a response. (I'll discuss this more in the next section.)</p>
<p>&#9632; The CLR can unload an AppDomain This aborts all of the threads that are in the AppDomain and causes the problematic code to be unloaded.</p>
<p>&#9632; The CLR can be disabled This stops any more managed code from executing in the process, but unmanaged code is still allowed to run.</p>
<p>&#9632; The CLR can exit the Windows process This aborts all of the threads and unloads all of the AppDomains first so that cleanup operations occur, and then the process terminates.</p>
<p>The CLR can abort a thread or AppDomain gracefully or rudely. A graceful abort means that cleanup code executes. In other words, code in <b>finally </b>blocks runs, and objects have their <b>Finalize </b>methods executed. A rude abort means that cleanup code does not execute. In other words, code in <b>finally </b>blocks may not run, and objects may not have their <b>Finalize </b>methods executed. A graceful abort cannot abort a thread that is in a <b>catch </b>or <b>finally </b>block. However, a rude abort will abort a thread that is in a <b>catch </b>or <b>finally </b>block. Unfortunately, a thread that is in unmanaged code or in a constrained execution region (CER) cannot be aborted at all.</p>
<p>A host can set what is called an escalation policy, which tells the CLR how to deal with managed code failures For example, SQL Server tells the CLR what to do should an unhandled exception be thrown while the CLR is executing managed code When a thread experiences an unhandled exception, the CLR first attempts to upgrade the exception to a graceful thread abort. If the thread does not abort in a specified time period, the CLR attempts to upgrade the graceful thread abort to a rude thread abort.</p>
<p>What I just described is what usually happens. However, if the thread experiencing the unhandled exception is in a critical region, the policy is different. A thread that is in a critical region is a thread that has entered a thread synchronization lock that must be released by the same thread, for example, a thread that has called <b>Monitor.Enter, Mutex</b>'s <b>WaitOne, </b>or one of <b>ReaderWriterLock</b>'s <b>AcquireReaderLock </b>or <b>AcquireWriterLock </b>methods. <sup>6 </sup>Successfully waiting for an <b>AutoResetEvent, ManualResetEvent, </b>or <b>Semaphore </b>doesn't cause the thread to be in a critical region because another thread can signal these synchronization objects When a thread is in a critical region, the CLR believes that the thread is</p>
<p>All of these locks internally call <b>Thread</b>'s <b>BeginCriticalRegion </b>and <b>EndCriticalRegion </b>methods to indicate when they enter and leave critical regions Your code can call these methods too if you need to Normally, this would be necessary only if you are interoperating with unmanaged code.</p>
<p>accessing data that is shared by multiple threads in the same AppDomain. After all, this is probably why the thread took the lock. If the thread is accessing shared data, just terminating the thread isn't good enough because other threads may then try to access the shared data that is now corrupt, causing the AppDomain to run unpredictably or with possible security vulnerabilities.</p>
<p>So when a thread in a critical region experiences an unhandled exception, the CLR first attempts to upgrade the exception to a graceful AppDomain unload in an effort to get rid of all of the threads and data objects that are currently in use. If the AppDomain doesn't unload in a specified amount of time, the CLR upgrades the graceful AppDomain unload to a rude AppDomain unload.</p>
<h3>How a Host Gets Its Thread Back</h3>
<p>Normally, a host application wants to stay in control of its threads Let's take a database server as an example When a request comes into the database server, a thread picks up the request and then dispatches the request to another thread that is to perform the actual work. This other thread may need to execute code that wasn't created and tested by the team that produced the database server. For example, imagine a request coming into the database server to execute a stored procedure written in managed code by the company running the server It's great that the database server can run the stored procedure code in its own AppDomain, which is locked down with security. This prevents the stored procedure from accessing any objects outside of its own AppDomain, and it also prevents the code from accessing resources that it is not allowed to access, such as disk files or the clipboard.</p>
<p>But what if the code in the stored procedure enters an infinite loop? In this case, the database server has dispatched one of its threads into the stored procedure code, and this thread is never coming back. This puts the server in a precarious position; the future behavior of the server is unknown. For example, the performance might be terrible now because a thread is in an infinite loop. Should the server create more threads? Doing so uses more resources (such as stack space), and these threads could also enter an infinite loop themselves.</p>
<p>To solve these problems, the host can take advantage of thread aborting. Figure 22-3 shows the typical architecture of a host application trying to solve the runaway thread problem. Here's how it works (the numbers correspond to the circled numbers in the figure):</p>
<p><b>1. </b>A client sends a request to the server.</p>
<p><b>2. </b>A server thread picks up this request and dispatches it to a thread pool thread to perform the actual work.</p>
<p><b>3. </b>A thread pool thread picks up the client request and executes trusted code written by the company that built and tested the host application.</p>
<p><b>4. </b>This trusted code then enters a <b>try </b>block, and from within the <b>try </b>block, calls across an AppDomain boundary (via a type derived from <b>MarshalByRefObject). </b>This AppDomain contains the untrusted code (perhaps a stored procedure) that was not built and tested by the company that produced the host application. At this point, the server has given control of its thread to some untrusted code; the server is feeling nervous right now.</p>
<p><b>5. </b>When the host originally received the client's request, it recorded the time. If the untrusted code doesn't respond to the client in some administrator-set amount of time, the host calls <b>Thread</b>'s <b>Abort </b>method asking the CLR to stop the thread pool thread, forcing it to throw a <b>ThreadAbortException </b>.</p>
<p><b>6. </b>At this point, the thread pool thread starts unwinding, calling <b>finally </b>blocks so that cleanup code executes. Eventually, the thread pool thread crosses back over the AppDomain boundary. Since the host's stub code called the untrusted code from inside a <b>try </b>block, the host's stub code has a <b>catch </b>block that catches the <b>ThreadAbortException </b>.</p>
<p><b>7. </b>In response to catching the <b>ThreadAbortException, </b>the host calls <b>Thread</b>'s <b>ResetAbort </b>method. I'll explain the purpose of this call shortly.</p>
<p><b>8. </b>Now that the host's code has caught the <b>ThreadAbortException, </b>the host can return some sort of failure back to the client and allow the thread pool thread to return to the pool so that it can be used for a future client request.</p>
<img src="80.jpg"/>
<p><b>Figure 22-3 </b>How a host application gets its thread back</p>
<p>Let me now clear up a few loose ends about this architecture. First, <b>Thread</b>'s <b>Abort </b>method is asynchronous. When <b>Abort </b>is called, it sets the target thread's <b>AbortRequested </b>flag and returns immediately When the runtime detects that a thread is to be aborted, the runtime tries to get the thread to a safe place. A thread is in a safe place when the runtime feels that it can stop what the thread is doing without causing disastrous effects. A thread is in a safe place if it is performing a managed blocking operation such as sleeping or waiting. A thread can be corralled to a safe place by using hijacking (described in Chapter 21). A thread is not in a safe place if it is executing a type's class constructor, code in a <b>catch </b>or <b>finally </b>block, code in a CER, or unmanaged code.</p>
<p>Once the thread reaches a safe place, the runtime will detect that the <b>AbortRequested </b>flag is set for the thread. This causes the thread to throw a <b>ThreadAbortException. </b>If this exception is not caught, the exception will be unhandled, all pending <b>finally </b>blocks will execute, and the thread will kill itself gracefully. Unlike all other exceptions, an unhandled <b>ThreadAbortException </b>does not cause the application to terminate. The runtime silently eats this exception and the thread dies, but the application and all of its remaining threads continue to run just fine.</p>
<p>In my example, the host catches the <b>ThreadAbortException, </b>allowing the host to regain control of the thread and return it to the pool. But there is a problem: What is to stop the untrusted code from catching the <b>ThreadAbortException </b>itself to keep control of the thread? The answer is that the CLR treats the <b>ThreadAbortException </b>in a very special manner. Even when code catches the <b>ThreadAbortException, </b>the CLR doesn't allow the exception to be swallowed. In other words, at the end of the <b>catch </b>block, the CLR automatically rethrows the <b>ThreadAbortException </b>exception.</p>
<p>This CLR feature raises another question: If the CLR rethrows the <b>ThreadAbortException </b>at the end of a <b>catch </b>block, how can the host catch it to regain control of the thread? Inside the host's <b>catch </b>block, there is a call to <b>Thread</b>'s <b>ResetAbort </b>method. Calling this method tells the CLR to stop rethrowing the <b>ThreadAbortException </b>at the end of each <b>catch </b>block.</p>
<p>This raises yet another question: What's to stop the untrusted code from catching the <b>ThreadAbortException </b>and calling <b>Thread</b>'s <b>ResetAbort </b>method itself to keep control of the thread? The answer is that <b>Thread</b>'s <b>ResetAbort </b>method requires the caller to have the <b>SecurityPermission </b>with the <b>ControlThread </b>flag set to <b>true. </b>When the host creates the AppDomain for the untrusted code, the host will not grant this permission, and now, the untrusted code cannot keep control of the host's thread.</p>
<p>I should point out that there is still a potential hole in this story: While the thread is unwinding from its <b>ThreadAbortException, </b>the untrusted code can execute <b>catch </b>and <b>finally </b>blocks. Inside these blocks, the untrusted code could enter an infinite loop, preventing the host from regaining control of its thread. A host application fixes this problem by setting an escalation policy (discussed earlier). If an aborting thread doesn't finish in a reasonable amount of time, the CLR can upgrade the thread abort to a rude thread abort, a rude AppDomain unload, disabling of the CLR, or killing of the process I should also note that the untrusted code could catch the <b>ThreadAbortException </b>and, inside the <b>catch </b>block, throw some other kind of exception If this other exception is caught, at the end of the <b>catch </b>block, the CLR automatically rethrows the <b>ThreadAbortException.</b></p>
<p>It should be noted, though, that most untrusted code is not actually intended to be malicious; it is just written in such a way so as to be taking too long by the host's standards. Usually, <b>catch </b>and <b>finally </b>blocks contain very little code, and this code usually executes quickly without any infinite loops or long-running tasks. And so it is very unlikely that the escalation policy will have to go into effect for the host to regain control of its thread.</p>
<p>By the way, the <b>Thread </b>class actually offers two <b>Abort </b>methods: One takes no parameters, and the other takes an <b>Object </b>parameter allowing you to pass anything. When code catches the <b>ThreadAbortException, </b>it can query its read-only <b>ExceptionState </b>property. This property returns the object that was passed to <b>Abort </b>This allows the thread calling <b>Abort </b>to specify some additional information that can be examined by code catching the <b>ThreadAbortException </b>. The host can use this to let its own handling code know why it is aborting threads.</p>
<mbp:pagebreak/>
<a name="Chapter23"/>
<h1>Chapter 23: Assembly Loading and Reflection</h1>
<p><b>In this chapter:</b></p>
<a href="#b621">Assembly Loading</a><br/>
<a href="#b626">Using Reflection to Build a Dynamically Extensible Application</a><br/>
<a href="#b627">Reflection Performance</a><br/>
<a href="#b634">Designing an Application That Supports Add-Ins</a><br/>
<a href="#b637">Using Reflection to Discover a Type's Members</a><br/>
<p>This chapter is all about discovering information about types, creating instances of them, and accessing their members when you didn't know anything about them at compile time. The information in this chapter is typically used to create a dynamically extensible application. This is the kind of application for which one company builds a host application and other companies create add-ins to extend the host application The host can't be built or tested against the add-ins because the add-ins are created by different companies and are likely to be created after the host application has already shipped. This is why the host needs to discover the add-ins at runtime.</p>
<p>A dynamically extensible application could take advantage of common language runtime (CLR) hosting and AppDomains as discussed in Chapter 22, &quot;CLR Hosting and AppDomains.&quot; The host could run the add-in code in an AppDomain with its own security and configuration settings. The host could also unload the add-in code by unloading the AppDomain. At the end of this chapter, I'll talk a little about how to put all of this stuff together佑LR hosting, AppDomains, assembly loading, type discovery, type instance construction, and reflection in order to build a robust, secure, dynamically extensible application.</p>
<a name="b621"/><h2>Assembly Loading</h2>
<p>As you know, when the just-in-time (JIT) compiler compiles the Intermediate Language (IL) for a method, it sees what types are referenced in the IL code. Then at runtime, the JIT compiler uses the assembly's TypeRef and AssemblyRef metadata tables to determine what assembly defines the type being referenced. The AssemblyRef metadata table entry contains all of the parts that make up the strong name of the assembly. The JIT compiler grabs all of these parts溶ame (without extension or path), version, culture, and public key token幼oncatenates them into a string, and then attempts to load an assembly matching this identity into the AppDomain (assuming that it's not already loaded). If the assembly being loaded is weakly named, the identity is just the name of the assembly (no version, culture, or public key token information).</p>
<p>Internally, the CLR attempts to load this assembly by using the <b>System.Reflection.Assembly </b>class's static <b>Load </b>method. This method is publicly documented, and you can call it to explicitly load an assembly into your AppDomain. This method is the CLR equivalent of Win32's <b>LoadLibrary </b>function. There are actually several overloaded versions of <b>Assembly</b>'s <b>Load </b>method. Here are the prototypes of the more commonly used overloads:</p>
<p><code>public class Assembly {<br/>
public static Assembly Load(AssemblyName assemblyRef); public static Assembly Load(String assemblyString); // Less commonly used overloads of Load are not shown<br/>
}</code></p>
<p>Internally, <b>Load </b>causes the CLR to apply a version-binding redirection policy to the assembly and looks for the assembly in the global assembly cache (GAC), followed by the application's base directory, private path subdirectories, and codebase locations If you call <b>Load </b>passing a weakly named assembly, <b>Load </b>doesn't apply a version-binding redirection policy to the assembly, and the CLR won't look in the GAC for the assembly. If <b>Load </b>finds the specified assembly, it returns a reference to an <b>Assembly </b>object that represents the loaded assembly. If <b>Load </b>fails to find the specified assembly, it throws a <b>System.IO.FileNotFoundException </b>.</p>
<hr/>
<blockquote><b>Note </b>In some extremely rare situations, you may want to load an assembly that was built for a specific CPU architecture. In this case, when specifying an assembly's identity, you can also include a process architecture part For example, if my GAC happened to have an IL-neutral and an x86-specific version of an assembly, the CLR would favor the CPU-specific version of the assembly (as discussed in Chapter 3, &quot;Shared Assemblies and Strongly Named Assemblies&quot;). However, I can force the CLR to load the IL-neutral version by passing the following string to <b>Assembly</b>'s <b>Load </b>method:</blockquote>
<hr/>
<p><code>&quot;SomeAssembly, Version=2.0.0.0, Culture=neutral,<br/>
PublicKeyToken=01234567890abcde, ProcessorArchitecture=MSIL&quot;</code></p>
<p>Today, the CLR supports four possible values for ProcessorArchitecture: MSIL (Microsoft IL), x86, IA64, and AMD64.</p>
<hr/>
<blockquote><b>Important </b>Some developers notice that <b>System.AppDomain </b>offers a <b>Load </b>method Unlike <b>Assembly</b>'s static <b>Load </b>method, AppDomain's <b>Load </b>method is an instance method that allows you to load an assembly into the specified AppDomain. This method was designed to be called by unmanaged code, and it allows a host to inject an assembly into a specific AppDomain. Managed code developers generally shouldn't call this method because when AppDomain's <b>Load </b>method is called, you pass it a string that identifies an assembly. The method then applies policy and searches the normal places looking for the assembly Recall that an AppDomain has settings associated with it that tell the CLR how to look for assemblies To load this assembly, the CLR will use the settings associated with the specified AppDomain, not the calling AppDomain.</blockquote>
<hr/>
<p>However, AppDomain's <b>Load </b>method returns a reference to an assembly Because the <b>System.Assembly </b>class isn't derived from <b>System.MarshalByRefObject, </b>the assembly object must be marshaled by value back to the calling AppDomain. But the CLR will now use the calling AppDomain's settings to locate the assembly and load it If the assembly can't be found using the calling AppDomain's policy and search locations, a <b>FileNotFoundException </b>is thrown. This behavior is usually undesirable and is the reason that you should avoid AppDomain's <b>Load </b>method.</p>
<p>In most dynamically extensible applications, <b>Assembly</b>'s <b>Load </b>method is the preferred way of loading an assembly into an AppDomain. However, it does require that you have all of the pieces that make up an assembly's identity. Frequently, developers write tools or utilities (such as ILDasm.exe, PEVerify.exe, CorFlags.exe, GACUtil.exe, SGen.exe, SN.exe, XSD.exe) that perform some kind of processing on an assembly All of these tools take a command-line argument that refers to the path name of an assembly file (including file extension). To load an assembly specifying a path name, you call <b>Assembly</b>'s <b>LoadFrom </b>method:</p>
<p><code>public class Assembly {<br/>
public static Assembly LoadFrom(String path);<br/>
// Less commonly used overloads of LoadFrom are not shown<br/>
}</code></p>
<p>Internally, <b>LoadFrom </b>first calls <b>System.Reflection.AssemblyName</b>'s static <b>GetAssemblyName</b></p>
<p>method, which opens the specified file, finds the AssemblyDef metadata table's entry, and extracts the assembly identity information and returns it in a <b>System.Reflection. AssemblyName </b>object (the file is also closed). Then, <b>LoadFrom </b>internally calls <b>Assembly</b>'s <b>Load </b>method, passing it the <b>AssemblyName </b>object. At this point, the CLR applies version-binding redirection policy and searches the various locations looking for a matching assembly. If <b>Load </b>finds the assembly, it will load it, and an <b>Assembly </b>object that represents the loaded assembly will be returned; <b>LoadFrom </b>returns this value. If <b>Load </b>fails to find an assembly, <b>LoadFrom </b>loads the assembly at the path name specified in <b>LoadFrom</b>'s argument. Of course, if an assembly with the same identity is already loaded, <b>LoadFrom </b>simply returns an <b>Assembly </b>object that represents the already loaded assembly.</p>
<p>By the way, the <b>LoadFrom </b>method allows you to pass a URL as the argument. Here is an example:</p>
<p><code>Assembly a = Assembly.LoadFrom(@&quot;<a href="http://Wintellect.com/SomeAssembly.dll">http://Wintellect.com/SomeAssembly.dll</a>&quot;);</code></p>
<p>When you pass an Internet location, the CLR downloads the file, installs it into the user's download cache, and loads the file from there. Note that you must be online or an exception will be thrown. However, if the file has been downloaded previously, and if Windows Internet Explorer has been set to work offline (see Internet Explorer's Work Offline menu item in its File menu), the previously downloaded file will be used, and no exception will be thrown. You can also call <b>UnsafeLoadFrom, </b>which can load a Web-downloaded assembly, bypassing some security checks.</p>
<hr/>
<blockquote><b>Important </b>It is possible to have different assemblies on a single machine all with the same identity Because <b>LoadFrom </b>calls <b>Load </b>internally, it is possible that the CLR will not load the specified file and instead will load a different file giving you unexpected behavior. It is highly recommended that each build of your assembly change the version number; this ensures that each version has its own identity, and because of this, <b>LoadFrom </b>will now work as expected.</blockquote>
<hr/>
<p>Microsoft Visual Studio's UI designers and other tools typically use <b>Assembly</b>'s <b>LoadFile </b>method. This method can load an assembly from any path and can be used to load an assembly with the same identity multiple times into a single AppDomain. This can happen as changes to an application's UI are made in the designer/tool and the user rebuilds the assembly. When loading an assembly via <b>LoadFile, </b>the CLR will not resolve any dependencies automatically; your code must register with <b>AppDomain</b>'s <b>AssemblyResolve </b>event and have your event callback method explicitly load any dependent assemblies.</p>
<p>If you are building a tool that simply analyzes an assembly's metadata via reflection (as discussed later in this chapter), and you want to ensure that none of the code contained inside the assembly executes, the best way for you to load an assembly is to use <b>Assembly</b>'s <b>ReflectionOnlyLoadFrom </b>method, or in some rarer cases, <b>Assembly</b>'s <b>ReflectionOnlyLoad </b>method. Here are the prototypes of both methods:</p>
<p><code>public class Assembly {<br/>
public static Assembly ReflectionOnlyLoadFrom(String assemblyFile); public static Assembly ReflectionOnlyLoad(String assemblyString); // Less commonly used overload of ReflectionOnlyLoad is not shown<br/>
}</code></p>
<p>The <b>ReflectionOnlyLoadFrom </b>method will load the file specified by the path; the strong-name identity of the file is not obtained, and the file is not searched for in the GAC or elsewhere. The <b>ReflectionOnlyLoad </b>method will search for the specified assembly looking in the GAC, application base directory, private paths, and codebases However, unlike the <b>Load </b>method, the <b>ReflectionOnlyLoad </b>method does not apply versioning policies, so you will get the exact version that you specify. If you want to apply versioning policy yourself to an assembly identity, you can pass the string into <b>AppDomain</b>'s <b>ApplyPolicy </b>method.</p>
<p>When an assembly is loaded with <b>ReflectionOnlyLoadFrom </b>or <b>ReflectionOnlyLoad,</b></p>
<p>the CLR forbids any code in the assembly from executing; any attempt to execute code in an assembly loaded with either of these methods causes the CLR to throw an <b>InvalidOperationException. </b>These methods allow a tool to load an assembly that was delay-signed, would normally require security permissions that prevent it from loading, or was created for a different CPU architecture.</p>
<p>Frequently when using reflection to analyze an assembly loaded with one of these two methods, the code will have to register a callback method with <b>AppDomain</b>'s <b>ReflectionOnlyAssemblyResolve </b>event to manually load any referenced assemblies</p>
<p>(calling <b>AppDomain</b>'s <b>ApplyPolicy </b>method, if desired); the CLR doesn't do it automatically for you. When the callback method is invoked, it must call <b>Assembly</b>'s <b>ReflectionOnlyLoadFrom </b>or <b>ReflectionOnlyLoad </b>method to explicitly load a referenced assembly and return a reference to this assembly.</p>
<p><b>'</b><b>-</b><b>1</b></p>
<hr/>
<blockquote><b>Note </b>People often ask about assembly unloading Unfortunately, the CLR doesn't support the</blockquote>
<hr/>
<p>ability to unload individual assemblies If the CLR allowed it, your application would crash if a thread returned back from a method to code in the unloaded assembly The CLR is all about robustness and security, and allowing an application to crash in this way would be counterproductive to its goals. If you want to unload an assembly, you must unload the entire AppDomain that contains it. This was discussed in great detail in Chapter 22.</p>
<p>It would seem that assemblies loaded with either the <b>ReflectionOnlyLoadFrom </b>or the <b>ReflectionOnlyLoad </b>method could be unloaded After all, code in these assemblies is not allowed to execute. However, the CLR also doesn't allow assemblies loaded via either of these two methods to be unloaded The reason is that once an assembly is loaded this way, you can still use reflection to create objects that refer to the metadata defined inside these assemblies. Unloading the assembly would require the objects to be invalidated somehow. Keeping track of this would be too expensive in terms of implementation and execution speed.</p>
<p>Many applications consist of an EXE file that depends on many DLL files. When deploying this application, all the files must be deployed. However, there is a technique that you can use to deploy just a single EXE file. First, identify all the DLL files that your EXE file depends on that do not ship as part of the Microsoft .NET Framework itself. Then add these DLLs to your Visual Studio project. For each DLL file you add, display its properties and change its &quot;Build Action&quot; to &quot;Embedded Resource&quot; This causes the C# compiler to embed the DLL file(s) into your EXE file, and you can deploy this one EXE file.</p>
<p>At runtime, the CLR won't be able to find the dependent DLL assemblies, which is a problem. To fix this, when your application initializes, register a callback method with the <b>AppDomain</b>'s <b>ResolveAssembly </b>event. The code should look something like this:</p>
<p><code>AppDomain.CurrentDomain.AssemblyResolve += (sender, args) =&gt; { String resourceName = &quot;AssemblyLoadingAndReflection.&quot; + new AssemblyName(args.Name).Name + &quot;.dll&quot;;<br/>
using (var stream =<br/>
Assembly.GetExecutingAssemblyO.GetManifestResourceStream(resourceName)) { Byte[] assemblyData = new Byte[stream.Length]; stream.Read(assemblyData, 0, assemblyData.Length); return Assembly.Load(assemblyData);<br/>
}<br/>
};</code></p>
<p>Now, the first time a thread calls a method that references a type in a dependent DLL file, the <b>AssemblyResolve </b>event will be raised and the callback code shown above will find the embedded DLL resource desired and load it by calling an overload of <b>Assembly</b>'s <b>Load </b>method that takes a <b>Byte[] </b>as an argument.</p>
<a name="b626"/><h2>Using Reflection to Build a Dynamically Extensible Application</h2>
<p>As you know, metadata is stored in a bunch of tables. When you build an assembly or a module, the compiler that you're using creates a type definition table, a field definition table, a method definition table, and so on. The <b>System.Reflection </b>namespace contains several types that allow you to write code that reflects over (or parses) these metadata tables. In effect, the types in this namespace offer an object model over the metadata contained in an assembly or a module.</p>
<p>Using these object model types, you can easily enumerate all of the types in a type definition metadata table. Then for each type, you can obtain its base type, the interfaces it implements, and the flags that are associated with the type. Additional types in the <b>System.Reflection </b>namespace allow you to query the type's fields, methods, properties, and events by parsing the corresponding metadata tables. You can also discover any custom attributes (covered in Chapter 18, &quot;Custom Attributes&quot;) that have been applied to any of the metadata entities. There are even classes that let you determine referenced assemblies and methods that return the IL byte stream for a method. With all of this information, you could easily build a tool very similar to Microsoft's ILDasm.exe.</p>
<hr/>
<blockquote><b>Note </b>You should be aware that some of the reflection types and some of the members defined by these types are designed specifically for use by developers who are producing compilers for the CLR. Application developers don't typically use these types and members. The Framework Class Library (FCL) documentation doesn't explicitly point out which of these types and members are for compiler developers rather than application developers, but if you realize that not all reflection types and their members are for everyone, the documentation can be less confusing.</blockquote>
<hr/>
<p>In reality, very few applications will have the need to use the reflection types. Reflection is typically used by class libraries that need to understand a type's definition in order to provide some rich functionality. For example, the FCL's serialization mechanism (discussed in Chapter 24, &quot;Runtime Serialization&quot;) uses reflection to determine what fields a type defines. The serialization formatter can then obtain the values of these fields and write them into a byte stream that is used for sending across the Internet, saving to a file, or copying to the clipboard. Similarly, Visual Studio's designers use reflection to determine which properties should be shown to developers when laying out controls on their Web Forms or Windows Forms at design time.</p>
<p>Reflection is also used when an application needs to load a specific type from a specific assembly at runtime to accomplish some task. For example, an application might ask the user to provide the name of an assembly and a type. The application could then explicitly load the assembly, construct an instance of the type, and call methods defined in the type. This usage is conceptually similar to calling Win32's <b>LoadLibrary </b>and <b>GetProcAddress </b>functions.</p>
<p>Binding to types and calling methods in this way is frequently referred to as late binding. (Early binding is when the types and methods used by an application are determined at compile time.</p>
<a name="b627"/><h2>Reflection Performance</h2>
<p>Reflection is an extremely powerful mechanism because it allows you to discover and use types and members at runtime that you did not know about at compile time. This power does come with two main drawbacks:</p>
<p>&#9632; Reflection prevents type safety at compile time. Since reflection uses strings heavily, you lose type safety at compile time. For example, if you call <b>Type.GetType</b>C<b>'Jef&quot;); </b>to ask reflection to find a type called &quot;Jef&quot; in an assembly that has a type called &quot;Jeff,&quot; the code compiles but produces an error at runtime because you accidentally misspelled the type name passed as the argument.</p>
<p>&#9632; Reflection is slow. When using reflection, the names of types and their members are not known at compile time; you discover them at runtime by using a string name to identify each type and member. This means that reflection is constantly performing string searches as the types in the <b>System.Reflection </b>namespace scan through an assembly's metadata. Often, the string searches are case-insensitive comparisons, which can slow this down even more.</p>
<p>Invoking a member by using reflection will also hurt performance. When using reflection to invoke a method, you must first package the arguments into an array; internally, reflection must unpack these on to the thread's stack. Also, the CLR must check that the arguments are of the correct data type before invoking a method Finally, the CLR ensures that the caller has the proper security permission to access the member being invoked.</p>
<p>For all of these reasons, it's best to avoid using reflection to access a field or invoke a method/property. If you're writing an application that will dynamically discover and construct type instances, you should take one of the following approaches:</p>
<p>&#9632; Have the types derive from a base type that is known at compile time. At runtime, construct an instance of the derived type, place the reference in a variable that is of the base type (by way of a cast), and call virtual methods defined by the base type.</p>
<p>&#9632; Have the type implement an interface that is known at compile time. At runtime, construct an instance of the type, place the reference in a variable that is of the interface type (by way of a cast), and call the methods defined by the interface.</p>
<p>I tend to prefer using the interface technique over the base type technique because the base type technique doesn't allow the developer to choose the base type that works best in a particular situation Although the base type technique works better in versioning scenarios since you could always add a member to the base type and the derived types just inherit it;</p>
<p>you can't add a member to an interface without forcing all types that implement the interface to modify their code and recompile it.</p>
<p>When you use either of these two techniques, I strongly suggest that the interface or base type be defined in its own assembly. This will reduce versioning issues. For more information about how to do this, see the section titled &quot;Designing an Application That Supports Add-Ins&quot; in this chapter.</p>
<h3>Discovering Types Defined in an Assembly</h3>
<p>Reflection is frequently used to determine what types an assembly defines. The FCL offers many methods to get this information. By far, the most commonly used method is <b>Assembly</b>'s <b>GetExportedTypes </b>. Here is an example of code that loads an assembly and shows the names of all of the publicly exported types defined in it:</p>
<p><code>using System;<br/>
using System.Reflection;<br/>
public static class Program { public static void Main() {<br/>
String dataAssembly = &quot;System.Data, version=4.0.0.0, &quot; +<br/>
&quot;culture=neutral, PublicKeyToken=b77a5c561934e089&quot;; LoadAssemAndShowPublicTypes(dataAssembly);<br/>
}<br/>
private static void LoadAssemAndShowPublicTypes(String assemId) { // Explicitly load an assembly in to this AppDomain Assembly a = Assembly.Load(assemId);<br/>
// Execute this loop once for each Type<br/>
// publicly-exported from the loaded assembly<br/>
foreach (Type t in a.GetExportedTypes()) {<br/>
// Display the full name of the type<br/>
Console.WriteLine(t.FullName);<br/>
}<br/>
}<br/>
}</code></p>
<h3>What Exactly Is a Type Object?</h3>
<p>Notice that the previous code iterates over an array of <b>System.Type </b>objects. The <b>System.Type </b>type is your starting point for doing type and object manipulations <b>System.Type </b>is an abstract base type derived from <b>System.Reflection.MemberInfo </b>(because a <b>Type </b>can be a member of another type). The FCL provides a few types that are derived from <b>System.Type:System.RuntimeType, System.ReflectionOnlyType, System.Reflection.TypeDelegator, </b>and some types defined in the <b>System.Reflection. Emit </b>namespace <b>(EnumBuilder, GenericTypeParameterBuilder, </b>and <b>TypeBuilder) </b>.</p>
<hr/>
<blockquote><b>Note </b>The <b>TypeDelegator </b>class allows code to dynamically subclass a <b>Type </b>by encapsulating the <b>Type, </b>allowing you to override some of the functionality while having the original <b>Type </b>handle most of the work. This powerful mechanism allows you to override the way reflection works.</blockquote>
<hr/>
<p>Of all of these types, the <b>System.RuntimeType </b>is by far the most interesting. <b>RuntimeType </b>is a type that is internal to the FCL, which means that you won't find it documented in the FCL documentation. The first time a type is accessed in an AppDomain, the CLR constructs an instance of a <b>RuntimeType </b>and initializes the object's fields to reflect (pun intended) information about the type.</p>
<p>Recall that <b>System.Object </b>defines a public, nonvirtual instance method named <b>GetType </b>. When you call this method, the CLR determines the specified object's type and returns a reference to its <b>RuntimeType </b>object. Because there is only one <b>RuntimeType </b>object per type in an AppDomain, you can use equality and inequality operators to see whether two objects are of the same type:</p>
<p><code>private static Boolean AreObjectsTheSameType(Object o1, Object o2) { return o1.GetType() == o2.GetType();<br/>
}</code></p>
<p>In addition to calling <b>Object</b>'s <b>GetType </b>method, the FCL offers several more ways to obtain a <b>Type </b>object:</p>
<p>&#9632; The <b>System.Type </b>type offers several overloaded versions of the static <b>GetType </b>method. All versions of this method take a <b>String. </b>The string must specify the full name of the type (including its namespace) Note that the primitive type names supported by the compiler (such as C#'s <b>int, string, bool, </b>and so on) aren't allowed because these names mean nothing to the CLR. If the string is simply the name of a type, the method checks the calling assembly to see whether it defines a type of the specified name. If it does, a reference to the appropriate <b>RuntimeType </b>object is returned.</p>
<p>If the calling assembly doesn't define the specified type, the types defined by MSCorLib.dll are checked. If a type with a matching name still can't be found, <b>null </b>is returned or a <b>System.TypeLoadException </b>is thrown, depending on which overload of the <b>GetType </b>method you called and what parameters you passed to it The FCL documentation fully explains this method.</p>
<p>You can pass an assembly-qualified type string, such as &quot;System.Int32, mscorlib, Version=4. 0. 0. 0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;, to <b>GetType. </b>In this case, <b>GetType </b>will look for the type in the specified assembly (loading the assembly if necessary).</p>
<p>&#9632; The <b>System.Type </b>type offers a static <b>ReflectionOnlyGetType </b>method. This method behaves similarly to the <b>GetType </b>method mentioned in the previous bullet, except that the type is loaded so that it can be reflected over but cannot be executed.</p>
<p>&#9632; The <b>System.Type </b>type offers the following instance methods: <b>GetNestedType </b>and <b>GetNestedTypes </b>.</p>
<p>&#9632; The <b>System.Reflection.Assembly </b>type offers the following instance methods: <b>GetType, GetTypes, </b>and <b>GetExportedTypes </b>.</p>
<p>&#9632; The <b>System.Reflection.Module </b>type offers the following instance methods: <b>GetType, GetTypes,</b>and <b>FindTypes </b>.</p>
<hr/>
<blockquote><b>Note </b>Microsoft has defined a Backus-Naur Form grammar for type names and assembly-qualified type names that is used for constructing strings that will be passed to reflection methods. Knowledge of the grammar can come in quite handy when you are using reflection, specifically if you are working with nested types, generic types, generic methods, reference parameters, or arrays For the complete grammar, see the FCL documentation or do a Web search for &quot;Backus-Naur Form Grammar for Type Names.&quot; You can also look at <b>Type</b>'s <b>MakeArrayType, MakeByRefType, MakeGenericType, </b>and <b>MakePointerType </b>methods.</blockquote>
<hr/>
<p>Many programming languages also offer an operator that allows you to obtain a <b>Type </b>object from a type name that is known at compile time. When possible, you should use this operator to obtain a reference to a <b>Type </b>instead of using any of the methods in the preceding list, because the operator generally produces faster code. In C#, the operator is called <b>typeof, </b>and you use this operator typically to compare late-bound type information with early-bound (known at compile time) type information. The following code demonstrates an example of its use:</p>
<p><code>private static void SomeMethod(Object o) {<br/>
// GetType returns the type of the object at runtime (late-bound) // typeof returns the type of the specified class (early-bound) if (o.GetType() == typeof(FileInfo)){... }<br/>
if (o.GetType() == typeof(DirectoryInfo)) {... }<br/>
}</code></p>
<hr/>
<blockquote><b>Note </b>The first <b>if </b>statement in the code checks if the variable <b>o </b>refers to an object of the <b>FileInfo </b>type; it does not check if <b>o </b>refers to an object that is derived from the <b>FileInfo </b>type. In other words, the code above tests for an exact match, not a compatible match, which is what you would get if you use a cast or C#'s <b>is </b>or <b>as </b>operators.</blockquote>
<hr/>
<p>Once you have a reference to a <b>Type </b>object, you can query many of the type's properties to learn more about it. Most of the properties, such as <b>IsPublic, IsSealed, IsAbstract, IsClass, IsValueType, </b>and so on, indicate flags associated with the type. Other properties, such as <b>Assembly, AssemblyQualifiedName, FullName, Module, </b>and so on, return the name of the type's defining assembly or module and the full name of the type. You can also query the <b>BaseType </b>property to obtain the type's base type, and a slew of methods will give you even more information about the type.</p>
<p>The FCL documentation describes all of the methods and properties that <b>Type </b>exposes. Be aware that there are a lot of them. In fact, <b>Type </b>offers about 60 public instance properties. This doesn't even include the methods and fields that <b>Type </b>also defines. I'll be covering some of these methods in the next section.</p>
<h3>Building a Hierarchy of Exception-Derived Types</h3>
<p>The code shown below uses many of the concepts discussed already in this chapter to load a bunch of assemblies into the AppDomain and display all of the classes that are ultimately derived from <b>System.Exception </b>. By the way, this is the program I wrote to build the exception hierarchy displayed in the &quot;FCL-Defined Exception Classes&quot; section in Chapter 20, &quot;Exceptions and State Management.&quot;</p>
<p><code>public static void Go() {<br/>
// Explicitly load the assemblies that we want to reflect over LoadAssemblies();<br/>
// Recursively build the class hierarchy as a hyphen-separated string Func&lt;Type, String&gt; ClassNameAndBase = null; ClassNameAndBase = t =&gt; &quot;-&quot; + t.FullName +<br/>
((t.BaseType != typeof(Object)) ? ClassNameAndBase(t.BaseType) : String.Empty);<br/>
// Define query to find all public Exception-derived types in this AppDomain's assemblies var exceptionTree =<br/>
(from a in AppDomain.CurrentDomain.GetAssemblies() from t in a.GetExportedTypes()<br/>
where t.IsClass &amp;&amp; t.IsPublic &amp;&amp; typeof(Exception).IsAssignableFrom(t) let typeHierarchyTemp = ClassNameAndBase(t).Split('-').Reverse().ToArray() let typeHierarchy =<br/>
String.Join(&quot;-&quot;, typeHierarchyTemp, 0, typeHierarchyTemp.Length - 1) orderby typeHierarchy select typeHierarchy).ToArray();<br/>
// Display the Exception tree<br/>
Console.WriteLine(&quot;{0} Exception types found.&quot;, exceptionTree.Length); foreach (String s in exceptionTree) {<br/>
// For this Exception type, split its base types apart<br/>
String[] x = s.Split('-');<br/>
// Indent based on # of base types and show the most-derived type Console.WriteLine(new StringC  ', 3 * (x.Length - 1)) + x[x.Length - 1]);<br/>
}<br/>
}<br/>
private static void LoadAssemblies() { String[] assemblies = {<br/>
&quot;System, PublicKeyToken={0}&quot;, &quot;System.Core, PublicKeyToken={0}&quot;, &quot;System.Data, PublicKeyToken={0}&quot;, &quot;System.Design, PublicKeyToken={1}&quot;,<br/>
&quot;System.DirectoryServices, PublicKeyToken={1}&quot;, &quot;System.Drawing, PublicKeyToken={1}&quot;, &quot;System.Drawing.Design, PublicKeyToken={1}&quot;, &quot;System.Management, PublicKeyToken={1}&quot;, &quot;System.Messaging, PublicKeyToken={1}&quot;, &quot;System.Runtime.Remoting, PublicKeyToken={0}&quot;, &quot;System.Security, PublicKeyToken={1}&quot;, &quot;System.ServiceProcess, PublicKeyToken={1}&quot;, &quot;System.Web, PublicKeyToken={1}&quot;, &quot;System.Web.RegularExpressions, PublicKeyToken={1}&quot;, &quot;System.Web.Services, PublicKeyToken={1}&quot;, &quot;System.Windows.Forms, PublicKeyToken={0}&quot;, &quot;System.Xml, PublicKeyToken={0}&quot;,<br/>
};<br/>
String EcmaPublicKeyToken = &quot;b77a5c561934e089&quot;; String MSPublicKeyToken = &quot;b03f5f7flld50a3a&quot;;<br/>
// Get the version of the assembly containing System.Object // We'll assume the same version for all the other assemblies Version version = typeof(System.Object).Assembly.GetName().Version;<br/>
// Explicitly load the assemblies that we want to reflect over foreach (String a in assemblies) { String AssemblyIdentity =<br/>
String.Format(a, EcmaPublicKeyToken, MSPublicKeyToken) + &quot;, Culture=neutral, Version=&quot; + version; Assembly.Load(AssemblyIdentity);<br/>
}<br/>
}</code></p>
<h3>Constructing an Instance of a Type</h3>
<p>Once you have a reference to a <b>Type</b>-derived object, you might want to construct an instance of this type. The FCL offers several mechanisms to accomplish this:</p>
<p><b>&#9632; System.Activator's CreateInstance methods </b>The <b>Activator </b>class offers several overloads of its static <b>CreateInstance </b>method When you call this method, you can pass either a reference to a <b>Type </b>object or a <b>String </b>that identifies the type of object you want to create The versions that take a type are simpler You get to pass a set of arguments for the type's constructor, and the method returns a reference to the new object.</p>
<p>The versions of this method in which you specify the desired type by using a string are a bit more complex. First, you must also specify a string identifying the assembly that defines the type. Second, these methods allow you to construct a remote object if you have remoting options configured properly. Third, these versions don't return a reference to the new object. Instead, they return a <b>System.Runtime.Remoting. ObjectHandle </b>(which is derived from <b>System.MarshalByRefObject).</b></p>
<p>An <b>ObjectHandle </b>is a type that allows an object created in one AppDomain to be passed around to other AppDomains without forcing the object to materialize. When you're ready to materialize the object, you call <b>ObjectHandle</b>'s <b>Unwrap </b>method. This method loads the assembly that defines the type being materialized in the AppDomain where <b>Unwrap </b>is called. If the object is being marshaled by reference, the proxy type and object are created. If the object is being marshaled by value, the copy is deserialized.</p>
<p><b>&#9632; System.Activator's CreateInstanceFrom methods </b>The <b>Activator </b>class also offers a set of static <b>CreateInstanceFrom </b>methods These methods behave just as the <b>CreateInstance </b>method, except that you must always specify the type and its assembly via string parameters. The assembly is loaded into the calling AppDomain by using <b>Assembly</b>'s <b>LoadFrom </b>method (instead of <b>Load) </b>. Because none of these methods takes a <b>Type </b>parameter, all of the <b>CreateInstanceFrom </b>methods return a reference to an <b>ObjectHandle, </b>which must be unwrapped.</p>
<p><b>&#9632; System.AppDomain's methods   </b>The <b>AppDomain </b>type offers four instance methods (each with several overloads) that construct an instance of a type: <b>CreateInstance, CreateInstanceAndUnwrap, CreateInstanceFrom, </b>and <b>CreateInstanceFromAndUnwrap </b>These methods work just as <b>Activator</b>'s methods except that these methods are instance methods, allowing you to specify which AppDomain the object should be constructed in The methods that end with <b>Unwrap </b>exist for convenience so that you don't have to make an additional method call.</p>
<p><b>&#9632; System.Type's InvokeMember instance method   </b>Using a reference to a <b>Type </b>object, you can call the <b>InvokeMember </b>method This method locates a constructor matching the parameters you pass and constructs the type The type is always created in the calling AppDomain, and a reference to the new object is returned. I'll discuss this method in more detail later in this chapter.</p>
<p><b>&#9632; System.Reflection.ConstructorInfo's Invoke instance method   </b>Using a reference to a <b>Type </b>object, you can bind to a particular constructor and obtain a reference to the constructor's <b>ConstructorInfo </b>object Then you can use the reference to the <b>ConstructorInfo </b>object to call its <b>Invoke </b>method The type is always created in the calling AppDomain, and a reference to the new object is returned. I'll also discuss this method in more detail later in this chapter.</p>
<hr/>
<blockquote><b>Note </b>The CLR doesn't require that value types define any constructors. However, this is a problem because all of the mechanisms in the preceding list construct an object by calling its constructor. However, <b>Activator</b>'s <b>CreateInstance </b>methods will allow you to create an instance of a value type without calling a constructor If you want to create an instance of a value type without calling a constructor, you must call the version of the <b>CreateInstance </b>method that takes a single <b>Type </b>parameter or the version that takes <b>Type </b>and <b>Boolean </b>parameters.</blockquote>
<hr/>
<p>The mechanisms just listed allow you to create an object for all types except for arrays <b>(System.Array</b>-derived types) and delegates <b>(System.MulticastDelegate</b>-derived types). To create an array, you should call <b>Array</b>'s static <b>CreateInstance </b>method (several overloaded versions exist). The first parameter to all versions of <b>CreateInstance </b>is a reference to the <b>Type </b>of elements you want in the array. <b>CreateInstance</b>'s other parameters allow you to specify various combinations of dimensions and bounds. To create a delegate, you should call <b>Delegate</b>'s static <b>CreateDelegate </b>method (several overloads exist). The first parameter to all versions of <b>CreateDelegate </b>is a reference to the <b>Type </b>of delegate you want to create. <b>CreateDelegate</b>'s other parameters allow you to specify which instance method of an object or which static method of a type the delegate should wrap.</p>
<p>To construct an instance for a generic type, first get a reference to the open type, and then call <b>Type</b>'s public, instance <b>MakeGenericType </b>method, passing in an array of types that you want to use as the type arguments. Then, take the returned <b>Type </b>object and pass it into one of the various methods listed above. Here is an example:</p>
<p><code>using System;<br/>
using System.Reflection;<br/>
internal sealed class Dictionary&lt;TKey, TValue&gt; { }<br/>
public static class Program { public static void Main() {<br/>
// Get a reference to the generic type's type object Type openType = typeof(Dictionary&lt;,&gt;);<br/>
// Close the generic type by using TKey=String, TValue=Int32<br/>
Type closedType = openType.MakeGenericType(typeof(String), typeof(Int32));<br/>
// Construct an instance of the closed type Object o = Activator.CreateInstance(closedType);<br/>
// Prove it worked Console.WriteLine(o.GetType());<br/>
}<br/>
}</code></p>
<p>If you compile the code shown above and run it, you get the following output: Dictionary&quot;2[System.String,System.Int32]</p>
<a name="b634"/><h2>Designing an Application That Supports Add-Ins</h2>
<p>When you're building extensible applications, interfaces should be the centerpiece. You could use a base class instead of an interface, but in general, an interface is preferred because it allows add-in developers to choose their own base class Suppose, for example, that you're writing an application and you want others to be able to create types that your application can load and use seamlessly. Here's the way to design this application:</p>
<p>&#9632; Create a Host SDK assembly that defines an interface whose methods are used as the communication mechanism between the host application and the add-in components. When defining the parameters and return values for the interface methods, try to use other interfaces or types defined in MSCorLib.dll. If you want to pass and return your own data types, define them in this Host SDK assembly, too. Once you settle on your interface definitions, give this assembly a strong name (discussed in Chapter 3), and then package and deploy it to your partners and users. Once published, you should really avoid making any kind of breaking changes to the types in this assembly. For example, do not change the interface in any way. However, if you define any data types, it is OK to add new members. If you make any modifications to the assembly, you'll probably want to deploy it with a publisher policy file (also discussed in Chapter 3).</p>
<p>&#9632;H-H.</p>
<hr/>
<blockquote><b>Note </b>You can use types defined in MSCorl_ib.dll because the CLR always loads the version of MSCorLib.dll that matches the version of the CLR itself. Also, only a single version</blockquote>
<hr/>
<p>Lof MSCorLib.dll is ever loaded into a CLR instance. In other words, different versions of MSCorLib dll never load side by side (as described in Chapter 3) As a result, you won't have any type version mismatches, and your application will require less memory.</p>
<p>&#9632; The add-in developers will, of course, define their own types in their own Add-In assembly. Their Add-In assembly will reference the types in your Host SDK assembly. The add-in developers are able to put out a new version of their assembly as often as they'd like, and the host application will be able to consume the add-in types without any problem whatsoever.</p>
<p>&#9632; Create a separate Host Application assembly containing your application's types. This assembly will obviously reference the Host SDK assembly and use the types defined in it. Feel free to modify the code in the Host Application assembly to your heart's desire. Because the add-in developers don't reference the Host Application assembly, you can put out a new version of it every hour if you want to and not affect any of the add-in developers.</p>
<p>This section contains some very important information. When using types across assemblies, you need to be concerned with assembly-versioning issues Take your time to architect this cleanly by isolating the types that you use for communication across assembly boundaries into their own assembly. Avoid mutating or changing these type definitions. However, if you really need to modify the type definitions, make sure that you change the assembly's version number and create a publisher policy file for the new version.</p>
<p>I'll now walk through a very simple scenario that puts all of this together. First, here is the code for the HostSDK.dll assembly:</p>
<p><code>using System;<br/>
namespace Wintellect.HostSDK { public interface IAddln {<br/>
String DoSomething(Int32 x);<br/>
}<br/>
}</code></p>
<p>Second, here is the code for an AddInTypes.dll assembly defining two public types that implement the HostSDK's interface. To build this assembly, the HostSDK.dll assembly must be referenced:</p>
<p><code>using System;<br/>
using Wintellect.HostSDK;<br/>
public sealed class AddIn_A : IAddln { public AddIn_A() { }<br/>
public String DoSomething(Int32 x) { return &quot;AddIn_A: &quot; + x.ToStringC);<br/>
}<br/>
}<br/>
public sealed class AddIn_B : IAddIn { public AddIn_B() { }<br/>
public String DoSomething(Int32 x) {<br/>
return &quot;AddIn_B: &quot; + (x * 2).ToString();<br/>
}<br/>
}</code></p>
<p>Third, here is the code for a simple Host, exe assembly (a console application). To build this assembly, the HostSDK.dll assembly must be referenced. To discover usable add-in types, this host code assumes that the types are defined in assemblies ending with a.dll file extension and that these assemblies are deployed into the same directory as the host's EXE file. Microsoft's Managed Extensibility Framework (MEF) is built on top of the various mechanisms that I show here, and it also offers add-in registration and discovery mechanisms. I urge you to check MEF out if you are building a dynamically extensible application, as it can simplify some of the material in this chapter.</p>
<p><code>using System;<br/>
using System.IO;<br/>
using System.Reflection;<br/>
using System.Collections.Ceneric;<br/>
using Wintellect.HostSDK;<br/>
public static class Program { public static void Main() {<br/>
// Find the directory that contains the Host exe<br/>
String AddInDir = Path.CetDirectoryName(Assembly.CetEntryAssemblyO.Location);<br/>
// Assume AddIn assemblies are in same directory as host's EXE file String[] AddInAssemblies = Directory.CetFiles(AddInDir, &quot;*.dll&quot;);<br/>
// Create a collection of usable add-in Types List&lt;Type&gt; AddInTypes = new List&lt;Type&gt;();<br/>
// Load add-in assemblies; discover which types are usable by the host foreach (String file in AddInAssemblies) {<br/>
Assembly AddInAssembly = Assembly.LoadFrom(file);<br/>
// Examine each publicly exported type<br/>
foreach (Type t in AddInAssembly.GetExportedTypesO) {<br/>
// If the type is a class that implements the IAddIn<br/>
// interface, then the type is usable by the host<br/>
if (t.IsClass &amp;&amp; typeof(IAddIn).IsAssignableFrom(t)) { AddInTypes.Add(t);<br/>
}<br/>
}<br/>
}<br/>
// Initialization complete: the host has discovered the usable add-ins<br/>
// Here's how the host can construct add-in objects and use them foreach (Type t in AddInTypes) {<br/>
IAddIn ai = (IAddIn) Activator.CreateInstance(t);<br/>
Console.WriteLine(ai.DoSomething(5));<br/>
}<br/>
}<br/>
}</code></p>
<p>The simple host/add-in scenario just shown doesn't use AppDomains. However, in a real-life scenario, you will likely create each add-in in its own AppDomain with its own security and configuration settings. And of course, each AppDomain could be unloaded if you wanted to remove an add-in from memory. To communicate across the AppDomain boundary, you'd either tell the add-in developers to derive their add-in types from <b>MarshalByRefObject </b>or, more likely, have the host application define its own internal type that is derived from <b>MarshalByRefObject </b>. As each AppDomain is created, the host would create an instance of its own <b>MarshalByRefObject</b>-derived type in the new AppDomain. The host's code (in the default AppDomain) would communicate with its own type (in the other AppDomains) to have it load add-in assemblies and create and use instances of the add-in types.</p>
<a name="b637"/><h2>Using Reflection to Discover a Type's Members</h2>
<p>So far, this chapter has focused on the parts of reflection預ssembly loading, type discovery, and object construction溶ecessary to build a dynamically extensible application. In order to have good performance and compile-time type safety, you want to avoid using reflection as much as possible. In the dynamically extensible application scenario, once an object is constructed, the host code typically casts the object to an interface type or a base class that is known at compile time; this allows the object's members to be accessed in a high-performance and compile-time type-safe way.</p>
<p>In the remainder of this chapter, I'm going to focus on some other aspects of reflection that you can use to discover and then invoke a type's members. The ability to discover and invoke a type's members is typically used to create developer tools and utilities that analyze an assembly by looking for certain programming patterns or uses of certain members. Examples of tools/utilities that do this are ILDasm.exe, FxCopCmd.exe, and Visual Studio's Windows Forms and Web Forms designers. In addition, some class libraries use the ability to discover and invoke a type's members in order to offer rich functionality as a convenience to developers Examples of class libraries that do so are serialization/deserialization and simple data binding.</p>
<h3>Discovering a Type's Members</h3>
<p>Fields, constructors, methods, properties, events, and nested types can all be defined as members within a type. The FCL contains a type called <b>System.Reflection.Memberlnfo. </b>This class is an abstract base class that encapsulates a bunch of properties common to all type members. Derived from <b>Memberlnfo </b>are a bunch of classes; each class encapsulates some more properties related to a specific type member. Figure 23-1 shows the hierarchy of these types.</p>
<p><b>Figure 23-1 </b>Hierarchy of the reflection types that encapsulate information about a type's member</p>
<p>The following program demonstrates how to query a type's members and display some information about them. This code processes all of the public types defined in all assemblies loaded in the calling AppDomain For each type, the <b>GetMembers </b>method is called and</p>
<img src="81.jpg"/>
<p>returns an array of <b>MemberInfo</b>-derived objects; each object refers to a single member defined within the type. The <b>BindingFlags </b>variable, <b>bf, </b>passed to the <b>GetMembers </b>method tells the method which kinds of members to return. I'll talk about <b>BindingFlags </b>later in this chapter. Then, for each member, its kind (field, constructor, method, property, etc.) and its string value (obtained by calling <b>ToString) </b>is shown.</p>
<p><code>using System;<br/>
using System.Reflection;<br/>
public static class Program { public static void Main() {<br/>
// Loop through all assemblies loaded in this AppDomain Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies(); foreach (Assembly a in assemblies) { WriteLine(0, &quot;Assembly: {0}&quot;, a);<br/>
// Find Types in the assembly foreach (Type t in a.GetExportedTypes()) { WriteLine(1, &quot;Type: {0}&quot;, t);<br/>
// Discover the type's members<br/>
const BindingFlags bf = BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static;<br/>
foreach (MemberInfo mi in t.GetMembers(bf)){ String typeName = String.Empty;<br/>
if (mi is Type).typeName.=.&quot;(Nested) Type&quot;;<br/>
else if (mi is FieldInfo).typeName.=.&quot;FieldInfo&quot;;<br/>
else if (mi is MethodInfo).typeName.=.&quot;MethodInfo&quot;;<br/>
else if (mi is ConstructorInfo).typeName.=.&quot;ConstructoInfo&quot;;<br/>
else if (mi is PropertyInfo).typeName.=.&quot;PropertyInfo&quot;;<br/>
else if (mi is EventInfo).typeName.=.&quot;EventInfo&quot;;<br/>
WriteLine(2, &quot;{0}: {1}&quot;, typeName, mi);<br/>
}<br/>
}<br/>
}<br/>
}<br/>
private static void WriteLine(Int32 indent, String format, params Object[] args) { Console.WriteLine(new StringC  ', 3 * indent) + format, args);<br/>
}<br/>
}</code></p>
<p>When you compile and run this code, a ton of output is produced Here is a small sampling of what it looks like:</p>
<p><code>Assembly: mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089 Type: System.Object<br/>
MethodInfo: System.String ToString()<br/>
MethodInfo: Boolean Equals(System.Object)<br/>
MethodInfo: Boolean Equals(System.Object, System.Object)<br/>
MethodInfo: Boolean ReferenceEquals(System.Object, System.Object)<br/>
MethodInfo: Int32 GetHashCode() MethodInfo: System.Type GetType() MethodInfo: Void Finalize() MethodInfo: System.Object MemberwiseClone()<br/>
MethodInfo: Void FieldSetter(System.String, System.String, System.Object)<br/>
MethodInfo: Void FieldGetter(System.String, System.String, System.Object ByRef)<br/>
MethodInfo: System.Reflection.FieldInfo GetFieldInfo(System.String, System.String)<br/>
ConstructoInfo: Void.ctor() Type: System.Collections.Generic.IComparer'1[T]<br/>
MethodInfo: Int32 Compare(T, T) Type: System.Collections.IEnumerator<br/>
MethodInfo: Boolean MoveNext()<br/>
MethodInfo: System.Object get_Current()<br/>
MethodInfo: Void Reset()<br/>
PropertyInfo: System.Object Current Type: System.IDisposable<br/>
MethodInfo: Void Dispose() Type: System.Collections.Generic.IEnumerator'1[T]<br/>
MethodInfo: T get_Current()<br/>
PropertyInfo: T Current Type: System.ArraySegment'1[T]<br/>
MethodInfo: T[] get_Array()<br/>
MethodInfo: Int32 get_Offset()<br/>
MethodInfo: Int32 get_Count()<br/>
MethodInfo: Int32 GetHashCode()<br/>
MethodInfo: Boolean Equals(System.Object)<br/>
MethodInfo: Boolean Equals(System.ArraySegment'1[T])<br/>
MethodInfo: Boolean op_Equality(System.ArraySegment'1[T], System.ArraySegment'1[T])<br/>
MethodInfo: Boolean op_Inequality(System.ArraySegment'1[T], System.ArraySegment'1[T])<br/>
ConstructoInfo: Void.ctor(T[])<br/>
ConstructoInfo: Void.ctor(T[], Int32, Int32)<br/>
PropertyInfo: T[] Array<br/>
PropertyInfo: Int32 Offset<br/>
PropertyInfo: Int32 Count<br/>
FieldInfo: T[] _array<br/>
FieldInfo: Int32 _offset</code></p>
<p>Since <b>MemberInfo </b>is the root of the member hierarchy, it makes sense for us to discuss it a bit more. Table 23-1 shows several read-only properties and methods offered by the <b>MemberInfo </b>class These properties and methods are common to all members of a type Don't forget that <b>System.Type </b>is derived from <b>MemberInfo, </b>and therefore, <b>Type </b>also offers all of the properties shown in Table 23-1.</p>
<p><b>Table 23-1 </b><b>Properties and Methods Common to All MemberInfo-Derived Types</b></p>
<table border="1">
<tr>
<td>
<p>Member Name</p>
</td>
<td>
<p>Member Type</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
<tr>
<td>
<p>Name</p>
</td>
<td>
<p>String property</p>
</td>
<td>
<p>Returns the name of the member. In the case of a nested type, Name returns the concatenation of the name of the containing type, followed by '+', followed by the name of the nested type.</p>
</td>
</tr>
</table>
<table border="1">
<tr>
<td>
<p>e</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p><b>MemberTypes </b>(enum) property</p>
</td>
<td>
<p>Returns the kind of member (field, constructor, method, property, event, type (non-nested type or nested type).</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p><b>Type </b>property</p>
</td>
<td>
<p>Returns the <b>Type </b>that declares the member</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p><b>Type </b>property</p>
</td>
<td>
<p>Returns the <b>Type </b>used to obtain this member</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p><b>Module </b>property</p>
</td>
<td>
<p>Returns the <b>Module </b>that declares the member</p>
</td>
</tr>
<tr>
<td>
<p>n</p>
</td>
<td>
<p><b>Int32 </b>property</p>
</td>
<td>
<p>Returns the metadata token (within the module) that identifies the member</p>
</td>
</tr>
<tr>
<td>
<p>s</p>
</td>
<td>
<p>Method returning <b>Object[]</b></p>
</td>
<td>
<p>Returns an array in which each element identifies an instance of a custom attribute applied to this member Custom attributes can be applied to any member Use this method with assemblies that have not been loaded in the &quot;reflection only&quot; context.</p>
</td>
</tr>
<tr>
<td>
<p>a</p>
</td>
<td>
<p>Method returning <b>IList&lt;CustomAttributeData&gt;</b></p>
</td>
<td>
<p>Returns a collection in which each element identifies an instance of a custom attribute applied to this member Custom attributes can be applied to any member Even though <b>Assembly </b>does not derive from <b>MemberInfo, </b>it provides the same method that can be used with assemblies.</p>
</td>
</tr>
<tr>
<td>
<p>d</p>
</td>
<td>
<p>Method returning <b>Boolean</b></p>
</td>
<td>
<p>Returns <b>true </b>if at least one instance of the specified custom attribute is applied to the member</p>
</td>
</tr>
</table>
<p>Most of the properties mentioned in Table 23-1 are self-explanatory. However, developers frequently confuse the <b>DeclaringType </b>and <b>ReflectedType </b>properties. To fully understand these properties, let's define the following type:</p>
<p><code>public sealed class MyType {<br/>
public override String ToString() { return null; }<br/>
}</code></p>
<p>What would happen if the following line of code executed? MemberInfo[] members = typeof(MyType).GetMembers();</p>
<p>The <b>members </b>variable is a reference to an array in which each element identifies a public member defined by <b>MyType </b>and any of its base types, such as <b>System.Object </b>. If you were to query the <b>DeclaringType </b>property for the <b>MemberInfo </b>element identifying the <b>ToString </b>method, you'd see <b>MyType </b>returned because <b>MyType </b>declares a <b>ToString </b>method. On the other hand, if you were to query the <b>DeclaringType </b>property for the <b>MemberInfo </b>element identifying the <b>Equals </b>method, you'd see <b>System.Object </b>returned because <b>Equals </b>is declared by <b>System.Object, </b>not by <b>MyType </b>. The <b>ReflectedType </b>property always returns <b>MyType </b>because this was the type specified when <b>GetMembers </b>was called to perform the reflection.</p>
<p>Each element of the array returned by calling <b>GetMembers </b>is a reference to one of the concrete types in the hierarchy (unless the <b>BindingFlags.DeclaredOnly </b>flag is specified). Although <b>Type</b>'s <b>GetMembers </b>method returns all of the type's members, <b>Type </b>also offers methods that return specific member types. For example, <b>Type </b>offers <b>GetNestedTypes, GetFields, GetConstructors, GetMethods, GetProperties, </b>and <b>GetEvents </b>. These methods all return arrays in which each element is a reference to a <b>Type </b>object, <b>FieldInfo </b>object, <b>ConstructorInfo </b>object, <b>MethodInfo </b>object, <b>PropertyInfo </b>object, or <b>EventInfo </b>object, respectively.</p>
<p>Figure 23-2 summarizes the types used by an application to walk reflection's object model. From an AppDomain, you can discover the assemblies loaded into it From an assembly, you can discover the modules that make it up. From an assembly or a module, you can discover the types that it defines. From a type, you can discover its nested types, fields, constructors, methods, properties, and events. Namespaces are not part of this hierarchy because they are simply syntactical gatherings of types. If you want to list all of the namespaces defined in an assembly, you need to enumerate all of the types in this assembly and take a look at their <b>Namespace </b>property.</p>
<p>From a type, it is also possible to discover the interfaces it implements. (I'll show how to do this a little later) And from a constructor, method, property accessor method, or event add/remove method, you can call the <b>GetParameters </b>method to obtain an array of <b>ParameterInfo </b>objects, which tells you the types of the member's parameters. You can also query the read-only <b>ReturnParameter </b>property to get a <b>ParameterInfo </b>object for detailed information about a member's return value. For a generic type or method, you can call the <b>GetGenericArguments </b>method to get the set of type parameters. Finally, for any of these items, you can call the <b>GetCustomAttributes </b>method to obtain the set of custom attributes applied to them.</p>
<h3>BindingFlags: Filtering the Kinds of Members That Are Returned</h3>
<p>You query a type's members by calling <b>Type</b>'s <b>GetMembers, GetNestedTypes, GetFields, GetConstructors, GetMethods, GetProperties, </b>or <b>GetEvents </b>methods When you call any of these methods, you can pass in an instance of a <b>System.Reflection.BindingFlags </b>enumerated type. The enumerated type identifies a set of bit flags OR'd together to help you filter the members that are returned from these methods. Table 23-2 shows the relevant symbols defined by the <b>BindingFlags </b>enumerated type.</p>
<p>All of the methods that return a set of members have an overload that takes no arguments at all. When you don't pass a <b>BindingFlags </b>argument, all of these methods return only the public members. In other words, the default is <b>BindingFlags.Public | BindingFlags. Instance | BindingFlags.Static </b>.</p>
<p>Note that <b>Type </b>also defines <b>GetMember, GetNestedType, GetField, GetConstructor, GetMethod, GetProperty, </b>and <b>GetEvent </b>methods These methods allow you to pass in a <b>String </b>that identifies a member's name to look up. This is when <b>BindingFlags</b>'s <b>IgnoreCase </b>flag comes in handy.</p>
<img src="82.jpg"/>
<p><b>Table 23-2 </b><b>Search Symbols Defined by the BindingFlags Enumerated Type</b></p>
<table border="1">
<tr>
<td>
<p>l</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>0x00</p>
</td>
<td>
<p>A placeholder for no flags specified. Use this flag when you don't want to specify any of the flags listed in the remainder of this table.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>0x01</p>
</td>
<td>
<p>Return members matching specified string regardless of case.</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>0x02</p>
</td>
<td>
<p>Return only members of the reflected type, ignoring inherited members.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>0x04</p>
</td>
<td>
<p>Return instance members.</p>
</td>
</tr>
<tr>
<td>
<p>c</p>
</td>
<td>
<p>0x08</p>
</td>
<td>
<p>Return static members.</p>
</td>
</tr>
<tr>
<td>
<p>c</p>
</td>
<td>
<p>0x10</p>
</td>
<td>
<p>Return public members.</p>
</td>
</tr>
<tr>
<td>
<p>c</p>
</td>
<td>
<p>0x20</p>
</td>
<td>
<p>Return non-public members.</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>0x40</p>
</td>
<td>
<p>Return static members defined by base types.</p>
</td>
</tr>
</table>
<p><b>Discovering a Type's Interfaces</b></p>
<p>To obtain the set of interfaces that a type inherits, you can call <b>Type</b>'s <b>FindInterfaces, GetInterface, </b>or <b>GetInterfaces </b>method. All of these methods return <b>Type </b>objects that represent an interface. Note that these methods scan the type's inheritance hierarchy and return all of the interfaces defined on the specified type as well as all of its base types.</p>
<p>Determining which members of a type implement a particular interface is a little complicated because multiple interface definitions can all define the same method. For example, the <b>IBookRetailer </b>and <b>IMusicRetailer </b>interfaces might both define a method named <b>Purchase. </b>To get the <b>MethodInfo </b>objects for a specific interface, you call <b>Type</b>'s <b>GetInterfaceMap </b>instance method passing the interface type as an argument. This method returns an instance of a <b>System.Reflection.InterfaceMapping </b>(a value type). The <b>InterfaceMapping </b>type defines the four public fields listed in Table 23-3.</p>
<p><b>Table 23-3 </b><b>Public Fields Defined by the InterfaceMapping Type</b></p>
<table border="1">
<tr>
<td>
<p>e</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>This is the type that was used to call <b>GetInterfaceMapping </b>.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>This is the type of the interface passed to <b>GetInterfaceMapping </b>.</p>
</td>
</tr>
<tr>
<td>
<p>s</p>
</td>
<td>
<p><b>MethodInfo[]</b></p>
</td>
<td>
<p>This is an array in which each element exposes information about an interface's method.</p>
</td>
</tr>
<tr>
<td>
<p>s</p>
</td>
<td>
<p><b>MethodInfo[]</b></p>
</td>
<td>
<p>This is an array in which each element exposes information about the method that the type defines to implement the corresponding interface's method.</p>
</td>
</tr>
</table>
<p>The <b>InterfaceMethods </b>and <b>TargetMethods </b>arrays run parallel to each other; that is, <b>InterfaceMethods[0] </b>identifies the interface's <b>MethodInfo, </b>and <b>TargetMethods[0] </b>identifies the method defined by the type that implements this interface method. Here is some code that shows how to discover the interfaces and interface methods defined by a type:</p>
<p><code>using System;<br/>
using System.Reflection;<br/>
// Define two interfaces for testing<br/>
internal interface IBookRetailer : IDisposable {<br/>
void Purchase();<br/>
void ApplyDiscount();<br/>
}<br/>
internal interface IMusicRetailer { void Purchase();<br/>
}<br/>
// This class implements 2 interfaces defined by this assembly // and 1 interface defined by another assembly<br/>
internal sealed class MyRetailer : IBookRetailer, IMusicRetailer, IDisposable { // IBookRetailer methods void IBookRetailer.PurchaseO { } public void ApplyDiscount() { }<br/>
// IMusicRetailer method<br/>
void IMusicRetailer.PurchaseO { }<br/>
// IDisposable method public void Dispose() { }<br/>
// MyRetailer method (not an interface method) public void Purchase() { }<br/>
}<br/>
public static class Program { public static void Main() {<br/>
// Find interfaces implemented by MyRetailer where the interface is // defined in our own assembly. This is accomplished using a delegate // to a filter method that we pass to FindInterfaces. Type t = typeof(MyRetailer);<br/>
Type[] interfaces = t.FindInterfaces(TypeFilter, typeof(Program).Assembly); Console.WriteLine(<br/>
&quot;MyRetailer implements the following interfaces (defined in this assembly):&quot;);<br/>
// Show information about each interface foreach (Type i in interfaces) {<br/>
Console.WriteLine(&quot;\nInterface: &quot; + i);<br/>
// Get the type methods that map to the interface's methods InterfaceMapping map = t.GetInterfaceMap(i);<br/>
for (Int32 m = 0; m &lt; map.InterfaceMethods.Length; m++) { // Display the interface method name and which // type method implements the interface method. Console.WriteLine(&quot;     {0} is implemented by {1}&quot;, map.InterfaceMethods[m], map.TargetMethods[m]);<br/>
}<br/>
}<br/>
}<br/>
// Returns true if type matches filter criteria<br/>
private static Boolean TypeFilter(Type t, Object filterCriteria) {<br/>
// Return true if the interface is defined in   assembly identified by filterCriteria return t.Assembly == filterCriteria;<br/>
}<br/>
}</code></p>
<p>When you build and run the code above, you get the following output: MyRetailer implements the following interfaces (defined in this assembly):</p>
<p><code>Interface: IBookRetailer<br/>
Void Purchase() is implemented by Void IBookRetailer.PurchaseO Void ApplyDiscount() is implemented by Void ApplyDiscount()<br/>
Interface: IMusicRetailer<br/>
Void Purchase() is implemented by Void IMusicRetailer.PurchaseO</code></p>
<p>Note that the <b>IDisposable </b>interface does not appear in the output because this interface is not declared in the EXE file's assembly.</p>
<h3>Invoking a Type's Members</h3>
<p>Now that you know how to discover the members defined by a type, you may want to invoke one of these members. What invoke means depends on the kind of member being invoked. Invoking a <b>FieldInfo </b>lets you get or set a field's value, invoking a <b>ConstructorInfo </b>lets you create an instance of the type passing arguments to a constructor, invoking a <b>MethodInfo </b>lets you call a method passing arguments and obtaining its return value, invoking a <b>PropertyInfo </b>lets you call the property's get or set accessor method, and invoking an <b>EventInfo </b>lets you add or remove an event handler.</p>
<p>Let's discuss how to invoke a method first because this is the most complex member you can invoke. Then we'll discuss how to invoke the other members. The <b>Type </b>class offers an <b>InvokeMember </b>method that lets you invoke a member There are several overloaded versions of <b>InvokeMember </b>. I'll discuss one of the more common overloads; the other overloads work similarly.</p>
<p><code>public abstract class Type : MemberInfo, ... { public Object InvokeMember(<br/>
String name,// Name of member<br/>
BindingFlags invokeAttr,// How to look up members<br/>
Binder binder,// How to match members and arguments<br/>
Object target,// Object to invoke member on<br/>
Object[] args,// Arguments to pass to method<br/>
CultureInfo culture);// Culture used by some binders<br/>
}</code></p>
<p>When you call <b>InvokeMember, </b>it searches the type's members for a match. If no match is found, a <b>System.MissingMethodException, System.MissingFieldException, </b>or <b>System.MissingMemberException </b>exception is thrown. If a match is found, <b>InvokeMember </b>invokes the member. If the member returns something, <b>InvokeMember </b>returns it to you. If the member doesn't return anything, <b>InvokeMember </b>returns <b>null. </b>If the member you call throws an exception, <b>InvokeMember </b>catches the exception and throws a new <b>System.Reflection. TargetInvocationException </b>The <b>TargetInvocationException </b>object's <b>InnerException </b>property will contain the actual exception that the invoked method threw. Personally, I don't like this behavior. I'd prefer it if <b>InvokeMember </b>didn't wrap the exception and just allowed it to come through.</p>
<p>Internally, <b>InvokeMember </b>performs two operations First, it must select the appropriate member to be called葉his is known as binding. Second, it must actually invoke the member 葉his is known as invoking. When you call <b>InvokeMember, </b>you pass a string as the <b>name </b>parameter, indicating the name of the member you want <b>InvokeMember </b>to bind to. However, the type might offer several members with the same name. After all, there might be several overloaded versions of a method, or a method and a field might have the same name. Of course, <b>InvokeMember </b>must bind to a single member before it can invoke it. All of the parameters passed to <b>InvokeMember </b>(except for the <b>target </b>parameter) are used to help <b>InvokeMember </b>decide which member to bind to. Let's take a closer look at these parameters.</p>
<p>The <b>binder </b>parameter identifies an object whose type is derived from the abstract <b>System.Reflection.Binder </b>type. A <b>Binder</b>-derived type is a type that encapsulates the rules for how <b>InvokeMember </b>should select a single member. The <b>Binder </b>base type defines abstract virtual methods such as <b>BindToField, BindToMethod, ChangeType, ReorderArgumentArray, SelectMethod, </b>and <b>SelectProperty. </b>Internally, <b>InvokeMember </b>calls these methods by using the <b>Binder </b>object passed via <b>InvokeMember</b>'s <b>binder </b>parameter.</p>
<p>Microsoft has defined an internal (undocumented) concrete type, called <b>System. DefaultBinder, </b>which is derived from <b>Binder </b>. This <b>DefaultBinder </b>type ships with the FCL, and Microsoft expects that almost everyone will use this binder. Some compiler vendors will define their own <b>Binder</b>-derived type and ship it in a runtime library used by code emitted by their compiler. <sup>1</sup> When you pass <b>null </b>to <b>InvokeMember</b>'s <b>binder </b>parameter, it will use a</p>
<p>The code that accompanies this book includes the source code for a <b>SimpleBinder </b>class that demonstrates how to define your own <b>Binder</b>-derived type.</p>
<p><b>DefaultBinder </b>object. <b>Type </b>offers a public, static, read-only property, <b>DefaultBinder, </b>that you can query to obtain a reference to a <b>DefaultBinder </b>object should you want one.</p>
<p>When a binder object has its methods called, the methods will be passed parameters to help the binder make a decision. Certainly, the binder is passed the name of the member that is being looked for. In addition, the binder's methods are passed the specified <b>BindingFlags </b>as well as the types of all of the parameters that need to be passed to the member being invoked.</p>
<p>Earlier in this chapter, Table 23-2 described the following <b>BindingFlags: Default, IgnoreCase, DeclaredOnly, Instance, Static, Public, NonPublic, </b>and <b>FlattenHierarchy.</b></p>
<p>The presence of these flags tells the binder which members to include in the search.</p>
<p>In addition to these flags, the binder examines the number of arguments passed via <b>InvokeMember</b>'s <b>args </b>parameter. The number of arguments limits the set of possible matches even further The binder then examines the types of the arguments to limit the set even more. However, when it comes to the argument's types, the binder applies some automatic type conversions to make things a bit more flexible. For example, a type can define a method that takes a single <b>Int64 </b>parameter. If you call <b>InvokeMember, </b>and in the <b>args </b>parameter, pass a reference to an array containing an <b>Int32 </b>value, the <b>DefaultBinder </b>considers this a match. When invoking the method, the <b>Int32 </b>value will be converted to an <b>Int64 </b>value. The <b>DefaultBinder </b>supports the conversions listed in Table 23-4.</p>
<p><b>table </b><b>23-4 Conversions That DefaultBinder Supports</b></p>
<table border="1">
<tr>
<td>
<p>e</p>
</td>
<td>
<p>e</p>
</td>
</tr>
<tr>
<td>
<p>Any type</p>
</td>
<td>
<p>Its base type</p>
</td>
</tr>
<tr>
<td>
<p>Any type</p>
</td>
<td>
<p>The interfaces it implements</p>
</td>
</tr>
<tr>
<td>
<p>r</p>
</td>
<td>
<p><b>UInt16, UInt32, Int32, UInt64, Int64, Single, Double</b></p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p><b>Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</b></p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p><b>Int16, Int32, Int64, Single, Double</b></p>
</td>
</tr>
<tr>
<td>
<p>6</p>
</td>
<td>
<p><b>UInt32, Int32, UInt64, Int64, Single, Double</b></p>
</td>
</tr>
<tr>
<td>
<p>6</p>
</td>
<td>
<p><b>Int32, Int64, Single, Double</b></p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p><b>UInt64, Int64, Single, Double</b></p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p><b>Int64, Single, Double</b></p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p><b>Single, Double</b></p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p><b>Single, Double</b></p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>e</p>
</td>
</tr>
<tr>
<td>
<p>A value type instance</p>
</td>
<td>
<p>A boxed version of the value type instance</p>
</td>
</tr>
</table>
<p>There are two more <b>BindingFlags </b>that you can use to fine-tune the <b>DefaultBinder</b>'s</p>
<p>behavior. These are described in Table 23-5.</p>
<p><b>Table 23-5 </b><b>BindingFlags Used with DefaultBinder</b></p>
<table border="1">
<tr>
<td>
<p>l</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>g</p>
</td>
<td>
<p>0x010000</p>
</td>
<td>
<p>The binder will look for a member whose formal parameters exactly match the types of the supplied arguments.</p>
</td>
</tr>
<tr>
<td>
<p>g</p>
</td>
<td>
<p>0x040000</p>
</td>
<td>
<p>The binder will consider any member whose count of parameters matches the number of arguments passed. This flag is useful when there are members whose parameters have default values and for methods that take a variable number of arguments Only <b>Type</b>'s <b>InvokeMember </b>method honors this flag.</p>
</td>
</tr>
</table>
<p><b>InvokeMember</b>'s last parameter, <b>culture, </b>could also be used for binding However, the <b>DefaultBinder </b>type completely ignores this parameter. If you define your own binder, you could use the culture parameter to help with argument type conversions For example, the caller could pass a <b>String </b>argument with a value of &quot;1,23.&quot; The binder could examine this string, parse it using the specified <b>culture, </b>and convert the argument's type to a <b>Single </b>(if the culture is &quot;de-DE&quot;) or continue to consider the argument to be a <b>String </b>(if the culture is &quot;en-US&quot;).</p>
<p>At this point, I've gone through all <b>InvokeMember</b>'s parameters related to binding The one parameter I haven't discussed yet is <b>target </b>This parameter is a reference to the object whose member you want to call. If you want to call a type's static member, you should pass <b>null </b>for this parameter</p>
<p>The <b>InvokeMember </b>method is a very powerful method. It allows you to call a method (as I've been discussing), construct an instance of a type (basically by calling a constructor method), get or set a field, or get or set a property. You tell <b>InvokeMember </b>which of these actions you want to perform by specifying one of the <b>BindingFlags </b>listed in Table 23-6.</p>
<p>For the most part, the flags in Table 23-6 are mutually exclusive遥ou must pick one and only one when calling <b>InvokeMember </b>. However, you can specify both <b>GetField </b>and <b>GetProperty, </b>in which case <b>InvokeMember </b>searches for a matching field first and then for a matching property if it doesn't find a matching field. Likewise, <b>SetField </b>and <b>SetProperty </b>can both be specified and are matched the same way. The binder uses these flags to narrow the set of possible matches. If you specify the <b>BindingFlags.CreateInstance </b>flag, the binder knows that it can select only a constructor method.</p>
<p><b>Table 23-6 </b><b>BindingFlags Used with InvokeMember</b></p>
<table border="1">
<tr>
<td>
<p>l</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>d</p>
</td>
<td>
<p>0x0100</p>
</td>
<td>
<p>Tells <b>InvokeMember </b>to call a method</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>0x0200</p>
</td>
<td>
<p>Tells <b>InvokeMember </b>to create a new object and call its constructor</p>
</td>
</tr>
<tr>
<td>
<p>d</p>
</td>
<td>
<p>0x0400</p>
</td>
<td>
<p>Tells <b>InvokeMember </b>to get a field's value</p>
</td>
</tr>
<tr>
<td>
<p>d</p>
</td>
<td>
<p>0x0800</p>
</td>
<td>
<p>Tells <b>InvokeMember </b>to set a field's value</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>0x1000</p>
</td>
<td>
<p>Tells <b>InvokeMember </b>to call a property's get accessor method</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
</td>
<td>
<p>0x2000</p>
</td>
<td>
<p>Tells <b>InvokeMember </b>to call a property's set accessor method</p>
</td>
</tr>
</table>
<hr/>
<blockquote><b>Important </b>With what I've told you so far, it would seem that reflection makes it easy to bind to a non-public member and invoke the member allowing application code a way to access private members that a compiler would normally prohibit the code from accessing. However, reflection uses code access security (CAS) to ensure that its power isn't abused or exploited.</blockquote>
<hr/>
<p>When you call a method to bind to a member, the CLR first checks to see whether the member you're trying to bind to would be visible to you at compile time. If it would be, the bind is successful. If the member wouldn't normally be accessible to you, the method demands the <b>System.Security.Permissions.ReflectionPermission </b>permission, checking to see whether the <b>System.Security.Permissions.ReflectionPermissionFlags</b>'s <b>TypeInformation </b>bit is set. If this flag is set, the method will bind to the member. If the demand fails, a <b>System.Security.SecurityException </b>is thrown.</p>
<p>When you call a method to invoke a member, the method performs the same kind of check that it would when binding to a member. But this time, it checks whether the <b>ReflectionPermission </b>has <b>ReflectionPermissionFlag</b>'s <b>MemberAccess </b>bit set. If the bit is set, the member is invoked; otherwise, a <b>SecurityException </b>is thrown.</p>
<p>Of course, if your assembly has full-trust, security checks are assumed to be successful allowing binding and invoking to just work. However, you should never, ever use reflection to access any of a type's undocumented members because a future version of the assembly may easily break your code.</p>
<h3>Bind Once, Invoke Multiple Times</h3>
<p><b>Type</b>'s <b>InvokeMember </b>method gives you access to all of a type's members. However, you should be aware that every time you call <b>InvokeMember, </b>it must bind to a particular member and then invoke it. Having the binder select the right member each time you want to invoke a member is time-consuming, and if you do it a lot, your application's performance will suffer So if you plan on accessing a member frequently, you're better off binding to the desired member once and then accessing that member as often as you want.</p>
<p>In this chapter, we've already discussed how to bind to a member by calling one of <b>Type</b>'s methods: <b>GetFields, GetConstructors, GetMethods, GetProperties, GetEvents, </b>or any similar method. All of these methods return references to objects whose type offers methods to access the specific member directly. Table 23-7 shows which method to call for each kind of member to invoke that member</p>
<p><b>Table 23-7 </b><b>How to Invoke a Member After Binding to It</b></p>
<table border="1">
<tr>
<td>
<p>r</p>
</td>
<td>
<p>r</p>
</td>
</tr>
<tr>
<td>
<p>o</p>
</td>
<td>
<p>Call <b>GetValue </b>to get a field's value. Call <b>SetValue </b>to set a field's value.</p>
</td>
</tr>
<tr>
<td>
<p>o</p>
</td>
<td>
<p>Call <b>Invoke </b>to construct an instance of the type and call a constructor.</p>
</td>
</tr>
<tr>
<td>
<p>o</p>
</td>
<td>
<p>Call <b>Invoke </b>to call a method of the type.</p>
</td>
</tr>
<tr>
<td>
<p>o</p>
</td>
<td>
<p>Call <b>GetValue </b>to call a property's get accessor method. Call <b>SetValue </b>to call a property's set accessor method.</p>
</td>
</tr>
<tr>
<td>
<p>o</p>
</td>
<td>
<p>Call <b>AddEventHandler </b>to call an event's add accessor method.</p>
<p>Call <b>RemoveEventHandler </b>to call an event's remove accessor method.</p>
</td>
</tr>
</table>
<p>The <b>PropertyInfo </b>type represents metadata information about a property (as discussed in Chapter 10, &quot;Properties&quot;); that is, <b>PropertyInfo </b>offers <b>CanRead, CanWrite, </b>and <b>PropertyType </b>read-only properties These properties indicate whether a property is readable or writeable and what data type the property is <b>PropertyInfo </b>has a <b>GetAccessors </b>method that returns an array of <b>MethodInfo </b>elements: one for the get accessor method (if it exists), and one for the set accessor method (if it exists). Of more value are <b>PropertyInfo</b>'s <b>GetGetMethod </b>and <b>GetSetMethod </b>methods, each of which returns just one <b>MethodInfo </b>object. <b>PropertyInfo</b>'s <b>GetValue </b>and <b>SetValue </b>methods exist for convenience; internally, they get the appropriate <b>MethodInfo </b>and call it. To support parameterful properties (C# indexers), the <b>GetValue </b>and <b>SetValue </b>methods offer an <b>index </b>parameter of <b>Object[] </b>type.</p>
<p>The <b>EventInfo </b>type represents metadata information about an event (as discussed in Chapter 11, &quot;Events&quot;). The <b>EventInfo </b>type offers an <b>EventHandlerType </b>read-only property that returns the <b>Type </b>of the event's underlying delegate The <b>EventInfo </b>type also has <b>GetAddMethod </b>and <b>GetRemoveMethod </b>methods, which return the <b>MethodInfo </b>corresponding to the method that adds or removes a delegate to/from the event. To add or remove a delegate, you can invoke these <b>MethodInfo </b>objects, or you can call <b>EventInfo</b>'s more convenient <b>AddEventHandler </b>and <b>RemoveEventHandler </b>methods.</p>
<p>When you call one of the methods listed in the right column of Table 23-7, you're not binding to a member; you're just invoking the member You can call any of these methods multiple times, and because binding isn't necessary, the performance will be pretty good.</p>
<p>You might notice that <b>ConstructorInfo</b>'s <b>Invoke, MethodInfo</b>'s <b>Invoke, </b>and <b>PropertyInfo</b>'s <b>GetValue </b>and <b>SetValue </b>methods offer overloaded versions that take a reference to a <b>Binder</b>-derived object and some <b>BindingFlags </b>. This would lead you to believe that these methods bind to a member However, they don't.</p>
<p>When calling any of these methods, the <b>Binder</b>-derived object is used to perform type conversions on the supplied method parameters, such as converting an <b>Int32 </b>argument to an <b>Int64, </b>so that the already selected method can be called. As for the <b>BindingFlags </b>parameter, the only flag that can be passed here is <b>BindingFlags.SuppressChangeType. </b>However, binders are free to ignore this flag. Fortunately, the <b>DefaultBinder </b>class heeds this flag. When <b>DefaultBinder </b>sees this flag, it won't convert any arguments. If you use this flag and the arguments passed don't match the arguments expected by the method, an <b>ArgumentException </b>will be thrown.</p>
<p>Usually when you use the <b>BindingFlags.ExactBinding </b>flag to bind to a member, you'll specify the <b>BindingFlags.SuppressChangeType </b>flag to invoke the member. If you don't use these two flags in tandem, it's unlikely that invoking the member will be successful unless the arguments you pass happen to be exactly what the method expects. By the way, if you call <b>MemberInfo</b>'s <b>InvokeMethod </b>to bind and invoke a member, you'll probably want to specify both or neither of the two binding flags.</p>
<p>The following sample application demonstrates the various ways to use reflection to access a type's members The <b>SomeType </b>class represents a type that has various members: a private field <b>(m_someField), </b>a public constructor <b>(SomeType) </b>that takes an <b>Int32 </b>argument passed by reference, a public method <b>(ToString), </b>a public property <b>(SomeProp), </b>and a public event <b>(SomeEvent) </b>. Having defined the <b>SomeType </b>type, I offer three different methods that use reflection to access <b>SomeType</b>'s members. Each method uses reflection in a different way to accomplish the same thing:</p>
<p>&#9632; The <b>UseInvokeMemberToBindAndInvokeTheMember </b>method demonstrates how to use <b>Type</b>'s <b>InvokeMember </b>to both bind and invoke a member</p>
<p>&#9632; The <b>BindToMemberThenInvokeTheMember </b>method demonstrates how to bind to a member and invoke it later This technique yields faster-performing code if you intend to invoke the same member on different objects multiple times.</p>
<p>&#9632; The <b>BindToMemberCreateDelegateToMemberThenInvokeTheMember </b>method demonstrates how to bind to an object or member, and then it creates a delegate that refers to that object or member Calling through the delegate is very fast, and this technique yields even faster performance if you intend to invoke the same member on the same object multiple times.</p>
<p>&#9632; The <b>UseDynamicToBindAndInvokeTheMember </b>method demonstrates how to use C# <b>dynamic </b>primitive type (discussed at the end of Chapter 5, &quot;Primitive, Reference, and Value Types&quot;) to simplify the syntax for accessing members. In addition, this technique can give reasonably good performance if you intend to invoke the same member on different objects that are all of the same type because the binding will happen once per type and be cached so that it can be invoked multiple times quickly. You can also use this technique to invoke a member on objects of different types.</p>
<p><code>using System;<br/>
using System.Reflection;<br/>
using Microsoft.CSharp.RuntimeBinder;<br/>
// This class is used to demonstrate reflection<br/>
// It has a field, constructor, method, property, and an event<br/>
internal sealed class SomeType {<br/>
private Int32 m_someField;<br/>
public SomeType(ref Int32 x) { x *= 2; }<br/>
public override String ToString() { return m_someField.ToString(); } public Int32 SomeProp {<br/>
get { return m_someField; }<br/>
set {<br/>
if (value &lt; 1)<br/>
throw new ArgumentOutOfRangeException(&quot;value&quot;); m_someField = value;<br/>
}<br/>
public event EventHandler SomeEvent;<br/>
private void NoCompilerWarnings() { SomeEvent.ToString<b>O;}</b><br/>
}<br/>
public static class Program {<br/>
private const BindingFlags c_bf = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;<br/>
public static void Main() { Type t = typeof(SomeType); UseInvokeMemberToBindAndInvokeTheMember(t); Console.WriteLine<b>O;</b><br/>
BindToMemberThenInvokeTheMember(t); Console.WriteLine<b>O;</b><br/>
BindToMemberCreateDelegateToMemberThenInvokeTheMember(t); Console.WriteLine<b>O;</b><br/>
UseDynamicToBindAndInvokeTheMember(t); Console.WriteLine<b>O;</b><br/>
}<br/>
private static void UseInvokeMemberToBindAndInvokeTheMember(Type t) { Console.WriteLineC'llseInvokeMemberToBindAndInvokeTheMember&quot;);<br/>
// Construct an instance of the Type<br/>
Object[] args = new Object[] { 12 };   // Constructor arguments<br/>
Console.WriteLineC'x before constructor called: &quot; + args[0]);<br/>
Object obj = t.InvokeMember(nu11, c_bf | BindingFlags.CreateInstance,<br/>
null, null, args); Console.WriteLineC'Type: &quot; + obj.CetType().ToString()); Console.WriteLineC'x after constructor returns: &quot; + args[0]);<br/>
// Read and write to a field<br/>
t.InvokeMember(&quot;m_someField&quot;, c_bf | BindingFlags.SetField,<br/>
null, obj, new Object[] { 5 }); Int32 v = (Int32)t.InvokeMember(&quot;m_someField&quot;, c_bf | BindingFlags.CetField,<br/>
null, obj, null); Console.WriteLineC'someField: &quot; + v);<br/>
// Call a method String s = (String)<br/>
t.InvokeMember(&quot;ToString&quot;, c_bf | BindingFlags.InvokeMethod, null, obj, null); Console.WriteLineC'ToString: &quot; + s);<br/>
// Read and write a property<br/>
try {<br/>
t.InvokeMember(&quot;SomeProp&quot;, c_bf | BindingFlags.SetProperty, null, obj, new Object[] { 0 });<br/>
}<br/>
catch (TargetInvocationException e) {<br/>
if (e.InnerException.GetType() != typeof(ArgumentOutOfRangeException)) throw; Console.WriteLine(&quot;Property set catch.&quot;);<br/>
}<br/>
t.InvokeMember(&quot;SomeProp&quot;, c_bf | BindingFlags.SetProperty,<br/>
null, obj, new Object[] { 2 }); v = (Int32)t.InvokeMember(&quot;SomeProp&quot;, c_bf | BindingFlags.CetProperty,<br/>
null, obj, null); Console.WriteLineC'SomeProp: &quot; + v);<br/>
// Add and remove a delegate from the event by invoking the event's add/remove methods EventHandler eh = new EventHandler(EventCallback); t.InvokeMember(&quot;add_SomeEvent&quot;, c_bf | BindingFlags.InvokeMethod,<br/>
null, obj, new Object[] { eh }); t.InvokeMember(&quot;remove_SomeEvent&quot;, c_bf | BindingFlags.InvokeMethod,<br/>
null, obj, new Object[] { eh });<br/>
}<br/>
private static void BindToMemberThenInvokeTheMember(Type t) { Console.WriteLineC'BindToMemberThenInvokeTheMember&quot;);<br/>
// Construct an instance // ConstructorInfo ctor =<br/>
//      t.CetConstructor(new Type[] { Type.CetType(&quot;System.Int32&amp;&quot;) });<br/>
ConstructorInfo ctor = t.CetConstructor(new Type[] { typeof(Int32).MakeByRefType() });<br/>
Object[] args = new Object[] { 12 };   // Constructor arguments<br/>
Console.WriteLineC'x before constructor called: &quot; + args[0]);<br/>
Object obj = ctor.Invoke(args);<br/>
Console.WriteLine(&quot;Type: &quot; + obj.CetType().ToString()); Console.WriteLine(&quot;x after constructor returns: &quot; + args[0]);<br/>
// Read and write to a field<br/>
FieldInfo fi = obj.CetType().CetField(&quot;m_someField&quot;, c_bf); fi.SetValue(obj, 33);<br/>
Console.WriteLine(&quot;someField: &quot; + fi.CetValue(obj));<br/>
// Call a method<br/>
MethodInfo mi = obj.GetType().GetMethod(&quot;ToString&quot;, c_bf); String s = (String)mi.Invoke(obj, null); Console.WriteLineC'ToString: &quot; + s);<br/>
// Read and write a property<br/>
PropertyInfo pi = obj.GetType().GetProperty(&quot;SomeProp&quot;, typeof(Int32));<br/>
try {<br/>
pi.SetValue(obj, 0, null);<br/>
}<br/>
catch (TargetInvocationException e) {<br/>
if (e.InnerException.GetType() != typeof(ArgumentOutOfRangeException)) throw; Console.WriteLine(&quot;Property set catch.&quot;);<br/>
}<br/>
pi.SetValue(obj, 2, null);<br/>
Console.WriteLine(&quot;SomeProp: &quot; + pi.GetValue(obj, null));<br/>
// Add and remove a delegate from the event<br/>
EventInfo ei = obj.GetType().GetEvent(&quot;SomeEvent&quot;, c_bf);<br/>
EventHandler ts = new EventHandler(EventCallback); // See ei.EventHandlerType ei.AddEventHandler(obj, ts); ei.RemoveEventHandler(obj, ts);<br/>
}<br/>
// Callback method added to the event<br/>
private static void EventCallback(Object sender, EventArgs e) { }<br/>
private static void BindToMemberCreateDelegateToMemberThenInvokeTheMember(Type t) { Console.WriteLineC'BindToMemberCreateDelegateToMemberThenInvokeTheMember&quot;);<br/>
// Construct an instance (You can't create a delegate to a constructor) Object[] args = new Object[] { 12 };   // Constructor arguments Console.WriteLineC'x before constructor called: &quot; + args[0]); Object obj = Activator.CreateInstance(t, args); Console.WriteLine(&quot;Type: &quot; + obj.GetType().ToString()); Console.WriteLine(&quot;x after constructor returns: &quot; + args[0]);<br/>
// NOTE: You can't create a delegate to a field<br/>
// Call a method<br/>
MethodInfo mi = obj.GetType().GetMethod(&quot;ToString&quot;, c_bf);<br/>
var toString = (Func&lt;String&gt;) Delegate.CreateDelegate(typeof(Func&lt;String&gt;), obj, mi); String s = toString(); Console.WriteLine(&quot;ToString: &quot; + s);<br/>
// Read and write a property<br/>
PropertyInfo pi = obj.GetType().GetProperty(&quot;SomeProp&quot;, typeof(Int32)); var setSomeProp = (Action&lt;Int32&gt;)<br/>
Delegate.CreateDelegate(typeof(Action&lt;Int32&gt;), obj, pi.GetSetMethod());<br/>
try {<br/>
setSomeProp(0);<br/>
}<br/>
catch (ArgumentOutOfRangeException) {<br/>
Console.WriteLineC'Property set catch.&quot;);<br/>
}<br/>
setSomeProp(2);<br/>
var getSomeProp = (Func&lt;Int32&gt;)<br/>
Delegate.CreateDelegate(typeof(Func&lt;Int32&gt;), obj, pi.CetCetMethod()); Console.WriteLine(&quot;SomeProp: &quot; + getSomeProp());<br/>
// Add and remove a delegate from the event<br/>
EventInfo ei = obj.CetType().CetEvent(&quot;SomeEvent&quot;, c_bf);<br/>
var addSomeEvent = (Action&lt;EventHandler&gt;)<br/>
Delegate.CreateDelegate(typeof(Action&lt;EventHandler&gt;), obj, ei.CetAddMethod()); addSomeEvent(EventCallback); var removeSomeEvent = (Action&lt;EventHandler&gt;)<br/>
Delegate.CreateDelegate(typeof(Action&lt;EventHandler&gt;), obj, ei.CetRemoveMethod()); removeSomeEvent(EventCallback);<br/>
}<br/>
private static void UseDynamicToBindAndInvokeTheMember(Type t) { Console.WriteLine(&quot;UseDynamicToBindAndInvokeTheMember&quot;);<br/>
// Construct an instance (You can't create a delegate to a constructor) Object[] args = new Object[] { 12 };   // Constructor arguments Console.WriteLineC'x before constructor called: &quot; + args[0]); dynamic obj = Activator.CreateInstance(t, args); Console.WriteLineC'Type: &quot; + obj.CetType().ToString()); Console.WriteLine(&quot;x after constructor returns: &quot; + args[0]);<br/>
// Read and write to a field<br/>
try {<br/>
obj.m_someField = 5;<br/>
Int32 v = (Int32)obj.m_someField;<br/>
Console.WriteLineC'someField: &quot; + v);<br/>
}<br/>
catch (RuntimeBinderException e) {<br/>
// We get here because the field is private Console.WriteLineC'Failed to access field: &quot; + e.Message);<br/>
}<br/>
// Call a method<br/>
String s = (String)obj.ToString(); Console.WriteLineC'ToString: &quot; + s);<br/>
// Read and write a property<br/>
try {<br/>
obj.SomeProp = 0;<br/>
}<br/>
catch (ArgumentOutOfRangeException) {<br/>
Console.WriteLine(&quot;Property set catch.&quot;);<br/>
}<br/>
obj.SomeProp = 2;<br/>
Int32 val = (Int32)obj.SomeProp;<br/>
Console.WriteLine(&quot;SomeProp: &quot; + val);<br/>
// Add and remove a delegate from the event obj.SomeEvent += new EventHandler(EventCallback); obj.SomeEvent -= new EventHandler(EventCallback);<br/>
}<br/>
}</code></p>
<p>If you build and run this code, you'll see the following output:</p>
<p><code>UseInvokeMemberToBindAndInvokeTheMember x before constructor called: 12 Type: SomeType<br/>
x after constructor returns: 24 someField: 5 ToString: 5 Property set catch. SomeProp: 2<br/>
BindToMemberThenInvokeTheMember x before constructor called: 12 Type: SomeType<br/>
x after constructor returns: 24 someField: 33 ToString: 33 Property set catch. SomeProp: 2<br/>
BindToMemberCreateDelegateToMemberThenInvokeTheMember x before constructor called: 12 Type: SomeType<br/>
x after constructor returns: 24 ToString: 0 Property set catch. SomeProp: 2<br/>
UseDynamicToBindAndInvokeTheMember x before constructor called: 12 Type: SomeType<br/>
x after constructor returns: 24<br/>
Failed to access field:  'SomeType.m_someField' is inaccessible due to its protection level ToString: 0 Property set catch. SomeProp: 2</code></p>
<p>Notice that <b>SomeType</b>'s constructor takes an <b>Int32 </b>by reference as its only parameter. The previous code shows how to call this constructor and how to examine the modified <b>Int32 </b>value after the constructor returns. Furthermore, near the top of the <b>BindToMemberThenInvokeTheMember </b>method is a call to <b>Type</b>'s <b>GetType </b>method passing in a string of <b>&quot;System.Int32&amp;&quot;. </b>The ampersand (<b>&amp;</b>) in the string allows me to identify a parameter passed by reference. This ampersand is part of the Backus-Naur Form grammar for type names, which you can look up in the FCL documentation. That line of code could also have been written like this:</p>
<p><code>ConstructorInfo ctor = t.CetConstructor(new Type[] { typeof(Int32).MakeByRefType() });</code></p>
<h3>Using Binding Handles to Reduce Your Process's Memory Consumption</h3>
<p>Many applications bind to a bunch of types <b>(Type </b>objects) or type members <b>(MemberInfo-</b>derived objects) and save these objects in a collection of some sort. Then later, the application searches the collection for a particular object and then invokes this object. This is a fine way of doing things except for one small issue: <b>Type </b>and <b>MemberInfo</b>-derived objects require a lot of memory. So if an application holds on to too many of these objects and invokes them occasionally, the application's memory consumption increases dramatically, having an adverse effect on the application's performance.</p>
<p>Internally, the CLR has a more compact way of representing this information. The CLR creates these objects for our applications only to make things easier for developers. The CLR doesn't need these big objects itself in order to run. Developers who are saving/caching a lot of <b>Type </b>and <b>MemberInfo</b>-derived objects can reduce their working set by using runtime handles instead of objects. The FCL defines three runtime handle types (all defined in the System namespace): <b>RuntimeTypeHandle, RuntimeFieldHandle, </b>and <b>RuntimeMethodHandle </b>. All of these types are value types that contain just one field, an <b>IntPtr; </b>this makes instances of these types extremely cheap (memory-wise). The <b>IntPtr </b>field is a handle that refers to a type, field, or method in an AppDomain's loader heap. So what you need now is an easy and efficient way to convert a heavyweight <b>Type/MemberInfo </b>object to a lightweight runtime handle instance and vice versa. Fortunately, this is easy using the following conversion methods and properties:</p>
<p>&#9632; To convert a <b>Type </b>object to a <b>RuntimeTypeHandle, </b>call <b>Type</b>'s static <b>GetTypeHandle</b></p>
<p>method passing in the reference to the <b>Type </b>object.</p>
<p>&#9632; To convert a <b>RuntimeTypeHandle </b>to a <b>Type </b>object, call <b>Type</b>'s static <b>GetTypeFromHandle </b>method passing in the <b>RuntimeTypeHandle </b>.</p>
<p>&#9632; To convert a <b>FieldInfo </b>object to a <b>RuntimeFieldHandle, </b>query <b>FieldInfo</b>'s instance read-only <b>FieldHandle </b>property.</p>
<p>&#9632; To convert a <b>RuntimeFieldHandle </b>to a <b>FieldInfo </b>object, call <b>FieldInfo</b>'s static <b>GetFieldFromHandle </b>method.</p>
<p>&#9632; To convert a <b>MethodInfo </b>object to a <b>RuntimeMethodHandle, </b>query <b>MethodInfo</b>'s</p>
<p>instance read-only <b>MethodHandle </b>property.</p>
<p>&#9632; To convert a <b>RuntimeMethodHandle </b>to a <b>MethodInfo </b>object, call <b>MethodInfo</b>'s static <b>GetMethodFromHandle </b>method.</p>
<p>The program sample below acquires a lot of <b>MethodInfo </b>objects, converts them to <b>RuntimeMethodHandle </b>instances, and shows the working set difference:</p>
<p><code>using System;<br/>
using System.Reflection;<br/>
using System.Collections.Ceneric;<br/>
public sealed class Program {<br/>
private const BindingFlags c_bf = BindingFlags.FlattenHierarchy | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;<br/>
public static void Main() {<br/>
// Show size of heap before doing any reflection stuff Show(&quot;Before doing anything&quot;);<br/>
// Build cache of MethodInfo objects for all methods in MSCorlib.dll<br/>
List&lt;MethodBase&gt; methodInfos = new List&lt;MethodBase&gt;();<br/>
foreach (Type t in typeof(Object).Assembly.CetExportedTypes()) {<br/>
// Skip over any generic types<br/>
if (t.IsCenericTypeDefinition) continue;<br/>
MethodBase[] mb = t.CetMethods(c_bf); methodInfos.AddRange(mb);<br/>
}<br/>
// Show number of methods and size of heap after binding to all methods Console.WriteLine(&quot;# of methods={0:N0}&quot;, methodInfos.Count); Show(&quot;After building cache of MethodInfo objects&quot;);<br/>
// Build cache of RuntimeMethodHandles for all MethodInfo objects List&lt;RuntimeMethodHandle&gt; methodHandles =<br/>
methodInfos.ConvertAll&lt;RuntimeMethodHandle&gt;(mb =&gt; mb.MethodHandle);<br/>
Show(&quot;Holding MethodInfo and RuntimeMethodHandle cache&quot;); CC.KeepAlive(methodInfos); // Prevent cache from being CC'd early<br/>
methodInfos = null;// Allow cache to be CC'd now<br/>
Show(&quot;After freeing MethodInfo objects&quot;);<br/>
methodInfos = methodHandles.ConvertAll&lt;MethodBase&gt;(<br/>
rmh=&gt; MethodBase.CetMethodFromHandle(rmh)); Show(&quot;Size of heap after re-creating MethodInfo objects&quot;); CC.KeepAlive(methodHandles);   // Prevent cache from being CC'd early CC.KeepAlive(methodInfos);      // Prevent cache from being CC'd early<br/>
methodHandles = null;// Allow cache to be CC'd now<br/>
methodInfos = null;// Allow cache to be CC'd now<br/>
Show(&quot;After freeing MethodInfos and RuntimeMethodHandles&quot;);<br/>
}<br/>
}</code></p>
<p>When I compiled and executed this program, I got the following output:</p>
<p><code>Heap size=        85,000 - Before doing anything # of methods=48,467<br/>
Heap size=.7,065,632.-.After building cache of MethodInfo objects<br/>
Heap size=.7,453,496.-.Holding MethodInfo and RuntimeMethodHandle cache<br/>
Heap size=.6,732,704.-.After freeing MethodInfo objects<br/>
Heap size=.7,372,704.-.Size of heap after re-creating MethodInfo objects<br/>
Heap size=        192,232.-.After freeing MethodInfos and RuntimeMethodHandles</code></p>
<mbp:pagebreak/>
<a name="Chapter24"/>
<h1>Chapter 24: Runtime Serialization</h1>
<p><b>In this chapter:</b></p>
<a href="#b662">Serialization/Deserialization Quick Start</a><br/>
<a href="#b668">Controlling Serialization and Deserialization</a><br/>
<a href="#b672">How Formatters Serialize Type Instances</a><br/>
<a href="#b673">Controlling the Serialized/Deserialized Data</a><br/>
<a href="#b682"><b>Serializing a Type as a Different Type and Deserializing an Object</b></a><br/>
<a href="#b689">Overriding the Assembly and/or Type When Deserializing an Object</a><br/>
<p>Serialization is the process of converting an object or a graph of connected objects into a stream of bytes. Deserialization is the process of converting a stream of bytes back into its graph of connected objects. The ability to convert objects to and from a byte stream is an incredibly useful mechanism. Here are some examples:</p>
<p>&#9632; An application's state (object graph) can easily be saved in a disk file or database and then restored the next time the application is run. ASP.NET saves and restores session state by way of serialization and deserialization.</p>
<p>&#9632; A set of objects can easily be copied to the system's clipboard and then pasted into the same or another application. In fact, Windows Forms and Windows Presentation Foundation (WPF) use this.</p>
<p>&#9632; A set of objects can be cloned and set aside as a &quot;backup&quot; while a user manipulates the &quot;main&quot; set of objects.</p>
<p>&#9632; A set of objects can easily be sent over the network to a process running on another machine. The Microsoft .NET Framework's remoting architecture serializes and deserializes objects that are marshaled by value. It is also used to send objects across AppDomain boundaries, as discussed in Chapter 22, &quot;CLR Hosting and AppDomains.&quot;</p>
<p>In addition to the above, once you have serialized objects in a byte stream in memory, it is quite easy to process the data in more useful ways, such as encrypting and compressing the data.</p>
<p>With serialization being so useful, it is no wonder that many programmers have spent countless hours developing code to perform these types of actions. Historically, this code is difficult to write and is extremely tedious and error-prone. Some of the difficult issues that developers need to grapple with are communication protocols, client/server data type mismatches (such as little-endian/big-endian issues), error handling, objects that refer to other objects, in and out parameters, arrays of structures, and the list goes on.</p>
<p>Well, you'll be happy to know that the .NET Framework has fantastic support for serialization and deserialization built right into it. This means that all of the difficult issues mentioned above are now handled completely and transparently by the .NET Framework. As a developer, you can work with your objects before serialization and after deserialization and have the .NET Framework handle the stuff in the middle.</p>
<p>In this chapter, I explain how the .NET Framework exposes its serialization and deserialization services. For almost all data types, the default behavior of these services will be sufficient, meaning that it is almost no work for you to make your own types serializable. However, there is a small minority of types where the serialization service's default behavior will not be sufficient. Fortunately, the serialization services are very extensible, and I will also explain how to tap into these extensibility mechanisms, allowing you to do some pretty powerful things when serializing or deserializing objects. For example, I'll demonstrate how to serialize Version 1 of an object out to a disk file and then deserialize it a year later into an object of Version 2.</p>
<hr/>
<blockquote><b>Note </b>This chapter focuses on the runtime serialization technology in the common language runtime (CLR), which has a deep understanding of CLR data types and can serialize all the public, protected, internal, and even private fields of an object to a compressed binary stream for high performance. See the <b>System.Runtime.Serialization.NetDataContractSerializer </b>class if you wish to serialize CLR data types to an XML stream. The .NET Framework also offers other serialization technologies that are designed more for interoperating between CLR data types and non-CLR data types These other serialization technologies use the <b>System. Xml.Serialization.XmlSerializer </b>class and the <b>System.Runtime.Serialization. DataContractSerializer </b>class.</blockquote>
<hr/>
<a name="b662"/><h2>Serialization/Deserialization Quick Start</h2>
<p>Let's start off by looking at some code: using System;</p>
<p><code>using System.Collections.Ceneric; using System.IO;<br/>
using System.Runtime.Serialization.Formatters.Binary;<br/>
internal static class QuickStart { public static void Main() {<br/>
// Create a graph of objects to serialize them to the stream<br/>
var objectCraph = new List&lt;String&gt; { &quot;Jeff&quot;, &quot;Kristin&quot;, &quot;Aidan&quot;, &quot;Crant&quot; };<br/>
Stream stream = SerializeToMemory(objectCraph);<br/>
// Reset everything for this demo stream.Position = 0; objectCraph = null;<br/>
// Deserialize the objects and prove it worked<br/>
objectCraph = (List&lt;String&gt;) DeserializeFromMemory(stream);<br/>
foreach (var s in objectCraph) Console.WriteLine(s);<br/>
}<br/>
private static MemoryStream SerializeToMemory(Object objectCraph) { // Construct a stream that is to hold the serialized objects MemoryStream stream = new MemoryStream();<br/>
// Construct a serialization formatter that does all the hard work BinaryFormatter formatter = new BinaryFormatter();<br/>
// Tell the formatter to serialize the objects into the stream formatter.Serialize(stream, objectCraph);<br/>
// Return the stream of serialized objects back to the caller return stream;<br/>
}<br/>
private static Object DeserializeFromMemory(Stream stream) {<br/>
// Construct a serialization formatter that does all the hard work BinaryFormatter formatter = new BinaryFormatter();<br/>
// Tell the formatter to deserialize the objects from the stream return formatter.Deserialize(stream);<br/>
}<br/>
}</code></p>
<p>Wow, look how simple this is! The <b>SerializeToMemory </b>method constructs a <b>System. IO.MemoryStream </b>object. This object identifies where the serialized block of bytes is to be placed. Then the method constructs a <b>BinaryFormatter </b>object (which can be found in the <b>System.Runtime.Serialization.Formatters.Binary </b>namespace). A formatter is a type (implementing the <b>System.Runtime.Serialization.IFormatter </b>interface) that knows how to serialize and deserialize an object graph. The Framework Class Library (FCL) ships with two formatters: the <b>BinaryFormatter </b>(used in this code example) and a <b>SoapFormatter </b>(which can be found in the <b>System.Runtime.Serialization.Formatters.Soap </b>namespace and is implemented in the System. Runtime.Serialization. Formatters.Soap.dll assembly).</p>
<hr/>
<blockquote><b>Note </b>As of version 3.5 of the .NET Framework, the <b>SoapFormatter </b>class is obsolete and should not be used in production code However, it can still be useful for debugging serialization code as it produces XML text which you can read To use XML serialization and deserialization in production code, see the <b>XmlSerializer </b>and <b>DataContractSerializer </b>classes.</blockquote>
<hr/>
<p>To serialize a graph of objects, just call the formatter's <b>Serialize </b>method and pass it two things: a reference to a stream object and a reference to the object graph that you wish to serialize. The stream object identifies where the serialized bytes should be placed and can be an object of any type derived from the <b>System.IO.Stream </b>abstract base class. This means that you can serialize an object graph to a <b>MemoryStream, </b>a <b>FileStream, </b>a <b>NetworkStream, </b>and so on.</p>
<p>The second parameter to <b>Serialize </b>is a reference to an object. This object could be anything: an <b>Int32, </b>a <b>String, </b>a <b>DateTime, </b>an <b>Exception, </b>a <b>List&lt;String&gt;, </b>a <b>Dictionary&lt;Int32, DatTime&gt;, </b>and so on. The object referred to by the <b>objectGraph </b>parameter may refer to other objects. For example, <b>objectGraph </b>may refer to a collection that refers to a set of objects. These objects may also refer to other objects. When the formatter's <b>Serialize </b>method is called, all objects in the graph are serialized to the stream.</p>
<p>Formatters know how to serialize the complete object graph by referring to the metadata that describes each object's type. The <b>Serialize </b>method uses reflection to see what instance fields are in each object's type as it is serialized. If any of these fields refer to other objects, then the formatter's <b>Serialize </b>method knows to serialize these objects, too.</p>
<p>Formatters have very intelligent algorithms. They know to serialize each object in the graph no more than once out to the stream That is, if two objects in the graph refer to each other, then the formatter detects this, serializes each object just once, and avoids entering into an infinite loop.</p>
<p>In my <b>SerializeToMemory </b>method, when the formatter's <b>Serialize </b>method returns, the <b>MemoryStream </b>is simply returned to the caller. The application uses the contents of this flat byte array any way it desires. For example, it could save it in a file, copy it to the clipboard, send it over a wire, or whatever.</p>
<p>The <b>DeserializeFromStream </b>method deserializes a stream back into an object graph. This method is even simpler than serializing an object graph. In this code, a <b>BinaryFormatter </b>is constructed and then its <b>Deserialize </b>method is called. This method takes the stream as a parameter and returns a reference to the root object within the deserialized object graph.</p>
<p>Internally, the formatter's <b>Deserialize </b>method examines the contents of the stream, constructs instances of all the objects that are in the stream, and initializes the fields in all these objects so that they have the same values they had when the object graph was serialized. Typically, you will cast the object reference returned from the <b>Deserialize </b>method into the type that your application is expecting.</p>
<hr/>
<blockquote><b>Note </b>Here's a fun, useful method that uses serialization to make a deep copy, or clone, of an object:</blockquote>
<hr/>
<p><code>private static Object DeepClone(Object original) { // Construct a temporary memory stream using (MemoryStream stream = new MemoryStream()) {<br/>
// Construct a serialization formatter that does all the hard work BinaryFormatter formatter = new BinaryFormatter();<br/>
// This line is explained in this chapter's &quot;Streaming Contexts&quot; section formatter.Context = new StreamingContext(StreamingContextStates.Clone);<br/>
// Serialize the object graph into the memory stream formatter.Serialize(stream, original);<br/>
// Seek back to the start of the memory stream before deserializing stream.Position = 0;<br/>
// Deserialize the graph into a new set of objects and // return the root of the graph (deep copy) to the caller return formatter.Deserialize(stream);<br/>
}<br/>
}</code></p>
<p>At this point, I'd like to add a few notes to our discussion First, it is up to you to ensure that your code uses the same formatter for both serialization and deserialization. For example, don't write code that serializes an object graph using the <b>SoapFormatter </b>and then deserializes the graph using the <b>BinaryFormatter. </b>If <b>Deserialize </b>can't decipher the contents of the stream, then a <b>System.Runtime.Serialization.SerializationException </b>exception will be thrown.</p>
<p>The second thing I'd like to point out is that it is possible and also quite useful to serialize multiple object graphs out to a single stream. For example, let's say that we have the following two class definitions:</p>
<p><code>[Serializable] internal sealed class Customer { /*... */ } [Serializable] internal sealed class Order      { /*... */ }</code></p>
<p>And then, in the main class of our application, we define the following static fields:</p>
<p><code>private static List&lt;Customer&gt; s_customers.= new List&lt;Customer&gt;();<br/>
private static List&lt;Order&gt; s_pendingOrders = new List&lt;Order&gt;(); private static List&lt;Order&gt;      s_processedOrders = new List&lt;Order&gt;();</code></p>
<p>We can now serialize our application's state to a single stream with a method that looks like this:</p>
<p><code>private static void SaveApplicationState(Stream stream) {<br/>
// Construct a serialization formatter that does all the hard work BinaryFormatter formatter = new BinaryFormatter();<br/>
// Serialize our application's entire state formatter.Serialize(stream, s_customers); formatter.Serialize(stream, s_pendingOrders); formatter.Serialize(stream, s_processedOrders);<br/>
}</code></p>
<p>To reconstruct our application's state, we would deserialize the state with a method that looks like this:</p>
<p><code>private static void RestoreApplicationState(Stream stream) {<br/>
// Construct a serialization formatter that does all the hard work BinaryFormatter formatter = new BinaryFormatter();<br/>
// Deserialize our application's entire state (same order as serialized) s_customers.= (List&lt;Customer&gt;) formatter.Deserialize(stream);<br/>
s_pendingOrders = (List&lt;Order&gt;) formatter.Deserialize(stream); s_processedOrders = (List&lt;Order&gt;) formatter.Deserialize(stream);<br/>
}</code></p>
<p>The third and last thing I'd like to point out has to do with assemblies When serializing an object, the full name of the type and the name of the type's defining assembly are written to the stream By default, <b>BinaryFormatter </b>outputs the assembly's full identity, which includes the assembly's file name (without extension), version number, culture, and public key information. When deserializing an object, the formatter first grabs the assembly identity and ensures that the assembly is loaded into the executing AppDomain by calling <b>System.Reflection.Assembly</b>'s <b>Load </b>method (discussed in Chapter 23, &quot;Assembly Loading and Reflection&quot;).</p>
<p>After an assembly has been loaded, the formatter looks in the assembly for a type matching that of the object being deserialized. If the assembly doesn't contain a matching type, an exception is thrown and no more objects can be deserialized. If a matching type is found, an instance of the type is created and its fields are initialized from the values contained in the stream. If the type's fields don't exactly match the names of the fields as read from the stream, then a <b>SerializationException </b>exception is thrown and no more objects can be deserialized. Later in this chapter, I'll discuss some sophisticated mechanisms that allow you to override some of this behavior</p>
<hr/>
<blockquote><b>Important </b>Some extensible applications use <b>Assembly.LoadFrom </b>to load an assembly</blockquote>
<hr/>
<p>and then construct objects from types defined in the loaded assembly. These objects can be serialized to a stream without any trouble. However, when deserializing this stream, the formatter attempts to load the assembly by calling <b>Assembly</b>'s <b>Load </b>method instead of calling the <b>LoadFrom </b>method. In most cases, the CLR will not be able to locate the assembly file, causing a <b>SerializationException </b>exception to be thrown. This catches many developers by surprise: Since the objects serialized correctly, they expect that they will deserialize correctly as well.</p>
<p>If your application serializes objects whose types are defined in an assembly that your application loads using <b>Assembly.LoadFrom, </b>then I recommend that you implement a method whose signature matches the <b>System.ResolveEventHandler </b>delegate and register this method with <b>System.AppDomain</b>'s <b>AssemblyResolve </b>event just before calling a formatter's <b>Deserialize </b>method. (Unregister this method with the event after <b>Deserialize </b>returns.) Now, whenever the formatter fails to load an assembly, the CLR calls your <b>ResolveEventHandler </b>method. This method is passed the identity of the assembly that failed to load The method can extract the assembly file name from the assembly's identity and use this name to construct the path where the application knows the assembly file can be found. Then, the method can call <b>Assembly.LoadFrom </b>to load the assembly and return the resulting <b>Assembly </b>reference back from the <b>ResolveEventHandler </b>method.</p>
<p>This section covered the basics of how to serialize and deserialize object graphs In the remaining sections, we'll look at what you must do in order to define your own serializable types, and we'll also look at various mechanisms that allow you to have greater control over serialization and deserialization.</p>
<h2>Making a Type Serializable</h2>
<p>When a type is designed, the developer must make the conscious decision as to whether or not to allow instances of the type to be serializable. By default, types are not serializable. For example, the following code does not perform as expected:</p>
<p><code>internal struct Point { public Int32 x, y; }<br/>
private static void OptInSerialization() { Point pt = new Point { x = 1, y = 2 }; using (var stream = new MemoryStream()) {<br/>
new BinaryFormatter().Serialize(stream, pt); // throws SerializationException<br/>
}<br/>
}</code></p>
<p>If you were to build and run this code in your program, you'd see that the formatter's <b>Serialize </b>method throws a <b>System.Runtime.Serialization.SerializationException </b>exception. The problem is that the developer of the <b>Point </b>type has not explicitly indicated that <b>Point </b>objects may be serialized. To solve this problem, the developer must apply the <b>System.SerializableAttribute </b>custom attribute to this type as follows. (Note that this attribute is defined in the <b>System </b>namespace, not the <b>System.Runtime.Serialization </b>namespace.</p>
<p><code>[Serializable]<br/>
internal struct Point { public Int32 x, y; }</code></p>
<p>Now, if we rebuild the application and run it, it does perform as expected and the <b>Point </b>objects will be serialized to the stream When serializing an object graph, the formatter checks that every object's type is serializable. If any object in the graph is not serializable, the formatter's <b>Serialize </b>method throws the <b>SerializationException </b>exception.</p>
<hr/>
<blockquote><b>Note </b>When serializing a graph of objects, some of the object's types may be serializable while some of the objects may not be serializable For performance reasons, formatters do not verify that all of the objects in the graph are serializable before serializing the graph So, when serializing an object graph, it is entirely possible that some objects may be serialized to the stream before the <b>SerializationException </b>is thrown. If this happens, the stream contains corrupt data. If you think you may be serializing an object graph where some objects may not be serializable, your application code should be able to recover gracefully from this situation. One option is to serialize the objects into a <b>MemoryStream </b>first. Then, if all objects are successfully serialized, you can copy the bytes in the <b>MemoryStream </b>to whatever stream (i.e.file, network) you really want the bytes written to.</blockquote>
<hr/>
<p>The <b>SerializableAttribute </b>custom attribute may be applied to reference types <b>(class), </b>value types <b>(struct), </b>enumerated types <b>(enum), </b>and delegate types <b>(delegate) </b>only. (Note that enumerated and delegate types are always serializable so there is no need to explicitly apply the <b>SerializableAttribute </b>attribute to these types.) In addition, the <b>SerializableAttribute </b>attribute is not inherited by derived types. So, given the following two type definitions, a <b>Person </b>object can be serialized but an <b>Employee </b>object cannot:</p>
<p><code>[Serializable]<br/>
internal class Person {... }<br/>
internal class Employee : Person {... }</code></p>
<p>To fix this, you would just apply the <b>SerializableAttribute </b>attribute to the <b>Employee </b>type as well:</p>
<p><code>[Serializable]<br/>
internal class Person {... } [Serializable]<br/>
internal class Employee : Person {... }</code></p>
<p>Note that this problem was easy to fix. However, the reverse妖efining a type derived from a base type that doesn't have the <b>SerializableAttribute </b>attribute applied to it擁s not easy to fix. But, this is by design; if the base type doesn't allow instances of its type to be serialized, its fields cannot be serialized since a base object is effectively part of the derived object. This is why <b>System.Object </b>has the <b>SerializableAttribute </b>attribute applied to it.</p>
<hr/>
<blockquote><b>Note </b>In general, it is recommended that most types you define be serializable. After all, this grants a lot of flexibility to users of your types. However, you must be aware that serialization reads all of an object's fields regardless of whether the fields are declared as <b>public, protected, internal, </b>or <b>private. </b>You might not want to make a type serializable if it contains sensitive or secure data (like passwords) or if the data would have no meaning or value if transferred.</blockquote>
<hr/>
<p>If you find yourself using a type that was not designed for serialization and you do not have the source code of the type to add serialization support, all is not lost. In the &quot;Overriding the Assembly and/or Type When Deserializing an Object&quot; section later in this chapter, I will explain how you can make any non-serializable type serializable.</p>
<a name="b668"/><h2>Controlling Serialization and Deserialization</h2>
<p>When you apply the <b>SerializableAttribute </b>custom attribute to a type, all instance fields <b>(public, private, protected, </b>and so on) are serialized. <sup>1</sup> However, a type may define some instance fields that should not be serialized. In general, there are two reasons why you would not want some of a type's instance fields to be serialized:</p>
<p>Do not use C#'s automatically implemented property feature to define properties inside types marked with the <b>[Serializable] </b>attribute, because the compiler generates the names of the fields and the generated names can be different each time that you recompile your code, preventing instances of your type from being deserializable.</p>
<p>&#9632; The field contains information that would not be valid when deserialized. For example, an object that contains a handle to a Windows kernel object (such as a file, process, thread, mutex, event, semaphore, and so on) would have no meaning when deserialized into another process or machine since Windows kernel handles are process-relative values.</p>
<p>&#9632; The field contains information that is easily calculated. In this case, you select which fields do not need to be serialized, thus improving your application's performance by reducing the amount of data transferred.</p>
<p>The code below uses the <b>System.NonSerializedAttribute </b>custom attribute to indicate which fields of the type should not be serialized. (Note that this attribute is also defined in the <b>System </b>namespace, not the <b>System.Runtime.Serialization </b>namespace.)</p>
<p><code>[Serializable] internal class Circle { private Double m_radius;<br/>
[NonSerialized] private Double m_area;<br/>
public Circle(Double radius) { m_radius = radius;<br/>
m_area = Math.PI * m_radius * m_radius;<br/>
}<br/>
}</code></p>
<p>In the code above, objects of <b>Circle </b>may be serialized. However, the formatter will serialize the values in the object's <b>m_radius </b>field only. The value in the <b>m_area </b>field will not be serialized because it has the <b>NonSerializedAttribute </b>attribute applied to it. This attribute can be applied only to a type's fields, and it continues to apply to this field when inherited by another type. Of course, you may apply the <b>NonSerializedAttribute </b>attribute to multiple fields within a type.</p>
<p>So, let's say that our code constructs a <b>Circle </b>object as follows: Circle c = new Circle(10);</p>
<p>Internally, the <b>m_area </b>field is set to a value approximate to 314.159. When this object gets serialized, only the value of the <b>m_radius </b>field (10) gets written to the stream. This is exactly what we want, but now we have a problem when the stream is deserialized back into a <b>Circle </b>object. When deserialized, the <b>Circle </b>object will get its <b>m_radius </b>field set to 10, but its <b>m_area </b>field will be initialized to 0溶ot 314.159!</p>
<p>The code shown below demonstrates how to modify the <b>Circle </b>type to fix this problem:</p>
<p><code>[Serializable] internal class Circle { private Double m_radius;<br/>
[NonSerialized] private Double m_area;<br/>
public Circle(Double radius) { m_radius = radius;<br/>
m_area = Math.PI * m_radius * m_radius;<br/>
}<br/>
[OnDeserialized]<br/>
private void OnDeserialized(StreamingContext context) { m_area = Math.PI * m_radius * m_radius;<br/>
}<br/>
}</code></p>
<p>I've changed <b>Circle </b>so that it now contains a method marked with the <b>System.Runtime. Serialization.OnDeserializedAttribute </b>custom attribute.<sup>2</sup> Whenever an instance of a type is deserialized, the formatter checks if the type defines a method with this attribute on it and then the formatter invokes this method When this method is called, all the serializable fields will be set correctly and they may be accessed to perform any additional work that would be necessary to fully deserialize the object.</p>
<p>In the modified version of <b>Circle </b>above, I made the <b>OnDeserialized </b>method simply calculate the area of the circle using the <b>m_radius </b>field and place the result in the <b>m_area </b>field. Now, <b>m_area </b>will have the desired value of 314.159.</p>
<p>In addition to the <b>OnDeserializedAttribute </b>custom attribute, the <b>System.Runtime.Serialization </b>namespace also defines <b>OnSerializingAttribute, OnSerializedAttribute, </b>and <b>OnDeserializingAttribute </b>custom attributes, which you can apply to your type's methods to have even more control over serialization and deserialization. Here is a sample class that applies each of these attributes to a method:</p>
<p><code>[Serializable] public class MyType {<br/>
Int32 x, y; [NonSerialized] Int32 sum;<br/>
public MyType(Int32 x, Int32 y) {<br/>
this.x = x; this.y = y; sum = x + y;<br/>
}<br/>
[OnDeserializing]<br/>
private void OnDeserializing(StreamingContext context) {</code></p>
<p>Use of the <b>System.Runtime.Serialization.OnDeserialized </b>custom attribute is the preferred way of invoking a method when an object is deserialized, as opposed to having a type implement the <b>System.Runtime.Serialization.IDeserializationCallback </b>interface's <b>OnDeserialization </b>method.</p>
<p><code>// Example: Set default values for fields in a new version of this type<br/>
}<br/>
[OnDeserialized]<br/>
private void OnDeserialized(StreamingContext context) { // Example: Initialize transient state from fields sum = x + y;<br/>
}<br/>
[OnSerializing]<br/>
private void OnSerializing(StreamingContext context) { // Example: Modify any state before serializing<br/>
}<br/>
[OnSerialized]<br/>
private void OnSerialized(StreamingContext context) { // Example: Restore any state after serializing<br/>
}<br/>
}</code></p>
<p>Whenever you use any of these four attributes, the method you define must take a single <b>StreamingContext </b>parameter (discussed in the &quot;Streaming Contexts&quot; section later in this chapter) and return <b>void. </b>The name of the method can be anything you want it to be. Also, you should declare the method as <b>private </b>to prevent it from being called by normal code; the formatters run with enough security that they can call private methods.</p>
<hr/>
<blockquote><b>Note </b>When you are serializing a set of objects, the formatter first calls all of the objects' methods that are marked with the <b>OnSerializing </b>attribute. Next it serializes all of the objects' fields, and finally it calls all of the objects' methods marked with the <b>OnSerialized </b>attribute. Similarly, when you deserialize a set of objects, the formatter calls all of the objects' methods that are marked with the <b>OnDeserializing </b>attribute, then it deserializes all of the object's fields, and then it calls all of the objects' methods marked with the <b>OnDeserialized </b>attribute.</blockquote>
<hr/>
<p>Note also that during deserialization, when a formatter sees a type offering a method marked with the <b>OnDeserialized </b>attribute, the formatter adds this object's reference to an internal list. After all the objects have been deserialized, the formatter traverses this list in reverse order and calls each object's <b>OnDeserialized </b>method. When this method is called, all the serializable fields will be set correctly, and they may be accessed to perform any additional work that would be necessary to fully deserialize the object. Invoking these methods in reverse order is important because it allows inner objects to finish their deserialization before the outer objects that contain them finish their deserialization.</p>
<p>For example, imagine a collection object (like <b>Hashtable </b>or <b>Dictionary) </b>that internally uses a hash table to maintain its sets of items The collection object type would implement a method marked with the <b>OnDeserialized </b>attribute. Even though the collection object would start being deserialized first (before its items), its <b>OnDeserialized </b>method would be called last (after any of its items' <b>OnDeserialized </b>methods). This allows the items to complete deserialization so that all their fields are initialized properly, allowing a good hash code value to be calculated. Then, the collection object creates its internal buckets and uses the items' hash codes to place the items into the buckets. I show an example of how the <b>Dictionary </b>class uses this in the upcoming &quot;Controlling the Serialized/Deserialized Data&quot; section of this chapter.</p>
<p>If you serialize an instance of a type, add a new field to the type, and then try to deserialize the object that did not contain the new field, the formatter throws a <b>SerializationException </b>with a message indicating that the data in the stream being deserialized has the wrong number of members. This is very problematic in versioning scenarios where it is common to add new fields to a type in a newer version. Fortunately, you can use the <b>System.Runtime.Serialization.OptionalFieldAttribute </b>attribute to help you.</p>
<p>You apply the <b>OptionalFieldAttribute </b>attribute to each new field you add to a type. Now, when the formatters see this attribute applied to a field, the formatters will not throw the <b>SerializationException </b>if the data in the stream does not contain the field.</p>
<a name="b672"/><h2>How Formatters Serialize Type Instances</h2>
<p>In this section, I give a bit more insight into how a formatter serializes an object's fields. This knowledge can help you understand the more advanced serialization and deserialization techniques explained in the remainder of this chapter.</p>
<p>To make things easier for a formatter, the FCL offers a <b>FormatterServices </b>type in the <b>System.Runtime.Serialization </b>namespace. This type has only static methods in it, and no instances of the type may be instantiated. The following steps describe how a formatter automatically serializes an object whose type has the <b>SerializableAttribute </b>attribute applied to it:</p>
<p><b>1.</b>The formatter calls <b>FormatterServices</b>'s <b>GetSerializableMembers </b>method:</p>
<p><code>public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context);</code></p>
<p>This method uses reflection to get the type's public and private instance fields (excluding any fields marked with the <b>NonSerializedAttribute </b>attribute). The method returns an array of <b>MemberInfo </b>objects, one for each serializable instance field.</p>
<p><b>2. </b>The object being serialized and the array of <b>System.Reflection.MemberInfo </b>objects are then passed to <b>FormatterServices' </b>static <b>GetObjectData </b>method:</p>
<p><code>public static Object[] GetObjectData(Object obj, MemberInfo[] members);</code></p>
<p>This method returns an array of <b>Object</b>s where each element identifies the value of a field in the object being serialized. This <b>Object </b>array and the <b>MemberInfo </b>array are parallel. That is, element 0 in the <b>Object </b>array is the value of the member identified by element 0 in the <b>MemberInfo </b>array.</p>
<p><b>3. </b>The formatter writes the assembly's identity and the type's full name to the stream.</p>
<p><b>4. </b>The formatter then enumerates over the elements in the two arrays, writing each member's name and value to the stream.</p>
<p>The following steps describe how a formatter automatically deserializes an object whose type has the <b>SerializableAttribute </b>attribute applied to it:</p>
<p><b>1. </b>The formatter reads the assembly's identity and full type name from the stream. If the assembly is not currently loaded into the AppDomain, it is loaded (as described earlier). If the assembly can't be loaded, a <b>SerializationException </b>exception is thrown and the object cannot be deserialized. If the assembly is loaded, the formatter passes the assembly identity information and the type's full name to <b>FormatterServices' </b>static <b>GetTypeFromAssembly </b>method:</p>
<p><code>public static Type GetTypeFromAssembly(Assembly assem, String name);</code></p>
<p>This method returns a <b>System.Type </b>object indicating the type of object that is being deserialized.</p>
<p><b>2. </b>The formatter calls <b>FormatterServices</b>'s static <b>GetUninitializedObject </b>method: public static Object GetUninitializedObject(Type type);</p>
<p>This method allocates memory for a new object but does not call a constructor for the object. However, all the object's bytes are initialized to <b>null </b>or <b>0 </b>.</p>
<p><b>3. </b>The formatter now constructs and initializes a <b>MemberInfo </b>array as it did before by calling <b>FormatterServices</b>'s <b>GetSerializableMembers </b>method. This method returns the set of fields that were serialized and that need to be deserialized.</p>
<p><b>4. </b>The formatter creates and initializes an <b>Object </b>array from the data contained in the stream.</p>
<p><b>5. </b>The reference to the newly allocated object, the <b>MemberInfo </b>array, and the parallel <b>Object </b>array of field values is passed to <b>FormatterServices' </b>static <b>PopulateObjectMembers </b>method:</p>
<p><code>public static Object PopulateObjectMembers(<br/>
Object obj, MemberInfo[] members, Object[] data);</code></p>
<p>This method enumerates over the arrays, initializing each field to its corresponding value. At this point, the object has been completely deserialized.</p>
<a name="b673"/><h2>Controlling the Serialized/Deserialized Data</h2>
<p>As discussed earlier in this chapter, the best way to get control over the serialization and deserialization process is to use the <b>OnSerializing, OnSerialized, OnDeserializing, OnDeserialized, NonSerialized, </b>and <b>OptionalField </b>attributes. However, there are some very rare scenarios where these attributes do not give you all the control you need In addition, the formatters use reflection internally and reflection is slow, which increases the time it takes to serialize and deserialize objects To get complete control over what data is serialized/deserialized or to eliminate the use of reflection, your type can implement the <b>System.Runtime.Serialization.ISerializable </b>interface, which is defined as follows:</p>
<p><code>public interface ISerializable {<br/>
void GetObjectData(SerializationInfo info, StreamingContext context);<br/>
}</code></p>
<p>This interface has just one method in it, <b>GetObjectData </b>. But most types that implement this interface will also implement a special constructor that I'll describe shortly.</p>
<hr/>
<blockquote><b>Important </b>The big problem with the <b>ISerializable </b>interface is that once a type implements it, all derived types must implement it too, and the derived types must make sure that they invoke the base class's <b>GetObjectData </b>method and the special constructor In addition, once a type implements this interface, it can never remove it because it will lose compatibility with the derived types. It is always OK for <b>sealed </b>types to implement the <b>ISerializable </b>interface. Using the custom attributes described earlier in this chapter avoids all of the potential problems associated with the <b>ISerializable </b>interface.</blockquote>
<hr/>
<hr/>
<blockquote><b>Important </b>The <b>ISerializable </b>interface and the special constructor are intended to be used by the formatters However, other code could call <b>GetObjectData, </b>which might then return potentially sensitive information, or other code could construct an object that passes in corrupt data For this reason, it is recommended that you apply the following attribute to the <b>GetObjectData </b>method and the special constructor:</blockquote>
<hr/>
<p><code>[SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]</code></p>
<p>When a formatter serializes an object graph, it looks at each object. If its type implements the <b>ISerializable </b>interface, then the formatter ignores all custom attributes and instead constructs a new <b>System.Runtime.Serialization.SerializationInfo </b>object. This object contains the actual set of values that should be serialized for the object.</p>
<p>When constructing a <b>SerializationInfo, </b>the formatter passes two parameters: <b>Type </b>and <b>System.Runtime.Serialization.IFormatterConverter. </b>The <b>Type </b>parameter identifies the object that is being serialized. Two pieces of information are required to uniquely identify a type: the string name of the type and its assembly's identity (which includes the assembly name, version, culture, and public key). When a <b>SerializationInfo </b>object is constructed, it obtains the type's full name (by internally querying <b>Type</b>'s <b>FullName </b>property) and stores this string in a private field. You can obtain the type's full name by querying <b>SerializationInfo</b>'s <b>FullTypeName </b>property. Likewise, the constructor obtains the type's defining assembly (by internally querying <b>Type</b>'s <b>Module </b>property followed by querying <b>Module</b>'s <b>Assembly </b>property followed by querying <b>Assembly</b>'s <b>FullName </b>property) and stores this string in a private field. You can obtain the assembly's identity by querying <b>SerializationInfo</b>'s <b>AssemblyName </b>property.</p>
<hr/>
<blockquote><b>Note </b>While you can set a <b>SerializationInfo</b>'s <b>FullTypeName </b>and <b>AssemblyName </b>properties, this is discouraged. If you want to change the type that is being serialized, it is recommended that you call <b>SerializationInfo</b>'s <b>SetType </b>method, passing a reference to the desired <b>Type </b>object. Calling <b>SetType </b>ensures that the type's full name and defining assembly are set correctly An example of calling <b>SetType </b>is shown in the &quot;Serializing a Type as a Different Type and Deserializing an Object as a Different Object&quot; section later in this chapter.</blockquote>
<hr/>
<p>Once the <b>SerializationInfo </b>object is constructed and initialized, the formatter calls the type's <b>GetObjectData </b>method, passing it the reference to the <b>SerializationInfo </b>object. The <b>GetObjectData </b>method is responsible for determining what information is necessary to serialize the object and adding this information to the <b>SerializationInfo </b>object. <b>GetObjectData </b>indicates what information to serialize by calling one of the many overloaded <b>AddValue </b>methods provided by the <b>SerializationInfo </b>type. <b>AddValue </b>is called once for each piece of data that you wish to add.</p>
<p>The code below shows how the <b>Dictionary&lt;TKey, TValue&gt; </b>type implements the <b>ISerializable </b>and <b>IDeserializationCallback </b>interfaces to take control over the serialization and deserialization of its objects.</p>
<p><code>[Serializable]<br/>
public class Dictionary&lt;TKey, TValue&gt;: ISerializable, IDeserializationCallback { // Private fields go here (not shown)<br/>
private SerializationInfo m_siInfo;   // Only used for deserialization<br/>
// Special constructor (required by ISerializable) to control deserialization [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)] protected Dictionary(SerializationInfo info, StreamingContext context) {<br/>
// During deserialization, save the SerializationInfo for OnDeserialization m_siInfo = info;<br/>
}<br/>
// Method to control serialization [SecurityCritical]<br/>
public virtual void GetObjectData(SerializationInfo info, StreamingContext context) { info.AddValue(&quot;Version&quot;, m_version);<br/>
info.AddValue(&quot;Comparer&quot;, m_comparer, typeof(IEqualityComparer&lt;TKey&gt;)); info.AddValue(&quot;HashSize&quot;, (m_ buckets == null) ? 0 : m_buckets.l_ength); if (m_buckets != null) {<br/>
KeyValuePair&lt;TKey, TValue&gt;[] array = new KeyValuePair&lt;TKey, TValue&gt;[Count]; CopyTo(array, 0);<br/>
info.AddValue(&quot;KeyValuePairs&quot;, array, typeof(KeyValuePair&lt;TKey, TValue&gt;[]));<br/>
}<br/>
}<br/>
// Method called after all key/value objects have been deserialized public virtual void IDeserializationCallback.OnDeserialization(Object sender) { if (m_siInfo == null) return; // Never set, return<br/>
Int32 num = m_siInfo.GetInt32(&quot;Version&quot;); Int32 num2 = m_siInfo.GetInt32(&quot;HashSize&quot;); m_comparer = (IEqualityComparer&lt;TKey&gt;)<br/>
m_siInfo.GetValue(&quot;Comparer&quot;, typeof(IEqualityComparer&lt;TKey&gt;)); if (num2 != 0) {<br/>
m_buckets = new Int32[num2];<br/>
for (Int32 i = 0; i &lt; m_buckets.l_ength;.m_buckets[i] = -1;<br/>
m_entries = new Entry&lt;TKey, TValue&gt;[num2];<br/>
m_freeList = -1;<br/>
KeyValuePair&lt;TKey, TValue&gt;[] pairArray = (KeyValuePair&lt;TKey, TValue&gt;[])<br/>
m_siInfo.GetValue(&quot;KeyValuePairs&quot;, typeof(KeyValuePair&lt;TKey, TValue&gt;[]));<br/>
if (pairArray == null)<br/>
ThrowHelper.ThrowSerializationException(<br/>
ExceptionResource.Serialization_MissingKeys);<br/>
for (Int32 j = 0; j &lt; pairArray.Length; { if (pairArray[j].Key == null)<br/>
ThrowHelper.ThrowSerializationException( ExceptionResource.Serialization_NullKey);<br/>
Insert(pairArray[j].Key, pairArray[j].Value, true);<br/>
}<br/>
} else { m_buckets = null; } m_version = num; m_siInfo = null;<br/>
}</code></p>
<p>Each <b>AddValue </b>method takes a <b>String </b>name and some data. Usually, the data is of a simple value type like <b>Boolean, Char, Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal, </b>or <b>DateTime </b>. However, you can also call <b>AddValue, </b>passing it a reference to an <b>Object </b>such as a <b>String. </b>After <b>GetObjectData </b>has added all of the necessary serialization information, it returns to the formatter.</p>
<p>r-</p>
<hr/>
<blockquote><b>Note </b>You should always call one of the overloaded <b>AddValue </b>methods to add serialization information for your type. If a field's type implements the <b>ISerializable </b>interface, don't call the <b>GetObjectData </b>on the field. Instead, call <b>AddValue </b>to add the field; the formatter will see that the field's type implements <b>ISerializable </b>and the formatter will call <b>GetObjectData </b>for you. If you were to call <b>GetObjectData </b>on the field object, the formatter wouldn't know to create a new object when deserializing the stream.</blockquote>
<hr/>
<p>The formatter now takes all of the values added to the <b>SerializationInfo </b>object and serializes each of them out to the stream. You'll notice that the <b>GetObjectData </b>method is passed another parameter: a reference to a <b>System.Runtime.Serialization.StreamingContext </b>object. Most types' <b>GetObjectData </b>methods will completely ignore this parameter, so I will not discuss it now. Instead, I'll discuss it in the &quot;Streaming Contexts&quot; section later in this chapter.</p>
<p>So now you know how to set all of the information used for serialization. At this point, let's turn our attention to deserialization. As the formatter extracts an object from the stream, it allocates memory for the new object (by calling the <b>System.Runtime.Serialize. FormatterServices </b>type's static <b>GetUninitializedObject </b>method). Initially, all of this object's fields are set to <b>0 </b>or <b>null. </b>Then, the formatter checks if the type implements the <b>ISerializable </b>interface. If this interface exists, the formatter attempts to call a special constructor whose parameters are identical to that of the <b>GetObjectData </b>method.</p>
<p>If your class is <b>sealed, </b>then it is highly recommended that you declare this special constructor to be <b>private </b>. This will prevent any code from accidentally calling increasing security. If not, then you should declare this special constructor as <b>protected </b>so that only derived classes can call it. Note that the formatters are able to call this special constructor no matter how it is declared.</p>
<p>This constructor receives a reference to a <b>SerializationInfo </b>object containing all of the values added to it when the object was serialized. The special constructor can call any of the <b>GetBoolean, GetChar, GetByte, GetSByte, GetInt16, GetUInt16, GetInt32, GetUInt32, GetInt64, GetUInt64, GetSingle, GetDouble, GetDecimal, GetDateTime, GetString, </b>and <b>GetValue </b>methods, passing in a string corresponding to the name used to serialize a value. The value returned from each of these methods is then used to initialize the fields of the new object.</p>
<p>When deserializing an object's fields, you should call the <b>Get </b>method that matches the type of value that was passed to the <b>AddValue </b>method when the object was serialized. In other words, if the <b>GetObjectData </b>method called <b>AddValue, </b>passing it an <b>Int32 </b>value, then the <b>GetInt32 </b>method should be called for the same value when deserializing the object. If the value's type in the stream doesn't match the type you're trying to get, then the formatter will attempt to use an <b>IFormatterConvert </b>object to &quot;cast&quot; the stream's value to the desired type.</p>
<p>As I mentioned earlier, when a <b>SerializationInfo </b>object is constructed, it is passed an object whose type implements the <b>IFormatterConverter </b>interface Since the formatter is responsible for constructing the <b>SerializationInfo </b>object, it chooses whatever <b>IFormatterConverter </b>type it wants. Microsoft's <b>BinaryFormatter </b>and <b>SoapFormatter </b>types always construct an instance of the <b>System.Runtime.Serialization.FormatterConverter </b>type. Microsoft's formatters don't offer any way for you to select a different <b>IFormatterConverter </b>type.</p>
<p>The <b>FormatterConverter </b>type calls the <b>System.Convert </b>class's static methods to convert values between the core types, such as converting an <b>Int32 </b>to an <b>Int64 </b>. However, to convert a value between other arbitrary types, the <b>FormatterConverter </b>calls <b>Convert</b>'s <b>ChangeType </b>method to cast the serialized (or original) type to an <b>IConvertible </b>interface and then calls the appropriate interface method. Therefore, to allow objects of a serializable type to be deserialized as a different type, you may want to consider having your type implement the <b>IConvertible </b>interface. Note that the <b>FormatterConverter </b>object is used only when deserializing objects and when you're calling a <b>Get </b>method whose type doesn't match the type of the value in the stream.</p>
<p>Instead of calling the various <b>Get </b>methods listed above, the special constructor could instead call <b>GetEnumerator, </b>which returns a <b>System.Runtime.Serialization. SerializationInfoEnumerator </b>object that can be used to iterate through all the values contained within the <b>SerializationInfo </b>object. Each value enumerated is a <b>System. Runtime.Serialization.SerializationEntry </b>object.</p>
<p>Of course, you are welcome to define a type of your own that derives from a type that implements <b>ISerializable</b>'s <b>GetObjectData </b>and special constructor. If your type also implements <b>ISerializable, </b>then your implementation of <b>GetObjectData </b>and your implementation of the special constructor must call the same functions in the base class in order for the object to be serialized and deserialized properly. Do not forget to do this or the objects will not serialize or deserialize correctly. The next section explains how to properly define an <b>ISerializable </b>type whose base type doesn't implement this interface.</p>
<p>If your derived type doesn't have any additional fields in it and therefore has no special serialization/deserialization needs, then you do not have to implement <b>ISerializable </b>at all. Like all interface members, <b>GetObjectData </b>is virtual and will be called to properly serialize the object. In addition, the formatter treats the special constructor as &quot;virtualized.&quot; That is, during deserialization, the formatter will check the type that it is trying to instantiate If that type doesn't offer the special constructor, then the formatter will scan base classes until it finds one that implements the special constructor.</p>
<hr/>
<blockquote><b>Important </b>The code in the special constructor typically extracts its fields from the <b>SerializationInfo </b>object that is passed to it. As the fields are extracted, you are not guaranteed that the objects are fully deserialized, so the code in the special constructor should not attempt to manipulate the objects that it extracts.</blockquote>
<hr/>
<p>If your type must access members (such as call methods) on an extracted object, then it is recommended that your type also provide a method that has the <b>OnDeserialized </b>attribute applied to it or have your type implement the <b>IDeserializationCallback </b>interface's <b>OnDeserialization </b>method (as shown in the <b>Dictionary </b>example). When this method is called, all objects have had their fields set. However, there is no guarantee to the order in which multiple objects have their <b>OnDeserialized </b>or <b>OnDeserialization </b>method called. So, while the fields may be initialized, you still don't know if a referenced object is completely deserialized if that referenced object also provides an <b>OnDeserialized </b>method or implements the <b>IDeserializationCallback </b>interface.</p>
<h3>How to Define a Type That Implements ISerializable when the Base Type Doesn't Implement This Interface</h3>
<p>As mentioned earlier, the <b>ISerializable </b>interface is extremely powerful since it allows a type to take complete control over how instances of the type get serialized and deserialized. However, this power comes at a cost: The type is now responsible for serializing all of its base type's fields as well. Serializing the base type's fields is easy if the base type also implements the <b>ISerializable </b>interface; you just call the base type's <b>GetObjectData </b>method.</p>
<p>However, someday, you may find yourself defining a type that needs to take control of its serialization but whose base type does not implement the <b>ISerializable </b>interface. In this case, your derived class must manually serialize the base type's fields by grabbing their values and adding them to the <b>SerializationInfo </b>collection. Then, in your special constructor, you will also have to get the values out of the collection and somehow set the base class's</p>
<p>fields. Doing all of this is easy (albeit tedious) if the base class's fields are <b>public </b>or <b>protected, </b>but it can be very difficult or impossible to do if the base class's fields are <b>private </b>.</p>
<p>This following code shows how to properly implement <b>ISerializable</b>'s <b>GetObjectData </b>method and its implied constructor so that the base type's fields are serialized:</p>
<p><code>[Serializable] internal class Base {<br/>
protected String m_name = &quot;Jeff&quot;;<br/>
public Base() { /* Make the type instantiable */ }<br/>
}<br/>
[Serializable]<br/>
internal class Derived : Base, ISerializable { private DateTime m_date = DateTime.Now; public Derived() { /* Make the type instantiable*/ }<br/>
// If this constructor didn't exist, we'd get a SerializationException // This constructor should be protected if this class were not sealed [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)] private Derived(SerializationInfo info, StreamingContext context) {<br/>
// Get the set of serializable members for our class and base classes<br/>
Type baseType = this.GetType().BaseType;<br/>
MemberInfo[] mi = FormatterServices.GetSerializableMembers(baseType, context);<br/>
// Deserialize the base class's fields from the info object for (Int32 i = 0; i &lt; mi.Length; {<br/>
// Get the field and set it to the deserialized value<br/>
FieldInfo fi = (FieldInfo)mi[i];<br/>
fi.SetValue(this, info.GetValue(baseType.FullName + &quot;+&quot; + fi.Name, fi.FieldType));<br/>
}<br/>
// Deserialize the values that were serialized for this class m_date = info.GetDateTime(&quot;Date&quot;);<br/>
}<br/>
[SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)] public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {<br/>
// Serialize the desired values for this class<br/>
info.AddValue(&quot;Date&quot;, m_date);<br/>
// Get the set of serializable members for our class and base classes Type baseType = this.GetType().BaseType;<br/>
MemberInfo[] mi = FormatterServices.GetSerializableMembers(baseType, context);<br/>
// Serialize the base class's fields to the info object for (Int32 i = 0; i &lt; mi.Length; {<br/>
// Prefix the field name with the fullname of the base type<br/>
info.AddValue(baseType.FullName + &quot;+&quot; + mi[i].Name, ((FieldInfo)mi[i]).GetValue(this));<br/>
}<br/>
}<br/>
public override String ToString() {<br/>
return String.Format(&quot;Name={0}, Date={1}&quot;, m_name, m_date);<br/>
}<br/>
}</code></p>
<p>In this code, there is a base class, <b>Base, </b>which is marked only with the <b>SerializableAttribute </b>custom attribute. Derived from <b>Base </b>is <b>Derived, </b>which also is marked with the <b>SerializableAttribute </b>attribute and also implements the <b>ISerializable </b>interface. To make the situation more interesting, you'll notice that both classes define a <b>String </b>field called <b>m_name. </b>When calling <b>SerializationInfo</b>'s <b>AddValue </b>method, you can't add multiple values with the same name The code above handles this situation by identifying each field by its class name prepended to the field's name. For example, when the <b>GetObjectData </b>method calls <b>AddValue </b>to serialize <b>Base</b>'s <b>m_name </b>field, the name of the value is written as &quot;Base+m_name.&quot;</p>
<h2>Streaming Contexts</h2>
<p>As mentioned earlier, there are many destinations for a serialized set of objects: same process, different process on the same machine, different process on a different machine, and so on. In some rare situations, an object might want to know where it is going to be deserialized so that it can emit its state differently For example, an object that wraps a Windows semaphore object might decide to serialize its kernel handle if the object knows that it will be deserialized into the same process, because kernel handles are valid within a process However, the object might decide to serialize the semaphore's string name if it knows that the object will be deserialized on the same machine but into a different process Finally, the object might decide to throw an exception if it knows that it will be deserialized in a process running on a different machine because a semaphore is valid only within a single machine.</p>
<p>A number of the methods mentioned earlier in this chapter accept a <b>StreamingContext </b>. A <b>StreamingContext </b>structure is a very simple value type offering just two public read-only properties, as shown in Table 24-1.</p>
<p><b>Table 24-1 </b><b>StreamingContext's Public Read-Only Properties</b></p>
<table border="1">
<tr>
<td>
<p>e</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>s</p>
</td>
<td>
<p>A set of bit flags indicating the source</p>
</td>
</tr>
<tr>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
<td>
<p>or destination of the objects being</p>
</td>
</tr>
<tr>
<td>
<p></p>
</td>
<td>
<p></p>
</td>
<td>
<p>serialized/deserialized</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>t</p>
</td>
<td>
<p>A reference to an object that contains any user-desired context information</p>
</td>
</tr>
</table>
<p>A method that receives a <b>StreamingContext </b>structure can examine the <b>State </b>property's bit flags to determine the source or destination of the objects being serialize/deserialized. Table 24-2 shows the possible bit flag values.</p>
<p><b>Table 24-2 </b><b>StreamingContextStates's Flags</b></p>
<table border="1">
<tr>
<td>
<p>e</p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>n</p>
</td>
</tr>
<tr>
<td>
<p>s</p>
</td>
<td>
<p>0x0001</p>
</td>
<td>
<p>The source or destination is a different process on the same machine.</p>
</td>
</tr>
<tr>
<td>
<p>s</p>
</td>
<td>
<p>0x0002</p>
</td>
<td>
<p>The source or destination is on a different machine.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>0x0004</p>
</td>
<td>
<p>The source or destination is a file. Don't assume that the same process will deserialize the data.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>0x0008</p>
</td>
<td>
<p>The source or destination is a store such as a database or a file. Don't assume that the same process will deserialize the data.</p>
</td>
</tr>
<tr>
<td>
<p>g</p>
</td>
<td>
<p>0x0010</p>
</td>
<td>
<p>The source or destination is remoting to an unknown location The location may be on the same machine but may also be on another machine.</p>
</td>
</tr>
<tr>
<td>
<p>r</p>
</td>
<td>
<p>0x0020</p>
</td>
<td>
<p>The source or destination is unknown.</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>0x0040</p>
</td>
<td>
<p>The object graph is being cloned The serialization code may assume that the same process will deserialize the data, and it is therefore safe to access handles or other unmanaged resources.</p>
</td>
</tr>
<tr>
<td>
<p>n</p>
</td>
<td>
<p>0x0080</p>
</td>
<td>
<p>The source or destination is a different AppDomain.</p>
</td>
</tr>
<tr>
<td>
<p>l</p>
</td>
<td>
<p>0x00FF</p>
</td>
<td>
<p>The source or destination may be any of the above contexts. This is the default context.</p>
</td>
</tr>
</table>
<p>Now that you know how to get this information, let's discuss how you would set this information. The <b>IFormatter </b>interface (which is implemented by both the <b>BinaryFormatter </b>and the <b>SoapFormatter </b>types) defines a read/write <b>StreamingContext </b>property called <b>Context. </b>When you construct a formatter, the formatter initializes its <b>Context </b>property so that <b>StreamingContextStates </b>is set to <b>All </b>and the reference to the additional state object is set to <b>null.</b></p>
<p>After the formatter is constructed, you can construct a <b>StreamingContext </b>structure using any of the <b>StreamingContextStates </b>bit flags, and you can optionally pass a reference to an object containing any additional context information you need Now, all you need to do is set the formatter's <b>Context </b>property with this new <b>StreamingContext </b>object before calling the formatter's <b>Serialize </b>or <b>Deserialize </b>methods. Code demonstrating how to tell a formatter that you are serializing/deserialzing an object graph for the sole purpose of cloning all the objects in the graph is shown in the <b>DeepClone </b>method presented earlier in this chapter.</p>
<a name="b682"/><h2>Serializing a Type as a Different Type and Deserializing an Object as a Different Object</h2>
<p>The .NET Framework's serialization infrastructure is quite rich, and in this section, we discuss how a developer can design a type that can serialize or deserialize itself into a different type or object. Below are some examples where this is interesting:</p>
<p>&#9632; Some types (such as <b>System.DBNull </b>and <b>System.Reflection.Missing) </b>are designed to have only one instance per AppDomain. These types are frequently called singletons. If you have a reference to a <b>DBNull </b>object, serializing and deserializing it should not cause a new <b>DBNull </b>object to be created in the AppDomain. After deserializing, the returned reference should refer to the AppDomain's already-existing <b>DBNull </b>object.</p>
<p>&#9632; Some types (such as <b>System.Type, System.Reflection.Assembly, </b>and other reflection types like <b>MemberInfo) </b>have one instance per type, assembly, member, and so on Imagine you have an array where each element references a <b>MemberInfo </b>object It's possible that five array elements reference a single <b>MemberInfo </b>object. After serializing and deserializing this array, the five elements that referred to a single <b>MemberInfo </b>object should all refer to a single <b>MemberInfo </b>object What's more, these elements should refer to the one <b>MemberInfo </b>object that exists for the specific member in the AppDomain. You could also imagine how this could be useful for polling database connection objects or any other type of object.</p>
<p>&#9632; For remotely controlled objects, the CLR serializes information about the server object that, when deserialized on the client, causes the CLR to create a proxy object. This type of the proxy object is a different type than the server object, but this is transparent to the client code. When the client calls instance methods on the proxy object, the proxy code internally remotes the call to the server that actually performs the request.</p>
<p>Let's look at some code that shows how to properly serialize and deserialize a singleton type:</p>
<p><code>// There should be only one instance of this type per AppDomain [Serializable]<br/>
public sealed class Singleton : ISerializable { // This is the one instance of this type<br/>
private static readonly Singleton theOneObject = new Singleton();<br/>
// Here are the instance fields<br/>
public String Name = &quot;Jeff&quot;;<br/>
public DateTime Date = DateTime.Now;<br/>
// Private constructor allowing this type to construct the singleton private Singleton() { }<br/>
// Method returning a reference to the singleton<br/>
public static Singleton GetSingleton() { return theOneObject; }<br/>
// Method called when serializing a Singleton<br/>
// I recommend using an Explicit Interface Method Impl. Here<br/>
[SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]<br/>
void ISerializable.CetObjectData(SerializationInfo info, StreamingContext context) { info.SetType(typeof(SingletonSerializationHelper)); // No other values need to be added<br/>
}<br/>
[Serializable]<br/>
private sealed class SingletonSerializationHelper : IObjectReference {<br/>
// Method called after this object (which has no fields) is deserialized public Object CetRealObject(StreamingContext context) { return Singleton.CetSingleton();<br/>
}<br/>
}<br/>
// NOTE: The special constructor is NOT necessary because it's never called<br/>
}</code></p>
<p>The <b>Singleton </b>class represents a type that allows only one instance of itself to exist per AppDomain. The following code tests the <b>Singleton</b>'s serialization and deserialization code to ensure that only one instance of the <b>Singleton </b>type ever exists in the AppDomain:</p>
<p><code>private static void SingletonSerializationTest() {<br/>
// Create an array with multiple elements referring to the one Singleton object Singleton[] al = { Singleton.CetSingleton(), Singleton.CetSingleton() }; Console.Writel_ine(&quot;Do both elements refer to the same object? &quot; + (a1[0] == a1[1])); // &quot;True&quot;<br/>
using (var stream = new MemoryStream()) {<br/>
BinaryFormatter formatter = new BinaryFormatter();<br/>
// Serialize and then deserialize the array elements formatter.Serialize(stream, al); stream.Position = 0;<br/>
Singleton[] a2 = (Singleton[])formatter.Deserialize(stream); // Prove that it worked as expected:<br/>
Console.Writel_ine(&quot;Do both elements refer to the same object? &quot;<br/>
+ (a2[0] == a2[1])); // &quot;True&quot; Console.Writel_ine(&quot;Do all   elements refer to the same object? &quot;<br/>
+ (a1[0] == a2[0])); // &quot;True&quot;<br/>
}<br/>
}</code></p>
<p>Now, let's walk through the code to understand what's happening When the <b>Singleton </b>type is loaded into the AppDomain, the CLR calls its static constructor, which constructs a <b>Singleton </b>object and saves a reference to it in a static field, <b>s_theOneObject </b>. The <b>Singleton </b>class doesn't offer any public constructors, which prevents any other code from constructing any other instances of this class.</p>
<p>In <b>SingletonSerializationTest, </b>an array is created consisting of two elements; each element references the <b>Singleton </b>object. The two elements are initialized by calling <b>Singleton</b>'s static <b>GetSingleton </b>method. This method returns a reference to the one <b>Singleton </b>object. The first call to <b>Console</b>'s <b>WriteLine </b>method displays &quot;True,&quot; verifying that both array elements refer to the same exact object.</p>
<p>Now, <b>SingletonSerializationTest </b>calls the formatter's <b>Serialize </b>method to serialize the array and its elements. When serializing the first <b>Singleton, </b>the formatter detects that the <b>Singleton </b>type implements the <b>ISerializable </b>interface and calls the <b>GetObjectData </b>method This method calls <b>SetType, </b>passing in the <b>SingletonSerializationHelper </b>type, which tells the formatter to serialize the <b>Singleton </b>object as a <b>SingletonSerializationHelper </b>object instead. Since <b>AddValue </b>is not called, no additional field information is written to the stream. Since the formatter automatically detected that both array elements refer to a single object, the formatter serializes only one object.</p>
<p>After serializing the array, <b>SingletonSerializationTest </b>calls the formatter's <b>Deserialize </b>method. When deserializing the stream, the formatter tries to deserialize a <b>SingletonSerializationHelper </b>object since this is what the formatter was &quot;tricked&quot; into serializing. (In fact, this is why the <b>Singleton </b>class doesn't provide the special constructor that is usually required when implementing the <b>ISerializable </b>interface.) After constructing the <b>SingletonSerializationHelper </b>object, the formatter sees that this type implements the <b>System.Runtime.Serialization.IObjectReference </b>interface. This interface is defined in the FCL as follows:</p>
<p><code>public interface IObjectReference {<br/>
Object CetRealObject(StreamingContext context);<br/>
}</code></p>
<p>When a type implements this interface, the formatter calls the <b>GetRealObject </b>method. This method returns a reference to the object that you really want a reference to now that deserialization of the object has completed. In my example, the <b>SingletonSerializationHelper </b>type has <b>GetRealObject </b>return a reference to the <b>Singleton </b>object that already exists in the AppDomain. So, when the formatter's <b>Deserialize </b>method returns, the <b>a2 </b>array contains two elements, both of which refer to the AppDomain's <b>Singleton </b>object. The <b>SingletonSerializationHelper </b>object used to help with the deserialization is immediately unreachable and will be garbage collected in the future.</p>
<p>The second call to <b>WriteLine </b>displays &quot;True,&quot; verifying that both of <b>a2</b>'s array elements refer to the exact same object. The third and last call to <b>WriteLine </b>also displays &quot;True,&quot; proving that the elements in both arrays all refer to the exact same object.</p>
<h2>Serialization Surrogates</h2>
<p>Up to now, I've been discussing how to modify a type's implementation to control how a type serializes and deserializes instances of itself However, the formatters also allow code that is not part of the type's implementation to override how a type serializes and deserializes its objects. There are two main reasons why application code might want to override a type's behavior:</p>
<p>&#9632; It allows a developer the ability to serialize a type that was not originally designed to be serialized.</p>
<p>&#9632; It allows a developer to provide a way to map one version of a type to a different version of a type.</p>
<p>Basically, to make this mechanism work, you first define a &quot;surrogate type&quot; that takes over the actions required to serialize and deserialize an existing type Then, you register an instance of your surrogate type with the formatter telling the formatter which existing type your surrogate type is responsible for acting on. When the formatter detects that it is trying to serialize or deserialize an instance of the existing type, it will call methods defined by your surrogate object. Let's build a sample that demonstrates how all this works.</p>
<p>A serialization surrogate type must implement the <b>System.Runtime.Serialization. ISerializationSurrogate </b>interface, which is defined in the FCL as follows:</p>
<p><code>public interface ISerializationSurrogate {<br/>
void CetObjectData(Object obj, SerializationInfo info, StreamingContext context);<br/>
Object SetObjectData(Object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);<br/>
}</code></p>
<p>Now, let's walk through an example that uses this interface. Let's say your program contains some <b>DateTime </b>objects that contain values that are local to the user's computer What if you want to serialize the <b>DateTime </b>objects to a stream but you want the values to be serialized in universal time? This would allow you to send the data over a network stream to another machine in another part of the world and have the <b>DateTime </b>value be correct. While you can't modify the <b>DateTime </b>type that ships with the FCL, you can define your own serialization surrogate class that can control how <b>DateTime </b>objects are serialized and deserialized. Here is how to define the surrogate class:</p>
<p><code>internal sealed class UniversalToLocalTimeSerializationSurrogate : ISerializationSurrogate { public void CetObjectData(Object obj, SerializationInfo info, StreamingContext context) { // Convert the DateTime from local to UTC<br/>
info.AddValue(&quot;Date&quot;, ((DateTime)obj).ToUniversalTime().ToString(&quot;u&quot;));<br/>
}<br/>
public Object SetObjectData(Object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector) { // Convert the DateTime from UTC to local<br/>
return DateTime.ParseExact(info.CetString(&quot;Date&quot;), &quot;u&quot;, null).ToLocalTime();<br/>
}<br/>
}</code></p>
<p>The <b>GetObjectData </b>method here works just like the <b>ISerializable </b>interface's <b>GetObjectData </b>method. The only difference is that <b>ISerializationSurrogate</b>'s</p>
<p><b>GetObjectData </b>method takes one additional parameter: a reference to the &quot;real&quot; object that is to be serialized In the <b>GetObjectData </b>method above, this object is cast to <b>DateTime, </b>the value is converted from local time to universal time, and a string (formatted using universal full date/time pattern) is added to the <b>SerializationInfo </b>collection.</p>
<p>The <b>SetObjectData </b>method is called in order to deserialize a <b>DateTime </b>object. When this method is called, it is passed a reference to a <b>SerializationInfo </b>object. <b>SetObjectData </b>gets the string date out of this collection, parses it as a universal full date/time formatted string, and then converts the resulting <b>DateTime </b>object from universal time to the machine's local time.</p>
<p>The <b>Object </b>that is passed for <b>SetObjectData</b>'s first parameter is a bit strange. Just before calling <b>SetObjectData, </b>the formatter allocates (via <b>FormatterServices</b>'s static <b>GetUninitializedObject </b>method) an instance of the type that the surrogate is a surrogate for The instance's fields are all <b>0/null </b>and no constructor has been called on the object. The code inside <b>SetObjectData </b>can simply initialize the fields of this instance using the values from the passed-in <b>SerializationInfo </b>object and then have <b>SetObjectData </b>return <b>null. </b>Alternatively, <b>SetObjectData </b>could create an entirely different object or even a different type of object and return a reference to this new object, in which case, the formatter will ignore any changes that may or may not have happened to the object it passed in to <b>SetObjectData </b>.</p>
<p>In my example, my <b>UniversalToLocalTimeSerializationSurrogate </b>class acts as a surrogate for the <b>DateTime </b>type which is a value type. And so, the <b>obj </b>parameter refers to a boxed instance of a <b>DateTime. </b>There is no way to change the fields in most value types (as they are supposed to be immutable) and so, my <b>SetObjectData </b>method ignores the <b>obj </b>parameter and returns a new <b>DateTime </b>object with the desired value in it.</p>
<p>At this point, I'm sure you're all wondering how the formatter knows to use this <b>ISerializationSurrogate </b>type when it tries to serialize/deserialize a <b>DateTime </b>object. The following code demonstrates how to test the <b>UniversalToLocalTimeSerializationSurrogate</b></p>
<p>class:</p>
<p><code>private static void SerializationSurrogateDemo() { using (var stream = new MemoryStream()) { // 1. Construct the desired formatter IFormatter formatter = new SoapFormatter();<br/>
// 2. Construct a SurrogateSelector object SurrogateSelector ss = new SurrogateSelector();<br/>
// 3. Tell the surrogate selector to use our surrogate for DateTime objects ss.AddSurrogate(typeof(DateTime), formatter.Context, new UniversalToLocalTimeSerializationSurrogate());<br/>
// NOTE: AddSurrogate can be called multiple times to register multiple surrogates<br/>
// 4. Tell the formatter to use our surrogate selector formatter.SurrogateSelector = ss;<br/>
// Create a DateTime that represents the local time on the machine &amp; serialize it DateTime localTimeBeforeSerialize = DateTime.Now; formatter.Serialize(stream, localTimeBeforeSerialize);<br/>
// The stream displays the Universal time as a string to prove it worked stream.Position = 0;<br/>
Console.WriteLine(new StreamReader(stream).ReadToEnd());<br/>
// Deserialize the Universal time string &amp; convert it to a local DateTime stream.Position = 0;<br/>
DateTime localTimeAfterDeserialize = (DateTime)formatter.Deserialize(stream); // Prove it worked correctly:<br/>
Console.WriteLine(&quot;LocalTimeBeforeSerialize ={0}&quot;, localTimeBeforeSerialize); Console.WriteLine(&quot;LocalTimeAfterDeserialize={0}&quot;, localTimeAfterDeserialize);<br/>
}<br/>
}</code></p>
<p>After steps 1 through 4 have executed, the formatter is ready to use the registered surrogate types. When the formatter's <b>Serialize </b>method is called, each object's type is looked up in the set maintained by the <b>SurrogateSelector </b>. If a match is found, then the <b>ISerializationSurrogate </b>object's <b>GetObjectData </b>method is called to get the information that should be written out to the stream.</p>
<p>When the formatter's <b>Deserialize </b>method is called, the type of the object about to be deserialized is looked up in the formatter's <b>SurrogateSelector </b>and if a match is found, then the <b>ISerializationSurrogate </b>object's <b>SetObjectData </b>method is called to set the fields within the object being deserialized.</p>
<p>Internally, a <b>SurrogateSelector </b>object maintains a private hash table. When <b>AddSurrogate </b>is called, the <b>Type </b>and <b>StreamingContext </b>make up the key and the <b>ISerializationSurrogate </b>object is the key's value. If a key with the same <b>Type/ StreamingContext </b>already exists, then <b>AddSurrogate </b>throws an <b>ArgumentException. </b>By including a <b>StreamingContext </b>in the key, you can register one surrogate type object that knows how to serialize/deserialize a <b>DateTime </b>object to a file and register a different surrogate object that knows how to serialize/deserialize a <b>DateTime </b>object to a different process.</p>
<hr/>
<blockquote><b>Note </b>The <b>BinaryFormatter </b>class has a bug that prevents a surrogate from serializing objects with references to each other. To fix this problem, you need to pass a reference to your <b>ISerializationSurrogate </b>object to <b>FormatterServices</b>'s static <b>GetSurrogateForCyclicalReference </b>method. This method returns an <b>ISerializationSurrogate </b>object, which you can then pass to the <b>SurrogateSelector</b>'s <b>AddSurrogate </b>method. However, when you use the <b>GetSurrogateForCyclicalReference </b>method, your surrogate's <b>SetObjectData </b>method must modify the value inside the object referred to by <b>SetObjectData</b>'s <b>obj </b>parameter and ultimately return <b>null </b>or <b>obj </b>to the calling method The downloadable code that accompanies this book shows how to modify the <b>UniversalToLocalTimeSerializationSurrogate </b>class and the <b>SerializationSurrogateDemo </b>method to support cyclical references.</blockquote>
<hr/>
<h3>Surrogate Selector Chains</h3>
<p>Multiple <b>SurrogateSelector </b>objects can be chained together For example, you could have a <b>SurrogateSelector </b>that maintains a set of serialization surrogates that are used for serializing types into proxies that get remoted across the wire or between AppDomains. You could also have a separate <b>SurrogateSelector </b>object that contains a set of serialization surrogates that are used to convert Version 1 types into Version 2 types.</p>
<p>If you have multiple <b>SurrogateSelector </b>objects that you'd like the formatter to use, you must chain them together into a linked list. The <b>SurrogateSelector </b>type implements the <b>ISurrogateSelector </b>interface, which defines three methods. All three of these methods are related to chaining. Here is how the <b>ISurrogateSelector </b>interface is defined:</p>
<p><code>public interface ISurrogateSelector {<br/>
void ChainSelector(ISurrogateSelector selector); ISurrogateSelector CetNextSelector();<br/>
ISerializationSurrogate CetSurrogate(Type type, StreamingContext context, out ISurrogateSelector selector);<br/>
}</code></p>
<p>The <b>ChainSelector </b>method inserts an <b>ISurrogateSelector </b>object immediately after the <b>ISurrogateSelector </b>object being operated on <b>('this' </b>object). The <b>GetNextSelector </b>method returns a reference to the next <b>ISurrogateSelector </b>object in the chain or <b>null </b>if the object being operated on is the end of the chain.</p>
<p>The <b>GetSurrogate </b>method looks up a <b>Type/StreamingContext </b>pair in the <b>ISurrogateSelector </b>object identified by <b>this </b>. If the pair cannot be found, then the next <b>ISurrogateSelector </b>object in the chain is accessed, and so on. If a match is found, then <b>GetSurrogate </b>returns the <b>ISerializationSurrogate </b>object that handles the serialization/ deserialization of the type looked up In addition, <b>GetSurrogate </b>also returns the <b>ISurrogateSelector </b>object that contained the match; this is usually not needed and is ignored. If none of the <b>ISurrogateSelector </b>objects in the chain have a match for the <b>Type/StreamingContext </b>pair, <b>GetSurrogate </b>returns <b>null.</b></p>
<hr/>
<blockquote><b>Note </b>The FCL defines an <b>ISurrogateSelector </b>interface and also defines a <b>SurrogateSelector </b>type that implements this interface. However, it is extremely rare that anyone will ever have to define their own type that implements the <b>ISurrogateSelector </b>interface. The only reason to define your own type that implements this interface is if you need to have more flexibility over mapping one type to another. For example, you might want to serialize all types that inherit from a specific base class in a special way. The <b>System.Runtime.Remoting.Messaging.RemotingSurrogateSelector </b>class is a perfect example. When serializing objects for remoting purposes, the CLR formats the objects using the <b>RemotingSurrogateSelector </b>. This surrogate selector serializes all objects that derive from <b>System.MarshalByRefObject </b>in a special way so that deserialization causes proxy objects to be created on the client side.</blockquote>
<hr/>
<a name="b689"/><h2>Overriding the Assembly and/or Type When Deserializing an Object</h2>
<p>When serializing an object, formatters output the type's full name and the full name of the type's defining assembly. When deserializing an object, formatters use this information to know exactly what type of object to construct and initialize. The earlier discussion about the <b>ISerializationSurrogate </b>interface showed a mechanism allowing you to take over the serialization and deserialization duties for a specific type. A type that implements the <b>ISerializationSurrogate </b>interface is tied to a specific type in a specific assembly.</p>
<p>However, there are times when the <b>ISerializationSurrogate </b>mechanism doesn't provide enough flexibility. Here are some scenarios when it might be useful to deserialize an object into a different type than it was serialized as:</p>
<p>&#9632; A developer might decide to move a type's implementation from one assembly to a different assembly For example, the assembly's version number changes making the new assembly different from the original assembly.</p>
<p>&#9632; An object on a server that gets serialized into a stream that is sent to a client When the client processes the stream, it could deserialize the object to a completely different type whose code knows how to remote method calls to the server's object.</p>
<p>&#9632; A developer makes a new version of a type. We want to deserialize any already-serialized objects into the new version of the type.</p>
<p>The <b>System.Runtime.Serialization.SerializationBinder </b>class makes deserializing an object to a different type very easy. To do this, you first define your own type that derives from the abstract <b>SerializationBinder </b>type. In the code below, assume that version 1. 0. 0. 0 of your assembly defined a class called <b>Ver1 </b>and assume that the new version of your assembly defines the <b>VerlToVer2SerializationBinder </b>class and also defines a class called <b>Ver2:</b></p>
<p><code>internal sealed class VerlToVer2SerializationBinder : SerializationBinder { public override Type BindToType(String assemblyName, String typeName) { // Deserialize any Verl object from version 1.0.0.0 into a Ver2 object<br/>
// Calculate the assembly name that defined the Ver1 type AssemblyName assemVerl = Assembly.CetExecutingAssembly().CetName(); assemVerl.Version = new Version(1, 0, 0, 0);<br/>
// If deserializing the Verl object from vl.0.0.0, turn it into a Ver2 object if (assemblyName == assemVerl.ToString() &amp;&amp; typeName == &quot;Verl&quot;) return typeof(Ver2);<br/>
// Else, just return the same type being requested<br/>
return Type.GetType(String.Format(&quot;{0}, {l}&quot;, typeName, assemblyName));<br/>
}<br/>
}</code></p>
<p>Now, after you construct a formatter, construct an instance of</p>
<p><b>VerlToVer2SerializationBinder </b>and set the formatter's <b>Binder </b>read/write property to refer to the binder object. After setting the <b>Binder </b>property, you can now call the formatter's <b>Deserialize </b>method During deserialization, the formatter sees that a binder has been set As each object is about to be deserialized, the formatter calls the binder's <b>BindToType </b>method, passing it the assembly name and type that the formatter wants to deserialize. At this point, <b>BindToType </b>decides what type should actually be constructed and returns this type.</p>
<hr/>
<blockquote><b>Note </b>The <b>SerializationBinder </b>class also makes it possible to change the assembly/type information while serializing an object by overriding its <b>BindToName </b>method, which looks like</blockquote>
<hr/>
<p>this:</p>
<p><code>public virtual void BindToName(Type serializedType, out string assemblyName, out string typeName)</code></p>
<p>During serialization, the formatter calls this method, passing you the type it wants to serialize You can then return (via the two out parameters) the assembly and type that you want to serialize instead. If you return <b>null </b>and <b>null </b>(which is what the default implementation does), then no change is performed.</p>
<mbp:pagebreak/>
<a name="Chapter25"/>
<h1>Chapter 25: Thread Basics</h1>
<p><b>In this chapter:</b></p>
<a href="#b691">Why Does Windows Support Threads?</a><br/>
<a href="#b692">Thread Overhead</a><br/>
<a href="#b696">Stop the Madness</a><br/>
<a href="#b699">CPU Trends</a><br/>
<a href="#b700">NUMA Architecture Machines</a><br/>
<a href="#b703">CLR Threads and Windows Threads</a><br/>
<a href="#b704">Using a Dedicated Thread to Perform an Asynchronous Compute-Bound Operation</a><br/>
<a href="#b706">Reasons to Use Threads</a><br/>
<a href="#b708">Thread Scheduling and Priorities</a><br/>
<a href="#b713">Foreground Threads versus Background Threads</a><br/>
<a href="#b715">What Now?</a><br/>
<p>In this chapter, I introduce the basic concepts concerning threads, and I offer a way for developers to conceptualize about them and their use. I'll explain why Microsoft Windows introduced the concept of threads, CPU trends, the relationship between common language runtime (CLR) threads and Windows threads, the overhead associated with using threads, how Windows schedules threads, the Microsoft .NET Framework classes that expose thread properties, and much more.</p>
<p>The chapters in Part V of this book, &quot;Threading,&quot; explain how Windows and the CLR work together to provide a threading architecture. It is my hope that after reading these chapters, you will take away a foundation of knowledge that will allow you to effectively use threads to design and build responsive, reliable, and scalable applications and components.</p>
<a name="b691"/><h2>Why Does Windows Support Threads?</h2>
<p>Back in the early days of computers, operating systems didn't offer the concept of a thread. In effect, there was just one thread of execution that ran throughout the entire system, which included both operating system code and application code The problem with having only one thread of execution was that a long-running task would prevent other tasks from executing. For example, in the days of 16-bit Windows, it was very common for an application that was printing a document to stall the entire machine, causing the OS and all other applications to stop responding And, sometimes applications would have a bug in them, resulting in an infinite loop that also stopped the entire machine from operating.</p>
<p>At this point, the end user would have no choice but to reboot the computer by pressing the reset button or power switch Of course, end users hated doing this (they still do, in fact) because all running applications terminated; more importantly, any data that these applications were processing was thrown out of memory and lost. Microsoft knew that 16-bit Windows would not be a good enough operating system to keep Microsoft relevant as the computer industry progressed, so they set out to build a new OS to address the needs of corporations and individuals This new OS had to be robust, reliable, scalable, and secure, and it had to improve the many deficiencies of 16-bit Windows. This OS kernel originally shipped in Microsoft Windows NT. Over the years, this kernel has had many tweaks and features added to it. The latest version of this kernel ships in the latest versions of the Microsoft client and server Windows operating systems.</p>
<p>When Microsoft was designing this OS kernel, they decided to run each instance of an application in what is called a process. A process is just a collection of resources that is used by a single instance of an application Each process is given a virtual address space, ensuring that the code and data used by one process is not accessible to another process. This makes application instances robust because one process cannot corrupt code or data being used by another In addition, the OS's kernel code and data are not accessible to processes; therefore, it's not possible for application code to corrupt operating system code or data So now, application code cannot corrupt other applications or the OS itself, and the whole computing experience is much better for end users. In addition, the system is more secure because application code cannot access user names, passwords, credit card information, or other sensitive information that is in use by another application or the operating system itself</p>
<p>This is all well and good, but what about the CPU itself? What if an application enters an infinite loop? Well, if there is only one CPU in the machine, then it executes the infinite loop and cannot execute anything else, so while the data cannot be corrupted and is more secure, the system could still stop responding to the end user Microsoft needed to fix this problem, too, and threads were the answer A thread is a Windows concept whose job is to virtualize the CPU Windows gives each process its very own thread (which functions similar to a CPU), and if application code enters an infinite loop, the process associated with that code freezes up, but other processes (which have their own threads) are not frozen; they keep running!</p>
<a name="b692"/><h2>Thread Overhead</h2>
<p>Threads are awesome because they enable Windows to be responsive even when applications are executing long-running tasks. Also, threads allow the user to use one application (like Task Manager) to forcibly kill an application that appears frozen because it is executing a long-running task. But as with every virtualization mechanism, threads have space (memory consumption) and time (runtime execution performance) overhead associated with them. Let's explore this overhead in more detail now. Every thread has one of each of the following:</p>
<p>&#9632; Thread kernel object   The OS allocates and initializes one of these data structures for each thread created in the system The data structure contains a bunch of properties (discussed later in this chapter) that describe the thread This data structure also contains what is called the thread's context. The context is a block of memory that contains a set of the CPU's registers. When Windows is running on a machine with an x86 CPU, the thread's context uses about 700 bytes of memory. For x64 and IA64 CPUs, the context is about 1,240 and 2,500 bytes of memory, respectively.</p>
<p>&#9632; Thread environment block (TEB)   The TEB is a block of memory allocated and initialized in user mode (address space that application code can quickly access). The TEB consumes 1 page of memory (4 KB on x86 and x64 CPUs, 8 KB on an IA64 CPU). The TEB contains the head of the thread's exception-handling chain Each try block that the thread enters inserts a node in the head of this chain; the node is removed from the chain when the thread exists in the try block. In addition, the TEB contains the thread's thread-local storage data as well as some data structures for use by Graphics Device Interface (GDI) and OpenGL graphics.</p>
<p>&#9632; User-mode stack  The user-mode stack is used for local variables and arguments passed to methods. It also contains the address indicating what the thread should execute next when the current method returns. By default, Windows allocates 1 MB of memory for each thread's user-mode stack. <sup>1</sup></p>
<p>&#9632; Kernel-mode stack  The kernel-mode stack is also used when application code passes arguments to a kernel-mode function in the operating system. For security reasons, Windows copies any arguments passed from user-mode code to the kernel from the thread's user-mode stack to the thread's kernel-mode stack. Once copied, the kernel can verify the arguments' values, and since the application code can't access the kernel-mode stack, the application can't modify the arguments' values after they have been validated and the OS kernel code begins to operate on them. In addition, the kernel calls methods within itself and uses the kernel-mode stack to pass its own arguments, to store a function's local variables, and to store return addresses. The kernel-mode stack is 12 KB when running on a 32-bit Windows system and 24 KB when running on a 64-bit Windows system.</p>
<p>For native applications, Windows reserves the 1 MB of address space and sparsely commits physical storage to it as the thread actually requires it when growing the stack. However, when managed applications create a thread, the CLR forces Windows to reserve and fully commit the stack immediately, so 1 MB of physical storage is fully allocated as each thread is created The CLR team did this to make managed code behave more reliably in situations where the system was running low on memory For example, the CLR and managed applications never have to worry about recovering from insufficient memory when attempting to grow a thread's stack. This was very important for Microsoft SQL Server when executing stored procedures implemented in managed code.</p>
<p><b>&#9632;   DLL thread-attach and thread-detach notifications   </b>Windows has a policy that whenever a thread is created in a process, all DLLs loaded in that process have their <b>DllMain </b>method called, passing a <b>DLL_THREAD_ATTACH </b>flag. Similarly, whenever a thread dies, all DLLs in the process have their <b>DllMain </b>method called, passing it a <b>DLL_THREAD_DETACH </b>flag. Some DLLs need these notifications to perform some special initialization or cleanup for each thread created/destroyed in the process For example, the C-Runtime library DLL allocates some thread-local storage state that is required should the thread use functions contained within the C-Runtime library.</p>
<p>In the early days of Windows, many processes had maybe 5 or 6 DLLs loaded into them, but today, some processes have several hundred DLLs loaded into them Right now, on my machine, Microsoft Office Outlook has about 250 DLLs loaded into its process address space! This means that whenever a new thread is created in Office Outlook, 250 DLL functions must get called before the thread is allowed to do what it was created to do And these 250 functions must be called again whenever a thread in Outlook dies. Wow葉his can seriously affect the performance of creating and destroying threads within a process. <sup>2</sup></p>
<p>So now, you see all the space and time overhead that is associated with creating a thread, letting it sit around in the system, and destroying it. But the situation gets even worse溶ow we're going to start talking about context switching. A computer with only one CPU in it can do only one thing at a time. Therefore, Windows has to share the actual CPU hardware among all the threads (logical CPUs) that are sitting around in the system.</p>
<p>At any given moment in time, Windows assigns one thread to a CPU. That thread is allowed to run for a time-slice (sometimes referred to as a quantum) When the time-slice expires, Windows context switches to another thread Every context switch requires that Windows performs the following actions:</p>
<p><b>1. </b>Save the values in the CPU's registers to the currently running thread's context structure inside the thread's kernel object.</p>
<p><b>2. </b>Select one thread from the set of existing threads to schedule next If this thread is owned by another process, then Windows must also switch the virtual address space seen by the CPU before it starts executing any code or touching any data.</p>
<p><b>3. </b>Load the values in the selected thread's context structure into the CPU's registers.</p>
<p>After the context switch is complete, the CPU executes the selected thread until its time-slice expires, and then another context switch happens again. Windows performs context switches about every 30 ms. Context switches are pure overhead; that is, there is no memory or performance benefit that comes from context switches. Windows performs context switching to provide end users with a robust and responsive operating system.</p>
<p>DLLs produced by C# and most other managed programming languages do not have a <b>DllMain </b>in them at all and so managed DLLs will not receive the <b>DLL_THREAD_ATTACH </b>and <b>DLL_THREAD_DETACH </b>notifications improving performance. In addition, unmanaged DLLs can opt out of these notifications by calling the Win32 <b>DisableThreadLibraryCalls </b>function. Unfortunately, many unmanaged developers are not aware of this function, so they don't call it.</p>
<p>Now, if an application's thread enters into an infinite loop, Windows will periodically preempt that thread, assign a different thread to an actual CPU, and let this other thread run for a while. This other thread could be Task Manager's thread and now, the end user can use Task Manager to kill the process containing the thread that is in an infinite loop. When doing this, the process dies and all the data it was working on is destroyed, too, but all other processes in the system continue to run just fine without losing their data. Of course, the user doesn't have to reset the machine and reboot, so context switches are required to provide end users with a much better overall experience at the cost of performance.</p>
<p>In fact, the performance hit is much worse than you might think. Yes, a performance hit occurs when Windows context switches to another thread. But the CPU was executing another thread, and the previously running thread's code and data reside in the CPU's caches so that the CPU doesn't have to access RAM memory as much, which has significant latency associated with it When Windows context switches to a new thread, this new thread is most likely executing different code and accessing different data that is not in the CPU's cache. The CPU must access RAM memory to populate its cache so it can get back to a good execution speed. But then, about 30 ms later, another context switch occurs.</p>
<p>The time required to perform a context switch varies with different CPU architectures and speed. And the time required to build up a CPU's cache depends on what applications are running in the system, the size of the CPU's caches, and various other factors. So it is impossible for me to give you an absolute figure or even an estimate as to what time overhead is incurred for each context switch. Suffice it to say that you want to avoid using context switches as much as possible if you are interested in building high-performing applications and components.</p>
<hr/>
<blockquote><b>Important </b>At the end of a time-slice, if Windows decides to schedule the same thread again (rather than switching to another thread), then Windows does not perform a context switch Instead, the thread is allowed to just continue running. This improves performance significantly, and avoiding context switches is something you want to achieve as often as possible when you design your code.</blockquote>
<hr/>
<hr/>
<blockquote><b>Important </b>A thread can voluntarily end its time-slice early, which happens quite frequently because threads typically wait for I/O operations (keyboard, mouse, file, network, etc.) to complete For example, Notepad's thread usually sits idle with nothing to do; this thread is waiting for input If the user presses the J key on the keyboard, Windows wakes Notepad's thread to have it process the J keystroke. It may take Notepad's thread just 5 ms to process the key, and then it calls a Win32 function that tells Windows that it is ready to process the next input event. If there are no more input events, then Windows puts Notepad's thread into a wait state (relinquishing the remainder of its time-slice) so that the thread is not scheduled on any CPU until the next input stimulus occurs This improves overall system performance since threads that are waiting for I/O operations to complete are not scheduled on a CPU and do not waste CPU time; other threads can be scheduled on the CPU instead.</blockquote>
<hr/>
<p>In addition, when performing a garbage collection, the CLR must suspend all the threads, walk their stacks to find the roots to mark objects in the heap, walk their stacks again (updating roots to objects that moved during compaction), and then resume all the threads. So avoiding threads will greatly improve the performance of the garbage collector, too. And whenever you are using a debugger, Windows suspends all threads in the application being debugged every time a breakpoint is hit and resumes all the threads when you single-step or run the application. So the more threads you have, the slower your debugging experience will be.</p>
<p>From this discussion, you should conclude that you must avoid using threads as much as possible because they consume a lot of memory and they require time to create, destroy, and manage Time is also wasted when Windows context switches between threads and when garbage collections occur However, this discussion should also help you realize that threads must be used sometimes because they allow Windows to be robust and responsive.</p>
<p>I should also point out that a computer with multiple CPUs in it can actually run multiple threads simultaneously, increasing scalability (the ability to do more work in less time). Windows will assign one thread to each CPU core, and each core will perform its own context switching to other threads Windows makes sure that a single thread is not scheduled on multiple cores at one time because this would wreak havoc Today, computers that contain multiple CPUs, hyperthreaded CPUs, or multi-core CPUs are commonplace. But when Windows was originally designed, single-CPU computers were commonplace, and Windows added threads to improve system responsiveness and reliability Today, threads are also being used to improve scalability, which can happen only on computers that have multiple cores in them.</p>
<p>The remaining chapters in this book discuss the various Windows and CLR mechanisms that exist so that you can effectively wrestle with the tension of creating as few threads as possible while still keeping your code responsive and allowing it to scale if your code is running on a machine with multiple cores.</p>
<a name="b696"/><h2>Stop the Madness</h2>
<p>If all we cared about was raw performance, then the optimum number of threads to have on any machine is identical to the number of CPUs on that machine So a machine with one CPU would have only one thread, a machine with two CPUs would have two threads, and so on. The reason is obvious: If you have more threads than CPUs, then context switching is introduced and performance deteriorates. If each CPU has just one thread, then no context switching exists and the threads run at full speed.</p>
<p>However, Microsoft designed Windows to favor reliability and responsiveness as opposed to favoring raw speed and performance. And I commend this decision: I don't think any of us would be using Windows or the .NET Framework today if applications could still stop the OS and other applications Therefore, Windows gives each process its own thread for improved system reliability and responsiveness. On my machine, for example, when I run Task Manager and select the Performance tab, I see the image shown in Figure 25-1.</p>
<img src="83.jpg"/>
<p><b>Figure 25-1 </b>Task Manager showing system performance</p>
<p>It shows that my machine currently has 60 processes running on it, and so we'd expect that there were at least 60 threads on my machine since each process gets at least 1 thread. But Task Manager also shows that my machine currently has 829 threads in it! This means that there is about 829 MB of memory allocated for just the thread stacks, and my machine has only 2 GB of RAM in it. This also means that there is an average of approximately 13.8 threads per process.</p>
<p>Now, look at the CPU Usage reading: It shows that my CPU is busy 0 percent of the time. This means that 100 percent of the time, these 829 threads have literally nothing to do葉hey are just soaking up memory that is definitely not being used when the threads are not running. You have to ask yourself: Do these applications need all these threads to do nothing 100 percent of the time? The answer to this question has to be &quot;No.&quot; Now, if you want to see which processes are the most wasteful, click the Processes tab, add the Threads column,<sup>3</sup> and sort this column in descending order, as shown in Figure 25-2.</p>
<p>You add the column by selecting the View menu's Select Columns menu item.</p>
<img src="84.jpg"/>
<p><b>Figure 25-2 </b>Task Manager showing processes</p>
<p>As you can see here, Outlook has created 38 threads and is using 0 percent of the CPU, Microsoft Visual Studio (Devenv exe) has created 34 threads to use 0 percent of the CPU, Windows Live Messenger (Msnmsgr.exe) has created 34 threads to use 0 percent of the CPU, and so on What is going on here?</p>
<p>When developers were learning about Windows, they learned that a process in Windows is very, very expensive. Creating a process usually takes several seconds, a lot of memory must be allocated, this memory must be initialized, the EXE and DLL files have to load from disk, and so on. By comparison, creating a thread in Windows is very cheap, so developers decided to stop creating processes and start creating threads instead So now we have lots of threads But even though threads are cheaper than processes, they are still very expensive compared to most other system resources, so they should be used sparingly and appropriately.</p>
<p>Well, without a doubt, we can say for sure that all of these applications we've just discussed are using threads inefficiently. There is just no way that all of these threads need to exist in the system It is one thing to allocate resources inside an application; it's quite another to allocate them and then not use them. This is just wasteful, and allocating all the memory for thread stacks means that there is less memory for more important data, such as a user's document <sup>4</sup></p>
<p>I just can't resist sharing with you another demonstration of how bad this situation is. Try this: Open Notepad.exe and use Task Manager to see how many threads are in it. Then select Notepad's File Open menu item to display the common File Open dialog box. Once the dialog box appears, look at Task Manager to see how many new threads just got created. On my machine, 22 additional threads are created just by displaying this dialog box! In fact, every application that uses the common File Open or File Save dialog box will get many additional threads created inside it that sit idle most of the time. A lot of these threads aren't even destroyed when the dialog box is closed.</p>
<p>To make matters worse, what if these were the processes running in a single user's Remote Desktop Services session預nd what if there were actually 100 users on this machine? Then there would be 100 instances of Outlook, all creating 38 threads only to do nothing with them. That's 3,800 threads each with its own kernel object, TEB, user-mode stack, kernel-mode stack, etc. That is a lot of wasted resources. This madness has to stop, especially if Microsoft wants to give users a good experience when running Windows on netbook computers, many of which have only 1 GB of RAM. Again, the chapters in this part of the book will describe how to properly design an application to use very few threads in an efficient manner.</p>
<p>Now, I will admit that today, most threads in the system are created by native code. Therefore, the thread's user-mode stack is really just reserving address space and most likely, the stack is not fully committed to using storage. However, as more and more applications become managed or have managed components running inside them (which Outlook supports), then more and more stacks become fully committed, and they are allocating a full 1 MB of physical storage Regardless, all threads still have a kernel object, kernel-mode stack, and other resources allocated to them. This trend of creating threads willy-nilly because they are cheap has to stop; threads are not cheap羊ather, they are expensive, so use them wisely.</p>
<a name="b699"/><h2>CPU Trends</h2>
<p>In the past, CPU speeds used to increase with time, so an application that ran slowly on one machine would typically run faster on a newer machine. However, CPU manufacturers are unable to continue the trend of making CPUs faster When you run CPUs at high speeds, they produce a lot of heat that has to be dissipated. A few years ago, I acquired a newly released notebook computer from a respected manufacturer. This computer had a bug in its firmware that made it not turn the fan on enough; as a result, after running the computer for a while, the CPU and the motherboard melted. The hardware manufacturer replaced the machine and then &quot;improved&quot; the firmware by making the fan run more frequently. Unfortunately, this had the effect of draining the battery faster, because fans consume a lot of power.</p>
<p>These are the kinds of problems that the hardware vendors face today. Since CPU manufacturers can't continuously produce higher-speed CPUs, they have instead turned their attention to making transistors smaller so that more of them can reside on a single chip Today, we can have a single silicon chip that contains two or more CPU cores The result is that our software only gets faster if we write our software to use the multiple cores. How do we do this? We use threads in an intelligent fashion.</p>
<p>Computers use three kinds of multi-CPU technologies today:</p>
<p>&#9632; Multiple CPUs   Some computers just have multiple CPUs in them. That is, the motherboard has multiple sockets on it, with each socket containing a CPU Since the motherboard must be bigger, the computer case is bigger as well, and sometimes these machines have multiple power supplies in them due to the additional power drain. These kinds of computers have been around for a few decades, but they are not as popular today due to their increased size and cost.</p>
<p>&#9632; Hyperthreaded chips  This technology (owned by Intel) allows a single chip to look like two chips The chip contains two sets of architectural states, such as CPU registers, but the chip has only one set of execution resources. To Windows, this looks like there are two CPUs in the machine, so Windows schedules two threads concurrently However, the chip only executes one of the threads at a time. When one thread pauses due to a cache miss, branch misprediction, or data dependency, the chip switches to the other thread This all happens in hardware, and Windows doesn't know that it is happening; Windows believes that both threads are running concurrently Windows does know about hyperthreaded CPUs, and if you have multiple hyperthreaded CPUs in a single machine, Windows will first schedule one thread on each CPU so that the threads are truly running concurrently and then schedule other threads on the already-busy CPUs. Intel claims that a hyperthreaded CPU can improve performance by</p>
<p>10 percent to 30 percent.</p>
<p>&#9632; Multi-core chips  A few years ago, single chips containing multiple CPU cores have entered the scene As I write this, chips with two, three, and four cores are readily available. Even my notebook computer has two cores in it; I'm sure it won't be long before our mobile phones have multiple cores in them too. Intel has even been working on a single chip with 80 cores on it! Wow, this is a lot of computing power! And Intel even has hyperthreaded multi-core chips.</p>
<a name="b700"/><h2>NUMA Architecture Machines</h2>
<p>While multi-core CPUs look great on the surface, they lead to a new problem. Now, multiple cores are accessing other system resources concurrently, so these other system resources become the bottleneck of the system's overall performance. For example, if two cores need to access RAM simultaneously, the memory bandwidth limits overall performance so that a dual-core system yields only a 30 percent to 70 percent performance improvement compared to a single-core system To help mitigate this, computers are now employing what is called a Cache-Coherent Non-Uniform Memory Access architecture, or simply, NUMA.</p>
<p>Figure 25-3 shows the architecture of a NUMA-based computer system This system has four nodes in it Each node contains four CPUs, a north bridge, a south bridge, and local memory (RAM). Some nodes also have local devices connected. All of the memory is accessible to any node; however, the time it takes to access the memory is non-uniform. For example, any CPU on Node 1 can access local memory on Node 1 very quickly. A CPU on Node 1 can also access memory on Nodes 2 and 4, but only with a significant performance hit. A CPU in Node 1 can also access memory on Node 3, but the resulting performance hit is even worse since there is no direct line of communication between Nodes 1 and 3. Even though the 16 CPUs are spread across four different nodes, the hardware ensures that the caches of all CPUs remain coherent and in sync with each other.</p>
<p>The Win32 API offers many functions to unmanaged developers that allow their applications to specifically allocate memory on a particular NUMA node and to force threads to run on a specific NUMA node. Today, the CLR does nothing special to accommodate NUMA systems. In the future, I imagine the CLR will include things like having one garbage-collected heap per NUMA node and perhaps the ability for an application to indicate on which node an object should be allocated Or perhaps the CLR will migrate objects from one node to another, depending on which CPU seems to be accessing the object the most.</p>
<p><b>Figure 25-3 </b>The architecture of a NUMA computer</p>
<p>Back in the early 1990s, it was hard to imagine that someday there would be computers that had 32 CPUs in them. Therefore, when 32-bit Windows was first created, it was designed to handle machines with up to 32 CPUs. Then, when Microsoft was making 64-bit Windows,</p>
<img src="85.jpg"/>
<p>it designed the system to handle up to 64 CPUs in a single machine At the time, 64 CPUs seemed like a lot, but today it looks like machines are going to get even more CPUs in them in the not-so-far-off future.</p>
<p>Starting with Windows Server 2008 R2, Microsoft has designed Windows to support machines that have up to 256 logical processors in them. Figure 25-4 shows how Windows supports all these logical processors. Here's how to interpret the figure:</p>
<p>&#9632; A single machine has 1 or more processor groups where each group contains 1 to 64 logical processors.</p>
<p>&#9632; A processor group has one or more NUMA nodes. Each node contains some logical processors, cache memory, and local memory (all in proximity to each other).</p>
<p>&#9632; Each NUMA node has one or more sockets on it for silicon chips.</p>
<p>&#9632; Each socket's chip contains one or more CPU cores.</p>
<p>&#9632; Each core contains one or more logical processors. There can be more than one logical processor if the chip is hyperthreaded.</p>
<p><b>Figure 25-4 </b>Windows uses processor groups to support machines with up to 256 logical processors in them</p>
<img src="86.jpg"/>
<p>Today, the CLR doesn't take advantage of processor groups and so all of the threads it creates run in processor group 0 (the default) and can only use up to 64 cores when running on 64-bit Windows. Since 32-bit versions of Windows only support processor group 0 and since 32-bit versions of Windows only support 32 CPUs, managed applications can use up to 32 cores when running on a 32-bit version of Windows.</p>
<a name="b703"/><h2>CLR Threads and Windows Threads</h2>
<p>Today, the CLR uses the threading capabilities of Windows, so Part V of this book is really focusing on how the threading capabilities of Windows are exposed to developers who write code by using the CLR. I will explain about how threads in Windows work and how the CLR alters the behavior (if it does). However, if you'd like more information about threads, I recommend reading some of my earlier writings on the topic, such as my book Windows via C/C++, 5th Edition (Microsoft Press, 2007).</p>
<p>While a CLR thread maps directly to a Windows thread today, the Microsoft CLR team reserves the right to divorce itself from Windows threads in the future Someday, the CLR may introduce its own logical thread concept so that a CLR logical thread doesn't necessarily map to a physical Windows thread For example, there has been talk of creating logical threads that use much less resources than physical threads, and then you could have many logical threads running on top of a very small number of physical threads. For instance, the CLR could determine that one of your threads is in a wait state and reassign that thread to do a different task. The benefits of this include easier coding, less resources used, and potentially improved performance. Unfortunately, implementing this solution would be a huge amount of work for the CLR team, so I would not expect a feature like this to make it into the CLR anytime soon.</p>
<p>For you, all of this means that your code should make as few assumptions as possible when manipulating threads. For example, you should avoid P/Invoking to native Windows functions since these functions have no knowledge of a CLR thread. <sup>5</sup> By avoiding native Windows functions and sticking with Framework Class Library (FCL) types whenever possible, you're guaranteed that your code will easily take advantage of these performance enhancements as they become available in the future.</p>
<p>If you need to P/Invoke out to native code and it is important that the code execute using the current physical operating system thread, then you should call <b>System.Threading.Thread</b>'s static <b>BeginThreadAffinity </b>method When the thread no longer requires running by using the physical operating system thread, it can notify the CLR by calling <b>Thread</b>'s static <b>EndThreadAffinity </b>method.</p>
<a name="b704"/><h2>Using a Dedicated Thread to Perform an Asynchronous Compute-Bound Operation</h2>
<p>In this section, I will show you how to create a thread and have it perform an asynchronous compute-bound operation While I am going to walk you through this, I highly recommend that you avoid the technique I show you here Instead, you should use the CLR's thread pool to execute asynchronous compute-bound operations whenever possible, and I go into the details about doing this in Chapter 26, &quot;Compute-Bound Asynchronous Operations.&quot;</p>
<p>However, there are some occasions when you might want to explicitly create a thread dedicated to executing a particular compute-bound operation Typically, you'd want to create a dedicated thread if you're going to execute code that requires the thread to be in a particular state that is not normal for a thread pool thread. For example, explicitly create your own thread if any of the following is true:</p>
<p>&#9632; You need the thread to run with a non-normal thread priority. All thread pool threads run at normal priority While you can change this, it is not recommended, and the priority change does not persist across thread pool operations.</p>
<p>&#9632; You need the thread to behave as a foreground thread, thereby preventing the application from dying until the thread has completed its task. For more information, see the &quot;Foreground Threads versus Background Threads&quot; section later in this chapter. Thread pool threads are always background threads, and they may not complete their task if the CLR wants to terminate the process.</p>
<p>&#9632; The compute-bound task is extremely long-running; this way, I would not be taxing the thread pool's logic as it tries to figure out whether to create an additional thread.</p>
<p>&#9632; I wanted to start a thread and possibly abort it prematurely by calling <b>Thread</b>'s <b>Abort </b>method (discussed in Chapter 22, &quot;CLR Hosting and AppDomains&quot;).</p>
<p>To create a dedicated thread, you construct an instance of the <b>System.Threading.Thread </b>class, passing the name of a method into its constructor. Here is the prototype of <b>Thread</b>'s constructor:</p>
<p><code>public sealed class Thread : CriticalFinalizerObject, ... { public Thread(ParameterizedThreadStart start); // Less commonly used constructors are not shown here<br/>
}</code></p>
<p>The <b>start </b>parameter identifies the method that the dedicated thread will execute, and this method must match the signature of the <b>ParameterizedThreadStart </b>delegate. <sup>6</sup></p>
<p><code>delegate void ParameterizedThreadStart(Object obj);</code></p>
<p>For the record, <b>Thread </b>also offers a constructor that takes a <b>ThreadStart </b>delegate that accepts no arguments and returns <b>void </b>Personally, I recommend that you avoid this constructor and delegate because they are more limiting. If your thread method takes an <b>Object </b>and returns <b>void, </b>then you can invoke your method using a dedicated thread or invoke it using the thread pool (as shown in Chapter 26).</p>
<p>Constructing a <b>Thread </b>object is a relatively lightweight operation because it does not actually create a physical operating system thread. To actually create the operating system thread and have it start executing the callback method, you must call <b>Thread</b>'s <b>Start </b>method, passing into it the object (state) that you want passed as the callback method's argument The following code demonstrates how to create a dedicated thread and have it call a method asynchronously:</p>
<p><code>using System;<br/>
using System.Threading;<br/>
public static class Program { public static void Main() {<br/>
Console.WriteLine<b>C</b>'Main thread: starting a dedicated thread &quot; +<br/>
&quot;to do an asynchronous operation&quot;); Thread dedicatedThread = new Thread(ComputeBoundOp); dedicatedThread.Start(5);<br/>
Console.WriteLine<b>C</b>'Main thread: Doing other work here...&quot;); Thread.Sleep(10000);        // Simulating other work (10 seconds)<br/>
dedicatedThread.Join(); // Wait for thread to terminate Console.WriteLine<b>C</b>'Hit &lt;Enter&gt; to end this program...&quot;); Console.ReadLine<b>O;</b><br/>
}<br/>
// This method's signature must match the ParameterizedThreadStart delegate private static void ComputeBoundOp(Object state) { // This method is executed by a dedicated thread<br/>
Console.WriteLine<b>C</b>'In ComputeBoundOp: state={0}&quot;, state); Thread.Sleep(1000);   // Simulates other work (1 second)<br/>
// When this method returns, the dedicated thread dies<br/>
}<br/>
}</code></p>
<p>When I compile and run this code, I get the following output:</p>
<p><code>Main thread: starting a dedicated thread to do an asynchronous operation Main thread: Doing other work here... In ComputeBoundOp: state=5</code></p>
<p>Sometimes when I run this code, I get the following output since I can't control how Windows schedules the two threads:</p>
<p><code>Main thread: starting a dedicated thread to do an asynchronous operation<br/>
In ComputeBoundOp: state=5<br/>
Main thread: Doing other work here...</code></p>
<p>Notice that the <b>Main </b>method calls <b>Join. </b>The <b>Join </b>method causes the calling thread to stop executing any code until the thread identified by <b>dedicatedThread </b>has destroyed itself or been terminated</p>
<a name="b706"/><h2>Reasons to Use Threads</h2>
<p>There are really three reasons to use threads.</p>
<p>&#9632; You can use threads to isolate code from other code. This can improve your application's reliability, and in fact, this is why Windows introduced the concept of threads into the operating system. Windows needs threads for reliability because your application</p>
<p>is a third-party component to the operating system and Microsoft doesn't verify the quality of your code before you ship it. However, you should be testing all of your applications before you ship them, and since you are testing complete applications, you should know that they are robust and of high quality. Because of this, your application's need for robustness is not as high as the operating system's need for robustness, and therefore, your application should not use many threads for the purpose of maintaining robustness. If your application supports the loading of components produced by other parties, then your application's need for robustness increases and using threads can help satisfy this requirement.</p>
<p>&#9632; You can use threads to make your coding easier.   Sometimes coding is easier if you execute a task via its own thread. But of course, when you do this, you are using additional resources and not writing the code as efficiently as possible. Now, I'm all for having an easier coding process even at the expense of some resources If I weren't OK with this, then I'd still be writing in machine language as opposed to being a C# developer. But sometimes I see people using threads thinking that they are choosing an easier programming methodology when, in fact, they are complicating their life (and their code) substantially. Usually, when you introduce threads, you introduce coordination code that may require thread synchronization constructs to know when the other thread has terminated Once you start handling coordination, you are using even more resources and complicating your code. So make sure that threads are really going to help you before you start using them.</p>
<p>&#9632; You can use threads to get concurrent execution.   If and only if you know that your application is running on a machine with multiple CPUs in it, you can get improved performance by having multiple tasks executing simultaneously. Today, machines with multiple CPUs in them are quite common, so designing your application to use multiple cores makes sense and is the focus of Chapter 26 and Chapter 27, &quot;I/O-Bound Asynchronous Operations &quot;</p>
<p>Now, I'd like to share with you a theory of mine. Every computer has an incredibly powerful resource inside it: the CPU itself. If someone spends money on a computer, then that computer should be working all the time. In other words, I believe that all the CPUs in a computer should be running at 100 percent utilization all the time. I will qualify this statement with two caveats. First, you may not want the CPUs running at 100 percent utilization if the computer is on battery power because that may drain the battery too quickly. Second, some data centers would prefer to have 10 machines running at 50 percent CPU utilization rather than</p>
<p>5 machines running at 100 percent CPU utilization because running CPUs at full power tends to generate heat, which requires cooling systems, and powering a HVAC cooling system can be more expensive than powering more computers running at reduced capacity. Although data centers find it increasingly expensive to maintain multiple machines because each machine has to have periodic hardware and software upgrades and monitoring, this has to be weighed against the expense of running a cooling system.</p>
<p>Now, if you agree with my theory, then the next step is to figure out what the CPUs should be doing. Before I give you my ideas here, let me say something else first. In the past, developers and end users always felt that the computer was not powerful enough Therefore, we developers would never just execute code unless the end users give us permission to do so and indicate that it is OK for the application to consume CPU resources via UI elements such as menu items, buttons, and check boxes.</p>
<p>But now, times have changed. Computers ship with phenomenal amounts of computing power, and even more computing power is being promised in the very near future. Earlier in this chapter, I showed you how Task Manager was reporting that my CPU was busy just 0 percent of the time. If my computer contained a quad-core CPU in it instead of the dual-core CPU that it now has, then Task Manager will report 0 percent more often. When an 80-core processor comes out, the machine will look like it's doing nothing almost all the time To computer purchasers, it looks like they're spending more money for more powerful CPUs and the computer is doing less work!</p>
<p>This is the reason why the hardware manufacturers are having a hard time selling multi-core computers to users: the software isn't taking advantage of the hardware and users get no benefit from buying machines with additional CPUs. What I'm saying is that we now have an abundance of computing power available and more is on the way, so developers can aggressively consume it. That's right擁n the past, we would never dream of having our applications perform some computation unless we knew the end user wanted the result of that computation. But now that we have extra computing power, we can dream like this.</p>
<p>Here's an example: When you stop typing in Visual Studio's editor, Visual Studio automatically spawns the compiler and compiles your code. This makes developers incredibly productive because they can see warnings and errors in their source code as they type and can fix things immediately. In fact, what developers think of today as the Edit-Build-Debug cycle will become just the Edit-Debug cycle because building (compiling) code will just happen all the time. You, as an end user, won't notice this because there is a lot of CPU power available and other things you're doing will barely be affected by the frequent running of the compiler. In fact, I would expect that in some future version of Visual Studio, the Build menu item will disappear completely because building will just become automatic. Not only does the application's UI get simpler, but the application also offers &quot;answers&quot; to the end user, making them more productive.</p>
<p>When we remove UI components like menu items, computers get simpler for end users There are fewer options for them and fewer concepts for them to read and understand It is the multi-core revolution that allows us to remove these UI elements, thereby making software so much simpler for end users that my grandmother might someday feel comfortable using a computer. For developers, removing UI elements usually results in less testing, and offering fewer options to the end user simplifies the code base. And if you currently localize the text in your UI elements and your documentation (like Microsoft does), then removing the UI elements means that you write less documentation and you don't have to localize this documentation anymore. All of this can save your organization a lot of time and money.</p>
<p>Here are some more examples of aggressive CPU consumption: spell checking and grammar checking of documents, recalculation of spreadsheets, indexing files on your disk for fast searching, and defragmenting your hard disk to improve I/O performance.</p>
<p>I want to live in a world where the UI is reduced and simplified, I have more screen real estate to visualize the data that I'm actually working on, and applications offer me information that helps me get my work done quickly and efficiently instead of me telling the application to go get information for me. I think the hardware has been there for software developers to use for the past few years. It's time for the software to start using the hardware creatively.</p>
<a name="b708"/><h2>Thread Scheduling and Priorities</h2>
<p>A preemptive operating system must use some kind of algorithm to determine which threads should be scheduled when and for how long. In this section, we'll look at the algorithm Windows uses. Earlier in this chapter, I mentioned how every thread's kernel object contains a context structure. The context structure reflects the state of the thread's CPU registers when the thread last executed. After a time-slice, Windows looks at all the thread kernel objects currently in existence. Of these objects, only the threads that are not waiting for something are considered schedulable Windows selects one of the schedulable thread kernel objects and context switches to it. Windows actually keeps a record of how many times each thread gets context switched to. You can see this when using a tool such as Microsoft Spy++. Figure 25-5 shows the properties for a thread. Notice that this thread has been scheduled 31,768 times <sup>7</sup></p>
<p>As a side note, you can also see that the thread has been in the system for more than 25 hours, but it actually used less than 1 second of CPU time, which wastes a lot of resources.</p>
<img src="87.jpg"/>
<p><b>Figure 25-5 </b>Spy++ showing a thread's properties</p>
<p>At this point, the thread is executing code and manipulating data in its process's address space. After another time-slice, Windows performs another context switch. Windows performs context switches from the moment the system is booted and continues until the system is shut down.</p>
<p>Windows is called a preemptive multithreaded operating system because a thread can be stopped at any time and another thread can be scheduled As you'll see, you have some control over this, but not much. Just remember that you cannot guarantee that your thread will always be running and that no other thread will be allowed to run.</p>
<hr/>
<blockquote><b>Note </b>Developers frequently ask me how they can guarantee that their thread will start running within some time period after some event庸or example, how can you ensure that a particular thread will start running within 1 ms of data coming from the serial port? I have an easy answer: You can't.</blockquote>
<hr/>
<p>Real-time operating systems can make these promises, but Windows is not a real-time operating system A real-time operating system requires intimate knowledge of the hardware it is running on so that it knows the latency associated with its hard disk controllers, keyboards, and other components. Microsoft's goal with Windows is to make it work on a wide variety of hardware: different CPUs, different drives, different networks, and so on. In short, Windows is not designed to be a real-time operating system. Let me also add that the CLR makes managed code behave even less in real time. There are many reasons for this, including just-in-time (JIT) loading of DLLs, JIT compiling of code, and the garbage collector kicking in at unpredictable times.</p>
<p>Every thread is assigned a priority level ranging from 0 (the lowest) to 31 (the highest). When the system decides which thread to assign to a CPU, it examines the priority 31 threads first and schedules them in a round-robin fashion. If a priority 31 thread is schedulable, it is assigned to a CPU At the end of this thread's time-slice, the system checks to see whether there is another priority 31 thread that can run; if so, it allows that thread to be assigned to a CPU.</p>
<p>So long as priority 31 threads are schedulable, the system never assigns any thread with a priority of 0 through 30 to a CPU. This condition is called starvation, and it occurs when higher-priority threads use so much CPU time that they prevent lower-priority threads from executing. Starvation is much less likely to occur on a multiprocessor machine because a priority 31 thread and a priority 30 thread can run simultaneously on such a machine. The system always tries to keep the CPUs busy, and CPUs sit idle only if no threads are schedulable.</p>
<p>Higher-priority threads always preempt lower-priority threads, regardless of what the lower-priority threads are executing. For example, if a priority 5 thread is running and the system determines that a higher-priority thread is ready to run, the system immediately suspends the lower-priority thread (even if it's in the middle of its time-slice) and assigns the CPU to the higher-priority thread, which gets a full time-slice.</p>
<p>By the way, when the system boots, it creates a special thread called the zero page thread. This thread is assigned priority 0 and is the only thread in the entire system that runs at priority 0 The zero page thread is responsible for zeroing any free pages of RAM in the system when no other threads need to perform work.</p>
<p>Microsoft realized that assigning priority levels to threads was going to be too hard for developers to rationalize. Should this thread be priority level 10? Should this other thread be priority level 23? To resolve this issue, Windows exposes an abstract layer over the priority level system.</p>
<p>When designing your application, you should decide whether your application needs to be more or less responsive than other applications that may be running on the machine. Then you choose a process priority class to reflect your decision. Windows supports six process priority classes: Idle, Below Normal, Normal, Above Normal, High, and Realtime. Of course, Normal is the default and is therefore the most common priority class by far.</p>
<p>The Idle priority class is perfect for applications (like screen savers) that run when the system is all but doing nothing. A computer that is not being used interactively might still be busy (acting as a file server, for example) and should not have to compete for CPU time with a screen saver. Statistics-tracking applications that periodically update some state about the system usually should not interfere with more critical tasks.</p>
<p>You should use the High priority class only when absolutely necessary. You should avoid using the Realtime priority class if possible. Realtime priority is extremely high and can interfere with operating system tasks, such as preventing required disk I/O and network traffic from occurring In addition, a Realtime process's threads could prevent keyboard and mouse input from being processed in a timely manner, causing the user to think that the system is completely frozen. Basically, you should have a good reason for using Realtime priority, such as the need to respond to hardware events with short latency or to perform some short-lived task.</p>
<hr/>
<blockquote><b>Note </b>To keep the overall system running smoothly, a process cannot run in the Realtime priority class unless the user has the Increase Scheduling Priority privilege Any user designated as an administrator or a power user has this privilege by default.</blockquote>
<hr/>
<p>Once you select a priority class, you should stop thinking about how your application relates to other applications and just concentrate on the threads within your application Windows supports seven relative thread priorities: Idle, Lowest, Below Normal, Normal, Above Normal, Highest, and Time-Critical. These priorities are relative to the process's priority class. Again, Normal relative thread priority is the default, and it is therefore the most common.</p>
<p>So, to summarize, your process is a member of a priority class and within that process you assign thread priorities that are relative to each other You'll notice that I haven't said anything about priority levels 0 through 31. Application developers never work with priority levels directly. Instead, the system maps the process's priority class and a thread's relative priority to a priority level. Table 25-1 shows how the process's priority class and the thread's relative priority maps to priority levels.</p>
<p><b>Table 25-1 </b><b>How Process Priority Class and Relative Thread Priorities Map to Priority Levels</b></p>
<table border="1">
<tr>
<td>
<p>y</p>
</td>
<td colspan="6">
<p>s</p>
</td>
</tr>
<tr>
<td>
<p></p>
</td>
<td>
<p>e</p>
</td>
<td>
<p>l</p>
</td>
<td>
<p>l</p>
</td>
<td>
<p>l</p>
</td>
<td>
<p>h</p>
</td>
<td>
<p>e</p>
</td>
</tr>
<tr>
<td>
<p><b>Time-Critical</b></p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>31</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>8</p>
</td>
<td>
<p>10</p>
</td>
<td>
<p>12</p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>26</p>
</td>
</tr>
<tr>
<td>
<p>l</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>7</p>
</td>
<td>
<p>9</p>
</td>
<td>
<p>11</p>
</td>
<td>
<p>14</p>
</td>
<td>
<p>25</p>
</td>
</tr>
<tr>
<td>
<p>l</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>8</p>
</td>
<td>
<p>10</p>
</td>
<td>
<p>13</p>
</td>
<td>
<p>24</p>
</td>
</tr>
<tr>
<td>
<p>l</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>7</p>
</td>
<td>
<p>9</p>
</td>
<td>
<p>12</p>
</td>
<td>
<p>23</p>
</td>
</tr>
<tr>
<td>
<p>t</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>8</p>
</td>
<td>
<p>11</p>
</td>
<td>
<p>22</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>16</p>
</td>
</tr>
</table>
<p>For example, a Normal thread in a Normal process is assigned a priority level of 8. Because most processes are of the Normal priority class and most threads are of Normal thread priority, most threads in the system have a priority level of 8.</p>
<p>If you have a Normal thread in a high-priority process, the thread will have a priority level of 13. If you change the process's priority class to Idle, the thread's priority level becomes 4. Remember that thread priorities are relative to the process's priority class. If you change a process's priority class, the thread's relative priority will not change, but its priority number will.</p>
<p>Notice that the table does not show any way for a thread to have a priority level of 0. This is because the 0 priority is reserved for the zero page thread and the system does not allow any other thread to have a priority of 0. Also, the following priority levels are not obtainable: 17, 18, 19, 20, 21, 27, 28, 29, or 30. If you are writing a device driver that runs in kernel mode, you can obtain these levels; a user-mode application cannot. Also note that a thread in the Realtime priority class can't be below priority level 16. Likewise, a thread in a priority class other than Realtime cannot be above 15.</p>
<p>f-</p>
<hr/>
<blockquote><b>Note </b>The concept of a process priority class confuses some people. They think that this somehow means that Windows schedules processes However, Windows never schedules processes; Windows only schedules threads. The process priority class is an abstract concept that Microsoft created to help you rationalize how your application compares with other running applications; it serves no other purpose.</blockquote>
<hr/>
<hr/>
<blockquote><b>Important </b>It is best to lower a thread's priority instead of raising another thread's priority You would normally lower a thread's priority if that thread was going to execute a long-running compute-bound task like compiling code, spell checking, spreadsheet recalculations, etc. You would raise a thread's priority if the thread needs to respond to something very quickly and then run for a very short period of time and go back to its wait state High-priority threads should be waiting for something most of their life so that they do not affect the responsiveness of the whole system. The Windows Explorer thread that responds to the user pressing the Windows key on the keyboard is an example of a high-priority thread. When the user presses this key, Windows Explorer preempts other lower-priority threads immediately and displays its menu. As the user navigates the menu, Windows Explorer's thread responds to each keystroke quickly, updates the menu, and then stops running until the user continues navigating the menu.</blockquote>
<hr/>
<p>Normally, a process is assigned a priority class based on the process that starts it running. And most processes are started by Windows Explorer, which spawns all its child processes in the Normal priority class. Managed applications are not supposed to act as though they own their own processes; they are supposed to act as though they run in an AppDomain, so managed applications are not supposed to change their process's priority class because this would affect all code running in the process. For example, many ASP.NET applications run in a single process, with each application in its own AppDomain The same is true for Silverlight applications, which run in an Internet browser process, and managed stored procedures, which run inside the Microsoft SQL Server process.</p>
<p>On the other hand, your application can change the relative thread priority of its threads by setting <b>Thread</b>'s <b>Priority </b>property, passing it one of the five values <b>(Lowest, BelowNormal, Normal, AboveNormal, </b>or <b>Highest) </b>defined in the <b>ThreadPriority </b>enumerated type. However, just as Windows has reserved the priority level 0 and the real-time range for itself, the CLR reserves the Idle and Time-Critical priority levels for itself. Today, the CLR has no threads that run at Idle priority level, but this could change in the future. However, the</p>
<p>CLR's finalizer thread, discussed in Chapter 21, &quot;Automatic Memory Management (Garbage Collection),&quot; runs at the Time-Critical priority level. Therefore, as a managed developer, you really only get to use the five highlighted relative thread priorities listed in Table 25-1.</p>
<hr/>
<blockquote><b>Important </b>Today, most applications do not take advantage of thread priorities. However, in the world that I envision, where the CPUs are busy 100 percent of the time doing some kind of useful work, using thread priorities becomes critically important so that system responsiveness is unaffected Unfortunately, end users have been trained to interpret a high-CPU usage number to mean that an application is out of control. In my new world, end users will need to be retrained to understand that high-CPU usage is a good thing葉hat it actually means that the computer is aggressively processing helpful pieces of information for users The real problem would be if all the CPUs are busy running threads that are priority level 8 and above, as this would mean that applications are having trouble responding to end user input Perhaps a future version of Task Manager will take thread priority levels into account when reporting CPU usage; this would be much more helpful in diagnosing a troubled system.</blockquote>
<hr/>
<p>I should point out that the <b>System.Diagnostics </b>namespace contains a <b>Process </b>class and a <b>ProcessThread </b>class. These classes provide the Windows view of a process and thread, respectively. These classes are provided for developers wanting to write utility applications in managed code or for developers who are trying to instrument their code to help them debug it. In fact, this is why the classes are in the <b>System.Diagnostics </b>namespace. Applications need to be running with special security permissions to use these two classes. You would not be able to use these classes from a Silverlight application or an ASP.NET application, for example.</p>
<p>On the other hand, applications can use the <b>AppDomain </b>and <b>Thread </b>classes, which expose the CLR's view of an AppDomain and thread. For the most part, special security permissions are not required to use these classes, although some operations are still considered privileged.</p>
<a name="b713"/><h2>Foreground Threads versus Background Threads</h2>
<p>The CLR considers every thread to be either a foreground thread or a background thread When all the foreground threads in a process stop running, the CLR forcibly ends any background threads that are still running These background threads are ended immediately; no exception is thrown.</p>
<p>Therefore, you should use foreground threads to execute tasks that you really want to complete, like flushing data from a memory buffer out to disk. And you should use background threads for tasks that are not mission-critical, like recalculating spreadsheet cells or indexing records, because this work can continue again when the application restarts, and there is no need to force the application to stay active if the user wants to terminate it.</p>
<p>The CLR needed to provide this concept of foreground and background threads to better support AppDomains You see, each AppDomain could be running a separate application and each of these applications would have its own foreground thread If one application exits, causing its foreground thread to terminate, then the CLR still needs to stay up and running so that other applications continue to run After all the applications exit and all their foreground threads terminate, the whole process can be destroyed.</p>
<p>The following code demonstrates the difference between foreground and background threads:</p>
<p><code>using System;<br/>
using System.Threading;<br/>
public static class Program { public static void Main() {<br/>
// Create a new thread (defaults to foreground) Thread t = new Thread(Worker);<br/>
// Make the thread a background thread t.IsBackground = true;<br/>
t.Start(); // Start the thread<br/>
// If t is a foreground thread, the application won't die for about 10 seconds // If t is a background thread, the application dies immediately Console.Writel_ine(&quot;Returning from Main&quot;);<br/>
}<br/>
private static void Worker() {<br/>
Thread.Sleep(10000);   // Simulate doing 10 seconds of work<br/>
// The line below only gets displayed if this code is executed by a foreground thread Console.Writel_ine(&quot;Returning from Worker&quot;);<br/>
}<br/>
}</code></p>
<p>It is possible to change a thread from foreground to background and vice versa at any time during its lifetime. An application's primary thread and any threads explicitly created by constructing a <b>Thread </b>object default to being foreground threads. On the other hand, thread pool threads default to being background threads. Also, any threads created by native code that enter the managed execution environment are marked as background threads.</p>
<hr/>
<blockquote><b>Important </b>Try to avoid using foreground threads as much as possible I was brought into a consulting job once where an application just wouldn't terminate After I spent several hours researching the problem, it turned out that a UI component was explicitly creating a foreground thread (the default), and that was why the process wouldn't terminate We changed the component to use the thread pool to fix the problem, and efficiency improved as well.</blockquote>
<hr/>
<a name="b715"/><h2>What Now?</h2>
<p>In this chapter, I've explained the basics about threads, and I hope I've made it clear to you that threads are very expensive resources that should be used sparingly The best way to accomplish this is by using the CLR's thread pool. The thread pool will manage thread creation and destruction for you automatically The thread pool creates a set of threads that get reused for various tasks so your application requires just a few threads to accomplish all of its work.</p>
<p>In Chapter 26, I will focus on how to use the CLR's thread pool to perform compute-bound operations. Then, in Chapter 27, I will discuss how to use the thread pool in combination with the CLR's Asynchronous Programming Model to perform I/O-bound operations. In many scenarios, you can perform asynchronous compute-bound and I/O-bound operations in such a way that thread synchronization is not required at all. However, there are some scenarios where thread synchronization is required, and the way that the thread synchronization constructs work and the difference between these various constructs are discussed in Chapter 28, &quot;Primitive Thread Synchronization Constructs,&quot; and Chapter 29, &quot;Hybrid Thread Synchronization Constructs &quot;</p>
<p>Before ending this discussion, I'd like to point out that I have been working extensively with threads since the first beta version of Windows NT 3. 1 was available around 1992. And when .NET was in beta, I started producing a library of classes that can simplify asynchronous programming and thread synchronization. This library is called the Wintellect Power Threading Library, and it is freely downloadable and usable. Versions of the library exist for the desktop CLR, the Silverlight CLR, and the Compact Framework. The library, documentation, and sample code can be downloaded from <a href="http://Wintellect.com/PowerThreading.aspx">http://Wintellect.com/PowerThreading.aspx</a>. This Web site also contains links to a support forum, as well as to videos that show how to use various parts of the library.</p>
<mbp:pagebreak/>
<a name="Chapter26"/>
<h1>Chapter 26: Compute-Bound Asynchronous Operations</h1>
<p><b>In this chapter:</b></p>
<a href="#b718">Introducing the CLR's Thread Pool</a><br/>
<a href="#b719">Performing a Simple Compute-Bound Operation</a><br/>
<a href="#b721">Execution Contexts</a><br/>
<a href="#b722">Cooperative Cancellation</a><br/>
<a href="#b726">Tasks</a><br/>
<a href="#b739">Parallel's Static For, ForEach, and Invoke Methods</a><br/>
<a href="#b743">Parallel Language Integrated Query</a><br/>
<a href="#b747">Performing a Periodic Compute-Bound Operation</a><br/>
<a href="#b750">How the Thread Pool Manages Its Threads</a><br/>
<a href="#b752">Cache Lines and False Sharing</a><br/>
<p>In this chapter, I'll talk about the various ways that you can perform operations asynchronously. When performing an asynchronous compute-bound operation, you execute it using other threads. Here are some examples of compute-bound operations: compiling code, spell checking, grammar checking, spreadsheet recalculations, transcoding audio or video data, and producing a thumbnail of an image. Certainly, compute-bound operations are common in financial and engineering applications.</p>
<p>I would say that most applications do not spend the bulk of their time processing in-memory data or performing calculations. You can verify that this is true by opening Task Manager and selecting the Performance tab. If your CPU usage is below 100% (which it tends to be most of the time), then the processes you have running are not using all the processing power made available by your machine's CPU cores. When the CPU usage is less than 100%, then some (if not all) of the threads within their processes are not running at all. Instead, these threads are waiting for some input or output operation to occur For example, these threads are waiting for a timer to come due, waiting for data to be read from or written to a database, Web service, file, network, or other hardware device, or waiting for keystrokes, mouse movement, or mouse button clicks. When performing an I/O-bound operation, the Microsoft Windows device driver has the hardware device do the work for you and the CPU itself doesn't execute any threads that happen to exist in the system Since threads are not running on a CPU, Task Manager indicates that CPU usage is low.</p>
<p>However, even in applications that are heavily I/O-bound, these applications perform some computation on data that has been received, and parallelizing this computation can greatly improve the application's throughput This chapter introduces the common language runtime's (CLR's) thread pool and some basic concepts about how it works and how to use it. This information is critically useful, as the thread pool is the core technology that enables you to design and implement scalable, responsive, and reliable applications and components. Then this chapter shows the various mechanisms available that allow you to perform compute-bound operations via the thread pool. There are two reasons why you would want to execute compute-bound operations asynchronously: to keep the UI responsive in a GUI application or to scale a time-consuming calculation across multiple CPUs.</p>
<a name="b718"/><h2>Introducing the CLR's Thread Pool</h2>
<p>As stated in the previous chapter, creating and destroying a thread is an expensive operation in terms of time. In addition, having lots of threads wastes memory resources and also hurts performance due to the operating system having to schedule and context switch between the runnable threads To improve this situation, the CLR contains code to manage its own thread pool You can think of a thread pool as being a set of threads that are available for your application's own use. There is one thread pool per CLR; this thread pool is shared by all AppDomains controlled by that CLR. If multiple CLRs load within a single process, then each CLR has its own thread pool.</p>
<p>When the CLR initializes, the thread pool has no threads in it Internally, the thread pool maintains a queue of operation requests When your application wants to perform an asynchronous operation, you call some method that appends an entry into the thread pool's queue. The thread pool's code will extract entries from this queue and dispatch the entry to a thread pool thread. If there are no threads in the thread pool, a new thread will be created. Creating a thread has a performance hit associated with it (as already discussed). However, when a thread pool thread has completed its task, the thread is not destroyed; instead, the thread is returned to the thread pool, where it sits idle waiting to respond to another request Since the thread doesn't destroy itself, there is no added performance hit.</p>
<p>If your application makes many requests of the thread pool, the thread pool will try to service all of the requests using just this one thread. However, if your application is queuing up several requests faster than the thread pool thread can handle them, additional threads will be created. Your application will eventually get to a point at which all of its requests can be handled by a small number of threads, so the thread pool should have no need to create a lot of threads.</p>
<p>If your application stops making requests of the thread pool, the pool may have a lot of threads in it that are doing nothing. This is wasteful of memory resources. So when a thread pool thread has been idle with nothing to do for some period of time (subject to change with different versions of the CLR), the thread wakes itself up and kills itself to free up resources</p>
<p>As the thread is killing itself, there is a performance hit. However, this probably doesn't matter since the thread is killing itself because it has been idle, which means that your application isn't performing a lot of work.</p>
<p>The great thing about the thread pool is that it manages the tension between having a few threads, to keep from wasting resources, and having more threads, to take advantage of multiprocessors, hyperthreaded processors, and multi-core processors And the thread pool is heuristic. If your application needs to perform many tasks and CPUs are available, the thread pool creates more threads If your application's workload decreases, the thread pool threads kill themselves.</p>
<p>Internally, the thread pool categorizes its threads as either worker threads or I/O threads Worker threads are used when your application asks the thread pool to perform an asynchronous compute-bound operation (which can include initiating an I/O-bound operation) I/O threads are used to notify your code when an asynchronous I/O-bound operation has completed. Specifically, this means that you are using the Asynchronous Programming Model (APM) to make I/O requests such as accessing a file, networked server, database, Web service, or other hardware device.</p>
<a name="b719"/><h2>Performing a Simple Compute-Bound Operation</h2>
<p>To queue an asynchronous compute-bound operation to the thread pool, you typically call one of the following methods defined by the <b>ThreadPool </b>class:</p>
<p><code>static Boolean QueueUserWorkItem(WaitCallback callBack);<br/>
static Boolean QueueUserWorkItem(WaitCallback callBack, Object state);</code></p>
<p>These methods queue a &quot;work item&quot; and optional state data to the thread pool's queue, and then all of these methods return immediately. A work item is simply a method identified by the <b>callback </b>parameter that will be called by a thread pool thread. The method can be passed a single parameter specified via the <b>state </b>(the state data) argument. The version of <b>QueueUserWorkItem </b>without the <b>state </b>parameter passes <b>null </b>to the callback method. Eventually, some thread in the pool will process the work item, causing your method to be called. The callback method you write must match the <b>System.Threading.WaitCallback </b>delegate type, which is defined as follows:</p>
<p><code>delegate void WaitCallback(Object state);</code></p>
<p><sub>r+++4l</sub> (-</p>
<hr/>
<blockquote><b>Note </b>The signatures of the <b>WaitCallback </b>delegate, the <b>TimerCallback </b>delegate (discussed <b>i        </b>in this chapter's &quot;Performing a Periodic Compute-Bound Operation&quot; section), and the</blockquote>
<hr/>
<p><b>ParameterizedThreadStart </b>delegate (discussed in Chapter 25, &quot;Thread Basics&quot;) are all identical. If you define a method matching this signature, the method can be invoked by using <b>ThreadPool.QueueUserWorkItem, </b>by using a <b>System.Threading.Timer </b>object, or by using a <b>System.Threading.Thread </b>object.</p>
<p>The following code demonstrates how to have a thread pool thread call a method asynchronously:</p>
<p><code>using System;<br/>
using System.Threading;<br/>
public static class Program { public static void Main() {<br/>
Console.WriteLineC'Main thread: queuing an asynchronous operation&quot;); ThreadPool.QueueUserWorkItemCComputeBoundOp, 5); Console.WriteLineC'Main thread: Doing other work here...&quot;); Thread.Sleep(10000);   // Simulating other work (10 seconds) Console.WriteLineC'Hit &lt;Enter&gt; to end this program...&quot;); Console.ReadLineO;<br/>
}<br/>
// This method's signature must match the WaitCallback delegate private static void ComputeBoundOp(Object state) { // This method is executed by a thread pool thread<br/>
Console.WriteLineC'In ComputeBoundOp: state={0}&quot;, state); Thread.Sleep(1000);   // Simulates other work (1 second)<br/>
// When this method returns, the thread goes back // to the pool and waits for another task<br/>
}<br/>
}</code></p>
<p>When I compile and run this code, I get the following output:</p>
<p><code>Main thread: queuing an asynchronous operation Main thread: Doing other work here... In ComputeBoundOp: state=5</code></p>
<p>And, sometimes when I run this code, I get this output:</p>
<p><code>Main thread: queuing an asynchronous operation<br/>
In ComputeBoundOp: state=5<br/>
Main thread: Doing other work here...</code></p>
<p>The difference in the order of the lines in the output is attributed to the fact that the two methods are running asynchronously with respect to one another. The Windows scheduler determines which thread to schedule first, or it may schedule them both simultaneously if the application is running on a multi-CPU machine.</p>
<hr/>
<blockquote><b>Note </b>If the callback method throws an exception that is unhandled, the CLR terminates the process (unless the host imposes its own policy). Unhandled exceptions are discussed in Chapter 20, &quot;Exceptions and State Management &quot;</blockquote>
<hr/>
<a name="b721"/><h2>Execution Contexts</h2>
<p>Every thread has an execution context data structure associated with it The execution context includes things such as security settings (compressed stack, <b>Thread</b>'s <b>Principal </b>property, and Windows identity), host settings (see <b>System.Threading. HostExecutionContextManager), </b>and logical call context data (see <b>System.Runtime. Remoting.Messaging.CallContext</b>'s <b>LogicalSetData </b>and <b>LogicalGetData </b>methods). When a thread executes code, some operations are affected by the values of the thread's execution context settings. This is certainly true for the security settings. Ideally, whenever a thread uses another (helper) thread to perform tasks, the issuing thread's execution context should flow (be copied) to the helper thread. This ensures that any operations performed by helper thread(s) are executing with the same security settings and host settings. It also ensures that any data stored in the initiating thread's logical call context is available to the helper thread.</p>
<p>By default, the CLR automatically causes the initiating thread's execution context to flow to any helper threads This transfers context information to the helper thread, but it comes at a performance cost because there is a lot of information in an execution context, and accumulating all of this information and then copying it for the helper thread takes a fair amount of time. If the helper thread then employs additional helper threads, then more execution context data structures have to be created and initialized as well.</p>
<p>In the <b>System.Threading </b>namespace, there is an <b>ExecutionContext </b>class that allows you to control how a thread's execution context flows from one thread to another. Here is what the class looks like:</p>
<p><code>public sealed class ExecutionContext : IDisposable, ISerializable { [SecurityCritical] public static AsyncFlowControl SuppressFlow(); public static void RestoreFlow(); public static Boolean IsFlowSuppressed();<br/>
// Less commonly used methods are not shown<br/>
}</code></p>
<p>You can use this class to suppress the flowing of an execution context, thereby improving your application's performance The performance gains can be quite substantial for a server application. There is not much performance benefit for a client application, and the <b>SuppressFlow </b>method is marked with the <b>[SecurityCritical] </b>attribute, making it impossible to call in some client applications (like Silverlight) Of course, you should suppress the flowing of execution context only if the helper thread does not need or access the context information. If the initiating thread's execution context does not flow to a helper thread, the helper thread will use whatever execution context it last associated with it Therefore, the helper thread really shouldn't execute any code that relies on the execution context state (such as a user's Windows identity).</p>
<p>Here is an example showing how suppressing the flow of execution context affects data in a thread's logical call context when queueing a work item to the CLR's thread pool<sup>1</sup>:</p>
<p><code>public static void Main() {<br/>
// Put some data into the Main thread's logical call context CallContext.LogicalSetDataC'Name&quot;, &quot;Jeffrey&quot;);<br/>
// Initiate some work to be done by a thread pool thread<br/>
// The thread pool thread can access the logical call context data<br/>
ThreadPoo1.QueueUserWorkItem(<br/>
state =&gt; Console.WriteLine(&quot;Name={0}&quot;, CallContext.LogicalGetDataC'Name&quot;)));<br/>
// Now, suppress the flowing of the Main thread's execution context ExecutionContext.SuppressFlow();<br/>
// Initiate some work to be done by a thread pool thread<br/>
// The thread pool thread can NOT access the logical call context data<br/>
ThreadPoo1.QueueUserWorkItem(<br/>
state =&gt; Console.WriteLine(&quot;Name={0}&quot;, CallContext.LogicalGetDataC'Name&quot;)));<br/>
// Restore the flowing of the Main thread's execution context in case // it employs more thread pool threads in the future ExecutionContext.RestoreFlow();<br/>
}</code></p>
<p>When I compile and run the code above, I get the following output:</p>
<p><code>Name=Jeffrey Name=</code></p>
<p>While this discussion has focused on suppressing the flow of execution context when calling <b>ThreadPool.QueueUserWorkItem, </b>this technique is also useful when using <b>Task </b>objects (discussed in the &quot;Tasks&quot; section of this chapter) and is also useful when initiating asynchronous I/O operations (discussed in Chapter 27, &quot;I/O-Bound Asynchronous Operations&quot;).</p>
<a name="b722"/><h2>Cooperative Cancellation</h2>
<p>The Microsoft .NET Framework offers a standard pattern for canceling operations. This pattern is cooperative, meaning that the operation that you wish to cancel has to explicitly support being canceled In other words, the code performing the operation that you wish to cancel and the code that attempts to cancel the operation must both use the types mentioned in this section It is nice when long-running compute-bound operations offer cancellation, so you should consider adding cancellation to your own compute-bound operations</p>
<p>The items that you add to the logical call context must be serializable, as discussed in Chapter 24, &quot;Runtime Serialization. &quot; Flowing an execution context that contains logical call context data items can hurt performance dramatically because capturing the execution context requires serializing and deserializing all the data items.</p>
<p>In this section, I'll explain how to accomplish this. But, first, let me explain the two main types provided in the Framework Class Library (FCL) that are part of the standard cooperative cancellation pattern.</p>
<p>To cancel an operation, you must first create a <b>System.Threading. CancellationTokenSource </b>object. This class looks like this:</p>
<p><code>public sealed class CancellationTokenSource : IDisposable {   // A reference type public CancellationTokenSource();<br/>
public void Dispose();   // Frees resources (like the WaitHandle)<br/>
public Boolean IsCancellationRequested { get; } public CancellationToken Token { get; }<br/>
public void Cance1();   // Internally, calls Cancel passing false public void Cance1(Boolean throwOnFirstException);<br/>
}</code></p>
<p>This object contains all the state having to do with managing cancellation After constructing a <b>CancellationTokenSource </b>(a reference type), one or more <b>CancellationToken </b>(a value type) instances can be obtained from its <b>Token </b>property and passed around to your operations that allow themselves to be canceled. Here are the most useful members of the <b>CancellationToken </b>value type:</p>
<p><code>public struct CancellationToken {   // A value type<br/>
// IsCancellationRequested is called by non-Task invoked operations public Boolean      IsCancellationRequested { get; }<br/>
public void.ThrowIfCancellationRequested();   // Called by Task-invoked operations<br/>
// WaitHandle is signaled when the CancellationTokenSource is canceled public WaitHandle WaitHandle { get; }<br/>
// GetHashCode, Equals, operator== and operator!= members are not shown<br/>
public static CancellationToken None { get; }<br/>
public Boolean CanBeCanceled { get; }   // Rarely used<br/>
public CancellationTokenRegistration Register(Action&lt;Object&gt; callback, Object state, Boolean useSynchronizationContext);   // Simpler overloads not shown<br/>
}</code></p>
<p>A <b>CancellationToken </b>instance is a lightweight value type as it contains a single private field: a reference to its <b>CancellationTokenSource </b>object. A compute-bound operation's loop can periodically call <b>CancellationToken</b>'s <b>IsCancellationRequested </b>property to know if the loop should terminate early, thereby ending the compute-bound operation. Of course, the benefit here is that CPU time is no longer being wasted on an operation whose result you know you're not interested in. Now, let me put all this together with some sample code:</p>
<p><code>internal static class CancellationDemo { public static void Go() {<br/>
CancellationTokenSourcects = new CancellationTokenSource();<br/>
// Pass the CancellationToken and the number-to-count-to into the operation ThreadPoo1.QueueUserWorkItem(o =&gt; Count(cts.Token, 1000));<br/>
Console.Writel_ine(&quot;Press &lt;Enter&gt; to cancel the operation.&quot;); Console.ReadLineO;<br/>
cts.CancelO; // If Count returned already, Cancel has no effect on it // Cancel returns immediately, and the method continues running here...<br/>
}<br/>
private static void Count(CancellationToken token, Int32 countTo) { for (Int32 count = 0; count &lt;countTo; count++) { if (token.IsCancellationRequested) {<br/>
Console.WriteLineC'Count is cancelled&quot;); break; // Exit the loop to stop the operation<br/>
}<br/>
Console.WriteLine(count);<br/>
Thread.Sleep(200);     // For demo, waste some time<br/>
}<br/>
Console.WriteLineC'Count is done&quot;);<br/>
}<br/>
}</code></p>
<hr/>
<blockquote><b>Note </b>If you want to execute an operation and prevent it from being canceled, you can pass the operation the <b>CancellationToken </b>returned from calling <b>CancellationToken</b>'s static <b>None </b>property This property returns a special <b>CancellationToken </b>instance that is not associated with any <b>CancellationTokenSource </b>object (its private field is <b>null) </b>. Since there is no <b>CancellationTokenSource, </b>no code can call <b>Cancel, </b>and the operation that is querying the special <b>CancellationToken</b>'s <b>IsCancellationRequested </b>property will always get back <b>false </b>. If you query <b>CancellationToken</b>'s <b>CanBeCanceled </b>property using one of these special <b>CancellationToken </b>instances, the property will return <b>false </b>. The property returns <b>true </b>for all other <b>CancellationToken </b>instances obtained by querying a <b>CancellationTokenSource </b>object's <b>Token </b>property.</blockquote>
<hr/>
<p>If you'd like, you can register one or more methods to be invoked when a <b>CancellationTokenSource </b>is canceled. However, you register each callback method using <b>CancellationToken</b>'s <b>Register </b>method. To this method, you pass an <b>Action&lt;Object&gt; </b>delegate, a state value that will be passed to the callback via the delegate, and a <b>Boolean </b>indicating whether or not to invoke the delegate using the calling thread's <b>SynchronizationContext. </b>If you pass <b>false </b>for the <b>useSynchronizationContext </b>parameter, then the thread that calls <b>Cancel </b>will invoke all the registered methods sequentially. If you pass <b>true </b>for the <b>useSynchronizationContext </b>parameter, then the callbacks are sent (as opposed to posted) to the captured <b>SynchronizationContext </b>object which governs which thread invokes the callback. The <b>SynchronizationContext </b>class is discussed more in the &quot;Applications and Their Threading Models&quot; section in Chapter 27</p>
<hr/>
<blockquote><b>Note </b>If you register a callback method with a <b>CancellationTokenSource </b>after the <b>CancellationTokenSource </b>has already been canceled, then the thread calling <b>Register </b>invokes the callback (possible via the calling thread's <b>SynchronizationContext </b>if <b>true </b>is passed for the <b>useSynchronizationContext </b>parameter).</blockquote>
<hr/>
<p>If <b>Register </b>is called multiple times, then multiple callback methods will be invoked. These callback methods could throw an unhandled exception. If you call</p>
<p><b>CancellationTokenSource</b>'s <b>Cancel, </b>passing it <b>true, </b>then the first callback method that throws an unhandled exception stops the other callback methods from executing, and the exception thrown will be thrown from <b>Cancel </b>as well If you call <b>Cancel </b>passing it <b>false, </b>then all registered callback methods are invoked. Any unhandled exceptions that occur are added to a collection. After all callback methods have executed, if any of them threw an unhandled exception, then <b>Cancel </b>throws an <b>AggregateException </b>with its <b>InnerExceptions </b>property set to the collection of exception objects that were thrown If no registered callback methods threw an unhandled exception, then <b>Cancel </b>simply returns without throwing any exception at all.</p>
<hr/>
<blockquote><b>Important </b>There is no way to correlate an exception object from <b>AggregateException</b>'s <b>InnerExceptions </b>collection to a particular operation; you are basically just being told that some operation failed and the exception type tells you what the failure was To track down the specific location of the failure will require examining the exception object's <b>StackTrace </b>property and manually scanning your source code.</blockquote>
<hr/>
<p><b>CancellationToken</b>'s <b>Register </b>method returns a <b>CancellationTokenRegistration,</b></p>
<p>which looks like this:</p>
<p><code>public struct CancellationTokenRegistration :<br/>
IEquatable&lt;CancellationTokenRegistration&gt;, IDisposable { public void Dispose();<br/>
// GetHashCode, Equals, operator== and operator!= members are not shown<br/>
}</code></p>
<p>You can call <b>Dispose </b>to remove a registered callback from the <b>CancellationTokenSource </b>that it is associated with so that it does not get invoked when calling <b>Cancel </b>Here is some code that demonstrates registering two callbacks with a single <b>CancellationTokenSource:</b></p>
<p><code>varcts = new CancellationTokenSource();<br/>
cts.Token.Register(() =&gt; Console.WriteLineC'Canceled 1&quot;)); cts.Token.Register(() =&gt; Console.WriteLineC'Canceled 2&quot;));<br/>
// To test, let's just cancel it now and have the 2 callbacks execute cts.CancelO;</code></p>
<p>When I run this code, I get the following output as soon as the <b>Cancel </b>method is called:</p>
<p><code>Canceled 2 Canceled 1</code></p>
<p>Finally, you can create a new <b>CancellationTokenSource </b>object by linking a bunch of other <b>CancellationTokenSource </b>objects. This new <b>CancellationTokenSource </b>object will be canceled when any of the linked <b>CancellationTokenSource </b>objects are canceled The following code demonstrates:</p>
<p><code>// Create a CancellationTokenSource<br/>
var ctsl = new CancellationTokenSource();<br/>
ctsl.Token.Register(C) =&gt; Console.WriteLineC'ctsl canceled&quot;));<br/>
// Create another CancellationTokenSource var cts2 = new CancellationTokenSource();<br/>
cts2.Token.Register(() =&gt; Console.WriteLine(&quot;cts2 canceled&quot;));<br/>
// Create a new CancellationTokenSource that is canceled when ctsl or ct2 is canceled var linkedCts = CancellationTokenSource.CreateLinkedTokenSourceCctsl.Token, cts2.Token); linkedCts.Token.Register(C) =&gt; Console.WriteLineC'linkedCts canceled&quot;));<br/>
// Cancel one of the CancellationTokenSource objects (I chose cts2) cts2.Cance1();<br/>
// Display which CancellationTokenSource objects are canceled Console.WriteLineC'ctsl canceled={0}, cts2 canceled={l}, 1inkedCts={2}&quot;,<br/>
ctsl.IsCancellationRequested, cts2.IsCancellationRequested, linkedCts.IsCancellationRequested);</code></p>
<p>When I run the code above, I get the following output:</p>
<p><code>linkedCts canceled cts2 canceled<br/>
ctsl canceled=False, cts2 canceled=True, 1inkedCts=True</code></p>
<a name="b726"/><h2>Tasks</h2>
<p>Calling <b>ThreadPool</b>'s <b>QueueUserWorkItem </b>method to initiate an asynchronous compute-bound operation is very simple. However, this technique has many limitations. The biggest problem is that there is no built-in way for you to know when the operation has completed, and there is no way to get a return value back when the operation completes To address these limitations and more, Microsoft introduced the concept of tasks, and you use them via types in the <b>System.Threading.Tasks </b>namespace.</p>
<p>So, instead of calling <b>ThreadPool </b>'s <b>QueueUserWorkItem </b>method, you can do the same via tasks:</p>
<p><code>ThreadPoo1.QueueUserWorkItem(ComputeBoundOp, 5); // Calling QueueUserWorkItem<br/>
new Task(ComputeBoundOp, 5).Start();// Equivalent of above using Task</code></p>
<p>In the code above, I am creating the <b>Task </b>object and then immediately call <b>Start </b>to schedule the task to run. Naturally, you can create the <b>Task </b>object and then call <b>Start </b>on it later. You could imagine code that creates a <b>Task </b>object and then passes it to some other method that decides when to call <b>Start </b>to schedule the task.</p>
<p>When creating a <b>Task, </b>you always call a constructor, passing it an <b>Action </b>or an <b>Action&lt;Object&gt; </b>delegate that indicates the operation that you want performed. If you pass a method that expects an <b>Object, </b>then you must also pass to <b>Task</b>'s constructor the argument that you ultimately want passed to the operation. You can also optionally pass to <b>Task</b>'s constructor a <b>CancellationToken, </b>which allows the <b>Task </b>to be canceled before it has been scheduled (see the &quot;Cancelling a Task&quot; section later in this chapter).</p>
<p>You can also optionally pass to the constructor some <b>TaskCreationOptions </b>flags that control how the <b>Task </b>executes. <b>TaskCreationOptions </b>is an enumerated type defining a set of flags that you can bitwise-OR together. It is defined as follows:</p>
<p><code>[Flags, Serializable]<br/>
public enumTaskCreationOptions {<br/>
None.= 0x0000,// The default<br/>
// Causes the default TaskScheduler to put the task in the thread pool's // global queue instead of a worker thread's local queue. PreferFairness.= 0x000l,<br/>
// This flag is a hint to the TaskScheduler and it determines how to interpret this hint. // Today, the default TaskScheduler creates a thread for the task instead of queuing the // task to a thread pool thread. This behavior could change in the future. LongRunning.= 0x0002,<br/>
// Always honored: Associates a Task with its parent Task (discussed shortly) AttachedToParent    = 0x0004,<br/>
}</code></p>
<p>Most of these flags are hints that may or may not be honored by the <b>TaskScheduler </b>that is being used to schedule a <b>Task; </b>the <b>AttachedToParent </b>flag is always honored, as it has nothing to do with the <b>TaskScheduler </b>itself. <b>TaskScheduler </b>objects are discussed later in the &quot;Task Schedulers&quot; section.</p>
<h3>Waiting for a Task to Complete and Getting Its Result</h3>
<p>With tasks, it is also possible to wait for them to complete and then get their result. Let's say that we have a <b>Sum </b>method that is computationally intensive if <b>n </b>is a large value:</p>
<p><code>private static Int32 Sum(Int32 n) { Int32 sum = 0; for (; n &gt; 0; n--.<br/>
checked { sum += n; }     // in n is large, this will throw System.OverflowException return sum;<br/>
}</code></p>
<p>We can now construct a <b>Task&lt;TResult</b>&gt;object (which is derived from <b>Task), </b>and we pass for the generic <b>TResult </b>argument the compute-bound operation's return type. Now, after starting the task, we can wait for it to complete and then get its result using the following code:</p>
<p><code>// Create a Task (it does not start running now) Task&lt;Int32&gt; t = new Task&lt;Int32&gt;(n =&gt; Sum((Int32)n), l000000000);<br/>
// You can start the task sometime later t.Start();<br/>
// Optionally, you can explicitly wait for the task to complete t.Wait(); // FYI: Overloads exist accepting timeout/CancellationToken<br/>
// You can get the result (the Result property internally calls Wait) Console.WriteLine<b>C</b>'The Sum is: &quot; + t.Result); // An Int32 value</code></p>
<p><b>|-</b></p>
<hr/>
<blockquote><b>Important </b>When a thread calls the <b>Wait </b>method, the system checks if the <b>Task </b>that the thread is waiting for has started executing. If it has, then the thread calling <b>Wait </b>will block until the <b>Task </b>has completed running. But if the <b>Task </b>has not started executing yet, then the system may (depending on the <b>TaskScheduler) </b>execute the <b>Task </b>using the thread that called <b>Wait </b>. If this happens, then the thread calling <b>Wait </b>does not block; it executes the <b>Task </b>and returns immediately This is good in that no thread has blocked, thereby reducing resource usage (by not creating a thread to replace the blocked thread) while improving performance (no time is spent to create a thread and there is no context switching) But it can also be bad if, for example, the thread has taken a thread synchronization lock before calling <b>Wait </b>and then the <b>Task </b>tries to take the same lock, resulting in a deadlocked thread!</blockquote>
<hr/>
<p>If the compute-bound task throws an unhandled exception, the exception will be swallowed, stored in a collection, and the thread pool thread is allowed to return to the thread pool. When the <b>Wait </b>method or the <b>Result </b>property is invoked, these members will throw a <b>System.AggregateException </b>object.</p>
<p>The <b>AggregateException </b>type is used to encapsulate a collection of exception objects (which can happen if a parent task spawns multiple child tasks that throw exceptions). It contains an <b>InnerExceptions </b>property that returns a <b>ReadOnlyCollection&lt;Exception&gt; </b>object. Do not confuse the <b>InnerExceptions </b>property with the <b>InnerException </b>property, which the <b>AggregateException </b>class inherits from the <b>System.Exception </b>base class For the example above, element <b>0 </b>of <b>AggregateException</b>'s <b>InnerExceptions </b>property would refer to the actual <b>System.OverflowException </b>object thrown by the compute-bound method <b>(Sum).</b></p>
<p>As a convenience, <b>AggregateException </b>overrides <b>Exception</b>'s <b>GetBaseException </b>method. <b>AggregateException</b>'s implementation returns the innermost <b>AggregateException </b>that is the root cause of the problem (assuming that there is just one innermost exception in the collection). <b>AggregateException </b>also offers a <b>Flatten </b>method that creates a new <b>AggregateException, </b>whose <b>InnerExceptions </b>property contains a list of exceptions produced by walking the original <b>AggregateException</b>'s inner exception hierarchy. Finally, <b>AggregateException </b>also provides a <b>Handle </b>method that invokes a callback method for each exception contained in the <b>AggregateException </b>The callback can then decide, for each exception, how to handle the exception; the callback returns <b>true </b>to consider the exception handled and <b>false </b>if not. If, after calling <b>Handle, </b>at least one exception is not handled, then a new <b>AggregateException </b>object is created containing just the unhandled exceptions and the new <b>AggregateException </b>object is thrown. Later in this chapter, I show examples using the <b>Flatten </b>and <b>Handle </b>methods.</p>
<hr/>
<blockquote><b>Important </b>If you never call <b>Wait </b>or <b>Result </b>or query a <b>Task</b>'s <b>Exception </b>property, then your code never observes that this exception has occurred This is not ideal, as your program has experienced an unexpected problem that you are not aware of So, when a <b>Task </b>object is garbage collected, its <b>Finalize </b>method checks to see if the <b>Task </b>experienced an unobserved exception; if it has, <b>Task</b>'s <b>Finalize </b>method throws the <b>AggregateException </b>. Since you cannot catch an exception thrown by the CLR's finalizer thread, your process is terminated immediately. You must fix your code by invoking one of the aforementioned members, ensuring that your code observes the exception and recovers from it.</blockquote>
<hr/>
<p>To help you detect unobserved exceptions, you can register a callback method with <b>TaskScheduler</b>'s static <b>UnobservedTaskException </b>event. This event is raised by the CLR's finalizer thread whenever a <b>Task </b>with an unobserved exception is garbage collected. When raised, your event handler method will be passed an <b>UnobservedTaskExceptionEventArgs </b>object containing the unobserved <b>AggregateException </b>. You can call <b>UnobservedTaskExceptionEventArgs</b>'s <b>SetObserved </b>method to indicate that you've processed the exception, thus preventing the CLR from terminating the process. However, you should not do this as a standard policy. As discussed in Chapter 20, it is better for a process to terminate instead of running with corrupted state.</p>
<p>In addition to waiting for a single task, the <b>Task </b>class also offers two static methods that allow a thread to wait on an array of <b>Task </b>objects. <b>Task</b>'s static <b>WaitAny </b>method blocks the calling thread until any of the <b>Task </b>objects in the array have completed. This method returns an <b>Int32 </b>index into the array indicating which <b>Task </b>object completed, causing the thread to wake and continue running. The method returns <b>-1 </b>if the timeout occurs and throws an <b>OperationCanceledException </b>if <b>WaitAny </b>is canceled via a <b>CancellationToken </b>.</p>
<p>Similarly, the <b>Task </b>class has a static <b>WaitAll </b>method that blocks the calling thread until all the <b>Task </b>objects in the array have completed. The <b>WaitAll </b>method returns <b>true </b>if all the <b>Task </b>objects complete and <b>false </b>if a timeout occurs; an <b>OperationCanceledException </b>is thrown if <b>WaitAll </b>is canceled via a <b>CancellationToken </b>.</p>
<h3>Cancelling a Task</h3>
<p>Of course, you can use a <b>CancellationTokenSource </b>to cancel a <b>Task </b>First, we must revise our <b>Sum </b>method so that it accepts a <b>CancellationToken:</b></p>
<p><code>private static Int32 Sum(CancellationTokenct, Int32 n) { Int32 sum = 0; for (; n &gt; 0; n) {<br/>
// The following line throws OperationCanceledException when Cancel // is called on the CancellationTokenSource referred to by the token ct.ThrowIfCancellationRequested();<br/>
checked { sum += n; }     // in n is large, this will throw System.OverflowException<br/>
}<br/>
return sum;<br/>
}</code></p>
<p>In this code, the compute-bound operation's loop periodically checks to see if the operation has been canceled by calling <b>CancellationToken</b>'s <b>ThrowIfCancellationRequested </b>method. This method is similar to <b>CancellationToken</b>'s <b>IsCancellationRequested </b>property shown earlier in the &quot;Cooperative Cancellation&quot; section. However, <b>ThrowIfCancellationRequested </b>throws an <b>OperationCanceledException </b>if the <b>CancellationTokenSource </b>has been canceled. The reason for throwing an exception is because, unlike work items initiated with <b>ThreadPool</b>'s <b>QueueUserWorkItem </b>method, tasks have the notion of having completed and a task can even return a value. So, there needs to be a way to distinguish a completed task from a faulting task, and having the task throw an exception lets you know that the task did not run all the way to completion.</p>
<p>Now, we will create the <b>CancellationTokenSource </b>and <b>Task </b>objects as follows:</p>
<p><code>CancellationTokenSourcects = new CancellationTokenSource();<br/>
Task&lt;Int32&gt; t = new Task&lt;Int32&gt;(() =&gt; Sum(cts.Token, l0000), cts.Token);<br/>
t.Start();<br/>
// Sometime later, cancel the CancellationTokenSource to cancel the Task cts.Cancel(); // This is an asynchronous request, the Task may have completed already<br/>
try {<br/>
// If the task got canceled, Result will throw an AggregateException Console.WriteLine(&quot;The sum is: &quot; + t.Result);     // An Int32 value<br/>
}<br/>
catch (AggregateException x) {<br/>
// Consider any OperationCanceledException objects as handled. // Any other exceptions cause a new AggregateException containing // only the unhandled exceptions to be thrown x.Handle(e =&gt; e is OperationCanceledException);<br/>
// If all the exceptions were handled, the following executes Console.WriteLine(&quot;Sum was canceled&quot;);<br/>
}</code></p>
<p>When creating a <b>Task, </b>you can associate a <b>CancellationToken </b>with it by passing it to <b>Task</b>'s constructor (as shown above). If the <b>CancellationToken </b>gets canceled before the <b>Task </b>is scheduled, the <b>Task </b>gets canceled and never executes at all. <sup>2</sup> But if the <b>Task </b>has already been scheduled (by calling the <b>Start </b>method), then the <b>Task</b>'s code must explicitly support</p>
<p>By the way, if you try to cancel a task before it is even started, an <b>InvalidOperationException </b>is thrown.</p>
<p>cancellation if it allows its operation to be canceled while executing. Unfortunately, while a <b>Task </b>object has a <b>CancellationToken </b>associated with it, there is no way to access it, so you must somehow get the same <b>CancellationToken </b>that was used to create the <b>Task </b>object into the <b>Task</b>'s code itself The easiest way to write this code is to use a lambda expression and &quot;pass&quot; the <b>CancellationToken </b>as a closure variable (as I've done in the previous code example).</p>
<h3>Starting a New Task Automatically When Another Task Completes</h3>
<p>In order to write scalable software, you must not have your threads block This means that calling <b>Wait </b>or querying a task's <b>Result </b>property when the task has not yet finished running will most likely cause the thread pool to create a new thread, which increases resource usage and hurts scalability. Fortunately, there is a better way to find out when a task has completed running. When a task completes, it can start another task. Here is a rewrite of the earlier code that doesn't block any threads:</p>
<p><code>// Create Task, defer starting it, continue with another task Task&lt;Int32&gt; t = new Task&lt;Int32&gt;(n =&gt; Sum((Int32)n), l000000000);<br/>
// You can start the task sometime later t.Start();<br/>
// ContinueWith returns a Task but you usually don't care<br/>
Task cwt = t.ContinueWith(task =&gt; Console.WriteLine(&quot;The sum is: &quot; + task.Result));</code></p>
<p>Now, when the task executing <b>Sum </b>completes, this task will start another task (also on some thread pool thread) that displays the result The thread that executes the code above does not block waiting for either of these two tasks to complete; the thread is allowed to execute other code or, if it is a thread pool thread itself, it can return to the pool to perform other operations Note that the task executing <b>Sum </b>could complete before <b>ContinueWith </b>is called This will not be a problem because the <b>ContinueWith </b>method will see that the <b>Sum </b>task is complete and it will immediately start the task that displays the result.</p>
<p>Also, note that <b>ContinueWith </b>returns a reference to a new <b>Task </b>object (which my code placed in the <b>cwt </b>variable). Of course, you can invoke various members (like <b>Wait, Result, </b>or even <b>ContinueWith) </b>using this <b>Task </b>object, but usually you will ignore this <b>Task </b>object and will not save a reference to it in a variable.</p>
<p>I should also mention that <b>Task </b>objects internally contain a collection of <b>ContinueWith </b>tasks. So you can actually call <b>ContinueWith </b>several times using a single <b>Task </b>object. When the task completes, all the <b>ContinueWith </b>tasks will be queued to the thread pool. In addition, when calling <b>ContinueWith, </b>you can specify a bitwise OR'd set of <b>TaskContinuationOptions </b>. The first four flags<b>None, PreferFairness, LongRunning,</b></p>
<p>and <b>AttachedToParent</b>預re identical to the flags offered by the <b>TaskCreationOptions </b>enumerated type shown earlier. Here is what the <b>TaskContinuationOptions </b>type looks like:</p>
<p><code>[Flags, Serializable]<br/>
public enumTaskContinuationOptions {<br/>
None.= 0x0000,// The default<br/>
// Causes the default TaskScheduler to put the task in the thread pool's // global queue instead of a worker thread's local queue. PreferFairness.= 0x0001,<br/>
// Causes the default TaskScheduler to create a thread for the task instead // of queuing the task to a thread pool thread LongRunning.= 0x0002,<br/>
// Always honored: Associates a Task with its parent Task (discussed shortly) AttachedToParent.= 0x0004,<br/>
// This flag indicates that you want the thread that executed the first task to also // execute the ContinueWith task. If the first task has already completed, then the // thread calling ContinueWith will execute the ContinueWith task. ExecuteSynchronously   = 0x80000,<br/>
// These flags indicate under what circumstances to run the ContinueWith task NotOnRanToCompletion   = 0x10000, NotOnFaulted.= 0x20000,<br/>
NotOnCanceled.= 0x40000,<br/>
// These flags are convenient combinations of the above three flags OnlyOnCanceled.= NotOnRanToCompletion | NotOnFaulted,<br/>
OnlyOnFaulted.= NotOnRanToCompletion | NotOnCanceld,<br/>
OnlyOnRanToCompletion = NotOnFaulted.| NotOnCanceled,<br/>
}</code></p>
<p>When you call <b>ContinueWith, </b>you can indicate that you want the new task to execute only if the first task is canceled by specifying the <b>TaskContinuationOptions.OnlyOnCanceled </b>flag. Similarly, you have the new task execute only if the first task throws an unhandled exception using the <b>TaskContinuationOptions.OnlyOnFaulted </b>flag. And, of course, you can use the <b>TaskContinuationOptions.OnlyOnRanToCompletion </b>flag to have the new task execute only if the first task runs all the way to completion without being canceled or throwing an unhandled exception. By default, if you do not specify any of these flags, then the new task will run regardless of how the first task completes. When a <b>Task </b>completes, any of its continue-with tasks that do not run are automatically canceled. Here is an example that puts all of this together:</p>
<p><code>Task&lt;Int32&gt; t = new Task&lt;Int32&gt;(n =&gt; Sum((Int32)n), 10000);<br/>
// You can start the task sometime later t.Start();<br/>
// Each ContinueWith returns a Task but you usually don't care<br/>
t.ContinueWith(task =&gt; Console.WriteLine(&quot;The sum is: &quot; + task.Result), TaskContinuationOptions.OnlyOnRanToCompletion);<br/>
t.ContinueWith(task =&gt; Console.WriteLine(&quot;Sum threw: &quot; + task.Exception), TaskContinuationOptions.OnlyOnFaulted);<br/>
t.ContinueWith(task =&gt; Console.WriteLine(&quot;Sum was canceled&quot;), TaskContinuationOptions.OnlyOnCanceled);</code></p>
<h3>A Task May Start Child Tasks</h3>
<p>Finally, tasks support parent/child relationships, as demonstrated by the following code:</p>
<p><code>Task&lt;Int32[]&gt; parent = new Task&lt;Int32[]&gt;(() =&gt; {<br/>
var results = new Int32[3];     // Create an array for the results<br/>
// This tasks creates and starts 3 child tasks<br/>
new Task(() =&gt; results[0] = Sum(l0000), TaskCreationOptions.AttachedToParent).Start(); new Task(() =&gt; results[l] = Sum(20000), TaskCreationOptions.AttachedToParent).Start(); new Task(() =&gt; results[2] = Sum(30000), TaskCreationOptions.AttachedToParent).Start();<br/>
// Returns a reference to the array (even though the elements may not be initialized yet) return results;<br/>
});<br/>
// When the parent and its children have run to completion, display the results varcwt = parent.ContinueWith(<br/>
parentTask =&gt; Array.ForEach(parentTask.Result, Console.WriteLine));<br/>
// Start the parent Task so it can start its children parent.Start();</code></p>
<p>Here, the parent task creates and starts three <b>Task </b>objects. By default, <b>Task </b>objects created by another task are top-level tasks that have no relationship to the task that creates them However, the <b>TaskCreationOptions.AttachedToParent </b>flag associates a <b>Task </b>with the <b>Task </b>that creates it so that the creating task is not considered finished until all its children (and grandchildren) have finished running. When creating a <b>Task </b>by calling the <b>ContinueWith </b>method, you can make the continue-with task be a child by specifying the <b>TaskContinuationOptions.AttachedToParent </b>flag.</p>
<h3>Inside a Task</h3>
<p>Each <b>Task </b>object has a set of fields that make up the task's state. There is an <b>Int32 </b>ID (see <b>Task</b>'s read-only <b>Id </b>property), an <b>Int32 </b>representing the execution state of the <b>Task, </b>a reference to the parent task, a reference to the <b>TaskScheduler </b>specified when the <b>Task </b>was created, a reference to the callback method, a reference to the object that is to be passed to the callback method (queryable via <b>Task</b>'s read-only <b>AsyncState </b>property), a reference to an <b>ExecutionContext, </b>and a reference to a <b>ManualResetEventSlim </b>object. In addition, each <b>Task </b>object has a reference to some supplementary state that is created on demand.</p>
<p>The supplementary state includes a <b>CancellationToken, </b>a collection of <b>ContinueWithTask</b></p>
<p>objects, a collection of <b>Task </b>objects for child tasks that have thrown unhandled exceptions, and more. My point is that while tasks provide you a lot of features, there is some cost to tasks because memory must be allocated for all this state. If you don't need the additional features offered by tasks, then your program will use resources more efficiently if you use <b>ThreadPool.QueueUserWorkItem </b>.</p>
<p>The <b>Task </b>and <b>Task&lt;TResult&gt; </b>classes implement the <b>IDisposable </b>interface, allowing you to call <b>Dispose </b>when you are done with the <b>Task </b>object. Today, all the <b>Dispose </b>method does is close the <b>ManualResetEventSlim </b>object. However, it is possible to define classes derived from <b>Task </b>and <b>Task&lt;TResult&gt;, </b>and these classes could allocate their own resources, which would be freed in their override of the <b>Dispose </b>method. Of course, most developers will not explicitly call <b>Dispose </b>on a <b>Task </b>object in their code; instead, they will just let the garbage collector clean up any resources when it determines that they are no longer in use.</p>
<p>You'll notice that each <b>Task </b>object contains an <b>Int32 </b>field representing a <b>Task</b>'s unique ID. When you create a <b>Task </b>object, the field is initialized to zero. Then the first time you query <b>Task</b>'s read-only <b>Id </b>property, the property assigns a unique <b>Int32 </b>value to this field and returns it from the property. Task IDs start at 1 and increment by 1 as each ID is assigned. Just looking at a <b>Task </b>object in the Microsoft Visual Studio debugger will cause the debugger to display the <b>Task</b>'s ID, forcing the <b>Task </b>to be assigned an ID.</p>
<p>The idea behind the ID is that each <b>Task </b>can be identified by a unique value. In fact, Visual Studio shows you these task IDs in its Parallel Tasks and Parallel Stacks windows. But since you don't assign the IDs yourself in your code, it is practically impossible to correlate an ID number with what your code is doing. While running a task's code, you can query <b>Task</b>'s static <b>CurrentId </b>property, which returns a nullable <b>Int32 (Int32?) </b>You can also call this from Visual Studio's Watch window or Immediate window while debugging to get the ID for the code that you are currently stepping through. Then you can find your task in the Parallel Tasks/Stacks windows. If you query the <b>CurrentId </b>property while a task is not executing, it returns <b>null.</b></p>
<p>During a <b>Task </b>object's existence, you can learn where it is in its lifecycle by querying <b>Task</b>'s read-only <b>Status </b>property. This property returns a <b>TaskStatus </b>value that is defined as follows:</p>
<p><code>public enum TaskStatus {<br/>
// These flags indicate the state of a Task during its lifetime:<br/>
Created,// Task created explicitly; you can manually Start() this task<br/>
WaitingForActivation,// Task created implicitly; it starts automatically<br/>
WaitingToRun,   // The task was scheduled but isn't running yet Running,// The task is actually running<br/>
// The task is waiting for children to complete before it considers itself complete WaitingForChildrenToComplete,<br/>
// A task's final state is one of these:<br/>
RanToCompletion,<br/>
Canceled,<br/>
Faulted<br/>
}</code></p>
<p>When you first construct a <b>Task </b>object, its status is <b>Created. </b>Later, when the task is started, its status changes to <b>WaitingToRun. </b>When the <b>Task </b>is actually running on a thread, its status changes to <b>Running </b>. When the task stops running and is waiting for any child tasks, the status changes to <b>WaitingForChildrenToComplete </b>. When a task is completely finished, it enters one of three final states: <b>RanToCompletion, Canceled, </b>or <b>Faulted. </b>When a <b>Task&lt;TResult&gt; </b>runs to completion, you can query the task's result via<b>Task&lt;TResult</b>&gt;'s <b>Result </b>property. When a <b>Task </b>or <b>Task&lt;TResult&gt; </b>faults, you can obtain the unhandled exception that the task threw by querying <b>Task</b>'s <b>Exception </b>property; which always returns an <b>AggregateException </b>object whose collection contains the set of unhandled exceptions.</p>
<p>For convenience, <b>Task </b>offers several read-only, <b>Boolean </b>properties: <b>IsCanceled, IsFaulted, </b>and <b>IsCompleted </b>. Note that <b>IsCompleted </b>returns <b>true </b>when the <b>Task </b>is in the <b>RanToCompleted, Canceled, </b>or <b>Faulted </b>state. The easiest way to determine if a <b>Task </b>completed successfully is to use code like this:</p>
<p><code>if (task.Status == TaskStatus.RanToCompletion)...</code></p>
<p>A <b>Task </b>object is in the <b>WaitingForActivation </b>state if that <b>Task </b>is creating by calling one of these functions: <b>ContinueWith, ContinueWhenAll, ContinueWhenAny, </b>or <b>FromAsync </b>A <b>Task</b></p>
<p>created by constructing a <b>TaskCompletionSource&lt;TResult&gt; </b>object is also created in the <b>WaitingForActivation </b>state This state means that the <b>Task</b>'s scheduling is controlled by the task infrastructure. For example, you cannot explicitly start a <b>Task </b>object that was created by calling <b>ContinueWith </b>. This <b>Task </b>will start automatically when its antecedent task has finished executing.</p>
<h3>Task Factories</h3>
<p>Occasionally, you might want to create a bunch of <b>Task </b>objects that share the same state To keep you from having to pass the same parameters to each <b>Task</b>'s constructor over and over again, you can create a task factory that encapsulates the common state The <b>System.Threading.Tasks </b>namespace defines a <b>TaskFactory </b>type as well as a <b>TaskFactory&lt;TResult&gt; </b>type. Both of these types are derived from <b>System.Object; </b>that is, they are peers of each other.</p>
<p>If you want to create a bunch of tasks that have no return values, then you will construct a <b>TaskFactory. </b>If you want to create a bunch of tasks that have a specific return value, then you will construct a <b>TaskFactory&lt;TResult&gt; </b>where you pass the task's desired return type for the generic <b>TResult </b>argument. When you create one of these task factory classes, you pass to its constructor the defaults that you want the tasks that the factory creates to have. Specifically, you pass to the task factory the <b>CancellationToken, TaskScheduler, TaskCreationOptions, </b>and <b>TaskContinuationOptions </b>settings that you want factory-created tasks to have.</p>
<p>Here is some sample code demonstrating the use of a <b>TaskFactory:</b></p>
<p><code>Task parent = new Task(() =&gt; {<br/>
varcts = new CancellationTokenSource(); vartf = new TaskFactory&lt;Int32&gt;(cts.Token, TaskCreationOptions.AttachedToParent, TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);<br/>
// This tasks creates and starts 3 child tasks varchildTasks = new[] { tf.StartNew(() =&gt; Sum(cts.Token, l0000)), tf.StartNew(() =&gt; Sum(cts.Token, 20000)),<br/>
tf.StartNew(() =&gt; Sum(cts.Token, Int32.MaxValue)) // Too big, throws OverflowException };<br/>
// If any of the child tasks throw, cancel the rest of them for (Int32 task = 0; task &lt;childTasks.Length; task++) childTasks[task].ContinueWith(<br/>
t =&gt; cts.Cancel(), TaskContinuationOptions.OnlyOnFaulted);<br/>
// When all children are done, get the maximum value returned from the // non-faulting/canceled tasks. Then pass the maximum value to another // task which displays the maximum result tf.ContinueWhenAll( childTasks,<br/>
completedTasks =&gt; completedTasks.Where(<br/>
t =&gt; It.IsFaulted &amp;&amp; !t.IsCanceled).Max(t =&gt; t.Result), CancellationToken.None)<br/>
.ContinueWith(t =&gt;Console.WriteLine(&quot;The maximum is: &quot; + t.Result), TaskContinuationOptions.ExecuteSynchronously);<br/>
});<br/>
// When the children are done, show any unhandled exceptions too parent.ContinueWith(p =&gt; {<br/>
// I put all this text in a StringBuilder and call Console.WriteLine just once<br/>
// because this task could execute concurrently with the task above &amp; I don't<br/>
// want the tasks' output interspersed<br/>
StringBuildersb = new StringBuilder(<br/>
&quot;The following exception(s) occurred:&quot; + Environment.NewLine);<br/>
foreach (var e in p.Exception.Flatten().InnerExceptions)<br/>
sb.AppendLine(&quot;     &quot;+ e.CetType().ToString()); Console.WriteLine(sb.ToString()); }, TaskContinuationOptions.OnlyOnFaulted);<br/>
// Start the parent Task so it can start its children parent.Start();</code></p>
<p>With this code, I am creating a <b>TaskFactory&lt;Int32&gt; </b>object that I will use to create three <b>Task </b>objects I want four things: for each <b>Task </b>object to share the same <b>CancellationTokenSource </b>token, for all three tasks to be considered children of their parent, for all continue-with tasks created by the <b>TaskFactory </b>object to execute synchronously, and for all the <b>Task </b>objects created by this <b>TaskFactory </b>to use the default <b>TaskScheduler </b>.</p>
<p>Then I create an array consisting of the three child <b>Task </b>objects, all created by calling <b>TaskFactory</b>'s <b>StartNew </b>method. This method conveniently creates and starts each child task In a loop, I tell each child task that throws an unhandled exception to cancel all the other child tasks that are still running Finally, using the <b>TaskFactory, </b>I call <b>ContinueWhenAll, </b>which creates a <b>Task </b>that runs when all the child tasks have completed running Since this task is created with the <b>TaskFactory, </b>it will also be considered a child of the parent task and it will execute synchronously using the default <b>TaskScheduler. </b>However, I want this task to run even if the other child tasks were canceled, so I override the <b>TaskFactory</b>'s <b>CancellationToken </b>by passing in <b>CancellationToken.None, </b>which prevents this task from being cancelable at all Finally, when the task that processes all the results is complete, I create another task that displays the highest value returned from all the child tasks.</p>
<p><b>|-</b></p>
<hr/>
<blockquote><b>Note </b>When calling <b>TaskFactory</b>'s or <b>TaskFactory&lt;TResult</b>&gt;'s static <b>ContinueWhenAll </b>and <b>ContinueWhenAny </b>methods, the following <b>TaskContinuationOption </b>flags are illegal: <b>NotOnRanToCompletion, NotOnFaulted, </b>and <b>NotOnCanceled. </b>And of course, the convenience flags <b>(OnlyOnCanceled, OnlyOnFaulted, </b>and <b>OnlyOnRanToCompletion) </b>are also illegal. That is, <b>ContinueWhenAll </b>and <b>ContinueWhenAny </b>execute the continue-with task regardless of how the antecedent tasks complete.</blockquote>
<hr/>
<h3>Task Schedulers</h3>
<p>The task infrastructure is very flexible, and <b>TaskScheduler </b>objects are a big part of this flexibility. A <b>TaskScheduler </b>object is responsible for executing scheduled tasks and also exposes task information to the Visual Studio debugger. The FCL ships with two <b>TaskScheduler-</b>derived types: the thread pool task scheduler and a synchronization context task scheduler By default, all applications use the thread pool task scheduler This task scheduler schedules tasks to the thread pool's worker threads and is discussed in more detail in this chapter's &quot;How the Thread Pool Manages Its Threads&quot; section. You can get a reference to the default task scheduler by querying <b>TaskScheduler</b>'s static <b>Default </b>property.</p>
<p>The synchronization context task scheduler is typically used for Windows Forms, Windows Presentation Foundation (WPF), and Silverlight applications This task scheduler schedules all tasks onto the application's GUI thread so that all the task code can successfully update UI components like buttons, menu items, and so on The synchronization context task scheduler does not use the thread pool at all You can get a reference to a synchronization context task scheduler by querying <b>TaskScheduler</b>'s static <b>FromCurrentSynchronizationContext</b></p>
<p>method.</p>
<p>Here is a simple Windows Forms application that demonstrates the use of the synchronization context task scheduler:</p>
<p><code>internalsealed class MyForm : Form { public MyForm() {<br/>
Text = &quot;Synchronization Context Task Scheduler Demo&quot;; Visible = true; Width = 400; Height = l00;<br/>
}<br/>
// Cet a reference to a synchronization context task scheduler private readonly TaskScheduler m_syncContextTaskScheduler = TaskScheduler.FromCurrentSynchronizationContext();<br/>
private CancellationTokenSource m_cts;<br/>
protected override void OnMouseClick(MouseEventArgs e) {<br/>
if (m_cts != null) { // An operation is in flight, cancel it m_cts.Cancel(); m_cts = null;<br/>
} else { // An operation is not in flight, start it Text = &quot;Operation running&quot;; m_cts = new CancellationTokenSource();<br/>
// This task uses the default task scheduler and executes on a thread pool thread<br/>
var t = new Task&lt;Int32&gt;(() =&gt; Sum(m_cts.Token, 20000), m_cts.Token);<br/>
t.Start();<br/>
// These tasks use the sync context task scheduler and execute on the CUI thread t.ContinueWith(task =&gt; Text = &quot;Result: &quot; + task.Result,<br/>
CancellationToken.None, TaskContinuationOptions.OnlyOnRanToCompletion,<br/>
m_syncContextTaskScheduler);<br/>
t.ContinueWith(task =&gt; Text = &quot;Operation canceled&quot;,<br/>
CancellationToken.None, TaskContinuationOptions.OnlyOnCanceled, m_syncContextTaskScheduler);<br/>
t.ContinueWith(task =&gt; Text = &quot;Operation faulted&quot;,<br/>
CancellationToken.None, TaskContinuationOptions.OnlyOnFaulted, m_syncContextTaskScheduler);<br/>
}<br/>
base.OnMouseClick(e);<br/>
}<br/>
}</code></p>
<p>When you click in the client area of this form, a compute-bound task will start executing on a thread pool thread This is good because the GUI thread is not blocked during this time and can therefore respond to other UI operations However, the code executed by the thread pool thread should not attempt to update UI components or else an <b>InvalidOperationException </b>will be thrown.</p>
<p>When the compute-bound task is done, one of the three continue-with tasks will execute These tasks are all issued against the synchronization context task scheduler corresponding to the GUI thread, and this task scheduler queues the tasks to the GUI thread, allowing the code executed by these tasks to update UI components successfully. All of these tasks update the form's caption via the inherited <b>Text </b>property.</p>
<p>Since the compute-bound work <b>(Sum) </b>is running on a thread pool thread, the user can interact with the UI to cancel the operation. In my simple code example, I allow the user to cancel the operation by clicking in the form's client area while an operation is running.</p>
<p>You can, of course, define your own class derived from <b>TaskScheduler </b>if you have special task scheduling needs Microsoft has provided a bunch of sample code for tasks and includes the source code for a bunch of task schedulers in the Parallel Extensions Extras package, which can be downloaded from here: <a href="http://code.msdn.microsoft.com/ParExtSamples">http://code.msdn.microsoft.com/ParExtSamples</a>. Here are some of the task schedulers included in this package:</p>
<p><b>&#9632; IOTaskScheduler   </b>This task scheduler queues tasks to the thread pool's I/O threads instead of its worker threads.</p>
<p><b>&#9632; LimitedConcurrencyLevelTaskScheduler   </b>This task scheduler allows no more than n (a constructor parameter) tasks to execute simultaneously.</p>
<p><b>&#9632; OrderedTaskScheduler </b>This task scheduler allows only one task to execute at a time. This class is derived from <b>LimitedConcurrencyLevelTaskScheduler </b>and just passes 1 for n.</p>
<p><b>&#9632; PrioritizingTaskScheduler   </b>This task scheduler queues tasks to the CLR's thread pool. After this has occurred, you can call <b>Prioritize </b>to indicate that a <b>Task </b>should be processed before all normal tasks (if it hasn't been processed already) You can call <b>Deprioritize </b>to make a <b>Task </b>be processed after all normal tasks.</p>
<p><b>&#9632; ThreadPerTaskScheduler   </b>This task scheduler creates and starts a separate thread for each task; it does not use the thread pool at all.</p>
<a name="b739"/><h2>Parallel's Static For, ForEach, and Invoke Methods</h2>
<p>There are some common programming scenarios that can potentially benefit from the improved performance possible with tasks. To simplify programming, the static <b>System. Threading.Tasks.Parallel </b>class encapsulates these common scenarios while using <b>Task </b>objects internally For example, instead of processing all the items in a collection like this:</p>
<p><code>// One thread performs all this work sequentially for (Int32 i = 0; i &lt; l000; DoWork(i);</code></p>
<p>you can instead get multiple thread pool threads to assist in performing this work by using the <b>Parallel </b>class's <b>For </b>method:</p>
<p><code>// The thread pool's threads process the work in parallel Parallel.For(0, l000, i =&gt; DoWork(i));</code></p>
<p>Similarly, if you have a collection, instead of doing this:</p>
<p><code>// One thread performs all this work sequentially foreach (var item in collection) DoWork(item);</code></p>
<p>you can do this:</p>
<p><code>// The thread pool's threads process the work in parallel Parallel.ForEach(collection, item =&gt; DoWork(item));</code></p>
<p>If you can use either <b>For </b>or <b>ForEach </b>in your code, then it is recommended that you use <b>For </b>because it executes faster.</p>
<p>And finally, if you have several methods that you need to execute, you could execute them all sequentially, like this:</p>
<p><code>// One thread executes all the methods sequentially<br/>
Methodl(); Method2(); Method3();</code></p>
<p>or you could execute them in parallel, like this:</p>
<p><code>// The thread pool's threads execute the methods in parallel Parallel.Invoke(<br/>
() =&gt; Methodl(),<br/>
() =&gt; Method2(),<br/>
() =&gt; Method3());</code></p>
<p>All of <b>Parallel</b>'s methods have the calling thread participate in the processing of the work, which is good in terms of resource usage because we wouldn't want the calling thread to just suspend itself while waiting for thread pool threads to do all the work. However, if the calling thread finishes its work before the thread pool threads complete their part of the work, then the call thread will suspend itself until all the work is done, which is also good because this gives you the same semantics as you'd have when using a <b>for </b>or <b>foreach </b>loop: The thread doesn't continue running until all the work is done. Also note that if any operation throws an unhandled exception, the <b>Parallel </b>method you called will ultimately throw an <b>AggregateException </b>.</p>
<p>Of course, you should not go through all your source code replacing <b>for </b>loops with calls to <b>Parallel.For </b>and <b>foreach </b>loops with calls to <b>Parallel.ForEach. </b>When calling the <b>Parallel </b>method, there is an assumption that it is OK for the work items to be performed concurrently. Therefore, do not use the <b>Parallel </b>methods if the work must be processed in sequential order. Also, avoid work items that modify any kind of shared data because the data could get corrupted if it is manipulated by multiple threads simultaneously. Normally, you would fix this by adding thread synchronization locks around the data access, but if you do this, then one thread at a time can access the data and you would lose the benefit of processing multiple items in parallel.</p>
<p>In addition, there is overhead associated with the <b>Parallel </b>methods; delegate objects have to be allocated, and these delegates are invoked once for each work item If you have lots of work items that can be processed by multiple threads, then you might gain a performance increase. Also, if you have lots of work to do for each item, then the performance hit of calling through the delegate is negligible. You will actually hurt your performance if you use the <b>Parallel </b>methods for just a few work items or for work items that are processed very quickly.</p>
<p>I should mention that <b>Parallel</b>'s <b>For, ForEach, </b>and <b>Invoke </b>methods all have overloads that accept a <b>ParallelOptions </b>object, which looks like this:</p>
<p><code>public class ParallelOptions{ public ParallelOptions();<br/>
// Allows cancellation of the operation<br/>
public CancellationTokenCancellationToken { get; set; } // Default=CancellationToken.None<br/>
// Allows you to specify the maximum number of work items // that can be operated on concurrently<br/>
public Int32MaxDegreeOfParallelism { get; set; }        // Default=-l (# of available CPUs) // Allows you to specify which TaskScheduler to use<br/>
public TaskSchedulerTaskScheduler { get; set; }        // Default=TaskScheduler.Default<br/>
}</code></p>
<p>In addition, there are overloads of the <b>For </b>and <b>ForEach </b>methods that let you pass three delegates:</p>
<p>&#9632; The task local initialization delegate <b>(localInit) </b>is invoked once for each task participating in the work This delegate is invoked before the task is asked to process a work item.</p>
<p>&#9632; The body delegate <b>(body) </b>is invoked once for each item being processed by the various threads participating in the work.</p>
<p>&#9632; The task local finally delegate <b>(localFinally) </b>is invoked once for each task participating in the work This delegate is invoked after the task has processed all the work items that will be dispatched to it. It is even invoked if the body delegate code experiences an unhandled exception.</p>
<p>Here is some sample code that demonstrates the use of the three delegates by adding up the bytes for all files contained within a directory:</p>
<p><code>private static Int64 DirectoryBytes(String path, String searchPattern, SearchOptionsearchOption) {<br/>
var files = Directory.EnumerateFiles(path, searchPattern, searchOption); Int64 masterTotal = 0;<br/>
ParallelLoopResult result = Parallel.ForEach&lt;String, Int64&gt;(<br/>
files,<br/>
() =&gt; { // localInit: Invoked once per task at start // Initialize that this task has seen 0 bytes return 0;     // Set taskLocalTotal initial value to 0<br/>
},<br/>
(file, loopState, index, taskLocalTotal) =&gt; { // body: Invoked once per work item // Cet this file's size and add it to this task's running total Int64 fileLength = 0; FileStreamfs = null;<br/>
try {<br/>
fs = File.OpenRead(file); fileLength = fs.Length;<br/>
}<br/>
catch (IOException) { /* Ignore any files we can't access */ } finally { if (fs != null) fs.Dispose(); } return taskLocalTotal + fileLength;<br/>
},<br/>
taskLocalTotal =&gt; { // localFinally: Invoked once per task at end // Atomically add this task's total to the &quot;master&quot; total Interlocked.Add(ref masterTotal, taskLocalTotal);<br/>
});<br/>
return masterTotal;<br/>
}</code></p>
<p>Each task maintains its own running total (in the <b>taskLocalTotal </b>variable) for the files that it is given As each task completes its work, the master total is updated in a thread-safe way by calling the <b>Interlocked.Add </b>method (discussed in Chapter 28, &quot;Primitive Thread Synchronization Constructs&quot;). Since each task has its own running total, no thread synchronization is required during the processing of the item Since thread synchronization would hurt performance, not requiring thread synchronization is good. It's only after each task returns that <b>masterTotal </b>has to be updated in a thread-safe way, so the performance hit of calling <b>Interlocked.Add </b>occurs only once per task instead of once per work item.</p>
<p>You'll notice that the body delegate is passed a <b>ParallelLoopState </b>object, which looks like this:</p>
<p><code>public class ParallelLoopState{ public void Stop(); public BooleanIsStopped { get; }<br/>
public void Break();<br/>
public Int64? LowestBreakIteration{ get; }<br/>
public BooleanIsExceptional { get; }<br/>
public BooleanShouldExitCurrentIteration { get; }<br/>
}</code></p>
<p>Each task participating in the work gets its own <b>ParallelLoopState </b>object, and it can use this object to interact with the other task participating in the work The <b>Stop </b>method tells the loop to stop processing any more work, and future querying of the <b>IsStopped </b>property will return <b>true. </b>The <b>Break </b>method tells the loop to stop processing any items that are beyond the current item. For example, let's say that <b>ForEach </b>is told to process 100 items and <b>Break </b>is called while processing the fifth item, then the loop will make sure that the first five items are processed before <b>ForEach </b>returns. Note, however, that additional items may have been processed. The <b>LowestBreakIteration </b>property returns the lowest item number whose processing called the <b>Break </b>method. The <b>LowestBreakIteration </b>property returns <b>null </b>if <b>Break </b>was never called.</p>
<p>The <b>IsException </b>property returns <b>true </b>if the processing of any item resulted in an unhandled exception. If the processing of an item takes a long time, your code can query the <b>ShouldExitCurrentIteration </b>property to see if it should exit prematurely. This property returns <b>true </b>if <b>Stop </b>was called, <b>Break </b>was called, the <b>CancellationTokenSource </b>(referred to by the <b>ParallelOption</b>'s <b>CancellationToken </b>property) is canceled, or if the processing of an item resulted in an unhandled exception.</p>
<p><b>Parallel</b>'s <b>For </b>and <b>ForEach </b>methods both return a <b>ParallelLoopResult </b>instance, which looks like this:</p>
<p><code>publicstructParallelLoopResult{<br/>
// Returns false if the operation was ended prematurely public Boolean IsCompleted { get; } public Int64? LowestBreakIteration{ get; }<br/>
}</code></p>
<p>You can examine the properties to determine the result of the loop. If <b>IsCompleted </b>returns <b>true, </b>then the loop ran to completion and all the items were processed. If <b>IsCompleted </b>is <b>false </b>and <b>LowestBreakIteration </b>is <b>null </b>, then some thread participating in the work called the <b>Stop </b>method. If <b>IsCompleted </b>is <b>false </b>and <b>LowestBreakIteration </b>is not <b>null, </b>then some thread participating in the work called the <b>Break </b>method and the <b>Int64 </b>value returned from <b>LowestBreakIteration </b>indicates the index of the lowest item guaranteed to have been processed.</p>
<a name="b743"/><h2>Parallel Language Integrated Query</h2>
<p>Microsoft's Language Integrated Query (LINQ) feature offers a convenient syntax for performing queries over collections of data. Using LINQ, you can easily filter items, sort items, return a projected set of items, and much more. When you use LINQ to Objects, only one thread processes all the items in your data collection sequentially; we call this a sequential</p>
<p>query. You can potentially improve the performance of this processing by using Parallel LINQ, which can turn your sequential query into a parallel query, which internally uses tasks (queued to the default <b>TaskScheduler) </b>to spread the processing of the collection's items across multiple CPUs so that multiple items are processed concurrently. Like <b>Parallel</b>'s methods, you will get the most benefit from Parallel LINQ if you have many items to process or if the processing of each item is a lengthy compute-bound operation.</p>
<p>The static <b>System.Linq.ParallelEnumerable </b>class (defined in System. Core, dll) implements all of the Parallel LINQ functionality, and so you must import the <b>System.Linq </b>namespace into your source code via C#'s <b>using </b>directive. In particular, this class exposes parallel versions of all the standard LINQ operators such as <b>Where, Select, SelectMany, GroupBy, Join, OrderBy, Skip, Take, </b>and so on. All of these methods are extension methods that extend the <b>System.Linq.ParallelQuery&lt;T&gt; </b>type. To have your LINQ to Objects query invoke the parallel versions of these methods, you must convert your sequential query (based on <b>IEnumerable </b>or <b>IEnumerable&lt;T&gt;) </b>to a parallel query (based on <b>ParallelQuery </b>or <b>ParallelQuery&lt;T&gt;) </b>using <b>ParallelEnumerable</b>'s <b>AsParallel </b>extension method, which looks like this<sup>3</sup>:</p>
<p><code>public static ParallelQuery&lt;TSource&gt;AsParallel&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source) public static ParallelQueryAsParallel(this IEnumerablesource)</code></p>
<p>Here is an example of a sequential query that has been converted to a parallel query. This query returns all the obsolete methods defined within an assembly:</p>
<p><code>private static void ObsoleteMethods(Assembly assembly) { var query =<br/>
from type in assembly.CetExportedTypes<b>().AsParallel()</b><br/>
from method in type.CetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static)<br/>
let obsoleteAttrType = typeof(ObsoleteAttribute)<br/>
where Attribute.IsDefined(method, obsoleteAttrType)<br/>
orderbytype.FullName<br/>
let obsoleteAttrObj = (ObsoleteAttribute)<br/>
Attribute.CetCustomAttribute(method, obsoleteAttrType)<br/>
select String.Format(&quot;Type={0}\nMethod={l}\nMessage={2}\n&quot;, type.FullName, method.ToString(), obsoleteAttrObj.Message);<br/>
// Display the results<br/>
foreach (var result in query) Console.WriteLine(result);<br/>
}</code></p>
<p>The <b>ParallelQuery&lt;T&gt; </b>class is derived from the <b>ParallelQuery </b>class.</p>
<p>While uncommon, within a query you can switch from performing parallel operations back to performing sequential operations by calling <b>ParallelEnumerable</b>'s <b>AsSequential </b>method:</p>
<p><code>public static IEnumerable&lt;TSource&gt; AsSequential&lt;TSource&gt;(this ParallelQuery&lt;TSource&gt; source)</code></p>
<p>This method basically turns a <b>ParallelQuery&lt;T&gt; </b>back to an <b>IEnumerable&lt;T&gt; </b>so that operations performed after calling <b>AsSequential </b>are performed by just one thread.</p>
<p>Normally, the resulting data produced by a LINQ query is evaluated by having some thread execute a <b>foreach </b>statement (as shown earlier). This means that just one thread iterates over all the query's results If you want to have the query's results processed in parallel, then you should process the resulting query by using <b>ParallelEnumerable</b>'s <b>ForAll </b>method:</p>
<p><code>static void ForAll&lt;TSource&gt;(this ParallelQuery&lt;TSource&gt; source, Action&lt;TSource&gt; action)</code></p>
<p>This method allows multiple threads to process the results simultaneously. I could modify my code earlier to use this method as follows:</p>
<p><code>// Display the results query.ForAll(Console.WriteLine);</code></p>
<p>However, having multiple threads call <b>Console.WriteLine </b>simultaneously actually hurts performance since the <b>Console </b>class internally synchronizes threads, ensuring that only one at a time can access the console window This prevents text from multiple threads from being interspersed, making the output unintelligible. Use the <b>ForAll </b>method when you intend to perform calculations on each result.</p>
<p>Since Parallel LINQ processes items using multiple threads, the items are processed concurrently and the results are returned in an unordered fashion. If you need to have Parallel LINQ preserve the order of items as they are processed, then you can call <b>ParallelEnumerable</b>'s <b>AsOrdered </b>method When you call this method, threads will process items in groups and then the groups are merged back together, preserving the order; this will hurt performance The following operators produce unordered operations: <b>Distinct, Except, Intersect, Union, Join, GroupBy, GroupJoin, </b>and <b>ToLookup </b>. If you wish to enforce ordering again after one of these operators, just call the <b>AsOrdered </b>method.</p>
<p>The following operators produce ordered operations: <b>OrderBy, OrderByDescending, ThenBy, </b>and <b>ThenByDescending. </b>If you wish to go back to unordered processing again to improve performance after one of these operators, just call the <b>AsUnordered </b>method.</p>
<p>Parallel LINQ offers some additional <b>ParallelEnumerable </b>methods that you can call to control how the query is processed:</p>
<p><code>public static ParallelQuery&lt;TSource&gt; WithCancellation&lt;TSource&gt;(<br/>
this ParallelQuery&lt;TSource&gt; source, CancellationTokencancellationToken)<br/>
public static ParallelQuery&lt;TSource&gt; WithDegreeOfParallelism&lt;TSource&gt;( this ParallelQuery&lt;TSource&gt; source, Int32degreeOfParallelism)<br/>
public static ParallelQuery&lt;TSource&gt; WithExecutionMode&lt;TSource&gt;(<br/>
this ParallelQuery&lt;TSource&gt; source, ParallelExecutionModeexecutionMode)<br/>
public static ParallelQuery&lt;TSource&gt; WithMergeOptions&lt;TSource&gt;(<br/>
this ParallelQuery&lt;TSource&gt; source, ParallelMergeOptionsmergeOptions)</code></p>
<p>Obviously, the <b>WithCancellation </b>method allows you to pass a <b>CancellationToken </b>so that the query processing can be stopped prematurely. The <b>WithDegreeOfParallelism </b>method specifies the maximum number of threads allowed to process the query; it does not force the threads to be created if not all of them are necessary. Usually you will not call this method, and, by default, the query will execute using one thread per core. However, you could call <b>WIthDegreeOfParallelism, </b>passing a number that is smaller than the number of available cores if you want to keep some cores available for doing other work You could also pass a number that is greater than the number of cores if the query performs synchronous I/O operations because threads will be blocking during these operations This wastes more threads but can produce the final result in less time. You might consider doing this in a client application, but I'd highly recommend against performing synchronous I/O operations in a server application.</p>
<p>Parallel LINQ analyzes a query and then decides how to best process it. Sometimes processing a query sequentially yields better performance. This is usually true when using any of these operations: <b>Concat, ElementAt(OrDefault), First(OrDefault), Last(OrDefault), Skip(While), Take(While), </b>or <b>Zip </b>. It is also true when using overloads of <b>Select(Many) </b>or <b>Where </b>that pass a position index into your <b>selector </b>or <b>predicate </b>delegate. However, you can force a query to be processed in parallel by calling <b>WithExecutionMode, </b>passing it one of the <b>ParallelExecutionMode </b>flags:</p>
<p><code>public enum ParallelExecutionMode {<br/>
Default = 0,// Let Parallel LINQ decide to best process the query<br/>
ForceParallelism = 1 // Force the query to be processed in parallel<br/>
}</code></p>
<p>As mentioned before, Parallel LINQ has multiple threads processing items, and then the results must be merged back together. You can control how the items are buffered and merged by calling <b>WithMergeOptions, </b>passing it one of the <b>ParallelMergeOptions </b>flags:</p>
<p><code>public enum ParallelMergeOptions {<br/>
Default.= 0,      // Same as AutoBuffered today (could change in the future)<br/>
NotBuffered     = 1,      // Results are processed as ready<br/>
AutoBuffered   = 2,      // Each thread buffers some results before processed FullyBuffered = 3        // Each thread buffers all results before processed<br/>
}</code></p>
<p>These options basically give you some control over speed versus memory consumption. <b>NotBuffered </b>saves memory but processes items slower. <b>FullyBuffered </b>consumes more memory while running fastest. <b>AutoBuffered </b>is the compromise in between <b>NotBuffered </b>and <b>FullyBuffered. </b>Really, the best way to know which of these to pick for any given query is to try them all and compare their performance results, or just accept the default, which tends to work pretty well for many queries. See the following blog posts for more information about how Parallel LINQ partitions work across CPU cores:</p>
<p>&#9632; <a href="http://blogs.msdn.com/pfxteam/archive/2009/05/28/9648672.aspx">http://blogs.msdn.com/pfxteam/archive/2009/05/28/9648672.aspx</a></p>
<p>&#9632; <a href="http://blogs.msdn.com/pfxteam/archive/2009/06/13/9741072.aspx">http://blogs.msdn.com/pfxteam/archive/2009/06/13/9741072.aspx</a></p>
<a name="b747"/><h2>Performing a Periodic Compute-Bound Operation</h2>
<p>The <b>System.Threading </b>namespace defines a <b>Timer </b>class, which you can use to have a thread pool thread call a method periodically When you construct an instance of the <b>Timer </b>class, you are telling the thread pool that you want a method of yours called back at a future time that you specify. The <b>Timer </b>class offers several constructors, all quite similar to each other:</p>
<p><code>public sealed class Timer : MarshalByRefObject, IDisposable {<br/>
public Timer(TimerCallback callback, Object state, Int32 dueTime, Int32 period); public Timer(TimerCallback callback, Object state, UInt32 dueTime, UInt32 period); public Timer(TimerCallback callback, Object state, Int64 dueTime, Int64 period); public Timer(TimerCallback callback, Object state, Timespan dueTime, TimeSpan period);<br/>
}</code></p>
<p>All four constructors construct a <b>Timer </b>object identically. The <b>callback </b>parameter identifies the method that you want called back by a thread pool thread. Of course, the callback method that you write must match the <b>System.Threading.TimerCallback </b>delegate type, which is defined as follows:</p>
<p><code>delegate void TimerCallback(Object state);</code></p>
<p>The constructor's <b>state </b>parameter allows you to pass state data to the callback method each time it is invoked; you can pass <b>null </b>if you have no state data to pass. You use the <b>dueTime </b>parameter to tell the CLR how many milliseconds to wait before calling your callback method for the very first time. You can specify the number of milliseconds by using a signed or unsigned 32-bit value, a signed 64-bit value, or a <b>TimeSpan </b>value. If you want the callback method called immediately, specify <b>0 </b>for the <b>dueTime </b>parameter. The last parameter, <b>period, </b>allows you to specify how long, in milliseconds, to wait before each successive call to the callback method. If you pass <b>Timeout.Infinite (-1) </b>for this parameter, a thread pool thread will call the callback method just once.</p>
<p>Internally, the thread pool has just one thread that it uses for all <b>Timer </b>objects. This thread knows when the next <b>Timer </b>object's time is due. When the next <b>Timer </b>object is due, the thread wakes up, and internally calls <b>ThreadPool</b>'s <b>QueueUserWorkItem </b>to enter an entry into the thread pool's queue, causing your callback method to get called If your callback method takes a long time to execute, the timer could go off again. This could cause multiple thread pool threads to be executing your callback method simultaneously To work around this problem, I recommend the following: Construct the <b>Timer </b>specifying <b>Timeout.Infinite </b>for the <b>period </b>parameter. Now, the timer will fire only once. Then, in your callback method, call the <b>Change </b>method specifying a new due time and again specify <b>Timeout.Infinite </b>for the <b>period </b>parameter. Here is what the <b>Change </b>method overloads look like:</p>
<p><code>public sealed class Timer : MarshalByRefObject, IDisposable { public Boolean Change(Int32      dueTime, Int32 period); public Boolean Change(UInt32     dueTime, UInt32 period); public Boolean Change(Int64      dueTime, Int64 period); public Boolean Change(TimeSpan dueTime, TimeSpan period);<br/>
}</code></p>
<p>The <b>Timer </b>class also offers a <b>Dispose </b>method which allows you to cancel the timer altogether and optionally signal the kernel object identified by the <b>notifyObject </b>parameter when all pending callbacks for the time have completed. Here is what the <b>Dispose </b>method overloads look like:</p>
<p><code>public sealed class Timer : MarshalByRefObject, IDisposable { public Boolean Dispose();<br/>
public Boolean Dispose(WaitHandle notifyObject);<br/>
}</code></p>
<hr/>
<blockquote><b>Important </b>When a <b>Timer </b>object is garbage collected, its finalization code tells the thread pool to cancel the timer so that it no longer goes off So when using a <b>Timer </b>object, make sure that a variable is keeping the <b>Timer </b>object alive or else your callback method will stop getting called. This is discussed and demonstrated in the &quot;Garbage Collections and Debugging&quot; section in Chapter 21, &quot;Automatic Memory Management (Garbage Collection).&quot;</blockquote>
<hr/>
<p>The following code demonstrates how to have a thread pool thread call a method starting immediately and then every 2 seconds thereafter:</p>
<p><code>internal static class TimerDemo { private static Timer s_timer;<br/>
public static void Go() {<br/>
Console.WriteLineC'Main thread: starting a timer&quot;);<br/>
using (s_timer = new Timer(ComputeBoundOp, 5, 0, Timeout.Infinite)) {<br/>
Console.WriteLine(&quot;Main thread: Doing other work here...&quot;);<br/>
Thread.Sleep(10000);   // Simulating other work (10 seconds) } // Calls Dispose to cancel the timer now<br/>
}<br/>
// This method's signature must match the TimerCallback delegate private static void ComputeBoundOp(Object state) {<br/>
// This method is executed by a thread pool thread<br/>
Console.WriteLine(&quot;In ComputeBoundOp: state={0}&quot;, state);<br/>
Thread.Sleep(l000);   // Simulates other work (l second)<br/>
// Have the Timer call this method again in 2 seconds s_timer.Change(2000, Timeout.Infinite);<br/>
// When this method returns, the thread goes back // to the pool and waits for another work item<br/>
}<br/>
}</code></p>
<h3>So Many Timers, So Little Time</h3>
<p>Unfortunately, the FCL actually ships with several timers, and it is not clear to most programmers what makes each timer unique Let me attempt to explain:</p>
<p><b>&#9632; System.Threading's Timer class   </b>This is the timer discussed in the previous section, and it is the best timer to use when you want to perform periodic background tasks on a thread pool thread.</p>
<p><b>&#9632; System.Windows.Forms's Timer class   </b>Constructing an instance of this class tells Windows to associate a timer with the calling thread (see the Win32 <b>SetTimer </b>function) When this timer goes off, Windows injects a timer message <b>(WM_TIMER) </b>into the thread's message queue The thread must execute a message pump that extracts these messages and dispatches them to the desired callback method Notice that all of the work is done by just one thread葉he thread that sets the timer is guaranteed to be the thread that executes the callback method This also means that your timer method will not be executed by multiple threads concurrently.</p>
<p><b>&#9632; System.Windows.Threading's DispatcherTimer class   </b>This class is the equivalent of the <b>System.Windows.Forms</b>'s <b>Timer </b>class for Silverlight and WPF applications.</p>
<p><b>&#9632; System.Timers's Timer class  </b>This timer is basically a wrapper around <b>System. Threading</b>'s <b>Timer </b>class that causes the CLR to queue events into the thread pool when the timer comes due. The <b>System.Timers.Timer </b>class is derived from <b>System. ComponentModel</b>'s <b>Component </b>class, which allows these timer objects to be placed on a design surface in Visual Studio. Also, it exposes properties and events, allowing it to be used more easily from Visual Studio's designer. This class was added to the FCL years ago while Microsoft was still sorting out the threading and timer stuff This class probably should have been removed so that everyone would be using the <b>System. Threading.Timer </b>class instead. In fact, I never use the <b>System.Timers.Timer </b>class, and I'd discourage you from using it, too, unless you really want a timer on a design surface.</p>
<a name="b750"/><h2>How the Thread Pool Manages Its Threads</h2>
<p>Now I'd like to talk about how the thread pool code manages worker and I/O threads. However, I don't want to go into a lot of detail because the internal implementation has changed greatly over the years with each version of the CLR, and it will continue changing with future versions. It is best to think of the thread pool as a black box. The black box is not perfect for any one application, as it is a general-purpose thread scheduling technology designed to work with a large myriad of applications; it will work better for some applications than for others. It works very well today, and I highly recommend that you trust it because it would be very hard for you to produce a thread pool that works better than the one shipping in the CLR. And, over time, most applications should improve as the thread pool code internally changes how it manages threads.</p>
<h3>Setting Thread Pool Limits</h3>
<p>The CLR allows developers to set a maximum number of threads that the thread pool will create. However, it turns out that thread pools should never place an upper limit on the number of threads in the pool because starvation or deadlock might occur. Imagine queuing 1,000 work items that all block on an event that is signaled by the 1,001st item. If you've set a maximum of 1,000 threads, the 1,001st work item won't be executed, and all 1,000 threads will be blocked forever, forcing end users to terminate the application and lose all their work Also, it is very unusual for developers to artificially limit the resources that they have available to their application. For example, would you ever start your application and tell the system you'd like to restrict the amount of memory that the application can use or limit the amount of network bandwidth that your application can use? Yet, for some reason, developers feel compelled to limit the number of threads that the thread pool can have.</p>
<p>Because customers have had starvation and deadlock issues, the CLR team has steadily increased the default maximum number of threads that the thread pool can have. The default maximum is now about 1,000 threads, which is effectively limitless since a 32-bit process has at most 2 GB of usable address space within it After a bunch of Win32 DLLs load, the CLR DLLs load, the native heap and the managed heap is allocated, there is approximately 1. 5 GB of address space left over. Since each thread requires more than 1 MB of memory for its user-mode stack and thread environment block (TEB), the most threads you can get in a 32-bit process is about 1,360 Attempting to create more threads than this will result in an <b>OutOfMemoryException </b>being thrown. Of course, a 64-bit process offers 8 terabytes of address space, so you could theoretically create hundreds of thousands of threads. But allocating anywhere near this number of threads is really just a waste of resources, especially when the ideal number of threads to have is equal to the number of CPUs in the machine. What the CLR team should do is remove the limits entirely, but they can't do this now because doing so might break some applications that expect thread pool limits to exist.</p>
<p>The <b>System.Threading.ThreadPool </b>class offers several static methods that you can call to manipulate the number of threads in the thread pool: <b>GetMaxThreads, SetMaxThreads, GetMinThreads, SetMinThreads, </b>and <b>GetAvailableThreads. </b>I highly recommend that you do not call any of these methods. Playing with thread pool limits usually results in making an application perform worse, not better. If you think that your application needs hundreds or thousands of threads, there is something seriously wrong with the architecture of your application and the way that it's using threads. This chapter and Chapter 27 demonstrate the proper way to use threads.</p>
<h3>How Worker Threads Are Managed</h3>
<p>Figure 26-1 shows the various data structures that make up the worker threads part of the thread pool. The <b>ThreadPool.QueueUserWorkItem </b>method and the <b>Timer </b>class always queue work items to the global queue. Worker threads pull items from this queue using a first-in-first-out (FIFO) algorithm and process them. Since multiple worker threads can be removing items from the global queue simultaneously, all worker threads contend on a thread synchronization lock to ensure that two or more threads don't take the same work item. This thread synchronization lock can become a bottleneck in some applications, thereby limiting scalability and performance to some degree.</p>
<p><b>Figure 26-1 </b>The CLR's thread pool</p>
<p>Now let's talk about <b>Task </b>objects scheduled using the default <b>TaskScheduler </b>(obtained by querying <b>TaskScheduler</b>'s static <b>Default </b>property).<sup>4</sup> When a non-worker thread schedules a <b>Task, </b>the <b>Task </b>is added to the global queue But, each worker thread has its own local queue and when a worker thread schedules a <b>Task, </b>the <b>Task </b>is added to calling the thread's local queue.</p>
<p>Other <b>TaskScheduler</b>-derived objects may exhibit behavior different from what I describe here.</p>
<img src="88.jpg"/>
<p>When a worker thread is ready to process an item, it always checks its local queue for a <b>Task </b>first. If a <b>Task </b>exists, the worker thread removes the <b>Task </b>from its local queue and processes the item. Note that a worker thread pulls tasks from its local queue using a last-in-first-out (LIFO) algorithm. Since a worker thread is the only thread allowed to access the head of its own local queue, no thread synchronization lock is required and adding and removing <b>Task</b>s from the queue is very fast. A side effect of this behavior is that <b>Task</b>s are executed in the reverse order that they were queued.</p>
<hr/>
<blockquote><b>Important </b>Thread pools have never guaranteed the order in which queued items are processed, especially since multiple threads could be processing items simultaneously. However, this side effect exacerbates the problem. You must make sure that your application has no expectations about the order in which queued work items or Tasks execute.</blockquote>
<hr/>
<p>If a worker thread sees that its local queue is empty, then the worker thread will attempt to steal a <b>Task </b>from another worker thread's local queue. <b>Task</b>s are stolen from the tail of a local queue and require that a thread synchronization lock be taken, which hurts performance a little bit. Of course, the hope is that stealing rarely occurs, so this lock is taken rarely. If all the local queues are empty, then the worker thread will extract an item from the global queue (taking its lock) using the FIFO algorithm. If the global queue is empty, then the worker thread puts itself to sleep waiting for something to show up. If it sleeps for a long time, then it will wake itself up and destroy itself, allowing the system to reclaim the resources (kernel object, stacks, TEB) that were used by the thread.</p>
<p>The thread pool will quickly create worker threads so that the number of worker threads is equal to the value pass to <b>ThreadPool</b>'s <b>SetMinThreads </b>method. If you never call this method (and it's recommended that you never call this method), then the default value is equal to the number of CPUs that your process is allowed to use as determined by your process's affinity mask. Usually your process is allowed to use all the CPUs on the machine,<sup>5</sup> so the thread pool will quickly create worker threads up to the number of CPUs on the machine. After this many threads have been created, the thread pool monitors the completion rate of work items and if items are taking a long time to complete (the meaning of which is not documented), it creates more worker threads. If items start completing quickly, then worker threads will be destroyed.</p>
<a name="b752"/><h2>Cache Lines and False Sharing</h2>
<p>To improve the performance of repeatedly accessing memory, today's CPUs have on-chip cache memory. Accessing this memory is extremely fast, especially when compared to the speed of the CPU accessing motherboard memory. The first time that a thread reads some value in memory, the CPU fetches the desired value from the motherboard's memory and</p>
<p>However, as of CLR version 4, 64 CPUs are used at most when running in a 64-bit process, and 32 CPUs are used at most when running in a 32-bit process.</p>
<p>stores it in the CPU's on-chip cache In fact, to improve performance more, the CPU logically divides all memory into what is called a cache line. For the CPU in my computer, a cache line consists of 64 bytes, so the CPU fetches and stores 64-byte blocks from RAM.<sup>6</sup> Therefore, if your application needs to read an <b>Int32 </b>value, the 64 bytes that contain the <b>Int32 </b>will be fetched. Fetching more bytes than required usually results in a performance improvement because most applications tend to access data that is stored around other data the application is already accessing This neighboring data will now be in the CPU's cache, avoiding RAM access.</p>
<p>However, if two or more cores access bytes in the same cache line, then the cores must communicate with each other and effectively pass the cache line from core to core so that multiple cores are not manipulating adjacent bytes at the same time This can have an awful impact on the performance of your compute-bound operation Let me demonstrate this with some code:</p>
<p><code>internal static class FalseSharing { private class Data {<br/>
// These two fields are adjacent and (most likely) in the same cache line public Int32 fieldl; public Int32 field2;<br/>
}<br/>
private const Int32 iterations = 100000000; // 100 million private static Int32 s_operations = 2; private static Int64 s_startTime;<br/>
public static void Main() {<br/>
// Allocate an object and record the start time<br/>
Data data = new Data();<br/>
s_startTime = Stopwatch.GetTimestampO;<br/>
// Have 2 threads access their own fields within the structure ThreadPoo1.QueueUserWorkItem(o =&gt; AccessData(data, 0)); ThreadPoo1.QueueUserWorkItem(o =&gt; AccessData(data, 1));<br/>
// For testing, block the Main thread Console.ReadLineO;<br/>
}<br/>
private static void AccessData(Data data, Int32 field) {<br/>
// The threads in here each access their own field within the Data object for (Int32 x = 0; x &lt; iterations; x++)<br/>
if (field == 0) data.field1++; else data.field2++;<br/>
// Whichever thread finishes last, shows the time it took if (Interlocked.Decrement(ref s_operations) == 0)<br/>
Console.WriteLineC'Access time: {0:N0}&quot;, Stopwatch.GetTimestampO - s_startTime);<br/>
}<br/>
}</code></p>
<p>You can determine the number of bytes in a CPU's cache line by calling Win32's <b>GetProcessorInformation </b>function. My Power Threading library contains a managed wrapper over this function, making it easy to call from managed code.</p>
<p>In this code, a <b>Data </b>object is constructed containing two fields. Most likely, these two fields will reside in the same cache line. Then, two thread pool threads go and execute the <b>AccessData </b>method. One thread will add <b>1 </b>to <b>Data</b>'s <b>field1 </b>field 100,000,000 times, and the other thread will do the same to the <b>field2 </b>field. As each thread finishes, it decrements the value in the <b>s_Operations </b>field; whichever thread decrements the field to <b>0 </b>is the last thread to finish, and this thread shows how long it took for both threads to complete their work. When I run this on my machine, I get a result of 15,856,074 milliseconds.</p>
<p>Now, let's change the <b>Data </b>class so it looks like this:</p>
<p><code>[StructLayout(LayoutKind.Explicit)] private class Data {<br/>
// These two fields are separated now and no longer in the same cache line<br/>
[FieldOffset(0)]   public Int32 field1;<br/>
[FieldOffset(64)] public Int32 field2;<br/>
}</code></p>
<p>What I have done here is separate the two fields by a cache line (64 bytes). Now, when I run the program, I get a result of 3,415,703 milliseconds. The first version is four times slower because the two fields were part of the same cache line and the CPUs had to keep handing the bytes back and forth to each other! From the program's point of view, the two threads were manipulating different data; but, from the CPU's cache line point of view, the CPUs were manipulating the same data. This is called false sharing. If the CPUs are on different Non-Uniform Memory Access (NUMA) nodes, then the performance impact can be substantially worse. In the second version, the fields were on different cache lines, so the CPUs could each work independently; nothing was shared.</p>
<p>I bring up this discussion to show you that cache lines and false sharing can have an enormous impact on the performance of an application when adjacent data is accessed by multiple threads simultaneously. This is something you should be aware of in performance-conscience scenarios and, if you detect it, you can usually devise a way to avoid it (like my use of the <b>FieldOffset </b>attribute).</p>
<p>Be aware that arrays maintain their length at the beginning of the array's memory, which is right next to the first few array elements. When you access any array element, the CLR verifies that the index you are using is within the array's length. This means that accessing an array's element always involves accessing the array's length, too. Therefore, to avoid additional false sharing, you should avoid having one thread write to the first few elements in the array while other threads are accessing other elements in the array.</p>
<mbp:pagebreak/>
<a name="Chapter27"/>
<h1>Chapter 27: I/O-Bound Asynchronous Operations</h1>
<p><b>In this chapter:</b></p>
<a href="#b755">How Windows Performs I/O Operations</a><br/>
<a href="#b761">The CLR's Asynchronous Programming Model (APM)</a><br/>
<a href="#b770">Applications and Their Threading Models</a><br/>
<a href="#b773">Implementing a Server Asynchronously</a><br/>
<a href="#b774">The APM and Compute-Bound Operations</a><br/>
<a href="#b780">I/O Request Priorities</a><br/>
<a href="#b783">Converting the IAsyncResult APM to a Task</a><br/>
<a href="#b784">The Event-Based Asynchronous Pattern</a><br/>
<p>The previous chapter focused on ways to perform compute-bound operations asynchronously, allowing the thread pool to schedule the tasks onto multiple cores so that multiple threads can work concurrently, which increases throughput while using system resources efficiently. In this chapter, we'll focus on performing I/O-bound operations asynchronously, allowing hardware devices to handle the tasks so that threads and the CPU are not used at all This, of course, uses system resources very efficiently because system resources are not required at all. However, the thread pool still plays an important role because, as you'll see, the thread pool threads will process the results of the various I/O operations.</p>
<a name="b755"/><h2>How Windows Performs I/O Operations</h2>
<p>Let's begin by discussing how Microsoft Windows performs synchronous I/O operations. Figure 27-1 represents a computer system with several hardware devices connected to it Each of these hardware devices has its own circuit board, each of which contains a small, special-purpose computer that knows how to control its hardware device. For example, the hard disk drive has a circuit board that knows how to spin up the drive, seek the head to the right track, read or write data from or to the disk, and transfer the data to or from your computer's memory.</p>
<p><b>Figure 27-1 </b>How Windows performs a synchronous I/O operation</p>
<p>In your program, you open a disk file by constructing a <b>FileStream </b>object. Then you call the <b>Read </b>method to read data from the file. When you call <b>FileStream</b>'s <b>Read </b>method, your thread transitions from managed code to native/user-mode code and <b>Read </b>internally calls the Win32 <b>ReadFile </b>function (#1). <b>ReadFile </b>then allocates a small data structure called an I/O Request Packet (IRP) (#2). The IRP structure is initialized to contain the handle to the file, an offset within the file where bytes will start to be read from, the address of a <b>Byte[] </b>that should be filled with the bytes being read, the number of bytes to transfer, and some other less interesting stuff</p>
<p><b>ReadFile </b>then calls into the Windows kernel by having your thread transition from native/ user-mode code to native/kernel-mode code, passing the IRP data structure to the kernel (#3) From the device handle in the IRP, the Windows kernel knows which hardware device the I/O operation is destined for, and Windows delivers the IRP to the appropriate device driver's IRP queue (#4) Each device driver maintains its own IRP queue that contains I/O requests from all processes running on the machine. As IRP packets show up, the device driver passes the IRP information to the circuit board associated with the actual hardware device. The hardware device now performs the requested I/O operation (#5).</p>
<img src="89.jpg"/>
<p>But here is the important part: While the hardware device is performing the I/O operation, your thread that issued the I/O request has nothing to do, so Windows puts your thread to sleep so that it is not wasting CPU time (#6) This is great, but while your thread is not wasting time, it is wasting space (memory), as its user-mode stack, kernel-mode stack, thread environment block (TEB), and other data structures are sitting in memory but are not being accessed at all. This is bad.</p>
<p>Ultimately, the hardware device will complete the I/O operation, and then Windows will wake up your thread, schedule it to a CPU, and let it return from kernel mode to user mode, and then back to managed code (#7, #8, and #9). <b>FileStream</b>'s <b>Read </b>method now returns an <b>Int32, </b>indicating the actual number of bytes read from the file so that you know how many bytes you can examine in the <b>Byte[] </b>that you passed to <b>Read.</b></p>
<p>Let's imagine that you are implementing a Web application and as each client request comes in to your server, you need to make a database request When a client request comes in, a thread pool thread will call into your code. If you now issue a database request synchronously, the thread will block for an indefinite amount of time waiting for the database to respond with the result. If during this time another client request comes in, the thread pool will have to create another thread and again this thread will block when it makes another database request. As more and more client requests come in, more and more threads are created, and all these threads block waiting for the database to respond The result is that your Web server is allocating lots of system resources (threads and their memory) that are barely even used!</p>
<p>And to make matters worse, when the database does reply with the various results, threads become unblocked and they all start executing. But since you might have lots of threads running and relatively few CPU cores, Windows has to perform frequent context switches, which hurts performance even more. This is no way to implement a scalable application.</p>
<p>Now, let's discuss how Windows performs asynchronous I/O operations. In Figure 27-2, I have removed all the hardware devices except the hard disk from the picture, I introduce the common language runtime's (CLR's) thread pool, and I've modified the code slightly. I still open the disk file by constructing a <b>FileStream </b>object, but now I pass in the <b>FileOptions. Asynchronous </b>flag. This flag tells Windows that I want my read and write operations against the file to be performed asynchronously.</p>
<p><b>Figure 27-2 </b>How Windows performs an asynchronous I/O operation</p>
<p>To read data from the file, I now call <b>BeginRead </b>instead of <b>Read </b>. Like <b>Read, BeginRead </b>calls Win32's <b>ReadFile </b>function (#1). <b>ReadFile </b>allocates its IRP, initializes it just like it did in the synchronous scenario (#2), and then passes it down to the Windows kernel (#3). Windows adds the IRP to the hard disk driver's IRP queue (#4), but now, instead of blocking your thread, your thread is allowed to return to your code; your thread immediately returns from its call to <b>BeginRead </b>(#5, #6, and #7). Now, of course, the IRP has not necessarily been processed yet, so you cannot have code after <b>BeginRead </b>that attempts to access the bytes in the passed-in <b>Byte[],</b></p>
<p>Now you might ask, when and how do you process the data that will ultimately be read? Well, when you call <b>BeginRead, </b>you pass it the name of a callback method as an argument <b>(CallbackMethod </b>in my example). The delegate referring to your callback method is effectively passed inside the IRP all the way down to the device driver. When the hardware device completes processing the IRP (a), it will queue the IRP's delegate into the CLR's thread pool (b). Sometime in the future, a thread pool thread will extract the completed IRP and invoke your callback method (c). <sup>1</sup> So now you know when the operation has completed, and inside this method, you can safely access the data inside the <b>Byte[],</b></p>
<p>Completed IRPs are extracted from the thread pool using a first-in-first-out (FIFO) algorithm.</p>
<p>1</p>
<img src="90.jpg"/>
<p>Now that you understand the basics, let's put it all into perspective. Let's say that a client request comes in, and our server makes an asynchronous database request. As a result, our thread won't block, and it will be allowed to return to the thread pool so that it can handle more incoming client requests. So now we have just one thread handling all incoming client requests When the database server responds, its response is also queued into the thread pool, so our thread pool thread will just process it at some point and ultimately send the necessary data back to the client At this point, we have just one thread processing all client requests and all database responses. Our server is using very few system resources and it is still running as fast as it can, especially since there are no context switches!</p>
<p>If items appear in the thread pool quicker than our one thread can process them all, then the thread pool might create additional threads. The thread pool will quickly create one thread per CPU on the machine. So on a quad-processor machine, four client requests/database responses (in any combination) are running on four threads without any context switching. <sup>2</sup></p>
<p>However, if any of these threads voluntarily block (by invoking a synchronous I/O operation, calling <b>Thread.Sleep, </b>or waiting to acquire a thread synchronization lock), then Windows notifies the thread pool that one of its threads has stopped running. The thread pool now realizes that the CPUs are undersaturated and creates a new thread to replace the blocked thread. This, of course, is not ideal because creating a new thread is very expensive in terms of both time and memory.</p>
<p>What's worse is that the blocked thread might wake up and now the CPUs are oversaturated again and context switching must occur, decreasing performance. However, the thread pool is smart here As threads complete their processing and return to the pool, the thread pool won't let them process new work items until the CPUs become exactly saturated again, thereby reducing context switches and improving performance. And if the thread pool later determines that it has more threads in it than it needs, it lets the extra threads kill themselves, thereby reclaiming the resources that these threads were using.</p>
<p>Internally, the CLR's thread pool uses a Windows resource called an I/O Completion Port to elicit the behavior that I've just described The CLR creates an I/O Completion Port when it initializes and, as you open hardware devices, these devices can be bound to the I/O Completion Port so that device drivers know where to queue the completed IRPs. If you want to understand more about this mechanism, I recommend my book Windows via C/C++, 5th Edition (Microsoft Press, 2007).</p>
<p>This is assuming that other threads are not running on the computer, which is true most of the time since most computers are running at far less than 100% CPU usage. And CPU usage can be at 100% and this will still work as explained if the running threads have lower priorities. If other threads are running, then context switching does occur. This is bad for performance reasons, but it is good for reliability reasons. Remember that Windows gives each process at least one thread and performs context switches to ensure that an application whose thread is an infinite loop doesn't stop other applications' threads from running.</p>
<p>In addition to minimal resource usage and reduced context switches, we get many other benefits when performing I/O operations asynchronously. Whenever a garbage collection starts, the CLR must suspend all the threads in the process Therefore, the fewer threads we have, the faster the garbage collector runs In addition, when a garbage collection occurs, the CLR must walk all the threads' stacks looking for roots Again, the fewer threads there are, the fewer stacks there are, and this also makes the garbage collection faster But, in addition, if our threads don't block while processing work items, the threads tend to spend most of their time waiting in the thread pool. So when a garbage collection occurs, the threads are at the top of their stack, and walking each thread's stack for roots takes very little time.</p>
<p>Also, when you debug an application, Windows suspends all threads in the debuggee when you hit a breakpoint Then, when you continue executing the debuggee, Windows has to resume all its threads, so if you have a lot of threads in an application, single-stepping through the code in a debugger can be excruciatingly slow. Using asynchronous I/O allows you to have just a few threads, improving your debugging performance.</p>
<p>And, here's yet another benefit: Let's say that your application wants to download 10 images from various Web sites, and that it takes 5 seconds to download each image. If you perform this work synchronously (downloading one image after another), then it takes you 50 seconds to get the 10 images. However, if you use just one thread to initiate 10 asynchronous download operations, then all 10 are being performed concurrently and all 10 images will come back in just 5 seconds! That is, when performing multiple synchronous I/O operations, the time it takes to get all the results is the sum of the times required for each individual result However, when performing multiple asynchronous I/O operations, the time it takes to get all the results is the time required to get the single worst-performing operation.</p>
<p>For GUI applications, asynchronous operations offer yet another advantage: The application's user interface doesn't hang and remains responsive to the end user In fact, if you are building a Silverlight application, you must perform all I/O operations asynchronously because the Silverlight version of the Framework Class Library (FCL) doesn't even offer methods that perform synchronous I/O operations. This was done purposely because Silverlight runs in a Web browser, like Windows Internet Explorer, and a thread issuing a synchronous I/O operation could block waiting for a Web server to reply. If this happens, the entire Web browser would be frozen. The user might not even be able to switch to another tab to work with a different Web site. In fact, this is a big reason why Windows Internet Explorer 8 creates a different process for each tab. Now one tab (not running Silverlight code) could stop responding, but other tabs still respond. But creating a separate process per tab is very resource-intensive, all in the name of keeping the UI responsive.<sup>3</sup></p>
<p>For the record, there is also a security advantage to having each tab run in its own process.</p>
<a name="b761"/><h2>The CLR's Asynchronous Programming Model (APM)</h2>
<p>Performing asynchronous operations is the key to building high-performance, scalable applications that allow you to use very few threads to execute a lot of operations. And when coupled with the thread pool, asynchronous operations allow you to take advantage of all of the CPUs that are in the machine. Realizing the enormous potential here, Microsoft's CLR team designed a pattern that would make it easy for developers to take advantage of this capability. This pattern is called the Asynchronous Programming Model (APM).</p>
<p>Personally, I love the APM because it is relatively easy to learn, simple to use, and is supported by many types in the FCL. Here are some examples:</p>
<p>&#9632; All <b>System.IO.Stream</b>-derived classes that communicate with hardware devices (including <b>FileStream </b>and <b>NetworkStream) </b>offer <b>BeginRead </b>and <b>BeginWrite </b>methods. Note that <b>Stream</b>-derived classes that do not communicate with hardware devices (including <b>BufferedStream, MemoryStream, </b>and <b>CryptoStream) </b>also offer <b>BeginRead </b>and <b>BeginWrite </b>methods to fit into the APM. However, the code in these methods performs compute-bound operations, not I/O-bound operations, and therefore a thread is required to execute these operations.</p>
<p>&#9632; The <b>System.Net.Dns </b>class offers <b>BeginGetHostAddresses, BeginGetHostByName, BeginGetHostEntry, </b>and <b>BeginResolve </b>methods.</p>
<p>&#9632; The <b>System.Net.Sockets.Socket </b>class offers <b>BeginAccept, BeginConnect, BeginDisconnect, BeginReceive, BeginReceiveFrom, BeginReceiveMessageFrom, BeginSend, BeginSendFile, </b>and <b>BeginSendTo </b>methods.</p>
<p>&#9632; All <b>System.Net.WebRequest</b>-derived classes (including <b>FileWebRequest, FtpWebRequest, </b>and <b>HttpWebRequest) </b>offer <b>BeginGetRequestStream </b>and <b>BeginGetResponse </b>methods.</p>
<p>&#9632; The <b>System.IO.Ports.SerialPort </b>class has a read-only <b>BaseStream </b>property that returns a <b>Stream, </b>which, as you know, offers <b>BeginRead </b>and <b>BeginWrite </b>methods.</p>
<p>&#9632; The <b>System.Data.SqlClient.SqlCommand </b>class offers <b>BeginExecuteNonQuery, BeginExecuteReader, </b>and <b>BeginExecuteXmlReader </b>methods.</p>
<p>Furthermore, all delegate types define a <b>BeginInvoke </b>method for use with the APM. And finally, tools (such as WSDL.exe and SvcUtil.exe) that produce Web service proxy types also generate <b>BeginXxx </b>methods for use with the APM. By the way, there is a corresponding <b>EndXxx </b>method for each and every <b>BeginXxx </b>method. As you can see, support for the APM is pervasive throughout the FCL.</p>
<p>To synchronously read bytes from a <b>FileStream, </b>you'd call its <b>Read </b>method, which is prototyped as follows:</p>
<p><code>public Int32 Read(Byte[] array, Int32 offset, Int32 count)</code></p>
<p>Calling a function that internally performs synchronous I/O puts your application in an unpredictable state as you have no idea when (or even if) the method will return What if the file you opened was on a network server and just before calling <b>Read, </b>the server lost power? Now when will <b>Read </b>return?</p>
<p>And so, if you are interested in writing responsive, robust, and scalable software, you should not call methods that perform synchronous I/O; you should instead call methods that perform asynchronous I/O. To asynchronously perform an I/O operation, you would call a <b>BeginXxx </b>method like <b>FileStream</b>'s <b>BeginRead </b>method:</p>
<p><code>IAsyncResult BeginRead(Byte[] array, Int32 offset, Int32 numBytes, AsyncCallback userCallback, Object stateObject)</code></p>
<p>Notice that <b>BeginRead</b>'s first three parameters are identical to those of <b>Read. </b>And, in fact, every <b>BeginXxx </b>method has the same parameters as its synchronous counterpart method. But, every <b>BeginXxx </b>method has two additional parameters: <b>userCallback </b>and <b>stateObject </b>. The <b>userCallback </b>parameter is of the <b>AsyncCallback </b>delegate type:</p>
<p><code>public delegate void AsyncCallback(IAsyncResult ar);</code></p>
<p>For this parameter, you pass the name of a method (or lambda expression) representing code that you want to be executed by a thread pool thread when the asynchronous I/O operation completes. The last parameter to a <b>BeginXxx </b>method, <b>stateObject, </b>is a reference to any object you'd like forwarded on to your callback method Inside your callback method, you access your <b>objectState </b>by querying the <b>IAsyncResult </b>interface's read-only <b>AsyncState </b>property.</p>
<p>All <b>BeginXxx </b>methods return an object that implements the <b>System </b>. <b>IAsyncResult </b>interface. When you call a <b>BeginXxx </b>method, it constructs an object that uniquely identifies your I/O request, queues up the request to the Windows device driver, and returns to you a reference to the <b>IAsyncResult </b>object. You can think of this object as your receipt. You can actually ignore the object reference returned from <b>BeginXxx </b>because the CLR internally holds a reference to the <b>IAsyncResult </b>object as well. When the operation completes, a thread pool thread will invoke your callback method, passing to it a reference to the internally held <b>IAsyncResult </b>object.</p>
<p>Inside your method, you'll call the corresponding <b>EndXxx </b>method, passing it the <b>IAsyncResult </b>object. The <b>EndXxx </b>method returns the same result that you would have gotten if you had called the synchronous method. For example, <b>FileStream</b>'s <b>Read </b>method returns an <b>Int32 </b>that indicates the number of bytes actually read from the stream. <b>FileStream</b>'s <b>EndRead </b>method's return value has the same meaning:</p>
<p><code>Int32 EndRead(IAsyncResult result);   // Returns number of bytes read from the stream Below is the code for a named-pipe server class, <b>PipeServer, </b>which is implemented using</code></p>
<p>the APM:</p>
<p><code>internal sealed class PipeServer {<br/>
// Each server object performs asynchronous operations on this pipe private readonly NamedPipeServerStream m_pipe = new NamedPipeServerStream( &quot;Echo&quot;, PipeDirection.InOut, -1, PipeTransmissionMode.Message, PipeOptions.Asynchronous | PipeOptions.WriteThrough);<br/>
public PipeServer() {<br/>
// Asynchronously accept a client connection m_pipe.BeginWaitForConnection(ClientConnected, null);<br/>
}<br/>
private void ClientConnected(IAsyncResult result) { // A client connected, let's accept another client new PipeServer(); // Accept another client<br/>
// Accept the client connection m_pipe.EndWaitForConnection(result);<br/>
// Asynchronously read a request from the client Byte[] data = new Byte[1000];<br/>
m_pipe.BeginRead(data, 0, data.Length, GotRequest, data);<br/>
}<br/>
private void GotRequest(IAsyncResult result) { // The client sent us a request, process it. Int32 bytesRead = m_pipe.EndRead(result); Byte[] data = (Byte[])result.AsyncState;<br/>
// My sample server just changes all the characters to uppercase // But, you can replace this code with any compute-bound operation data = Encoding.UTF8.GetBytes(<br/>
Encoding.UTF8.GetString(data, 0, bytesRead).ToUpper().ToCharArrayO);<br/>
// Asynchronously send the response back to the client m_pipe.BeginWrite(data, 0, data.Length, WriteDone, null);<br/>
}<br/>
private void WriteDone(IAsyncResult result) {<br/>
// The response was sent to the client, close our side of the connection<br/>
m_pipe.EndWrite(result);<br/>
m_pipe.Close();<br/>
}<br/>
}</code></p>
<p>An instance of this class must be created before a client connects to the server because it is the constructor's call to <b>BeginWaitForConnection </b>that allows a client to connect. Once a client connects, the <b>ClientConnect </b>method will be called by a thread pool thread and a new instance of the <b>PipeServer </b>class is created so that additional clients can connect. Meanwhile, the <b>ClientConnected </b>method will call <b>BeginRead, </b>telling the network device driver to listen for incoming data from this client and put that data into the specified <b>Byte[],</b></p>
<p>When the client sends the data, some thread pool thread will call the <b>GotRequest </b>method This method will gain access to the <b>Byte[] </b>(by querying the <b>AsyncState </b>property) and then process the data. In my example, I use a UTF-8 encoder to convert the <b>Byte[] </b>into a <b>String,</b></p>
<p>uppercase the characters in the <b>String, </b>and then convert the <b>String </b>back to a <b>Byte[], </b>However, you can replace this code with your own compute-bound operation so that the server does whatever you need it to do Then <b>GotRequest </b>sends the output data back to the client by calling <b>BeginWrite. </b>When the device driver has finished sending the data to the client, some thread pool thread will call <b>WriteDone, </b>which then closes the pipe and terminates the connection.</p>
<p>Notice that all the methods follow the same pattern: They end with a call to a <b>BeginXxx </b>method (except the last method, <b>WriteDone) </b>and they start with a call to an <b>EndXxx </b>method (except the constructor). Between the <b>EndXxx </b>and <b>BeginXxx </b>methods, I perform only compute-bound work; the I/O operations are at the &quot;borders&quot; of the methods, so now, threads never block After each method, the threads return back to the thread pool where they can handle incoming client requests or incoming network responses And if the thread pool gets busy with work, then it will automatically create multiple threads to handle the workload洋y server scales automatically based on workload and based on the number of CPUs in the machine!</p>
<p>I created my server application as a console application and it initializes itself like this:</p>
<p><code>public static void Main() { // Start 1 server per CPU<br/>
for (Int32 n = 0; n &lt; Environment.ProcessorCount; n++) new PipeServer();<br/>
Console.WriteLineC'Press &lt;Enter&gt; to terminate this server application.&quot;); Console.ReadLineO;<br/>
}</code></p>
<p>Now, let me show you the code for a named-pipe client class that is also implemented using the APM. Notice that the <b>PipeClient </b>class is structured identically to the <b>PipeServer </b>class.</p>
<p><code>internal sealed class PipeClient {<br/>
// Each client object performs asynchronous operations on this pipe private readonly NamedPipeClientStream m_pipe;<br/>
public PipeClient(String serverName, String message) { m_pipe = new NamedPipeClientStream(serverName, &quot;Echo&quot;,<br/>
PipeDirection.InOut, PipeOptions.Asynchronous | PipeOptions.WriteThrough); m_pipe.Connect(); // Must Connect before setting ReadMode m_pipe.ReadMode = PipeTransmissionMode.Message;<br/>
// Asynchronously send data to the server Byte[] output = Encoding.UTF8.GetBytes(message); m_pipe.BeginWrite(output, 0, output.Length, WriteDone, null);<br/>
}<br/>
private void WriteDone(IAsyncResult result) { // The data was sent to the server m_pipe.EndWrite(result);<br/>
// Asynchronously read the server's response Byte[] data = new Byte[1000];<br/>
m_pipe.BeginRead(data, 0, data.Length, GotResponse, data);<br/>
}<br/>
private void GotResponse(IAsyncResult result) {<br/>
// The server responded, display the response and close out connection Int32 bytesRead = m_pipe.EndRead(result);<br/>
Byte[] data = (Byte[])result.AsyncState;<br/>
Console.WriteLineC'Server response: &quot; + Encoding.UTF8.GetString(data, 0, bytesRead)); m_pipe.Close();<br/>
}<br/>
}</code></p>
<p>And, my client console application makes one hundred calls into the server using this code:</p>
<p><code>public static void Main() {<br/>
// Now make 100 client requests against the server for (Int32 n = 0; n &lt; 100; n++)<br/>
new PipeClientC'localhost&quot;, &quot;Request #&quot; + n);<br/>
// Since all the requests are issued asynchronously, the constructors are likely // to return before all the requests are complete. The call below stops the // application from terminating until we see all the responses displayed. Console.ReadLineO;<br/>
}</code></p>
<p>Frequently, developers implement servers to use one thread per client request. However, a 32-bit process can create no more than about 1,360 threads before running out of virtual address space. This means that a server using the one-thread-per-client model can't operate on more than 1,360 clients simultaneously. However, I modified my program to construct a bunch of <b>PipeServer </b>objects, and in a 32-bit process, I was able to create over 4 million of them before running out of memory. So the asynchronous model allows many more concurrent clients, uses fewer resources, processes clients faster (due to reduced context switches), improves garbage collection time, and improves debugging performance, too! What else could you ask for?</p>
<h2>The AsyncEnumerator Class</h2>
<p>Well, one thing you could ask for is an easier way to do asynchronous programming. The APM's programming model is cumbersome, which is the main reason why a lot of developers don't use it. Here are some of the problems with it:</p>
<p>&#9632; You must split your code up into many callback methods.</p>
<p>&#9632; You have to avoid using argument and local variables because these variables are allocated on a thread's stack and can't be accessed by another thread or by another method.</p>
<p>&#9632; Many C# language constructs, like <b>try/catch/finally, using, for, do, while, </b>and</p>
<p><b>foreach, </b>can't be used if you want to start the construct as one method and end it in another method. For example, in my <b>Server </b>class, I'd like to use C#'s <b>using </b>statement to open the pipe and then have it automatically be closed in a <b>finally </b>block. However, I can't use <b>using </b>because I open the pipe in <b>Server</b>'s constructor and I close it in a different method, <b>WriteDone </b>.</p>
<p>&#9632; It's hard to implement other features that many developers typically need such as coordinating multiple concurrent operations, supporting cancellation and timeout, and marshaling work to the GUI thread to update controls.</p>
<p>These are the main reasons why many developers avoid the APM. However, I have created a class, <b>AsyncEnumerator, </b>which simplifies all of this and fixes all the problems mentioned above. In a nutshell, my <b>AsyncEnumerator </b>class allows you to perform asynchronous operations using a synchronous programming model by leveraging C#'s iterator language feature. The class is part of my Power Threading library and is completely free to use. Versions of this library exist for the desktop CLR, Silverlight, and the Microsoft .NET Compact Framework. You can download the latest version of the library and sample code from <a href="http://Wintellect.com/PowerThreading.aspx">http://Wintellect.com/PowerThreading.aspx</a>. This Web page contains links to my Concurrent Affairs column in MSDN Magazine, where I explain how my <b>AsyncEnumerator </b>class works. There are also links to some videos I did showing how to use it, and a link to a newsgroup where I offer free technical support.</p>
<p>For now, let me just share some of the features that the <b>AsyncEnumerator </b>class offers:</p>
<p>&#9632; It implements the APM itself so it easily integrates with all the Microsoft .NET Framework technologies, such as ASP.NET and Windows Communication Foundation (WCF). This also allows composition of asynchronous subroutines, as one <b>AsyncEnumerator </b>can invoke another.</p>
<p>&#9632; It coordinates multiple concurrent asynchronous operations. That is, you can issue many asynchronous operations, and the <b>AsyncEnumerator </b>can notify you after all of them have completed or notify you as each one completes.</p>
<p>&#9632; It supports discard groups, which allow you to issue a set of asynchronous operations and have the <b>AsyncEnumerator </b>object automatically throw away the results as they complete For example, you could request the temperature of London from three different Web servers within a single discard group Whichever server responds the fastest gives your application the information it needs to continue processing. Then you can cancel the remaining operations that are part of that discard group.</p>
<p>&#9632; It allows you to cancel a set of asynchronous operations automatically by calling each operation's <b>EndXxx </b>methods (and swallowing exceptions) for you if you don't care about the results. This is particularly good for GUI applications because it allows users to cancel the operations if they get tired of waiting for the results. In addition, you can have the cancel occur automatically after a timeout interval that you specify. This is particularly good for server applications that want to respond to the client within a certain period of time with whatever information the server has.</p>
<p>&#9632; It frees you from having to worry about your application's threading model (as discussed in the &quot;Applications and their Threading Models&quot; section later in this chapter). For example, in a GUI application, the <b>AsyncEnumerator </b>invokes your code on the GUI thread by default so you can update UI controls. For an ASP.NET Web Form or XML Web Service application, the <b>AsyncEnumerator </b>automatically ensures that your code is running under the client's culture and identity.</p>
<p>&#9632; It has rich error-handling support If your iterator returns and an asynchronous operation later completes, the <b>AsyncEnumerator </b>class throws an exception notifying you that there is no way for the <b>EndXxx </b>method to be called and therefore your application is leaking resources.</p>
<p>&#9632; It has rich debugging support Typically, an application will have many <b>AsyncEnumerator </b>objects in memory. This is especially true of server applications. In a debugger, you can query the <b>AsyncEnumerator</b>'s static <b>GetInProgressList </b>method, which returns a list of all the <b>AsyncEnumerator </b>objects currently in existence. This list is sorted with the object that has been waiting the longest for an operation to complete at the top If your application appears to be hung, looking at the item at the top of the list will usually take you right to the line in your code that is waiting for an operation to complete. In addition, when you look at an individual <b>AsyncEnumerator </b>object in the debugger, it displays a user-definable tag identifying the operation, the timestamp of the last asynchronous operation it performed, which operations have completed, and which operations have not completed yet. It also shows you the source code file and line within that file where the asynchronous operations were initiated.</p>
<p>Here is what the pipe server code looks like when implemented for use with my <b>AsyncEnumerator </b>class<sup>4</sup>:</p>
<p><code>private static IEnumerator&lt;Int32&gt; PipeServerAsyncEnumerator(AsyncEnumerator ae) { // Each server object performs asynchronous operations on this pipe using (var pipe = new NamedPipeServerStream(<br/>
&quot;Echo&quot;, PipeDirection.InOut, -1, PipeTransmissionMode.Message,<br/>
PipeOptions.Asynchronous | PipeOptions.WriteThrough)) {<br/>
// Asynchronously accept a client connection pipe.BeginWaitForConnection(ae.End(), null); yield return 1;<br/>
// A client connected, let's accept another client var aeNewClient = new AsyncEnumerator();<br/>
aeNewClient.BeginExecute(PipeServerAsyncEnumerator(aeNewClient), aeNewClient.EndExecute);<br/>
// Accept the client connection<br/>
pipe.EndWaitForConnection(ae.DequeueAsyncResult());<br/>
// Asynchronously read a request from the client Byte[] data = new Byte[1000];</code></p>
<p>The sample code for this book contains the pipe client code re-implemented to use <b>AsyncEnumerator </b>This version of the code follows the same structure shown here.</p>
<p><code>pipe.BeginRead(data, 0, data.Length, ae.End(), null); yield return 1;<br/>
// The client sent us a request, process it.<br/>
Int32 bytesRead = pipe.EndRead(ae.DequeueAsyncResult());<br/>
// My sample server just changes all the characters to uppercase // But, you can replace this code with any compute-bound operation data = Encoding.UTF8.GetBytes(<br/>
Encoding.UTF8.GetString(data, 0, bytesRead).ToUpper().ToCharArray());<br/>
// Asynchronously send the response back to the client pipe.BeginWrite(data, 0, data.Length, ae.End(), null); yield return 1;<br/>
// The response was sent to the client, close our side of the connection pipe.EndWrite(ae.DequeueAsyncResult()); } // Close happens in a finally block now!<br/>
}</code></p>
<p>There are several things to notice about this new version of the code:</p>
<p>&#9632; All the code is in one method as opposed to lots of methods spread out within a class Since there is no class, there are no fields; all the variables are local variables.</p>
<p>&#9632; Where I would have had a method separation, I now have a <b>yield return 1 </b>statement. This allows the thread to return to where it came from so that it can do more work.</p>
<p>&#9632; To every <b>BeginXxx </b>method, I pass <b>ae.End(); </b>this method returns a delegate referring to a method inside the <b>AsyncEnumerator </b>object When the operation completes, the thread pool thread notifies the <b>AsyncEnumerator </b>object, which in turn continues executing your iterator method after the <b>yield return 1 </b>statement.</p>
<p>&#9632; I always pass <b>null </b>as the last argument to every <b>BeginXxx </b>method. Therefore, I never need to call <b>IAsyncResult</b>'s <b>AsyncState </b>property and cast its return value to the right type; I just use the local variables directly.</p>
<p>&#9632; To every <b>EndXxx </b>method, I pass the result of calling <b>ae.DequeueAsyncResult(). </b>This method returns the <b>IAsyncResult </b>object that was passed to the <b>AsyncEnumerator</b></p>
<p>object by the thread pool thread when the asynchronous operation completed.</p>
<p>&#9632; And last, but not least, notice that now I can use C#'s <b>using </b>statement to control the lifetime of the <b>NamedPipeServerStream. </b>This also means that the <b>NamedPipeServerStream </b>object will be closed within a <b>finally </b>block should any other code throw an unhandled exception.</p>
<p>This gives you a good introduction as to what the <b>AsyncEnumerator </b>class can do for you and how it simplifies asynchronous programming. The code above doesn't even show some of the more exciting features If you're interested in learning more about it, I encourage you to visit the Wintellect Web site mentioned earlier.</p>
<h2>The APM and Exceptions</h2>
<p>Whenever you call a <b>BeginXxx </b>method, it could throw an exception, of course. If this happens, you can assume that the asynchronous operation has not been queued, and therefore a thread pool thread will not invoke any callback method that you may have passed to the <b>BeginXxx </b>method.</p>
<p>When a Windows device driver is processing an asynchronous I/O request, it is possible for something to go wrong, and Windows will need to inform your application of this. For example, while sending bytes or waiting for bytes to come in over the network, a timeout could expire. If the data does not come in time, the device driver will want to tell you that the asynchronous operation completed with an error To accomplish this, the device driver posts the completed IRP to the CLR's thread pool and effectively puts an error code in the <b>IAsyncResult </b>object that represents the asynchronous operation. A thread pool thread will then invoke your callback method, passing it the <b>IAsyncResult </b>object. Your callback method will then pass the <b>IAsyncResult </b>object to the appropriate <b>EndXxx </b>method, which will see the error code, convert it to an appropriate <b>Exception</b>-derived object, and then throw this exception object.</p>
<p>The result of all this is that exceptions work the same with asynchronous programming as they do with synchronous programming. However, you usually don't care about exceptions thrown from a <b>BeginXxx </b>call, and you usually do care about exceptions thrown from an <b>EndXxx </b>call The following code demonstrates the use of exception handling and the APM:</p>
<p><code>internal static class ApmExceptionHandling { public static void Main() {<br/>
// Try to access an invalid IP address<br/>
WebRequest webRequest = WebRequest.Create(&quot;<a href="http://0.0.0.0/">http://0.0.0.0/</a>&quot;); webRequest.BeginGetResponse(ProcessWebResponse, webRequest); Console.ReadLine();<br/>
}<br/>
private static void ProcessWebResponse(IAsyncResult result) { WebRequest webRequest = (WebRequest)result.AsyncState;<br/>
WebResponse webResponse = null;<br/>
try {<br/>
webResponse = webRequest.EndGetResponse(result); Console.WriteLine(&quot;Content length: &quot; + webResponse.ContentLength);<br/>
}<br/>
catch (WebException we) {<br/>
Console.WriteLine(we.GetType() + &quot;: &quot; + we.Message);<br/>
}<br/>
finally {<br/>
if (webResponse != null) webResponse.Close();<br/>
}<br/>
}<br/>
}</code></p>
<p>When I run the above program, I get the following output:</p>
<p><code>System.Net.WebException: Unable to connect to the remote server</code></p>
<hr/>
<blockquote><b>Note </b>A common problem exists when performing multiple asynchronous Hypertext Transfer Protocol (HTTP) requests that catches many developers by surprise. The HTTP (RFC 2616) states that a client application should not have more than two simultaneous connections to a single server. The classes in the FCL actually enforce this rule, and any thread trying to create additional connections to a particular server is blocked until one of the two existing connections is closed You should either design your application to have no more than two outstanding connections to a single server at any one time or increase the maximum number of concurrent connections by setting <b>System.Net.ServicePointManager</b>'s static <b>DefaultConnectionLimit </b>property to whatever number your application needs.</blockquote>
<hr/>
<a name="b770"/><h2>Applications and Their Threading Models</h2>
<p>The .NET Framework supports several different kinds of application models, and each application model might impose its own threading model Console applications and Windows Services (which are really console applications; you just don't see the console) do not impose any kind of threading model; that is, any thread can do whatever it wants when it wants.</p>
<p>However, GUI applications, including Windows Forms, Windows Presentation Foundation (WPF), and Silverlight, impose a threading model where the thread that created the window is the only thread allowed to update that window. It is common for the GUI thread to spawn off an asynchronous operation so that the GUI thread doesn't block and stop responding to user input like mouse, keystroke, pen, and touch events. However, when the asynchronous operation completes, it completes using a thread pool thread which cannot update the UI showing the results. Somehow, the thread pool thread must have the GUI thread update the UI.</p>
<p>Like console applications, ASP.NET Web Form and XML Web Service applications allow any thread to do whatever it wants When a thread pool thread starts to process a client's request, it can assume the client's culture <b>(System.Globalization.CultureInfo), </b>allowing the Web server to return culture-specific formatting for numbers, dates, and times. <sup>5</sup> In addition, the Web server can assume the client's identity <b>(System.Security.Principal. IPrincipal) </b>so that the server can access only the resources that the client is allowed to access When a thread pool thread spawns an asynchronous operation, it will be completed by another thread pool thread, which will be processing the result of an asynchronous operation While this work is being performed on behalf of the original client request, the culture and identity information doesn't flow to the new thread pool thread by default so any additional work done on behalf of the client is now not using the client's culture and identity information. Ideally, we want the culture and identity information to flow to the other thread pool threads that are still doing work on behalf of the same client.</p>
<p>For more information, see <a href="http://msdn.microsoft.com/en-us/library/bz9tc508.aspx">http://msdn.microsoft.com/en-us/library/bz9tc508.aspx</a>.</p>
<p>Fortunately, the FCL defines a base class, called <b>System.Threading. SynchronizationContext, </b>which solves all these problems. Simply stated, a <b>SynchronizationContext</b>-derived object connects an application model to its threading model. The FCL defines several classes derived from <b>SynchronizationContext, </b>but usually you will not deal directly with these classes; in fact, many of them are not publicly exposed or documented. Here is what the <b>SynchronizationContext </b>class looks like (I show only the members relevant to this discussion):</p>
<p><code>public class SynchronizationContext {<br/>
public static SynchronizationContext Current { get; }<br/>
public virtual void Post(SendOrPostCallback d, object state); // Call asynchronously public virtual void Send(SendOrPostCallback d, object state); // Call synchronously<br/>
}<br/>
// SendOrPostCallback is a delegate defined like this: public delegate void SendOrPostCallback(Object state);</code></p>
<p>For Windows Forms applications, WPF applications, and Silverlight applications, the GUI thread will have a <b>SynchronizationContext</b>-derived class associated with it You can get a reference to this object by having the GUI thread query <b>SynchronizationContext</b>'s static <b>Current </b>property You would then save a reference to this object in some shared variable (like a <b>static </b>field of your own class). Then, whenever a thread pool thread needs to have the GUI thread update the UI, you would have the thread pool thread reference the saved <b>SynchronizationContext</b>-derived object and call its <b>Post </b>method, passing in the method (matching the <b>SendOrPostCallback </b>delegate's signature) that should be invoked by the GUI thread and an argument that should be passed to this method.</p>
<p>I recommend calling the <b>Post </b>method, as it queues up the callback to the GUI thread and allows the thread pool thread to return immediately <b>Send, </b>on the other hand, queues up the callback to the GUI thread and then blocks the thread pool thread until the GUI thread has completed calling the callback. Blocking the thread pool thread will most likely cause the thread pool to create a new thread, increasing resource consumption while decreasing performance. This is why I always avoid calling the <b>Send </b>method.</p>
<p><b>|-</b></p>
<hr/>
<blockquote><b>Note </b>For the curious, here is how the various <b>SynchronizationContext</b>-derived classes get the GUI thread to invoke the <b>SendOrPostCallback </b>method. For Windows Forms, the <b>System. Windows.Forms.WindowsFormsSynchronizationContext </b>class's <b>Post </b>method internally calls <b>System.Windows.Forms.Control</b>'s <b>BeginInvoke </b>method, and its <b>Send </b>method internally calls <b>Control</b>'s <b>Invoke </b>method. For WPF and Silverlight, the <b>System.Windows.Threading. DispatcherSynchronizationContext </b>class's <b>Post </b>method internally calls <b>System.Windows. Threading.Dispatcher</b>'s <b>BeginInvoke </b>method, and its <b>Send </b>method internally calls <b>Dispatcher</b>'s <b>Invoke </b>method.</blockquote>
<hr/>
<p>For ASP.NET Web Form and XML Web Service applications, the thread pool thread that starts running due to an incoming client request will have a <b>SynchronizationContext-</b>derived class associated with it This object contains within it the client's culture and identity information. You can get a reference to this object by having the thread pool thread query <b>SynchronizationContext</b>'s static <b>Current </b>property. You would then save a reference to this object in some field that is a member of the object that is processing the client's request. When another thread pool thread calls back into a method of the class, you would have the thread pool thread reference the saved <b>SynchronizationContext</b>-derived object and call its <b>Post </b>method, passing in the method (matching the <b>SendOrPostCallback </b>delegate's signature) that should be invoked using the client's culture and identity information. This method will be executed by the same thread pool thread that called <b>Post </b>. For ASP.NET applications, the <b>SynchronizationContext</b>-derived type's <b>Post </b>and <b>Send </b>methods perform identically.</p>
<p>For a console or Windows Service application, there will not be a <b>SynchronizationContext-</b>derived object associated with the thread; querying <b>SynchronizationContext</b>'s static <b>Current </b>property will return <b>null.</b></p>
<p>At first, all of this can be very confusing, so I wrote a little method that simplifies things greatly:</p>
<p><code>private static AsyncCallback SyncContextCallbackCAsyncCallback callback) { // Capture the calling thread's SynchronizationContext-derived object SynchronizationContext sc = SynchronizationContext.Current;<br/>
// If there is no SC, just return what was passed in if (sc == null) return callback;<br/>
// Return a delegate that, when invoked, posts to the captured SC a method that<br/>
// calls the original AsyncCallback passing it the IAsyncResult argument<br/>
return asyncResult =&gt; sc.Post(result =&gt; callback((IAsyncResult)result), asyncResult);<br/>
}</code></p>
<p>This method turns a normal <b>AsyncCallback </b>method into an <b>AsyncCallback </b>method that is invoked via the calling thread's <b>SynchronizationContext</b>-derived object, ensuring that the right threading model is used no matter what application model I'm using. <sup>6</sup> Here is a Windows Forms example that uses the APM and my <b>SyncContextCallback </b>method to ensure that everything works correctly:</p>
<p><code>internal sealed class MyWindowsForm : Form { public MyWindowsFormC) {<br/>
Text = &quot;Click in the window to start a Web request&quot;; Width = 400; Height = 100;<br/>
}</code></p>
<p>You might wonder why the .NET Framework doesn't just automatically provide what my <b>SyncContextCallback </b>method does. It wasn't until after .NET Framework version 1. 0 shipped that everyone realized how big a problem this whole &quot;application models have their own threading models&quot; thing was. To address these problems, the <b>SynchronizationContext </b>class was added in .NET Framework version 2. 0. To make this the default behavior now could have potentially broken existing applications, and this is why the &quot;right&quot; behavior isn't the default behavior.</p>
<p><code>protected override void OnMouseClick(MouseEventArgs e) { // The GUI thread initiates the asynchronous Web request<br/>
Text = &quot;Web request initiated&quot;;<br/>
var webRequest = WebRequest.Create(&quot;<a href="http://Wintellect.com/">http://Wintellect.com/</a>&quot;);<br/>
webRequest.BeginGetResponseC<b>SyncContextCallback</b>CProcessWebResponse), webRequest); base.OnMouseClick(e);<br/>
}<br/>
private void ProcessWebResponse(IAsyncResult result) {<br/>
// If we get here, this must be the GUI thread, it's OK to update the UI var webRequest = (WebRequest)result.AsyncState; using (var webResponse = webRequest.EndGetResponse(result)) { Text = &quot;Content length: &quot; + webResponse.ContentLength;<br/>
}<br/>
}<br/>
}</code></p>
<p>Now, see how similar the WPF version is<sup>7</sup>:</p>
<p><code>private sealed class MyWpfWindow : System.Windows.Window { public MyWpfWindow() {<br/>
Title = &quot;Click in the window to start a Web request&quot;; Width = 400; Height = 100;<br/>
}<br/>
protected override void OnMouseDown(MouseButtonEventArgs e) { // The GUI thread initiates the asynchronous Web request Title = &quot;Web request initiated&quot;;<br/>
var webRequest = WebRequest.Create(&quot;<a href="http://Wintellect.com/">http://Wintellect.com/</a>&quot;);<br/>
webRequest.BeginGetResponse<b>(SyncContextCallback</b>(ProcessWebResponse), webRequest); base.OnMouseDown(e);<br/>
}<br/>
private void ProcessWebResponse(IAsyncResult result) {<br/>
// If we get here, this must be the GUI thread, it's OK to update the UI var webRequest = (WebRequest)result.AsyncState; using (var webResponse = webRequest.EndGetResponse(result)) { Title = &quot;Content length: &quot; + webResponse.ContentLength;<br/>
}<br/>
}<br/>
}</code></p>
<a name="b773"/><h2>Implementing a Server Asynchronously</h2>
<p>Earlier in this chapter, I showed my pipe server, which is implemented as a console application, and I implemented it taking advantage of the APM. Other servers using different application models can also be implemented using the APM However, I have run into a lot of people who don't know that this is even possible. So, in this section, I just want to make you aware that you can implement all kinds of servers asynchronously. See the .NET Framework SDK documentation for more details.</p>
<p>By the way, the Silverlight version is practically identical to this. The differences are all related to setting the title and detecting the mouse click; the code related to the APM is absolutely identical to the WPF version.</p>
<p>To implement an ASP.NET Web Form page asynchronously, open your.aspx file and add &quot;Async=true&quot; to your <b>Page </b>directive. Then, inside your code, call the <b>AddOnPreRenderCompleteAsync </b>method (your class inherits this method from <b>System.Web. Ul.Page), </b>passing it the names of <b>BeginXxx </b>and <b>EndXxx </b>methods that you write yourself In your <b>BeginXxx </b>method, start your asynchronous operation and let the thread pool thread return to the pool. Note that even though the thread is returning, the page is not sent back to the client When the asynchronous operation completes, your <b>EndXxx </b>method will be called. Grab the data, update the page's controls, and now the page will be sent back to the client.</p>
<p>To implement an ASP.NET Web Service asynchronously, just implement your Web method as two methods, a <b>BeginXxx </b>method and an <b>EndXxx </b>method, following the pattern described in this chapter Mark both methods with the <b>[WebMethod] </b>attribute.</p>
<p>To implement a Windows Communication Foundation Web Service asynchronously, define <b>BeginXxx </b>and <b>EndXxx </b>methods in your contracts following the pattern described in this chapter Then, mark the <b>BeginXxx </b>method with the <b>[OperationContract(AsyncPattern= true)] </b>attribute.</p>
<p>Let me point out that my <b>AsyncEnumerator </b>class can really simplify your coding when you want to implement a server asynchronously.</p>
<a name="b774"/><h2>The APM and Compute-Bound Operations</h2>
<p>Chapter 26, &quot;Compute-Bound Asynchronous Operations,&quot; showed how to perform compute-bound operations by calling <b>ThreadPool</b>'s <b>QueueUserWorkItem </b>method and also by using the <b>System.Tlireading.Tasks.Task </b>class. Well, in this section, I'll show you how to perform a compute-bound operation using the APM It's unfortunate that the NET Framework offers so many different programming models for accomplishing the same thing, as it is confusing to developers which one to use when And since the multi-core revolution is still in its infancy, I suspect that even more programming models will show up in the future. This is just the way of the world. Eventually, many years from now, I'm sure things will get simpler; but for today and the near future, things will get more complicated. In this chapter's &quot;Programming Model Soup&quot; section, I attempt to compare and contrast the various APMs offered today by the .NET Framework.</p>
<p>You can call any method by using the APM, but first, you need to use a delegate that has the same signature as the method you want to call. For example, let's say you want to call a method that sums up the numbers from 1 to <b>n </b>. This computationally intensive task (which performs no I/O) could take a long time to execute if <b>n </b>is a large value. <sup>8</sup> Here is the <b>Sum </b>method:</p>
<p>Yes, I know that a sum can be calculated quickly for any value of <b>n </b>using this formula: <b>n * (n + 1) / 2 </b>. For this example, let's just forget that this formula exists and do it the old-fashioned way: manually adding up the numbers so that it takes a long time.</p>
<p><code>private static UInt64 Sum(UInt64 n) { UInt64 sum = 0;<br/>
for (UInt64 i = 1; i &lt;= n; { checked {<br/>
// I use checked code so that an OverflowException gets // thrown if the sum doesn't fit in a UInt64. sum += i;<br/>
}<br/>
}<br/>
return sum;<br/>
}</code></p>
<p>If <b>n </b>is large, <b>Sum </b>could take a long time to execute. To keep the UI of my application responsive or to take advantage of other CPUs in the computer, I'd like to execute this method asynchronously. To do this, I use the generic <b>System.Func&lt;T, TResult&gt; </b>delegate that accepts two type parameters; one for the argument and one for the return type:</p>
<p><code>public delegate TResult Func&lt;T, TResult&gt;(T arg);</code></p>
<p>You'll recall from the delegate discussion in Chapter 17, &quot;Delegates,&quot; that the C# compiler compiles this line of code into a class definition that logically looks like this:</p>
<p><code>public sealed class Func&lt;T, TResult&gt; : MulticastDelegate { public Func(Object object, IntPtr method); public TResult Invoke(T arg);<br/>
public IAsyncResult BeginInvoke(T arg, AsyncCallback callback, Object object); public TResult EndInvoke(IAsyncResult result);<br/>
}</code></p>
<p>When you define a delegate in C# source code, the compiler always produces a class that has <b>BeginInvoke </b>and <b>EndInvoke </b>methods The <b>BeginInvoke </b>method has the same parameters as the delegate definition, with two additional parameters at the end: <b>AsyncCallback </b>and <b>Object </b>All <b>BeginInvoke </b>methods return an <b>IAsyncResult </b>The <b>EndInvoke </b>method has one parameter, an <b>IAsyncResult, </b>and the <b>EndInvoke </b>method returns whatever data type the delegate's signature returns.</p>
<p>Now that you understand all of this, using a delegate to execute a compute-bound operation is trivial because it follows the APM pattern we've been talking about Here is some code that shows how to call <b>Sum </b>asynchronously:</p>
<p><code>public static void Main() {<br/>
// Initialize a delegate variable to refer to the method we want to call asynchronously Func&lt;UInt64, UInt64&gt; sumDelegate = Sum;<br/>
// Call the method using a thread pool thread sumDelegate.BeginInvoke(1000000000, SumIsDone, sumDelegate);<br/>
// Executing some other code here would be useful...<br/>
// For this demo, I'll just suspend the primary thread Console.ReadLine();<br/>
}</code></p>
<p>The <b>sumDelegate </b>variable is first initialized to refer to the method you want to call asynchronously. Then <b>BeginInvoke </b>is called to initiate the asynchronous calling of the method. Internally, the CLR constructs an <b>IAsyncResult </b>object to identify the asynchronous operation. As you know, I/O operations are queued to a Windows device driver; however, a delegate's <b>BeginInvoke </b>method queues compute-bound operations to the CLR's thread pool by internally calling <b>ThreadPool</b>'s <b>QueueUserWorkItem </b>. Finally, <b>BeginInvoke </b>returns the <b>IAsyncResult </b>object to its caller (which usually ignores it).</p>
<p>Since <b>BeginInvoke </b>queued the operation to the CLR's thread pool, a thread pool thread will wake, dequeue the work item, and call the compute-bound method <b>(Sum, </b>in this example) Normally, when a thread pool thread returns from executing a method, the thread returns back to the pool. However, in my example, <b>BeginInvoke </b>was called, passing in the name of a method <b>(SumIsDone) </b>for the second-to-last parameter Because of this, when <b>Sum </b>returns, the thread pool thread does not return back to the pool; instead, it now calls <b>SumIsDone </b>In other words, the callback is called when the compute-bound operation has completed, just as it would be called when an I/O-bound operation has completed. Here is what my <b>SumIsDone </b>method looks like:</p>
<p><code>private static void SumIsDone(IAsyncResult ar) {<br/>
// Extract the sumDelegate (state) from the IAsyncResult object var sumDelegate = (Func&lt;UInt64, UInt64&gt;) ar.AsyncState;<br/>
try {<br/>
// Get the result and display it<br/>
Console.WriteLineC'Sum's result: &quot; + sumDelegate.EndInvoke(result));<br/>
}<br/>
catch (OverflowException) {<br/>
Console.WriteLineC'Sum's result is too large to calculate&quot;);<br/>
}<br/>
}</code></p>
<h2>APM Considerations</h2>
<p>All in all, I am a huge fan of the APM, but I must admit that it does have some shortcomings, and it would be nice if Microsoft solved some of these, or at least provided some guidance for developers. Let's discuss these issues.</p>
<h3>Using the APM Without the Thread Pool</h3>
<p>In this chapter, I have discussed how to use the APM and have thread pool threads invoke your callback methods with the asynchronous operations completed. What I have shown you is the preferred way to use the APM, as it uses little resources and offers excellent performance. However, the APM offers three other ways to know when the asynchronous operation has completed.</p>
<p>All <b>BeginXxx </b>methods return a reference to an object that implements the <b>IAsyncResult </b>interface:</p>
<p><code>public interface IAsyncResult {<br/>
Object       AsyncState{ get; }<br/>
WaitHandle AsyncWaitHandle{ get; } // Avoid using this<br/>
Boolean      IsCompleted{ get; } // Avoid using this<br/>
Boolean      CompletedSynchronously { get; } // true if the op completed synchronously<br/>
}</code></p>
<p>First, if a thread calls <b>EndXxx, </b>passing in this <b>IAsyncResult </b>object before the operation is complete, the calling thread will block waiting for it to complete and the thread will wake with the result returned from <b>EndXxx </b>Second, a thread can also block, waiting for the operation to complete, by calling <b>WaitOne </b>(discussed in Chapter 28, &quot;Primitive Thread Synchronization Constructs&quot;) on the <b>WaitHandle </b>returned from querying <b>IAsyncResult</b>'s <b>AsyncWaitHandle </b>property. These first two techniques should be avoided, however, because they block a thread, potentially causing the thread pool to allocate another thread.</p>
<p>Third, a thread could continuously query <b>IAsyncResult</b>'s <b>IsCompleted </b>property in a loop to know when the operation is complete This technique should also be avoided because it wastes CPU time while polling. If you poll waiting for a compute-bound operation to complete, then you steal CPU time away from the compute-bound operation, making it take longer to complete. Frequently, to reduce continuous polling, programmers call <b>Thread.Sleep </b>within each iteration of the polling loop. If you do this, now you are blocking threads and polling!</p>
<h3>Always Call the EndXxx Method, and Call It Only Once</h3>
<p>You must call <b>EndXxx </b>or else you will leak resources Some developers have written code to call <b>BeginXxx </b>to write some data to a device, and there is no processing that needs to be done after the data has been written, so they don't care about calling <b>EndXxx. </b>However, calling <b>EndXxx </b>is required for two reasons First, the CLR allocates some internal resources when you initiate an asynchronous operation When the operation completes, the CLR will hold onto these resources until <b>EndXxx </b>is called If <b>EndXxx </b>is never called, these resources remain allocated and will be reclaimed only when the process terminates. Second, when you initiate an asynchronous operation, you don't actually know if the operation eventually succeeded or failed. The only way you can discover this is by calling <b>EndXxx </b>and checking the return value or seeing if it throws an exception.</p>
<p>You should not call <b>EndXxx </b>more than once for any given asynchronous operation. When you call <b>EndXxx, </b>it could access some internal resources and then release them. If you call <b>EndXxx </b>again, the resources will have been released already, and the results will be unpredictable In reality, calling <b>EndXxx </b>multiple times for a single operation may or may not work; it depends on how the class that implements the <b>IAsyncResult </b>interface has been written. Since Microsoft never told developers how this should behave, different developers implemented it in different ways. The only thing you can count on is that calling <b>EndXxx </b>just once will work.</p>
<h3>Always Use the Same Object When Calling the EndXxx Method</h3>
<p>Whatever object you use when calling <b>BeginXxx </b>should be the same object that you use to call <b>EndXxx. </b>For example, don't construct a delegate and call its <b>BeginInvoke </b>method and then construct another delegate (of the same type referring to the same object/method) and use it to call its <b>EndInvoke </b>method While this seems as if it should work (since both delegate objects are identical in every way), it doesn't work because the <b>IAsyncResult </b>object internally keeps a reference to the original object used when calling <b>BeginInvoke, </b>and if they don't match, <b>EndInvoke </b>throws an <b>InvalidOperationException </b>with a string message of <b>&quot;The IAsyncResult object provided does not match this delegate.&quot; </b>Again, using one object to call <b>BeginInvoke </b>and another object to call <b>EndInvoke </b>may work for some object types depending on how they were implemented.</p>
<h3>Using ref, out, and params Arguments with BeginXxx and EndXxx Methods</h3>
<p>The parameters of <b>BeginXxx </b>and <b>EndXxx </b>methods will deviate slightly from the patterns I've described in this chapter if the non-asynchronous version of the method uses any <b>out/ref </b>parameters or if it has a parameter marked with the <b>params </b>keyword. Since this is very rare, I won't show an example, but you should be aware of it. You'll easily figure out how to call the methods correctly when you need to.</p>
<h3>You Can't Cancel an Asynchronous I/O-Bound Operation</h3>
<p>There is currently no way to cancel an outstanding asynchronous I/O-bound operation. This is a feature that many developers would like, but it is actually quite hard to implement. After all, if you request 1,000 bytes from a server and then you decide you don't want those bytes anymore, there really is no way to tell the server to forget about your request. The way to deal with this is just to let the bytes come back to you and then throw them away. In addition, there is a race condition here: Your request to cancel the request could come just as the last byte is being read. Now what should your application do? You'd need to handle this potential race condition occurring in your own code and decide whether to throw the data away or act on it. Some <b>BeginXxx </b>methods might return an object that implements the <b>IAsyncResult </b>interface, as well as offering some kind of cancel method. In this case, you could cancel the operation. You'd have to check the documentation for the <b>BeginXxx </b>method or the class it returns to see whether cancellation is supported.</p>
<h3>Memory Consumption</h3>
<p>Whenever you call a <b>BeginXxx </b>method, it constructs an instance of a type that implements the <b>IAsyncResult </b>interface. This means that an object is created for every asynchronous operation that you want to perform This adds more overhead and creates more objects on the heap, which causes more garbage collections to occur The result: poorer application performance. So if you know for a fact that your I/O operations are going to execute extremely quickly, it may make more sense to perform them synchronously. Many developers (including myself) wish that the APM returned value types instead or had some other lightweight way of identifying a queued asynchronous operation; maybe Microsoft will improve the CLR someday by supporting this.</p>
<h3>Some I/O Operations Must Be Done Synchronously</h3>
<p>The Win32 API offers many functions that execute I/O operations. Unfortunately, some of these methods do not let you perform the I/O asynchronously. For example, the Win32 <b>CreateFile </b>method (called by <b>FileStream</b>'s constructor) always executes synchronously. If you're trying to create or open a file on a network server, it could take several seconds before <b>CreateFile </b>returns葉he calling thread is idle all the while. An application designed for optimum performance and scalability would ideally call a Win32 function that lets you create or open a file asynchronously so that your thread is not sitting and waiting for the server to reply. Unfortunately, Win32 has no <b>CreateFile</b>-like function to let you do this, and therefore the FCL cannot offer an efficient way to open a file asynchronously.</p>
<p>Here is an example where this is a real problem Imagine writing a simple UI control that allows the user to type a file path and provides automatic completion (similar to the common File Open dialog box). The control must use separate threads to enumerate directories looking for files because Windows doesn't offer any functions to enumerate files asynchronously. As the user continues to type in the UI control, you have to use more threads and ignore the results from any previously spawned threads. With Windows Vista, Microsoft introduced a new Win32 function called <b>CancelSynchronousIO. </b>This function allows one thread to cancel a synchronous I/O operation that is being performed by another thread. This function is not exposed by the FCL, but you can also P/Invoke to it if you want to take advantage of it from managed code. I show the P/Invoke signature for it in the next section of this chapter.</p>
<p>The point I want you to take away though is that many people think that synchronous APIs are easier to work with, and in many cases this is true. But in some cases, synchronous APIs can make things much harder. Microsoft's Windows team is looking at the synchronous-only APIs and deciding which function needs to be exposed with asynchronous APIs in future versions of Windows. Once they do this, the FCL will expose this functionality, too.</p>
<p>You can always call any method asynchronously via a delegate's <b>BeginInvoke </b>method, but when you do this, you are using a thread, so you are losing some efficiency. And actually, you can't use a delegate to call a constructor. So the only way to construct a <b>FileStream </b>object asynchronously is to call some other method asynchronously and have this other method construct the <b>FileStream </b>object. Windows doesn't offer functions to asynchronously access the registry, access the event log, get a directory's files/subdirectories, or change a file's/ directory's attributes, to name just a few.</p>
<h3>FileStream-Specific Issues</h3>
<p>When you create a <b>FileStream </b>object, you get to specify whether you want to communicate using synchronous or asynchronous operations via the <b>FileOptions.Asynchronous </b>flag (which is equivalent to calling the Win32 <b>CreateFile </b>function and passing into it the <b>FILE_FLAG_OVERLAPPED </b>flag). If you do not specify this flag, Windows performs all operations against the file synchronously. Of course, you can still call <b>FileStream</b>'s <b>BeginRead </b>method, and to your application, it looks as if the operation is being performed asynchronously, but internally, the <b>FileStream </b>class uses another thread to emulate asynchronous behavior. This additional thread is wasteful and hurts performance.</p>
<p>On the other hand, you can create a <b>FileStream </b>object by specifying the <b>FileOptions. Asynchronous </b>flag. Then you can call <b>FileStream</b>'s <b>Read </b>method to perform a synchronous operation. Internally, the <b>FileStream </b>class emulates this behavior by starting an asynchronous operation and then immediately puts the calling thread to sleep until the operation is complete. This is also inefficient, but it is not as inefficient as calling <b>BeginRead </b>by using a <b>FileStream </b>constructed without the <b>FileOptions.Asynchronous </b>flag.</p>
<p>So, to summarize: When working with a <b>FileStream, </b>you must decide up front whether you intend to perform synchronous or asynchronous I/O against the file and indicate your choice by specifying the <b>FileOptions.Asynchronous </b>flag (or not). If you specify this flag, always call <b>BeginRead. </b>If you do not specify this flag, always call <b>Read. </b>This will give you the best performance If you intend to make some synchronous and some asynchronous operations against the <b>FileStream, </b>it is more efficient to construct it using the <b>FileOptions.Asynchronous </b>flag. Alternatively, you can create two <b>FileStream </b>objects over the same file; open one <b>FileStream </b>for asynchronous I/O and open the other <b>FileStream </b>for synchronous I/O.</p>
<p>You should also be aware that the NTFS file system device driver performs some operations synchronously no matter how you open the file. For more information about this, see <a href="http://support.microsoft.com/default.aspx?scid=kb%3Ben-us%3B156932">http://support.microsoft.com/default.aspx?scid=kb%3Ben-us%3B156932</a>.</p>
<a name="b780"/><h2>I/O Request Priorities</h2>
<p>In Chapter 25, &quot;Thread Basics,&quot; I showed how setting thread priorities affects how threads are scheduled However, threads also perform I/O requests to read and write data from various hardware devices. If a low-priority thread gets CPU time, it could easily queue hundreds or thousands of I/O requests in a very short time. Because I/O requests typically require time to process, it is possible that a low-priority thread could significantly affect the responsiveness of the system by suspending high-priority threads, which prevents them from getting their work done Because of this, you can see a machine become less responsive when executing long-running low-priority services such as disk defragmenters, virus scanners, content indexers, and so on.<sup>9</sup></p>
<p>The Windows SuperFetch feature takes advantage of low-priority I/O requests.</p>
<p>Starting with Windows Vista, it is now possible for a thread to specify a priority when making I/O requests For more details about I/O priorities, refer to the white paper at <a href="http://www.microsoft.com/whdc/driver/priorityio.mspx">http://www.microsoft.com/whdc/driver/priorityio.mspx</a>. Unfortunately, the FCL does not include this functionality yet; hopefully, it will be added in a future version. However, you can still take advantage of this feature by P/Invoking out to native Win32 functions. Here is the P/Invoke code:</p>
<p><code>internal static class ThreadIO {<br/>
public static BackgroundProcessingDisposer BeginBackgroundProcessing( Boolean process = false) {<br/>
ChangeBackgroundProcessing(process, true); return new BackgroundProcessingDisposer(process);<br/>
}<br/>
public static void EndBackgroundProcessing(Boolean process = false) { ChangeBackgroundProcessingCprocess, false);<br/>
}<br/>
private static void ChangeBackgroundProcessing(Boolean process, Boolean start) { Boolean ok = process<br/>
? SetPriorityClass(GetCurrentWin32ProcessHandle(),<br/>
start ? ProcessBackgroundMode.Start : ProcessBackgroundMode.End) : SetThreadPriority(GetCurrentWin32ThreadHandle(),<br/>
start ? ThreadBackgroundgMode.Start : ThreadBackgroundgMode.End); if (!ok) throw new Win32Exception();<br/>
}<br/>
// This struct lets C#'s using Statement end the background processing mode public struct BackgroundProcessingDisposer : IDisposable { private readonly Boolean m_process;<br/>
public BackgroundProcessingDisposer(Boolean process) { m_process = process; } public void Dispose() { EndBackgroundProcessing(m_process); }<br/>
}<br/>
// See Win32's THREAD_MODE_BACKGROUND_BEGIN and THREAD_MODE_BACKGROUND_END private enum ThreadBackgroundgMode { Start = 0x10000, End = 0x20000 }<br/>
// See Win32's PROCESS_MODE_BACKGROUND_BEGIN and PROCESS_MODE_BACKGROUND_END private enum ProcessBackgroundMode { Start = 0x100000, End = 0x200000 }<br/>
[DllImport(&quot;Kerne132&quot;, EntryPoint = &quot;GetCurrentProcess&quot;, ExactSpelling = true)] private static extern SafeWaitHandle GetCurrentWin32ProcessHandle();<br/>
[DllImport(&quot;Kerne132&quot;, ExactSpelling = true, SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)] private static extern Boolean SetPriorityClass(<br/>
SafeWaitHandle hprocess, ProcessBackgroundMode mode);<br/>
[DllImport(&quot;Kerne132&quot;, EntryPoint = &quot;GetCurrentThread&quot;, ExactSpelling = true)] private static extern SafeWaitHandle GetCurrentWin32ThreadHandle();<br/>
[DllImport(&quot;Kerne132&quot;, ExactSpelling = true, SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)] private static extern Boolean SetThreadPriority(<br/>
SafeWaitHandle hthread, ThreadBackgroundgMode mode);<br/>
// <a href="http://msdn.microsoft.com/en-us/1ibrary/aa480216.aspx">http://msdn.microsoft.com/en-us/1ibrary/aa480216.aspx</a><br/>
[DllImport(&quot;Kerne132&quot;, SetLastError = true, EntryPoint = &quot;CancelSynchronousIo&quot;)] [return: MarshalAs(UnmanagedType.Bool)]<br/>
private static extern Boolean CancelSynchronousIO(SafeWaitHandle hThread);<br/>
}</code></p>
<p>And here is code showing how to use it:</p>
<p><code>public static void Main () {<br/>
using (ThreadIO.BeginBackgroundProcessingO) {<br/>
// Issue low-priority I/O requests in here (eg: calls to BeginRead/BeginWrite)<br/>
}<br/>
}</code></p>
<p>You tell Windows that you want your thread to issue low-priority I/O requests by calling <b>ThreadIO</b>'s <b>BeginBackgroundProcessing </b>method. Note that this also lowers the CPU scheduling priority of the thread. You can return the thread to making normal-priority I/O requests (and normal CPU scheduling priority) by calling <b>EndBackgroundProcessing </b>or by calling <b>Dispose </b>on the value returned by <b>BeginBackgroundProcessing </b>(as shown above via C#'s <b>using </b>statement). A thread can only affect its own background processing mode; Windows doesn't allow a thread to change the background processing mode of another thread.</p>
<p>If you want all threads in a process to make low-priority I/O requests and have low CPU scheduling, you can call <b>BeginBackgroundProcessing, </b>passing in <b>true </b>for the <b>process </b>parameter. A process can only affect its own background processing mode; Windows doesn't allow a thread to change the background processing mode of another process.</p>
<p><b>|-</b></p>
<hr/>
<blockquote><b>Important </b>As a developer, it is your responsibility to use these new background priorities to allow the foreground applications to be more responsive, taking care to avoid priority inversion. In the presence of intense normal-priority I/Os, a thread running at background priority can be delayed for seconds before getting the result of its I/O requests. If a low-priority thread has grabbed a thread synchronization lock for which the normal-priority thread is waiting, the normal-priority threads might end up waiting for the background-priority thread until the low-priority I/O requests are completed Your background-priority thread does not even have to submit I/Os for the problem to happen. So using shared synchronization objects between normal- and background-priority threads should be minimized (or eliminated if possible) to avoid these priority inversions where normal-priority threads are blocked on locks owned by background-priority threads.</blockquote>
<hr/>
<a name="b783"/><h2>Converting the IAsyncResult APM to a Task</h2>
<p>In &quot;The APM and Compute-Bound Operations&quot; section earlier in this chapter, I showed how to use the APM to perform a compute-bound operation. In this section, I show how to do the opposite: use a <b>Task </b>to perform an I/O-bound operation.</p>
<p>In the <b>System.Threading.Tasks </b>namespace, there is a class called <b>TaskFactory. </b>This class was discussed in Chapter 26. However, this class offers a <b>FromAsync </b>method, which I did not discuss in Chapter 26. This method accepts four arguments and returns a reference to a <b>Task </b>object. The four arguments are a <b>BeginXxx </b>method, an <b>EndXxx </b>method, an <b>Object </b>state, and an optional <b>TaskCreationOptions<sup>10</sup> </b>value. So instead of initiating an asynchronous operation like this:</p>
<p><code>WebRequest webRequest = WebRequest.Create(&quot;<a href="http://Wintellect.com/">http://Wintellect.com/</a>&quot;); webRequest.BeginGetResponse(result =&gt; { WebResponse webResponse = nu11;<br/>
try {<br/>
webResponse = webRequest.EndGetResponse(result); Console.WriteLine(&quot;Content length: &quot; + webResponse.ContentLength);<br/>
}<br/>
catch (WebException we) {<br/>
Console.WriteLine(&quot;Failed: &quot; + we.GetBaseException().Message);<br/>
}<br/>
finally { if (webResponse != null) webResponse.Close(); }<br/>
}, nu11);</code></p>
<p>you can turn it into a <b>Task, </b>and then use it with the rest of the <b>Task </b>infrastructure like this:</p>
<p><code>WebRequest webRequest = WebRequest.Create(&quot;<a href="http://Wintellect.com/">http://Wintellect.com/</a>&quot;); Task.Factory.FromAsync&lt;WebResponse&gt;(<br/>
webRequest.BeginGetResponse, webRequest.EndGetResponse, null, TaskCreationOptions.None)<br/>
.ContinueWith(task =&gt; {<br/>
WebResponse webResponse = nu11;<br/>
try {<br/>
webResponse = task.Result;<br/>
Console.WriteLine(&quot;Content length: &quot; + webResponse.ContentLength);<br/>
}<br/>
catch (AggregateException ae) {<br/>
if (ae.GetBaseException() is WebException)<br/>
Console.WriteLine(&quot;Failed: &quot; + ae.GetBaseException().Message); else throw;<br/>
}<br/>
finally { if (webResponse != null) webResponse.Close(); }<br/>
});</code></p>
<p>The <b>FromAsync </b>method has additional overloads that allow you to pass up to three parameters to a <b>BeginXxx </b>method If you need to call a <b>BeginXxx </b>method that takes more than three parameters, then there is a <b>FromAsync </b>overload that accepts an <b>IAsyncResult </b>parameter; you call the <b>BeginXxx </b>method yourself and its return value here. Avoid this overload if you can because it is less efficient than the overloads of <b>FromAsync </b>that do not take an <b>IAsyncResult </b>.</p>
<p>By the way, the <b>Task </b>class implements the <b>IAsyncResult </b>interface, so tasks support the APM to some extent. <b>Task</b>'s <b>AsyncState </b>property is the <b>IAsyncResult AsyncState </b>property, and this returns whatever state was passed in to <b>TaskFactory</b>'s <b>state </b>parameter Since the <b>Task </b>is going to internally call the <b>EndXxx </b>method for you, the other <b>IAsyncResult </b>interface members that are potentially interesting are <b>AsyncWaitHandle, IsCompleted, </b>and maybe <b>CompletedSynchronously </b>Well, as discussed earlier in this chapter in the &quot;Using the APM Without the Thread Pool&quot; section, the <b>AsyncWaitHandle </b>and <b>IsCompleted </b>properties should always be avoided, and the <b>CompletedSynchronously </b>property is more informative than actionable.</p>
<a name="b784"/><h2>The Event-Based Asynchronous Pattern</h2>
<p>When the .NET Framework was introduced, the only APM it offered is the one based on the <b>IAsyncResult </b>interface that I've been discussing this whole chapter. Microsoft's Windows Forms team felt that the <b>IAsyncResult </b>APM was too difficult for many Windows Form developers, so they created a new Event-based Asynchronous Pattern (EAP).<sup>11</sup> The main benefit of the EAP is that it integrates with the Microsoft Visual Studio UI designers. That is, you can drag most classes that implement the EAP to a Visual Studio design surface and then double-click event names and have Visual Studio automatically produce the event callback methods and wire the method up to the events themselves.</p>
<p>Many people, including me, believe that the EAP should never have been introduced into the .NET Framework. We believe that it adds more complication than it solves. For example, should classes that want to offer asynchronous behavior now implement both patterns? Or will two classes now be exposed that basically offer the same functionality, only differing by asynchronous pattern? How would users of a class choose which pattern to use and why? There are also some other technical problems that exist with this pattern, which I describe at the end of this section.</p>
<p>In fact, I'm often asked about the following MSDN Web page: <a href="http://msdn2.microsoft.com">http://msdn2.microsoft.com</a> /en-gb/library/ms228966.aspx. This Web page actually instructs class developers to expose their asynchronous behavior using the EAP, not the APM. It also says, &quot;It is rare for the <b>IAsyncResult </b>pattern to be implemented without the event-based pattern also being implemented.&quot; This Web page was produced by people on the Windows Forms team. There are very few people at Microsoft who actually agree with this Web page. And, in fact, Microsoft ships only three classes that actually implement both patterns and adhere to what this Web page says. Since I'm not a fan of this pattern and I discourage its use, I do not want to spend a lot of time on it. However, I know that some people do like and use the pattern, so I do want to spend some time on it.</p>
<p>Many people from Microsoft's Windows Forms moved to Microsoft's WPF team, so WPF and Silverlight have also adopted this EAP.</p>
<p>Since the EAP was created for Windows Forms developers, let me show you some Windows Forms code that uses the pattern:</p>
<p><code>internal static class Eap { public static void Main() {<br/>
// Create the form and show it Application.RunCnew MyForm());<br/>
}<br/>
private sealed class MyForm : Form {<br/>
protected override void OnClick(EventArgs e) {<br/>
// The System.Net.WebClient class supports the Event-based Asynchronous Pattern WebClient wc = new WebClient();<br/>
// When a string completes downloading, the WebClient object raises the<br/>
// DownloadStringCompleted event which will invoke our ProcessString method<br/>
wc.DownloadStringCompleted += ProcessString;<br/>
// Start the asynchronous operation (this is like calling a BeginXxx method) wc.DownloadStringAsyncCnew Uri(&quot;<a href="http://Wintellect.com">http://Wintellect.com</a>&quot;)); base.OnClick(e);<br/>
}<br/>
// This method is guaranteed to be called via the GUI thread<br/>
private void ProcessString(Object sender, DownloadStringCompletedEventArgs e) { // If an error occurred, display it; else display the downloaded string MessageBox.Show((e.Error != null) ? e.Error.Message : e.Result);<br/>
}<br/>
}<br/>
}</code></p>
<p>In this sample, I manually wrote all the code, but I could have used Visual Studio to drag a <b>WebClient </b>control to my form. Then Visual Studio could have emitted the <b>ProcessString </b>method with no code in it and emitted the code to register this method with <b>WebClient</b>'s <b>DownloadStringCompleted </b>event. The EAP also guarantees that the event is raised on the application's GUI thread, allowing code in the event handler method to update UI controls. In addition to Visual Studio designer support, this is another big feature of the EAP That is, classes that support the EAP automatically map the application model to its threading model; the EAP classes use the <b>SynchronizationContext </b>class internally. In addition, some of the EAP classes offer cancellation and progress reporting.</p>
<p>In the whole FCL, there are just 17 types that implement the EAP pattern. Some of these classes are derived from <b>System.ComponentModel.Component, </b>which allows them to be dragged and dropped onto a Visual Studio design surface, but most of the classes derive directly from <b>System.Object </b>. Here is the list of classes that support the EAP:</p>
<p><code>System.ComponentModel.Component-derived types System.ComponentModel.BackgroundWorker System.Media.SoundPlayer System.Net.WebClient <a href="http://System.Net.NetworkInformation.Ping">System.Net.NetworkInformation.Ping</a><br/>
System.Windows.Forms.PictureBox (derived from Control)<br/>
System.Object-derived types System.Net.Mail.SmtpClient<br/>
System.Deployment.Application.ApplicationDeployment System.Deployment.Application.InPlaceHostingManager System.Activities.Workflowlnvoker<br/>
System.ServiceModel.Activities.WorkflowControlClient<br/>
System.Net.PeerToPeer.PeerNameResolver<br/>
System.Net.PeerToPeer.Collaboration.ContactManager<br/>
System.Net.PeerToPeer.Collaboration.Peer<br/>
System.Net.PeerToPeer.Collaboration.PeerContact<br/>
System.Net.PeerToPeer.Collaboration.PeerNearMe<br/>
System.ServiceModel.Discovery.AnnouncementClient<br/>
System.ServiceModel.Discovery.DiscoveryClient</code></p>
<p>The FCL ships 60 classes that implement the <b>IAsyncResult </b>pattern, including the following classes for which there is no equivalent class available that implements the EAP: the various <b>Stream</b>-derived classes <b>(FileStream, IsolatedStorageFileStream, DeflateStream, GZipStream, </b>and <b>PipeStream), SqlCommand, </b>and more.</p>
<p>I should also point out that tools that produce Web service proxy classes, like WSDL.exe and SvcUtil.exe, can produce proxy classes that support both the APM and the EAP.</p>
<p>If you look at the 17 classes listed above, they are all related to performing I/O-bound work except for one: <b>BackgroundWorker </b>. The <b>BackgroundWorker </b>class is designed for doing asynchronous compute-bound work, but unfortunately, a lot of developers use <b>BackgroundWorker </b>to perform synchronous I/O-bound work, which blocks a thread I/O-bound work should be performed using one of the other 16 EAP classes or any of the classes that support the APM The <b>BackgroundWorker </b>class offers the following three events:</p>
<p><b>&#9632; DoWork </b>The method that you register with this event should contain the compute-bound code. This event is raised by a thread pool thread.</p>
<p><b>&#9632; ProgressChanged  </b>The method that you register with this event should contain the code that updates the UI with progress information This event is always raised on the GUI thread. The <b>DoWork </b>event handler method must periodically call <b>BackgroundWorker</b>'s <b>ReportProgress </b>method to raise the <b>ProgressChanged </b>event.</p>
<p><b>&#9632; RunWorkerCompleted  </b>The method that you register with this event should contain the code that updates the UI with the result of the compute-bound operation This event is always raised on the GUI thread The <b>DoWork </b>event handler method is passed a reference to a <b>DoWorkEventArgs </b>object. This object's <b>Result </b>property must be set to the value that the compute-bound operation wishes to return.</p>
<h3>Converting the EAP to a Task</h3>
<p>In the &quot;Converting the <b>IAsyncResult </b>APM to a <b>Task&quot; </b>section earlier in this chapter, I showed how to use the <b>IAsyncResult </b>APM to turn an asynchronous operation into a <b>Task </b>so that it could be used with the rest of the <b>Task </b>infrastructure Well, it is also possible to turn an asynchronous operation using the EAP into a <b>Task </b>The <b>System.Threading.Tasks </b>namespace defines a <b>TaskCompletionSource </b>class that looks like this:</p>
<p><code>public class TaskCompletionSource&lt;TResult&gt; { public TaskCompletionSource();<br/>
public TaskCompletionSource(Object state, TaskCreationOptions creationOptions); public void SetCanceled();<br/>
public void SetException(IEnumerable&lt;Exception&gt; exceptions); public void SetResult(TResult result);<br/>
public Task&lt;TResult&gt; Task { get; }<br/>
// Less important methods not shown<br/>
}</code></p>
<p>Constructing a <b>TaskCompletionSource </b>object also causes the creation of a <b>Task </b>that you can refer to by querying <b>TaskCompletionSource</b>'s <b>Task </b>property Then, when an asynchronous operation completes, it uses the <b>TaskCompletionSource </b>object to set the reason for its completion: cancellation, unhandled exception, or its result. Calling one of the <b>SetXxx </b>methods sets the state of the underlying <b>Task </b>object. Here is code showing how to turn the EAP into a <b>Task:</b></p>
<p><code>internal sealed class MyFormTask : Form {<br/>
protected override void OnClick(EventArgs e) {<br/>
// The System.Net.WebClient class supports the Event-based Asynchronous Pattern WebClient wc = new WebClient();<br/>
// Create the TaskCompletionSource and its underlying Task object var tcs = new TaskCompletionSource&lt;String&gt;();<br/>
// When a string completes downloading, the WebClient object raises the<br/>
// DownloadStringCompleted event which will invoke our ProcessString method<br/>
wc.DownloadStringCompleted += (sender, ea) =&gt; {<br/>
// This code always executes on the GUI thread; set the Task's state<br/>
if (ea.Cancelled) tcs.SetCanceled();<br/>
else if (ea.Error != null) tcs.SetException(ea.Error);<br/>
else tcs.SetResult(ea.Result);<br/>
};<br/>
// Have the Task continue with this Task that shows the result in a message box // NOTE: The ExecuteSynchronously flag is required to have this code run on the // GUI thread; without the flag, the code runs on a thread pool thread tcs.Task.ContinueWith(t =&gt; {<br/>
try {<br/>
MessageBox.Show(t.Result);<br/>
}<br/>
catch (AggregateException ae) {<br/>
MessageBox.Show(ae.GetBaseException().Message); }}, TaskContinuationOptions.ExecuteSynchronously);<br/>
// Start the asynchronous operation (this is like calling a BeginXxx method)<br/>
wc.DownloadStringAsync(new Uri(&quot;<a href="http://Wintellect.com">http://Wintellect.com</a>&quot;));<br/>
base.OnClick(e);<br/>
}<br/>
}</code></p>
<h3>Comparing the APM and the EAP</h3>
<p>In this section, I compare the APM to the EPM. The biggest benefit of the EPM over the APM is that it can be used with the Visual Studio offering a design-time approach to invoke asynchronous operations In addition, the EAP was introduced in the FCL at the same time as the <b>SynchronizationContext </b>class, and therefore it has built into it the ability to understand an application's threading model to ensure that, for GUI applications, the event handler method is invoked on the GUI thread.</p>
<p>However, the APM is closer to the metal and the EAP classes are typically implemented internally using the APM. This means that EAP classes tend to use more memory and perform slower than their APM equivalents In fact, the EAP must allocate <b>EventArg</b>-derived objects for all progress reporting and completion events that are raised Several EPM classes also contain a collection of <b>UserState </b>objects identifying separate operations and an <b>AsyncOperation </b>object, too. In a typical GUI application, these additional memory allocations (which cause additional garbage collections) are probably insignificant. However, the EPM would be an inappropriate choice for building a high-performance server application.</p>
<p>For simple scenarios, the EPM is easy to use and a fine choice. However, there are some scenarios where the EPM will actually be more complicated to use. If you call the <b>XxxAsync </b>method before registering the event handler method, it is possible that the asynchronous operation could complete before registering the event handler method and then the event handler method will not be invoked. Also, events are cumulative, and so you must unregister a method from the event and register a new method with the event if you want your next asynchronous operation to invoke a different method. Furthermore, static methods and singleton classes cannot offer the EPM for the same reason: different parts of an application may all register events at once, and all event handlers would be invoked when an operation completes regardless of which part of the application issued the asynchronous operation.</p>
<p>Error handling with the EAP is incongruous with the rest of the system First, exceptions aren't thrown; in your event handler, you must query the <b>AsyncCompletedEventArgs</b>'s <b>Exception </b>property to see if it is <b>null </b>or not. If it is not <b>null, </b>then you have to use <b>if </b>statements to determine the type of the <b>Exception</b>-derived object instead of using <b>catch </b>blocks. And, if your code ignores the error, then no unhandled exception occurs, errors go undetected, and your application continues running with unpredictable results.</p>
<a name=""/><h2>Programming Model Soup</h2>
<p>Over the years, the .NET Framework has amassed a number of asynchronous programming models, each with its pros and cons, and I'm sure that new programming models will appear in the future. In an effort to help you, I have produced Table 27-1, which summarizes the various models that currently exist. For each model, I show what's its intended primary use is (compute-bound or I/O-bound operations), how it can emulate the other kind of operation,</p>
<p>if the model supports parent/child relationships, if the model natively supports progress reporting, cancellation, blocking a thread until the operation completes (a feature you should avoid), notifying you when a timeout expires, and if you can get the result (or exception) of the operation when it completes. Here are some additional notes about Table 27-1:</p>
<p>&#9632; Tasks offer improved performance over <b>ThreadPool.QueueUserWorkItem </b>or a delegate's <b>BeginInvoke </b>if many tasks are being issued due to the work-stealing queues.</p>
<p>&#9632; You can use the <b>PreFairness </b>flag to get the same thread pool behavior as <b>ThreadPool.QueueUserWorkItem </b>or a delegate's <b>BeginInvoke </b>.</p>
<p>&#9632; You can use a customized <b>TaskScheduler, </b>allowing you to change scheduling algorithms without changing the code or programming model.</p>
<p>&#9632; <b>Task </b>objects consume more memory than just calling <b>ThreadPool.QueueUserWorkItem</b></p>
<p>or a delegate's <b>BeginInvoke </b>Calling a delegate's <b>BeginInvoke </b>method has known performance issues, and while <b>Task </b>objects require more memory, tasks run faster and are probably a better choice than calling a delegate's <b>BeginInvoke </b>method.</p>
<p>&#9632; The <b>IAsyncResult </b>APM offers four rendezvous techniques, which complicates the model; however, if you mentally restrict yourself to the callback method technique (as I do), then the model is simplified.</p>
<p>&#9632; The <b>IAsyncResult </b>APM is generally faster and uses fewer resources than the EAP.</p>
<p>&#9632; Some of the classes that support the EAP support cancellation.</p>
<p>&#9632; The <b>IAsyncResult </b>APM doesn't support cancellation at all; however, you can always obtain cancellation behavior by setting a flag and throwing away the result when it does complete. Wrapping the <b>IAsyncResult </b>pattern in a <b>Task </b>and setting the proper <b>ContinueWith </b>callbacks can help you here.</p>
<p>&#9632; The EAP is event-based, so that you can easily use it from within Visual Studio's Windows Forms, WPF, and Silverlight forms designers, and the notifying methods are called in the right UI thread.</p>
<img src="91.jpg"/>
<mbp:pagebreak/>
<a name="Chapter28"/>
<h1>Chapter 28: Primitive Thread Synchronization Constructs</h1>
<p><b>In this chapter:</b></p>
<a href="#b793">Class Libraries and Thread Safety</a><br/>
<a href="#b794">Primitive User-Mode and Kernel-Mode Constructs</a><br/>
<a href="#b796">User-Mode Constructs</a><br/>
<a href="#b813">Kernel-Mode Constructs</a><br/>
<p>When a thread pool thread blocks, the thread pool creates additional threads, and the time and memory resources required to create, destroy, and schedule threads is very expensive. And when many developers see that they have threads in their program that are not doing anything useful, they tend to create more threads in hopes that the new threads will do something useful. The key to building scalable and responsive applications is to not block the threads you have so that they can be used and reused to execute other tasks. Chapter 26, &quot;Compute-Bound Asynchronous Operations,&quot; focused on how to use existing threads to perform compute-bound operations, and Chapter 27, &quot;I/O-Bound Asynchronous Operations,&quot; focused on how to use threads when performing I/O-bound operations.</p>
<p>In this chapter, I focus on thread synchronization Thread synchronization is used to prevent corruption when multiple threads access shared data at the same time. I emphasize at the same time because thread synchronization is all about timing. If you have some data that is accessed by two threads and those threads cannot possibly touch the data simultaneously, then thread synchronization is not required at all. In Chapter 27, I showed some code that implements a named-pipe server. In the <b>ClientConnected </b>method, a thread allocates a <b>Byte[] </b>that will be filled with the data being sent from the client. When the client sends the data, a different thread pool thread will execute the <b>GotRequest </b>method, and this method will process the data in the <b>Byte[]. </b>Here we have two different threads accessing the same data. But the application is architected in such a way that it is impossible for two threads to access this same <b>Byte[] </b>at the same time. Therefore, no thread synchronization is used in the named-pipe application at all.</p>
<p>This is ideal because thread synchronization has many problems associated with it. First, it is tedious and extremely error-prone. In your code, you must identify all data that could potentially be touched by multiple threads at the same time. Then you must surround this code with additional code that acquires and releases a thread synchronization lock The lock ensures that only one thread at a time can access the resource. If you forget to surround just one block of code with a lock, then the data will become corrupted Also, there is no way to prove that you have added all your locking code correctly. You just have to run your application, stress-test it a lot, and hope that nothing goes wrong In fact, you should test your application on a machine that has as many CPUs as possible because the more CPUs you have, the better chance that two or more threads will attempt to access the resource at the same time, making it more likely you'll detect a problem.</p>
<p>The second problem with locks is that they hurt performance. It takes time to acquire and release a lock because there are additional method calls and because the CPUs must coordinate with each other to determine which thread will acquire the lock first. Having the CPUs in the machine communicate with each other this way hurts performance. For example, let's say that you have code that adds a node to the head of a linked list:</p>
<p><code>// This class is used by the LinkedList class public class Node {<br/>
internal Node m_next;<br/>
// Other members not shown<br/>
}<br/>
public sealed class LinkedList { private Node m_head;<br/>
public void Add(Node newNode) {<br/>
// The two lines below perform very fast reference assignments newNode.m_next = m_head; m_head = newNode;<br/>
}<br/>
}</code></p>
<p>This <b>Add </b>method simply performs two reference assignments that can execute extremely fast. Now, if we want to make <b>Add </b>thread safe so that multiple threads can call it simultaneously without corrupting the linked list, then we need to have the <b>Add </b>method acquire and release a lock:</p>
<p><code>public sealed class LinkedList {<br/>
private SomeKindOfLock m_1ock = new SomeKindOfLock(); private Node m_head;<br/>
public void Add(Node newNode) { m_1ock.Acquire();<br/>
// The two lines below perform very fast reference assignments newNode.m_next = m_head; m_head = newNode; m_1ock.Release();<br/>
}<br/>
}</code></p>
<p>While <b>Add </b>is now thread safe, it has also become substantially slower. How much slower depends on the kind of lock chosen; I will compare the performance of various locks in this chapter and in Chapter 29, &quot;Hybrid Thread Synchronization Constructs.&quot; But even the fastest lock could make the <b>Add </b>method several times slower than the version of it that didn't have any lock code in it at all. Of course, the performance becomes significantly worse if the code calls <b>Add </b>in a loop to insert several nodes into the linked list.</p>
<p>The third problem with thread synchronization locks is that they allow only one thread to access the resource at a time This is the lock's whole reason for existing, but it is also a problem because blocking a thread causes more threads to be created. So, for example, if a thread pool thread attempts to acquire a lock that it cannot have, it is likely that the thread pool will create a new thread to keep the CPUs saturated with work. As discussed in Chapter 25, &quot;Thread Basics,&quot; creating a thread is very expensive in terms of both memory and performance. And to make matters even worse, when the blocked threads gets to run again, it will run with this new thread pool thread; Windows is now scheduling more threads than there are CPUs, and this increases context switching, which also hurts performance.</p>
<p>The summary of all of this is that thread synchronization is bad, so you should try to design your applications to avoid as much of it as possible To that end, you should avoid shared data such as <b>static </b>fields. When a thread uses the <b>new </b>operator to construct an object, the <b>new </b>operator returns a reference to the new object. At this point in time, only the thread that constructs the object has a reference to it; no other thread can access that object If you avoid passing this reference to another thread that might use the object at the same time as the creating thread, then there is no need to synchronize access to the object.</p>
<p>Try to use value types because they are always copied, so each thread operates on its own copy. Finally, it is OK to have multiple threads accessing shared data simultaneously if that access is read-only. For example, many applications create some data structures during their initialization. Once initialized, the application can create as many threads as it wants; if all these threads just query the data, then all the threads can do this simultaneously without acquiring or releasing any locks. The <b>String </b>type is an example of this: Once a <b>String </b>object is created, it is immutable, so many threads can access a single <b>String </b>object at the same time without any chance of the <b>String </b>object becoming corrupted.</p>
<a name="b793"/><h2>Class Libraries and Thread Safety</h2>
<p>Now, I'd like to say a quick word about class libraries and thread synchronization. Microsoft's Framework Class Library (FCL) guarantees that all static methods are thread safe. This means that if two threads call a static method at the same time, no data will get corrupted. The FCL had to do this internally because there is no way that multiple companies producing different assemblies could coordinate on a single lock for arbitrating access to the resource The <b>Console </b>class contains a <b>static </b>field, inside which many of its methods acquire and release to ensure that only one thread at a time is accessing the console.</p>
<p>For the record, making a method thread safe does not mean that it internally takes a thread synchronization lock. A thread-safe method means that data doesn't get corrupted if two threads attempt to access the data at the same time. The <b>System.Math </b>class has a <b>static Max </b>method implemented as follows:</p>
<p><code>public static Int32 Max(Int32 vall, Int32 va12) { return (vall &lt; va12) ? va12 : vall;<br/>
}</code></p>
<p>This method is thread safe even though it doesn't take any lock. Since <b>Int32 </b>is a value type, the two <b>Int32 </b>values passed to <b>Max </b>are copied into it and multiple threads could be calling <b>Max </b>simultaneously, but each thread is working on its own data, isolated from any other thread.</p>
<p>On the other hand, the FCL does not guarantee that instance methods are thread safe because adding all the locking code would hurt performance too much. And, in fact, if every instance method acquires and releases a lock, then you ultimately end up having just one thread running in your application at any given time, which hurts performance even more As mentioned earlier, when a thread constructs an object, only this thread has a reference to the object, no other thread can access that object, and no thread synchronization is required when invoking instance methods. However, if the thread then exposes the reference to the object傭y placing it in a static field, passing as the state argument to <b>ThreadPool. QueueUserWorkItem </b>or to a <b>Task, </b>and so on葉hen thread synchronization is required if the threads could attempt simultaneous non-read-only access.</p>
<p>It is recommended that your own class libraries follow this pattern; that is, make all your static methods thread safe and make all your instance methods not thread-safe. There is one caveat to this pattern: if the purpose of the instance method is to coordinate threads, then the instance method should be thread safe. For example, one thread can cancel an operation by calling <b>CancellationTokenSource</b>'s <b>Cancel </b>method, and another thread detects that it should stop what it's doing by querying the corresponding <b>CancellationToken</b>'s <b>IsCancellationRequested </b>property. These two instance members have some special thread synchronization code inside them to ensure that the coordination of the two threads goes as expected. <sup>1</sup></p>
<a name="b794"/><h2>Primitive User-Mode and Kernel-Mode Constructs</h2>
<p>In this chapter, I explain the primitive thread synchronization constructs. By primitive, I mean the simplest constructs that are available to use in your code There are two kinds of primitive constructs: user-mode and kernel-mode Whenever possible, you should use the primitive user-mode constructs because they are significantly faster than the kernel-mode constructs as they use special CPU instructions to coordinate threads. This means that the coordination is occurring in hardware (which is what makes it fast) But this also means that the Microsoft</p>
<p>Specifically, the field that both members access is marked as <b>volatile, </b>a concept that will be discussed later in this chapter</p>
<p>Windows operating system never detects that a thread is blocked on a primitive user-mode construct. Since a thread pool thread blocked on a user-mode primitive construct is never considered blocked, the thread pool will not create a new thread to replace the temporarily blocked thread. In addition, these CPU instructions block the thread for an incredibly short period of time.</p>
<p>Wow! All of this sounds great, doesn't it? And it is great, which is why I recommend using these constructs as much as possible. However, there is a downside: Only the Windows operating system kernel can stop a thread from running so that it is not wasting CPU time A thread running in user mode can be preempted by the system, but the thread will be scheduled again as soon as possible So a thread that wants to acquire some resource but can't get it spins in user mode. This potentially wastes a lot of CPU time, which would be better spent performing other work or even just letting the CPU go idle to conserve power.</p>
<p>This brings us to the primitive kernel-mode constructs. The kernel-mode constructs are provided by the Windows operating system itself As such, they require that your application's threads call functions implemented in the operating system kernel. Having threads transition from user mode to kernel mode and back incurs a big performance hit, which is why kernel-mode constructs should be avoided. <sup>2</sup> However, they do have a positive feature: When a thread uses a kernel-mode construct to acquire a resource that another thread has, Windows blocks the thread so that it is no longer wasting CPU time. Then, when the resource becomes available, Windows resumes the thread, allowing it to access the resource.</p>
<p>A thread waiting on a construct might block forever if the thread currently holding the construct never releases it. If the construct is a user-mode construct, the thread is running on a CPU forever, and we call this a livelock If the construct is a kernel-mode construct, the thread is blocked forever, and we call this a deadlock Both of these are bad, but of the two, a deadlock is always preferable to a livelock because a livelock wastes both CPU time and memory (the thread's stack, etc.), while a deadlock wastes only memory. <sup>3</sup></p>
<p>In an ideal world, we'd like to have constructs that take the best of both worlds That is, we'd like a construct that is fast and non-blocking (like the user-mode constructs) when there is no contention. But when there is contention for the construct, we'd like it to be blocked by the operating system kernel. Constructs that work like this do exist; I call them hybrid constructs, and I will discuss them in Chapter 29. It is very common for applications to use the hybrid constructs because in most applications, it is rare for two or more threads to attempt to access the same data at the same time. A hybrid construct keeps your application running fast most of the time, and occasionally it runs slowly to block the thread. The slowness usually doesn't matter at this point because your thread is going to be blocked anyway.</p>
<p>I'll show a program that measures the performance later in this chapter</p>
<p>I say that the memory allocated for the thread is wasted because the memory is not being used in a productive manner if the thread is not making forward progress.</p>
<p>Many of the CLR's thread synchronization constructs are really just object-oriented class wrappers around Win32 thread synchronization constructs. After all, CLR threads are Windows threads, which means that Windows schedules and controls the synchronization of threads Windows thread synchronization constructs have been around since 1992, and a ton of material has been written about them.<sup>4</sup> Therefore, I give them only cursory treatment in this chapter.</p>
<a name="b796"/><h2>User-Mode Constructs</h2>
<p>There are two kinds of primitive user-mode thread synchronization constructs:</p>
<p>&#9632; Volatile constructs, which perform an atomic read or write operation on a variable containing a simple data type</p>
<p>&#9632; Interlocked constructs, which perform an atomic read and write operation on a variable containing a simple data type</p>
<p>All the volatile and interlocked constructs require you to pass a reference (memory address) to a variable containing a simple data type Some CPU architectures require that this memory address be properly aligned or else the constructs will throw a <b>DataMisalignedException </b>.</p>
<p>This means that a variable containing a 1-byte, 2-byte, and 4-byte value must be located at a memory address that is a multiple of 1, 2, or 4, respectively, and that a variable containing an 8-byte value is located at a memory address that allows the value to be manipulated atomically by the underlying hardware (a multiple of 4 or 8). Specifically, this means <b>(S)Byte </b>variables are on a 1-byte boundary, <b>(U)Int16 </b>variables are on a 2-byte boundary, <b>(U)Int32 </b>and <b>Single </b>variables are on a 4-byte boundary, and <b>(U)Int64 </b>and <b>Double </b>variables are on a 4-byte or an 8-byte boundary All reference variables and <b>(U)IntPtr </b>variables are 4 bytes wide in a 32-bit process and 8 bytes wide in a 64-bit process, so these variables are always aligned on 4-byte or 8-byte boundaries, depending on the type of process.</p>
<p>Fortunately, the CLR ensures that fields are properly aligned automatically unless the enclosing type has the <b>[StructLayout(LayoutKind.Explicit)] </b>attribute applied to it and <b>[FieldOffset(...)] </b>attributes applied to individual fields, forcing fields to be misaligned. If you avoid using these attributes, then you should have no trouble when using these user-mode constructs.</p>
<p>Accessing any properly aligned variable of the types mentioned above is always atomic. This means that all bytes within that variable are read from or written to all at once So, for example, if you have the following class:</p>
<p>In fact, my own book, Windows via C/C++, 5th Edition (Microsoft Press, 2007), has several chapters devoted to this subject.</p>
<p><code>internal static class SomeType { public static Int32 x = 0;<br/>
}</code></p>
<p>then, if some thread executes this line of code: SomeType.x = 0x01234567;</p>
<p>the <b>x </b>variable will change from <b>0x00000000 </b>to <b>0x01234567 </b>all at once (atomically). Another thread cannot possibly see the value in an intermediate state. For example, it is impossible for some other read to query <b>SomeType.x </b>and get a value of <b>0x01230000</b>. However, while the reads and writes to a properly aligned variable are guaranteed to happen all at once, you are not guaranteed when they happen due to compiler and CPU optimizations. The volatile constructs ensure that the read or write operation is atomic and, more importantly, they also control the timing of these atomic operations The interlocked constructs can perform operations that are slightly more complex than simple read and write operations, and they also control the timing of these operations.</p>
<p>Suppose that the <b>x </b>field in the <b>SomeType </b>class above is an <b>Int64 </b>that is not properly aligned. If a thread executes this line of code:</p>
<p><code>SomeType.x = 0x0123456789abcdef;</code></p>
<p>it is possible that another thread could query <b>x </b>and get a value of <b>0x0123456700000000 </b>or <b>0x0000000089abcdef </b>since the read and write operations are not atomic. This is called a torn read.</p>
<h3>Volatile Constructs</h3>
<p>Back in the early days of computing, software was written using assembly language. Assembly language is very tedious because programmers must explicitly state everything: Use this CPU register for this, branch to that, call indirect through this other thing, and so on. To simplify programming, higher-level languages were introduced. These higher-level languages introduced common useful constructs, like <b>if/else, switch/case, </b>various loops, local variables, arguments, virtual method calls, operator overloads, and much more Ultimately, these language compilers must convert the high-level constructs down to the low-level constructs so that the computer can actually do what you want it to do.</p>
<p>In other words, the C# compiler translates your C# constructs into Intermediate Language (IL), which is then converted by the just-in-time (JIT) compiler into native CPU instructions, which must then be processed by the CPU itself. In addition, the C# compiler, the JIT compiler, and even the CPU itself can optimize your code For example, the following ridiculous method can ultimately be compiled into nothing:</p>
<p><code>private static void OptimizedAway() {<br/>
// Constant expression is computed at compile time resulting in zero Int32 value = (1 * 100) - (50 * 2);<br/>
// If value is 0, the loop never executes for (Int32 x = 0; x &lt; value; x++) {<br/>
// There is no need to compile the code in the loop since it can never execute Console.Writel_ine(&quot;Jeff&quot;);<br/>
}<br/>
}</code></p>
<p>In this code, the compiler can see that <b>value </b>will always be <b>0; </b>therefore, the loop will never execute and consequently, there is no need to compile the code inside the loop This method could be compiled down to nothing In fact, when JITting a method that calls <b>OptimizedAway, </b>the JITter will try to inline the <b>OptimizedAway </b>method's code. Since there is no code, the JITter will even remove the code that tries to call <b>OptimizedAway. </b>We love this feature of compilers. As developers, we get to write the code in the way that makes the most sense to us. The code should be easy to write, read, and maintain. Then compilers translate our intentions into machine-understandable code We want our compilers to do the best job possible for us.</p>
<p>When the C# compiler, JIT compiler, and CPU optimize our code, they guarantee us that the intention of the code is preserved That is, from a single-threaded perspective, the method does what we want it to do, although it may not do it exactly the way we described in our source code. However, the intention might not be preserved from a multithreaded perspective Here is an example where the optimizations make the program not work as expected:</p>
<p><code>internal static class StrangeBehavior {<br/>
// As you'll see later, mark this field as volatile to fix the problem private static Boolean s_stopWorker = false;<br/>
public static void Main() {<br/>
Console.WriteLineC'Main: letting worker run for 5 seconds&quot;);<br/>
Thread t = new Thread(Worker);<br/>
t.Start();<br/>
Thread.Sleep(5000);<br/>
s_stopWorker = true;<br/>
Console.WriteLineC'Main: waiting for worker to stop&quot;); t.Join();<br/>
}<br/>
private static void Worker(Object o) { Int32 x = 0;<br/>
while (!s_stopWorker) x++;<br/>
Console.WriteLineC'Worker: stopped when x={0}&quot;, x);<br/>
}<br/>
}</code></p>
<p>In this code, the <b>Main </b>method creates a new thread that executes the <b>Worker </b>method. This <b>Worker </b>method counts as high as it can before being told to stop. The <b>Main </b>method allows the <b>Worker </b>thread to run for 5 seconds before telling it to stop by setting the <b>static</b></p>
<p><b>Boolean </b>field to <b>true </b>. At this point, the <b>Worker </b>thread should display what it counted up to, and then the thread will terminate. The <b>Main </b>thread waits for the <b>Worker </b>thread to terminate by calling <b>Join, </b>and then the <b>Main </b>thread returns, causing the whole process to terminate.</p>
<p>Looks simple enough, right? Well, the program has a potential problem due to all the optimizations that could happen to it. You see, when the <b>Worker </b>method is compiled, the compiler sees that <b>s_stopWorker </b>is either <b>true </b>or <b>false, </b>and it also sees that this value never changes inside the <b>Worker </b>method itself So the compiler could produce code that checks <b>s_stopWorker </b>first. If <b>s_stopWorker </b>is <b>true, </b>then <b>&quot;Worker: stopped when x=0&quot; </b>will be displayed. If <b>s_stopWorker </b>is <b>false, </b>then the compiler produces code that enters an infinite loop that increments <b>x </b>forever. You see, the optimizations cause the loop to run very fast because checking <b>s_stopWorker </b>only occurs once before the loop; it does not get checked with each iteration of the loop.</p>
<p>If you actually want to see this in action, put this code in a.cs file and compile the code using C#'s <b>/platform:x86 </b>and <b>/optimize+ </b>switches. Then run the resulting EXE file, and you'll see that the program runs forever. Note that you have to compile for x86 ensuring that the x86 JIT compiler is used at runtime. The x86 JIT compiler is more mature than the x64 or IA64 JIT compilers, so it performs more aggressive optimizations. The other JIT compilers do not perform this particular optimization, and therefore the program runs to completion with these other JIT compilers. This highlights another interesting point about all of this. Whether your program behaves as expected depends on a lot of factors, such as which compiler version and compiler switches are used, which JIT compiler is used, and which CPU your code is running on. In addition, to see the program above run forever, you must not run the program under a debugger because the debugger causes the JIT compiler to produce unoptimized code that is easier to step through.</p>
<p>Let's look at another example, which has two threads that are both accessing two fields:</p>
<p><code>internal sealed class ThreadsSharingData { private Int32 m_flag = 0; private Int32 m_value = 0;<br/>
// This method is executed by one thread public void Thread1() {<br/>
// Note: These could execute in reverse order<br/>
m_value = 5;<br/>
m_flag   = 1;<br/>
}<br/>
// This method is executed by another thread public void Thread2() {<br/>
// Note: m_value could be read before m_flag<br/>
if (m_flag == 1)<br/>
Console.WriteLine(m_value);<br/>
}<br/>
}</code></p>
<p>The problem with this code is that the compilers/CPU could translate the code in such a way as to reverse the two lines of code in the <b>Threadl </b>method. After all, reversing the two lines of code does not change the intention of the method. The method needs to get a <b>5 </b>in <b>m_value </b>and a <b>1 </b>in <b>m_flag </b>. From a single-threaded application's perspective, the order of executing this code is unimportant. If these two lines do execute in reverse order, then another thread executing the <b>Thread2 </b>method could see that <b>m_flag </b>is <b>1 </b>and then display <b>0 </b>.</p>
<p>Let's look at this code another way. Let's say that the code in the <b>Threadl </b>method executes in program order (the way it was written). When compiling the code in the <b>Thread2 </b>method, the compiler must generate code to read <b>m_flag </b>and <b>m_value </b>from RAM into CPU registers. It is possible that RAM will deliver the value of <b>m_value </b>first, which would contain a <b>0. </b>Then the <b>Threadl </b>method could execute, changing <b>m_value </b>to <b>5 </b>and <b>m_flag </b>to <b>1 </b>. But <b>Thread2</b>'s CPU register doesn't see that <b>m_value </b>has been changed to <b>5 </b>by this other thread, and then the value in <b>m_flag </b>could be read from RAM into a CPU register and the value of <b>m_flag </b>becomes <b>1 </b>now, causing <b>Thread2 </b>to again display <b>0 </b>.</p>
<p>This is all very exciting stuff and is more likely to cause problems in a release build of your program than in a debug build of your program, making it particularly tricky to detect these problems and correct your code. Now, let's talk about how to correct your code.</p>
<p>The <b>System.Threading.Thread </b>class offers three static methods that look like this<sup>5</sup>:</p>
<p><code>public sealed class Thread {<br/>
public static void   VolatileWrite(ref Int32 address, Int32 value); public static Int32 VolatileRead(ref Int32 address); public static void MemoryBarrier();<br/>
}</code></p>
<p>These methods are special In effect, these methods disable some optimizations usually performed by the C# compiler, the JIT compiler, and the CPU itself. Here's how the methods work:</p>
<p>&#9632; The <b>VolatileWrite </b>method forces the value in <b>address </b>to be written to at the point of the call. In addition, any earlier program-order loads and stores must occur before the call to <b>VolatileWrite </b>.</p>
<p>&#9632; The <b>VolatileRead </b>method forces the value in <b>address </b>to be read from at the point of the call. In addition, any later program-order loads and stores must occur after the call to <b>VolatileRead </b>.</p>
<p>&#9632; The <b>MemoryBarrier </b>method doesn't access memory but it forces any earlier program-order loads and stores to be completed before the call to <b>MemoryBarrier. </b>And it also forces any later program-order loads and stores to be completed after the call to <b>MemoryBarrier. MemoryBarrier </b>is much less useful than the other two methods.</p>
<p>There are also overloads of <b>VolatileRead </b>and <b>VolatileWrite </b>that operate on the following types: <b>(S)Byte, (U)Int16, UInt32, (U)Int64, (U)IntPtr, Single, Double, </b>and <b>Object</b></p>
<hr/>
<blockquote><b>Important </b>I know that this can be very confusing, so let me summarize it as a simple rule: When threads are communicating with each other via shared memory, write the last value by calling <b>VolatileWrite </b>and read the first value by calling <b>VolatileRead </b>.</blockquote>
<hr/>
<p>So now we can fix the <b>ThreadsSharingData </b>class using these methods:</p>
<p><code>internal sealed class ThreadsSharingData { private Int32 m_flag = 0; private Int32 m_value = 0;<br/>
// This method is executed by one thread public void Thread1() {<br/>
// Note: 5 must be written to m_value before 1 is written to m_flag<br/>
m_value = 5;<br/>
Thread.VolatileWriteCref m_flag, 1);<br/>
}<br/>
// This method is executed by another thread public void Thread2() {<br/>
// Note: m_value must be read after m_flag is read<br/>
if (Thread.VolatileReadCref m_flag) == 1) Console.Writel_ine(m_value);<br/>
}<br/>
}</code></p>
<p>First, notice that we are following the rule. The <b>Thread1 </b>method writes two values out to fields that are shared by multiple threads. The last value that we want written (setting <b>m_flag </b>to <b>1) </b>is performed by calling <b>VolatileWrite. </b>The <b>Thread2 </b>method reads two values from fields shared by multiple threads, and the first value being read <b>(m_flag) </b>is performed by calling <b>VolatileRead.</b></p>
<p>But what is really happening here? Well, for the <b>Thread1 </b>method, the <b>VolatileWrite </b>call ensures that all the writes above it are completed before a <b>1 </b>is written to <b>m_flag. </b>Since <b>m_value = 5 </b>is before the call to <b>VolatileWrite, </b>it must complete first. In fact, if there were many variables being modified before the call to <b>VolatileWrite, </b>they would all have to complete before <b>1 </b>is written to <b>m_flag. </b>Note that the writes before the call to <b>VolatileWrite </b>can be optimized to execute in any order; it's just that all the writes have to complete before the call to <b>VolatileWrite </b>.</p>
<p>For the <b>Thread2 </b>method, the <b>VolatileRead </b>call ensures that all variable reads after it start after the value in <b>m_flag </b>has been read. Since reading <b>m_value </b>is after the call to <b>VolatileRead, </b>the value must be read after having read the value in <b>m_flag. </b>If there were many reads after the call to <b>VolatileRead, </b>they would all have to start after the value in <b>m_flag </b>has been read. Note that the reads after the call to <b>VolatileRead </b>can be optimized to execute in any order; it's just that the reads can't start happening until after the call to <b>VolatileRead </b>.</p>
<h3>C#'s Support for Volatile Fields</h3>
<p>Making sure that programmers call the <b>VolatileRead </b>and <b>VolatileWrite </b>methods correctly is a lot to ask. It's hard for programmers to keep all of this in their minds and to start imagining what other threads might be doing to shared data in the background To simplify this, the C# compiler has the <b>volatile </b>keyword, which can be applied to static or instance fields of any of these types: <b>Byte, SByte, Int16, UInt16, Int32, UInt32, Char, Single, </b>or <b>Boolean. </b>You can also apply the <b>volatile </b>keyword to reference types and any enum field so long as the enumerated type has an underlying type of <b>Byte, SByte, Int16, UInt16, Int32, UInt32, Single, </b>or <b>Boolean </b>. The JIT compiler ensures that all accesses to a volatile field are performed as volatile reads and writes so that it is not necessary to explicitly call <b>Thread</b>'s static <b>VolatileRead </b>or <b>VolatileWrite </b>methods. Furthermore, the <b>volatile </b>keyword tells the C# and JIT compilers not to cache the field in a CPU register, ensuring that all reads to and from the field actually cause the value to be read from memory.</p>
<p>Using the <b>volatile </b>keyword, we can rewrite the <b>ThreadsSharingData </b>class as follows:</p>
<p><code>internal sealed class ThreadsSharingData { private volatile Int32 m_flag = 0; private.Int32 m_value = 0;<br/>
// This method is executed by one thread public void Thread1() {<br/>
// Note: 5 must be written to m_value before 1 is written to m_flag<br/>
m_value = 5;<br/>
m_flag = 1;<br/>
}<br/>
// This method is executed by another thread public void Thread2() {<br/>
// Note: m_value must be read after m_flag is read<br/>
if (m_flag == 1)<br/>
Console.Writel_ine(m_value);<br/>
}<br/>
}</code></p>
<p>There are some developers (and I am one of them) who do not like C#'s <b>volatile </b>keyword, and they think that the language should not provide it. Our thinking is that most algorithms require few volatile read or write accesses to a field and that most other accesses to the field can occur normally, improving performance; seldom is it required that all accesses to a field be volatile. For example, it is difficult to interpret how to apply volatile read operations to algorithms like this one:</p>
<p><code>m_amount = m_amount + m_amount; // Assume m_amount is a volatile field defined in a class</code></p>
<p>Normally, an integer number can be doubled simply by shifting all bits left by 1 bit, and many compilers can examine the code above and perform this optimization. However, if <b>m_amount </b>is a <b>volatile </b>field, then this optimization is not allowed. The compiler must produce code to read <b>m_amount </b>into a register and then read it again into another register, add the two registers together, and then write the result back out to the <b>m_amount </b>field. The un-optimized code is certainly bigger and slower; it would be unfortunate if it were contained inside a loop.</p>
<p>Furthermore, C# does not support passing a <b>volatile </b>field by reference to a method. For example, if <b>m_amount </b>is defined as a <b>volatile Int32, </b>attempting to call <b>Int32</b>'s <b>TryParse </b>method causes the compiler to generate a warning as shown here:</p>
<p><code>Boolean success = Int32.TryParse(&quot;123&quot;, out m_amount);<br/>
// The above line causes the C# compiler to generate a warning:<br/>
// CS0420: a reference to a volatile field will not be treated as volatile</code></p>
<h3>Interlocked Constructs</h3>
<p><b>Thread</b>'s <b>VolatileRead </b>method performs an atomic read operation, and its <b>VolatileWrite </b>method performs an atomic write operation That is, each method performs either an atomic read operation or an atomic write operation. In this section, we look at the static <b>System. Threading.Interlocked </b>class's methods. Each of the methods in the <b>Interlocked </b>class performs an atomic read and write operation. In addition, all the <b>Interlocked </b>methods are full memory fences. That is, any variable writes before the call to an <b>Interlocked </b>method execute before the <b>Interlocked </b>method, and any variable reads after the call execute after the call.</p>
<p>The static methods that operate on <b>Int32 </b>variables are by far the most commonly used methods I show them here:</p>
<p><code>public static class Interlocked { // return (++location)<br/>
public static Int32 Increment(ref Int32 location); // return (--location)<br/>
public static Int32 Decrement(ref Int32 location); // return (location1 += value)<br/>
// Note: value can be a negative number allowing subtraction public static Int32 Add(ref Int32 location1, Int32 value);<br/>
// Int32 old = location1; location1 = value; return old; public static Int32 Exchange(ref Int32 location1, Int32 value);<br/>
// Int32 old = location1;<br/>
// if (location1 == comparand) location1 = value; // return old;<br/>
public static Int32 CompareExchange(ref Int32 location1, Int32 value, Int32 comparand);<br/>
}</code></p>
<p>There are also overloads of the above methods that operate on <b>Int64 </b>values. Furthermore, the <b>Interlocked </b>class offers <b>Exchange </b>and <b>CompareExchange </b>methods that take <b>Object, IntPtr, Single, </b>and <b>Double, </b>and there is also a generic version in which the generic type is constrained to <b>class </b>(any reference type).</p>
<p>Personally, I love the <b>Interlocked </b>methods because they are relatively fast and you can do so much with them. Let me show you some code that uses the <b>Interlocked </b>methods to asynchronously query several Web servers for data. This code is pretty short, never blocks any threads, and uses thread pool threads to scale automatically, consuming up to the number of CPUs available if its workload could benefit from it. In addition, the code, as is, supports accessing up to 2,147,483,647 <b>(Int32.MaxValue) </b>Web servers. In other words, this code is a great model to follow for your own scenarios.</p>
<p><code>internal sealed class MultiWebRequests {<br/>
// This helper class coordinates all the asynchronous operations private AsyncCoordinator m_ac = new AsyncCoordinator();<br/>
// This is the set of Web servers we want to query private WebRequest[] m_requests = new WebRequest[] {<br/>
WebRequest.Create(&quot;<a href="http://Wintellect.com/">http://Wintellect.com/</a>&quot;),<br/>
WebRequest.Create(&quot;<a href="http://Microsoft.com/">http://Microsoft.com/</a>&quot;)<br/>
};<br/>
// Create the response array: one response for each request private WebResponse[] m_results = new WebResponse[2];<br/>
public MultiWebRequests(Int32 timeout = Timeout.Infinite) { // Asynchronously initiate all the requests all at once for (Int32 n = 0; n &lt; m_requests.Length; n++) { m_ac.AboutToBegin(1);<br/>
m_requests[n].BeginGetResponse(EndGetResponse, n);<br/>
}<br/>
// Tell the helper class that all operations have been initiated // and to call AllDone when all operations complete, Cancel is // called, or the timeout occurs m_ac.AllBegun(AllDone, timeout);<br/>
}<br/>
// Calling this method indicates that the results don't matter anymore public void Cancel() { m_ac.Cancel(); }<br/>
// As each Web server responds, this method is called private void EndGetResponse(IAsyncResult result) {<br/>
// Get the index corresponding to the request<br/>
Int32 n = (Int32)result.AsyncState;<br/>
// Store the response in the same index as the request m_results[n] = m_requests[n].EndGetResponse(result);<br/>
// Tell the helper class that a Web server responded m_ac.JustEnded();<br/>
}<br/>
// This method is called after all Web servers respond, // Cancel is called, or the timeout occurs private void AllDone(CoordinationStatus status) { switch (status) {<br/>
case CoordinationStatus.Cancel:<br/>
Console.WriteLineC'The operation was canceled&quot;); break;<br/>
case CoordinationStatus.Timeout:<br/>
Console.WriteLineC'The operation timed-out&quot;); break;<br/>
case CoordinationStatus.AllDone:<br/>
Console.WriteLineC'Here are the results from all the Web servers&quot;); for (Int32 n = 0; n &lt; m_requests.Length; n++) { Console.WriteLine(&quot;{0} returned {1} bytes.&quot;,<br/>
m_results[n].ResponseUri, m_results[n].ContentLength);<br/>
}<br/>
break;<br/>
}<br/>
}<br/>
}</code></p>
<p>OK, the code above doesn't actually use any <b>Interlocked </b>methods directly because I encapsulated all the coordination code in a reusable class called <b>AsyncCoordinator, </b>which I'll explain shortly. Let me first explain what this class is doing. When the <b>MultiWebRequest </b>class is constructed, it initializes an <b>AsyncCoordinator, </b>the array of <b>WebRequest </b>objects, and the array of <b>WebResponse </b>objects. It then issues all the Web requests asynchronously by calling <b>BeginGetResponse. </b>Just before issuing each request, it calls the <b>AsyncCoordinator</b>'s <b>AboutToBegin </b>method, passing it the number of requests about to be issued. <sup>6</sup></p>
<p>After all the Web servers' requests have been made, <b>AsyncCoordinator</b>'s <b>AllBegun </b>method is called, passing it the name of the method that should execute when all the operations complete <b>(AllDone) </b>and a timeout value. As each Web server responds, various thread pool threads will call <b>MultiWebRequests</b>'s <b>EndGetResponse </b>method. This method determines which request it is processing (by examining the <b>IAsyncResult</b>'s <b>AsyncState </b>property) and then saves the <b>WebResponse </b>object in the <b>m_results </b>array. After storing each result, <b>AsyncCoordinator</b>'s <b>JustEnded </b>method is called to let the <b>AsyncCoordinator </b>object know that an operation completed.</p>
<p>If all the operations have completed, then the <b>AsyncCoordinator </b>will invoke the <b>AllDone </b>method to process the results from all the Web servers. The code executing the <b>AllDone </b>method will be the thread pool thread that just happened to get the last Web server response. If timeout or cancellation occurs, then <b>AllDone </b>will be invoked via whatever thread pool thread notifies the <b>AsyncCoordinator </b>of timeout or using whatever thread happened to call the <b>Cancel </b>method. There is also a chance that the thread issuing the Web server requests could invoke <b>AllDone </b>itself if the last request completes before <b>AllBegin </b>is called.</p>
<p>The code would still work correctly if it was rewritten calling <b>m_ac.AboutToBeging(m_requests.Length) </b>just once before the for loop instead of calling <b>AboutToBegin </b>inside the loop.</p>
<p>Note that there is a race because it is possible that all Web server requests complete, <b>AllBegun </b>is called, timeout occurs, and <b>Cancel </b>is called all at the exact same time. If this happens, then the <b>AsyncCoordinator </b>will select a winner and three losers, ensuring that the <b>AllDone </b>method is never called more than once. The winner is identified by the status argument passed into <b>AllDone, </b>which can be one of the symbols defined by the <b>CoordinationStatus </b>type:</p>
<p><code>internal enum CoordinationStatus { AllDone, Timeout, Cancel };</code></p>
<p>Now that you get a sense of what happens, let's take a look at how it works. The <b>AsyncCoordinator </b>class encapsulates all the thread coordination logic in it. It uses <b>Interlocked </b>methods for everything to ensure that the code runs extremely fast and that no threads ever block Here is the code for this class:</p>
<p><code>internal sealed class AsyncCoordinator {<br/>
private Int32 m_opCount = 1;// Decremented by AllBegun<br/>
private Int32 m_statusReported = 0; // 0=false, 1=true private Action&lt;CoordinationStatus&gt; m_callback; private Timer m_timer;<br/>
// This method MUST be called BEFORE calling a BeginXxx method public void AboutToBegin(Int32 opsToAdd = 1) { Interlocked.Add(ref m_opCount, opsToAdd);<br/>
}<br/>
// This method MUST be called AFTER calling an EndXxx method public void JustEnded() {<br/>
if (Interlocked.Decrement(ref m_opCount) == 0) ReportStatus(CoordinationStatus.AllDone);<br/>
}<br/>
// This method MUST be called AFTER calling ALL BeginXxx methods public void AllBegun(Action&lt;CoordinationStatus&gt; callback, Int32 timeout = Timeout.Infinite) {<br/>
m_callback = callback;<br/>
if (timeout != Timeout.Infinite)<br/>
m_timer = new Timer(TimeExpired, null, timeout, Timeout.Infinite); JustEnded();<br/>
}<br/>
private void TimeExpired(Object o) { ReportStatus(CoordinationStatus.Timeout); } public void Cancel(){ ReportStatus(CoordinationStatus.Cancel); }<br/>
private void ReportStatus(CoordinationStatus status) {<br/>
// If status has never been reported, report it; else ignore it if (Interlocked.Exchange(ref m_statusReported, 1) == 0) m_callback(status);<br/>
}<br/>
}</code></p>
<p>The most important field in this class is the <b>m_opCount </b>field. This field keeps track of the number of asynchronous operations that are still outstanding. Just before each asynchronous operation is started, <b>AboutToBegin </b>is called. This method calls <b>Interlocked.Add </b>to add the number passed to it to the <b>m_opCount </b>field in an atomic way. Adding to <b>m_opCount </b>must be performed atomically because Web servers could be responding on thread pool threads as more operations are being started. As Web servers respond, <b>JustEnded </b>is called. This method calls <b>Interlocked.Decrement </b>to atomically subtract <b>1 </b>from <b>m_opCount </b>. Whichever thread happens to set <b>m_opCount </b>to <b>0 </b>calls <b>ReportStatus.</b></p>
<hr/>
<blockquote><b>Note </b>The <b>m_opCount </b>field is initialized to <b>1 </b>(not <b>0); </b>this is critically important as it ensures that <b>AllDone </b>is not invoked while the thread executing the constructor method is still issuing Web server requests. Before the constructor calls <b>AllBegun, </b>there is no way that <b>m_opCount </b>will ever reach <b>0 </b>. When the constructor calls <b>AllBegun, AllBegun </b>internally calls <b>JustEnded, </b>which decrements <b>m_opCount </b>and effectively undoes the effect of having initialized it to <b>1 </b>Now, <b>m_opCount </b>can reach <b>0, </b>but only after we know that all the Web server requests have been initiated.</blockquote>
<hr/>
<p>The <b>ReportStatus </b>method arbitrates the race that can occur among all the operations completing, the timeout occurring, and <b>Cancel </b>being called. <b>ReportStatus </b>must make sure that only one of these conditions is considered the winner so that the <b>m_callback </b>method is invoked only once. Arbitrating the winner is done via calling <b>Interlocked.Exchange, </b>passing it a reference to the <b>m_statusReported </b>field. This field is really treated as a Boolean variable; however, it can't actually be a <b>Boolean </b>variable because there are no <b>Interlocked </b>methods that accept a <b>Boolean </b>variable. So I use an <b>Int32 </b>variable instead where <b>0 </b>means <b>false </b>and <b>1 </b>means <b>true.</b></p>
<p>Inside <b>ReportStatus, </b>the <b>Interlocked.Exchange </b>call will change <b>m_statusReported </b>to <b>1 </b>But only the first thread to do this will see <b>Interlocked.Exchange </b>return a <b>0, </b>and only this thread will invoke the callback method. Any other threads that call <b>Interlocked.Exchange </b>will get a return value of <b>1, </b>effectively notifying these threads that the callback method has already been invoked and therefore it should not be invoked again.</p>
<h3>Implementing a Simple Spin Lock</h3>
<p>The <b>Interlocked </b>methods are great but they mostly operate on <b>Int32 </b>values. What if you need to manipulate a bunch of fields in a class object atomically? In this case, we need a way to stop all threads but one from entering the region of code that manipulates the fields. Using <b>Interlocked </b>methods, we can build a thread synchronization lock:</p>
<p><code>internal struct SimpleSpinLock {<br/>
private Int32 m_ResourceInUse; // 0=false (default), 1=true<br/>
public void Enter() {<br/>
// Set the resource to in-use and if this thread // changed it from Free, then return<br/>
while (Interlocked.Exchange(ref m_ResourceInUse, 1) != 0) { /* Black Magic goes here... */<br/>
}<br/>
}<br/>
public void Leave() {<br/>
// Mark the resource as Free Thread.VolatileWrite(ref m_ResourceInUse, 0);<br/>
}<br/>
}</code></p>
<p>And here is a class that shows how to use the <b>SimpleSpinLock:</b></p>
<p><code>public sealed class SomeResource {<br/>
private SimpleSpinLock m_s1 = new SimpleSpinLock();<br/>
public void AccessResource() { m_sl.Enter();<br/>
// Only one thread at a time can get in here to access the resource... m_sl.Leave();<br/>
}<br/>
}</code></p>
<p>The <b>SimpleSpinLock </b>implementation is very simple. If two threads call <b>Enter </b>at the same time, <b>Interlocked.Exchange </b>ensures that one thread changes <b>m_resourceInUse </b>from <b>0 </b>to <b>1 </b>and sees that <b>m_resourceInUse </b>was <b>0, </b>and this thread then returns from <b>Enter </b>so that it can continue executing the code in the <b>AccessResource </b>method The other thread will change <b>m_resourceInUse </b>from a <b>1 </b>to a <b>1 </b>This thread will see that it did not change <b>m_resourceInUse </b>from a <b>0, </b>and this thread will now start spinning continuously calling <b>Exchange </b>until the first thread calls <b>Leave.</b></p>
<p>When the first thread is done manipulating the fields of the <b>SomeResource </b>object, it calls <b>Leave, </b>which internally calls <b>Thread.VolatileWrite </b>and changes <b>m_resourceInUse </b>back to a <b>0 </b>This causes the spinning thread to then change <b>m_resourceInUse </b>from a <b>0 </b>to a <b>1 </b>and this thread now gets to return from <b>Enter </b>so that it can access <b>SomeResource </b>object's fields.</p>
<p>There you have it. This is a simple implementation of a thread synchronization lock. The big potential problem with this lock is that it causes threads to spin when there is contention for the lock. This spinning wastes precious CPU time, preventing the CPU from doing other, more useful work. As a result, spin locks should only ever be used to guard regions of code that execute very quickly.</p>
<p>And spin locks should not typically be used on single-CPU machines, as the thread that holds the lock can't quickly release it if the thread that wants the lock is spinning. The situation be-</p>
<p>comes much worse if the thread holding the lock is at a lower priority than the thread wanting to get the lock because now the thread holding the lock may not get a chance to run at all, resulting in a livelock situation. Windows sometimes boosts a thread's priority dynamically for short periods of time Therefore, boosting should be disabled for threads that are using spin locks; see the <b>PriorityBoostEnabled </b>properties of <b>System.Diagnostics.Process </b>and <b>System.Diagnostics.ProcessThread. </b>There are issues related to using spin locks on hyperthreaded machines, too In an attempt to circumvent these kinds of problems, many spin locks have some addition logic in them; I refer to the additional logic as Black Magic. I'd rather not go into the details of Black Magic because it changes over time as more people study locks and their performance. However, I will say this: The FCL ships with a structure, <b>System.Threading.SpinWait, </b>which encapsulates the state-of-the-art thinking around this Black Magic.</p>
<p><b>Putting a Delay in the Thread's Processing</b></p>
<p>The Black Magic is all about having a thread that wants a resource to pause its execution temporarily so that the thread that currently has the resource can execute its code and relinquish the resource. To do this, the <b>SpinWait </b>struct internally calls <b>Thread</b>'s static <b>Sleep, Yield, </b>and <b>SpinWait </b>methods. I'll briefly describe these methods in this sidebar.</p>
<p>A thread can tell the system that it does not want to be schedulable for a certain amount of time. This is accomplished by calling <b>Thread</b>'s static <b>Sleep </b>method:</p>
<p><code>public static void Sleep(Int32 millisecondsTimeout); <b>I    </b>public static void Sleep(TimeSpan timeout);</code></p>
<p>This method causes the thread to suspend itself until the specified amount of time has elapsed. Calling <b>Sleep </b>allows the thread to voluntarily give up the remainder of its time-slice. The system makes the thread not schedulable for approximately the amount of time specified. That's right擁f you tell the system you want to sleep for 100 milliseconds, you will sleep approximately that long, but possibly several seconds or even minutes more. Remember that Windows is not a real-time operating system. Your thread will probably wake up at the right time, but whether it does depends on what else is going on in the system.</p>
<p>You can call <b>Sleep </b>and pass the value in <b>System.Threading.Timeout.Infinite</b></p>
<p>(defined as <b>-1) </b>for the <b>millisecondsTimeout </b>parameter. This tells the system to never schedule the thread, and it is not a useful thing to do It is much better to have the thread exit and then recover its stack and kernel object. You can pass <b>0 </b>to <b>Sleep </b>. This tells the system that the calling thread relinquishes the remainder of its current time-slice, and it forces the system to schedule another thread However, the system can reschedule the thread that just called <b>Sleep </b>. This will happen if there are no more schedulable threads at the same priority or higher.</p>
<p>A thread can ask Windows to schedule another thread on the current CPU by calling <b>Thread</b>'s <b>Yield </b>method:</p>
<p><code>public static Boolean Yield();</code></p>
<p>If Windows has another thread ready to run on the current processor, then <b>Yield </b>returns <b>true </b>and the thread that called <b>Yield </b>ended its time-slice early, the selected thread gets to run for one time-slice, and then the thread that called <b>Yield </b>is scheduled again and starts running with a fresh new time-slice. If Windows does not have another thread to run on the current processor, then <b>Yield </b>returns <b>false </b>and the thread continues its time-slice.</p>
<p>The <b>Yield </b>method exists in order to give a thread of equal or lower priority that is starving for CPU time a chance to run A thread calls this method if it wants a resource that is currently owned by another thread. The hope is that Windows will schedule the thread that currently owns the resource and that this thread will relinquish the resource. Then, when the thread that called <b>Yield </b>runs again, this thread can have the resource.</p>
<p><b>Yield </b>is a cross between calling <b>Thread.Sleep(0) </b>and <b>Thread.Sleep(1). Thread. Sleep(0) </b>will not let a lower-priority thread run whereas <b>Thread.Sleep(1) </b>will always force a context switch and Windows will force the thread to sleep longer than 1 millisecond due to the resolution of the internal system timer.</p>
<p>Hyperthreaded CPUs really let only one thread run at a time. So, when executing spin loops on these CPUs, you need to force the current thread to pause so that the CPU switches to the other thread, allowing it to run A thread can force itself to pause, allowing a hyperthreaded CPU to switch to its other thread by calling <b>Thread</b>'s <b>SpinWait </b>method:</p>
<p><code>public static void SpinWait(Int32 iterations);</code></p>
<p>Calling this method actually executes a special CPU instruction; it does not tell Windows to do anything (since Windows already thinks that it has scheduled two threads on the CPU). On a non-hyperthreaded CPU, this special CPU instruction is simply ignored.</p>
<hr/>
<blockquote><b>Note </b>For more information about these methods, see their Win32 equivalents: <b>Sleep, </b><b>I   </b><b>SwitchToThread, </b>and <b>YieldProcessor </b>. You can also learn more about adjusting the <b>I   </b>resolution of the system timer by looking up the Win32 <b>timeBeginPeriod </b>and <b>I   </b><b>timeEndPeriod </b>functions.</blockquote>
<hr/>
<p>The FCL also includes a <b>System.Threading.SpinLock </b>structure that is similar to my <b>SimpleSpinLock </b>class shown earlier except that it uses the <b>SpinWait </b>structure to improve performance. The <b>SpinLock </b>structure also offers timeout support. By the way, it is interesting to note that my <b>SimpleSpinLock </b>and the FCL's <b>SpinLock </b>are both value types. This means that they are lightweight, memory-friendly objects. A <b>SpinLock </b>is a good choice if you need to associate a lock with each item in a collection, for example. However, you must make sure that you do not pass <b>SpinLock </b>instances around because they are copied and you will lose any and all synchronization. And while you can define instance <b>SpinLock </b>fields, do not mark the field as <b>readonly </b>because its internal state must change as the lock is manipulated.</p>
<h3>The Interlocked Anything Pattern</h3>
<p>Many people look at the <b>Interlocked </b>methods and wonder why Microsoft doesn't create a richer set of interlocked methods that can be used in a wider range of scenarios. For example, it would be nice if the <b>Interlocked </b>class offered <b>Multiple, Divide, Minimum, Maximum, And, Or, Xor, </b>and a bunch of other methods. While the <b>Interlocked </b>class doesn't offer these methods, there is a well-known pattern that allows you to perform any operation on an <b>Int32 </b>in an atomic way by using <b>Interlocked.CompareExchange. </b>In fact, since <b>Interlocked.CompareExchange </b>has additional overloads that operate on <b>Int64, Single, Double, Object, </b>and a generic reference type, this pattern will actually work for all these types, too.</p>
<p>Here is an example of the pattern that is being used to create an atomic <b>Maximum </b>method:</p>
<p><code>public static Int32 Maximum(ref Int32 target, Int32 value) { Int32 currentVal = target, startVal, desiredVal;<br/>
// Don't access target in the loop except in an attempt // to change it because another thread may be touching it<br/>
do {<br/>
// Record this iteration's starting value startVal = currentVal;<br/>
// Calculate the desired value in terms of startVal and value desiredVal = Math.Max(startVal, value);<br/>
// NOTE: the thread could be preempted here!<br/>
// if (target == startVal) target = desiredVal // Value prior to potential change is returned<br/>
currentVal = Interlocked.CompareExchange(ref target, desiredVal, startVal);<br/>
// If the starting value changed during this iteration, repeat } while (startVal  != currentVal);<br/>
// Return the maximum value when this thread tried to set it return desiredVal;<br/>
}</code></p>
<p>Now let me explain exactly what is going on here. Upon entering the method, <b>currentVal </b>is initialized to the value in <b>target </b>at the moment the method starts executing Then, inside the loop, <b>startVal </b>is initialized to this same value. Using <b>startVal, </b>you can perform any operation you desire. This operation can be extremely complex, consisting of thousands of lines of code But, ultimately, you must end up with a result that is placed into <b>desiredVal </b>In my example, I simply determine whether <b>startVal </b>or <b>value </b>contains the larger value.</p>
<p>Now, while this operation is running, another thread could change the value in <b>target </b>It is unlikely that this will happen, but it is possible. If this does happen, then the value in <b>derivedVal </b>is based off an old value in <b>startVal, </b>not the current value in <b>target, </b>and therefore, we should not change the value in <b>target </b>To ensure that the value in <b>target </b>is changed to <b>desiredVal </b>if no thread has changed <b>target </b>behind our thread's back, we use <b>Interlocked.CompareExchange. </b>This method checks if the value in <b>target </b>matches the value in <b>startVal </b>(which identifies the value that we thought was in <b>target </b>before starting to perform the operation) If the value in <b>target </b>didn't change, then <b>CompareExchange </b>changes it to the new value in <b>desiredVal. </b>If the value in <b>target </b>did change, then <b>CompareExchange </b>does not alter the value in <b>target </b>at all.</p>
<p><b>CompareExchange </b>returns the value that is in <b>target </b>at the time when <b>CompareExchange </b>is called, which I then place in <b>currentVal. </b>Then, a check is made comparing <b>startVal </b>with the new value in <b>currentVal </b>If these values are the same, then a thread did not change <b>target </b>behind our thread's back, <b>target </b>now contains the value in <b>desiredVal, </b>the <b>while </b>loop does not loop around, and the method returns. If <b>startVal </b>is not equal to <b>currentVal, </b>then a thread did change the value in <b>target </b>behind our thread's back, <b>target </b>did not get changed to our value in <b>desiredVal, </b>and the <b>while </b>loop will loop around and try the operation again, this time using the new value in <b>currentVal </b>that reflects the other thread's change.</p>
<p>Personally, I have used this pattern in a lot of my own code and, in fact, I made a generic method, <b>Morph, </b>which encapsulates this pattern<sup>7</sup>:</p>
<p><code>delegate Int32 Morpher&lt;TResult, TArgument&gt;(Int32 startValue, TArgument argument, out TResult morphResult);<br/>
static TResult Morph&lt;TResult, TArgument&gt;(ref Int32 target, TArgument argument, Morpher&lt;TResult, TArgument&gt; morpher) {<br/>
TResult morphResult;<br/>
Int32 currentVal = target, startVal, desiredVal;<br/>
do {<br/>
startVal = currentVal;<br/>
desiredVal = morpher(startVal, argument, out morphResult);<br/>
currentVal = Interlocked.CompareExchange(ref target, desiredVal, startVal); } while (startVal  != currentVal); return morphResult;<br/>
}</code></p>
<p>Obviously, the <b>Morph </b>method incurs a performance penalty due to invoking the <b>morpher </b>callback method For best performance, execute the operation inline, as in the <b>Maximum </b>example.</p>
<a name="b813"/><h2>Kernel-Mode Constructs</h2>
<p>Windows offers several kernel-mode constructs for synchronizing threads The kernel-mode constructs are much slower than the user-mode constructs because they require coordination from the Windows operating system itself and because each method call on a kernel object causes the calling thread to transition from managed code to native user-mode code to native kernel-mode code and then return all the way back. These transitions require a lot of CPU time and, if performed frequently, can adversely affect the overall performance of your application.</p>
<p>However, the kernel-mode constructs offer some benefits over the primitive user-mode constructs, such as:</p>
<p>&#9632; When a kernel-mode construct detects contention on a resource, Windows blocks the losing thread so that it is not spinning on a CPU, wasting processor resources.</p>
<p>&#9632; Kernel-mode constructs can synchronize native and managed threads with each other.</p>
<p>&#9632; Kernel-mode constructs can synchronize threads running in different processes on the same machine.</p>
<p>&#9632; Kernel-mode constructs can have security applied to them to prevent unauthorized accounts from accessing them.</p>
<p>&#9632; A thread can block until all kernel-mode constructs in a set are available or until any one kernel-mode construct in a set has become available.</p>
<p>&#9632; A thread can block on a kernel-mode construct specifying a timeout value; if the thread can't have access to the resource it desires in the specified amount of time, then the thread is unblocked and can perform other tasks.</p>
<p>The two primitive kernel-mode thread synchronization constructs are events and semaphores Other kernel-mode constructs, such as mutex, are built on top of the two primitive constructs. For more information about the Windows kernel-mode constructs, see my book Windows via C/C++, 5th Edition (Microsoft Press, 2007).</p>
<p>The <b>System.Threading </b>namespace offers an abstract base class called <b>WaitHandle. </b>The <b>WaitHandle </b>class is a simple class whose sole purpose is to wrap a Windows kernel object handle. The FCL provides several classes derived from <b>WaitHandle </b>. All classes are defined in the <b>System.Threading </b>namespace, and all classes are implemented in MSCorLib.dll except for <b>Semaphore, </b>which is implemented in System, dll. The class hierarchy looks like this:</p>
<p><code>WaitHandle<br/>
EventWaitHandle<br/>
AutoResetEvent<br/>
ManualResetEvent Semaphore Mutex</code></p>
<p>Internally, the <b>WaitHandle </b>base class has a <b>SafeWaitHandle </b>field that holds a Win32 kernel object handle. This field is initialized when a concrete <b>WaitHandle</b>-derived class is constructed. In addition, the <b>WaitHandle </b>class publicly exposes methods that are inherited by all the derived classes. Every method called on a kernel-mode construct represents a full memory fence. <b>WaitHandle</b>'s interesting public methods are shown below (some overloads for some methods are not shown):</p>
<p><code>public abstract class WaitHandle : MarshalByRefObject, IDisposable { // Close &amp; Dispose internally call the Win32 CloseHandle function. public virtual void Close(); public void Dispose();<br/>
// WaitOne internally calls the Win32 WaitForSingleObjectEx function. public virtual Boolean WaitOne();<br/>
public virtual Boolean WaitOne(Int32 millisecondsTimeout);<br/>
// WaitAny internally calls the Win32 WaitForMultipleObjectsEx function public static Int32 WaitAny(WaitHandle[] waitHandles);<br/>
public static Int32 WaitAny(WaitHandle[] waitHandles, Int32 millisecondsTimeout);<br/>
// WaitAll internally calls the Win32 WaitForMultipleObjectsEx function public static Boolean WaitAll(WaitHandle[] waitHandles);<br/>
public static Boolean WaitAll(WaitHandle[] waitHandles, Int32 millisecondsTimeout);<br/>
// SignalAndWait internally calls the Win32 SignalObjectAndWait function public static Boolean SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn); public static Boolean SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, Int32 millisecondsTimeout, Boolean exitContext)<br/>
// Use this to get access to the raw Win32 handle public SafeWaitHandle SafeWaitHandle { get; set; }<br/>
// Returned from WaitAny if a timeout occurs public const Int32 WaitTimeout = 0x102;<br/>
}</code></p>
<p>There are a few things to note about these methods:</p>
<p>&#9632; You call <b>WaitHandle</b>'s <b>Close </b>(or <b>IDisposable</b>'s parameterless <b>Dispose </b>method)</p>
<p>to close the underlying kernel object handle Internally, these methods call the Win32 <b>CloseHandle </b>function.</p>
<p>&#9632; You call <b>WaitHandle</b>'s <b>WaitOne </b>method to have the calling thread wait for the underlying kernel object to become signaled Internally, this method calls the Win32 <b>WaitForSingleObjectEx </b>function. The returned <b>Boolean </b>is <b>true </b>if the object became signaled or <b>false </b>if a timeout occurs.</p>
<p>&#9632; You call <b>WaitHandle</b>'s static <b>WaitAny </b>method to have the calling thread wait for any one of the kernel objects specified in the <b>WaitHandle[] </b>to become signaled. The returned <b>Int32 </b>is the index of the array element corresponding to the kernel object that became signaled, or <b>WaitHandle.WaitTimeout </b>if no object became signaled while waiting. Internally, this method calls the Win32 <b>WaitForMultipleObjectsEx </b>function, passing <b>FALSE </b>for the <b>bWaitAll </b>parameter.</p>
<p>&#9632; You call <b>WaitHandle</b>'s static <b>WaitAll </b>method to have the calling thread wait for all the kernel objects specified in the <b>WaitHandle[] </b>to become signaled. The returned <b>Boolean </b>is <b>true </b>if all of the objects became signaled or <b>false </b>if a timeout occurs. Internally, this method calls the Win32 <b>WaitForMultipleObjectsEx </b>function, passing <b>TRUE </b>for the <b>bWaitAll </b>parameter.</p>
<p>&#9632; The array that you pass to the <b>WaitAny </b>and <b>WaitAll </b>methods must contain no more than 64 elements or else the methods throw a <b>System.NotSupportedException.</b></p>
<p>&#9632; You call <b>WaitHandle</b>'s static <b>SignalAndWait </b>method to atomically signal one kernel object and wait for another kernel object to become signaled The returned <b>Boolean </b>is <b>true </b>if the object became signaled or <b>false </b>if a timeout occurs. Internally, this method calls the Win32 <b>SignalObjectAndWait </b>function.</p>
<hr/>
<blockquote><b>Note </b>In some cases, when a COM single-threaded apartment thread blocks, the thread can wake up internally to pump messages For example, the blocked thread will wake to process a Windows message sent from another thread. This is done to support COM interoperability. For most applications, this is not a problem擁n fact, it is a good thing. However, if your code takes another thread synchronization lock during the processing of the message, then deadlock could occur. As you'll see in Chapter 29, all the hybrid locks call these methods internally, so the same potential benefit or problem exists when using the hybrid locks as well.</blockquote>
<hr/>
<p>The versions of the <b>WaitOne, WaitAll, </b>and <b>SignalAndWait </b>that do not accept a timeout parameter should be prototyped as having a <b>void </b>return type, not <b>Boolean. </b>The reason is because these methods will return only <b>true </b>since the implied timeout is infinite <b>(System.Threading.Timeout.Infinite). </b>When you call any of these methods, you do not need to check their return value.</p>
<p>As already mentioned, the <b>AutoResetEvent, ManualResetEvent, Semaphore, </b>and <b>Mutex </b>classes are all derived from <b>WaitHandle, </b>so they inherit <b>WaitHandle</b>'s methods and their behavior However, these classes introduce additional methods of their own, and I'll address those now.</p>
<p>First, the constructors for all of these classes internally call the Win32 <b>CreateEvent </b>(passing <b>FALSE </b>for the <b>bManualReset </b>parameter) or <b>CreateEvent </b>(passing <b>TRUE </b>for the <b>bManualReset </b>parameter), <b>CreateSemaphore, </b>or <b>CreateMutex </b>functions The handle value returned from all of these calls is saved in a private <b>SafeWaitHandle </b>field defined inside the <b>WaitHandle </b>base class.</p>
<p>Second, the <b>EventWaitHandle, Semaphore, </b>and <b>Mutex </b>classes all offer static <b>OpenExisting </b>methods, which internally call the Win32 <b>OpenEvent, OpenSemaphore, </b>or <b>OpenMutex </b>functions, passing a <b>String </b>argument that identifies an existing named kernel object. The handle value returned from all of these functions is saved in a newly constructed object that is returned from the <b>OpenExisting </b>method. If no kernel object exists with the specified name, a <b>WaitHandleCannotBeOpenedException </b>is thrown.</p>
<p>A common usage of the kernel-mode constructs is to create the kind of application that allows only one instance of itself to execute at any given time. Examples of single-instance applications are Microsoft Office Outlook, Windows Live Messenger, Windows Media Player, and Windows Media Center. Here is how to implement a single-instance application:</p>
<p><code>using System;<br/>
using System.Threading;<br/>
public static class Program { public static void Main() { Boolean createdNew;<br/>
// Try to create a kernel object with the specified name<br/>
using (new Semaphore(0, 1, &quot;SomeUniqueStringIdentifyingMyApp&quot;, out createdNew)) { if (createdNew) {<br/>
// This thread created the kernel object so no other instance of this // application must be running. Run the rest of the application here... } else {<br/>
// This thread opened an existing kernel object with the same string name; // another instance of this application must be running now. // There is nothing to do in here, let's just return from Main to terminate // this second instance of the application.<br/>
}<br/>
}<br/>
}<br/>
}</code></p>
<p>In this code, I am using a <b>Semaphore, </b>but it would work just as well if I had used an <b>EventWaitHandle </b>or a <b>Mutex </b>because I'm not actually using the thread synchronization behavior that the object offers. However, I am taking advantage of some thread synchronization behavior that the kernel offers when creating any kind of kernel object Let me explain how the code above works Let's say that two instances of this process are started at the same exact time Each process will have its own thread, and both threads will attempt to create a <b>Semaphore </b>with the same string name (&quot;SomeUniqueStringIdentifyingMyApp,&quot; in my example). The Windows kernel ensures that only one thread actually creates a kernel object with the specified name; the thread that created the object will have its <b>createdNew </b>variable set to <b>true </b>.</p>
<p>For the second thread, Windows will see that a kernel object with the specified name already exists; the second thread does not get to create another kernel object with the same name, although if this thread continues to run, it can access the same kernel object as the first process's thread. This is how threads in different processes can communicate with each other via a single kernel object. However, in this example, the second process's thread sees that its <b>createdNew </b>variable is set to <b>false. </b>This thread now knows that another instance of this process is running, and the second instance of the process exits immediately.</p>
<h3>Event Constructs</h3>
<p>Events are simply Boolean variables maintained by the kernel. A thread waiting on an event blocks when the event is <b>false </b>and unblocks when the event is <b>true. </b>There are two kinds of events. When an auto-reset event is <b>true, </b>it wakes up just one blocked thread because the kernel automatically resets the event back to <b>false </b>after unblocking the first thread. When a manual-reset event is <b>true, </b>it unblocks all threads waiting for it because the kernel does not automatically reset the event back to <b>false; </b>your code must manually reset the event back to <b>false </b>The classes related to events look like this:</p>
<p><code>public class EventWaitHandle : WaitHandle {<br/>
public Boolean Set();      // Sets Boolean to true; always returns true public Boolean Reset();   // Sets Boolean to false; always returns true<br/>
}<br/>
public sealed class AutoResetEvent : EventWaitHandle { public AutoResetEvent(Boolean initialState);<br/>
}<br/>
public sealed class ManualResetEvent : EventWaitHandle { public ManualResetEvent(Boolean initialState);<br/>
}</code></p>
<p>Using an auto-reset event, we can easily create a thread synchronization lock whose behavior is similar to the <b>SimpleSpinLock </b>class I showed earlier:</p>
<p><code>internal sealed class SimpleWaitLock : IDisposable {<br/>
private AutoResetEvent m_ResourceFree = new AutoResetEvent(true); // Initially free<br/>
public void Enter() {<br/>
// Block efficiently in the kernel for the resource to be free, then return m_ResourceFree.WaitOne();<br/>
}<br/>
public void Leave() {<br/>
m_ResourceFree.Set();// Mark the resource as Free<br/>
}<br/>
public void Dispose() { m_ResourceFree.Dispose(); }<br/>
}</code></p>
<p>You would use this <b>SimpleWaitLock </b>exactly the same way that you'd use the <b>SimpleSpinLock </b>In fact, the external behavior is exactly the same; however, the performance of the two locks is radically different. When there is no contention on the lock, the <b>SimpleWaitLock </b>is much slower than the <b>SimpleSpinLock </b>because every call to <b>SimpleWaitLock</b>'s <b>Enter </b>and <b>Leave </b>methods forces the calling thread to transition from managed code to the kernel and back謡hich is bad. But when there is contention, the losing thread is blocked by the kernel and is not spinning and wasting CPU cycles謡hich is good. Note also that constructing the <b>AutoResetEvent </b>object and calling <b>Dispose </b>on it also cause managed to kernel transitions, affecting performance negatively These calls usually happen rarely, so they are usually not something to be too concerned about.</p>
<p>To give you a better feel for the performance differences, I wrote the following code:</p>
<p><code>public static void Main() { Int32 x = 0;<br/>
const Int32 iterations = 10000000;   // 10 million<br/>
// How long does it take to increment x 10 million times? Stopwatch sw = Stopwatch.StartNew(); for (Int32 i = 0; i &lt; iterations; { x++;<br/>
}<br/>
Console.WriteLine(&quot;Incrementing x: {0:N0}&quot;, sw.ElapsedMilliseconds);<br/>
// How long does it take to increment x 10 million times<br/>
// adding the overhead of calling a method that does nothing?<br/>
sw.Restart();<br/>
for (Int32 i = 0; i &lt; iterations; {<br/>
M(); x++; M();<br/>
}<br/>
Console.WriteLine(&quot;Incrementing x in M: {0:N0}&quot;, sw.ElapsedMilliseconds);<br/>
// How long does it take to increment x 10 million times<br/>
// adding the overhead of calling an uncontended SimpleSpinLock?<br/>
SimpleSpinLock ssl = new SimpleSpinLock();<br/>
sw.Restart();<br/>
for (Int32 i = 0; i &lt; iterations; { ssl.Enter(); x++; ssl.Leave();<br/>
}<br/>
Console.WriteLine(&quot;Incrementing x in SimpleSpinLock: {0:N0}&quot;, sw.ElapsedMilliseconds);<br/>
// How long does it take to increment x 10 million times // adding the overhead of calling an uncontended SimpleWaitLock? using (SimpleWaitLock swl = new SimpleWaitLock()) { sw.Restart();<br/>
for (Int32 i = 0; i &lt; iterations; { swl.Enter(); x++; swl.Leave();<br/>
}<br/>
Console.WriteLine(&quot;Incrementing x in SimpleWaitLock: {0:N0}&quot;, sw.ElapsedMilliseconds);<br/>
}<br/>
}<br/>
[MethodImpl(MethodImplOptions.NoInlining)]<br/>
private static void M() { /* This method does nothing but return */ } When I run the code above, I get the following output:<br/>
Incrementing x: 8<br/>
Incrementing x in M: 50<br/>
Incrementing x in SimpleSpinLock: 219<br/>
Incrementing x in SimpleWaitLock: 17,615</code></p>
<p>As you can clearly see, just incrementing <b>x </b>took only 8 milliseconds. To call a method around incrementing <b>x </b>added another 42 milliseconds. Then, executing code in a method that uses a user-mode construct caused the code to run 27 (219 / 8) times slower. But now see how much slower the program ran using a kernel-mode construct: 2,201 (17,615 / 8) times slower! So, if you can avoid thread synchronization, you should If you need thread synchronization, then try to use the user-mode constructs. Always try to avoid the kernel-mode constructs, as this code ran 80 (17,615 / 219) times slower.</p>
<h3>Semaphore Constructs</h3>
<p>Semaphores are simply <b>Int32 </b>variables maintained by the kernel. A thread waiting on a semaphore blocks when the semaphore is <b>0 </b>and unblocks when the semaphore is greater than <b>0. </b>When a thread waiting on a semaphore unblocks, the kernel automatically subtracts <b>1 </b>from the semaphore's count. Semaphores also have a maximum <b>Int32 </b>value associated with them, and the current count is never allowed to go over the maximum count. Here is what the <b>Semaphore </b>class looks like:</p>
<p><code>public sealed class Semaphore : WaitHandle {<br/>
public Semaphore(Int32 initialCount, Int32 maximumCount);<br/>
public Int32 Release();     // Calls Release(1); returns previous count<br/>
public Int32 Release(Int32 releaseCount);   // Returns previous count<br/>
}</code></p>
<p>So now let me summarize how these three kernel-mode primitives behave:</p>
<p>&#9632; When multiple threads are waiting on an auto-reset event, setting the event causes only one thread to become unblocked.</p>
<p>&#9632; When multiple threads are waiting on a manual-reset event, setting the event causes all threads to become unblocked.</p>
<p>&#9632; When multiple threads are waiting on a semaphore, releasing the semaphore causes <b>releaseCount </b>threads to become unblocked (where <b>releaseCount </b>is the argument passed to <b>Semaphore</b>'s <b>Release </b>method).</p>
<p>Therefore, an auto-reset event behaves very similarly to a semaphore whose maximum count is 1 The difference between the two is that <b>Set </b>can be called multiple times consecutively on an auto-reset event and still only one thread will be unblocked, whereas calling <b>Release </b>multiple times consecutively on a semaphore keeps incrementing its internal count, which could unblock many threads. By the way, if you call <b>Release </b>on a semaphore too many times, causing its count to exceed its maximum count, then <b>Release </b>will throw a <b>SemaphoreFullException.</b></p>
<p>Using a semaphore, we can re-implement the <b>SimpleWaitLock </b>as follows, so that it gives multiple threads concurrent access to a resource (which is not necessarily a safe thing to do unless all threads access the resource in a read-only fashion):</p>
<p><code>public sealed class SimpleWaitLock : IDisposable { private Semaphore m_AvailableResources;<br/>
public SimpleWaitLock(Int32 maximumConcurrentThreads) { m_AvailableResources =<br/>
new Semaphore(maximumConcurrentThreads, maximumConcurrentThreads);<br/>
}<br/>
public void Enter() {<br/>
// Wait efficiently in the kernel for resource access, then return m_AvailableResources.WaitOne();<br/>
}<br/>
public void Leave() {<br/>
// This thread doesn't need access anymore; another thread can have it m_ AvailableResources.Release();<br/>
}<br/>
public void Dispose() { m_AvailableResources.Close(); }<br/>
}</code></p>
<h3>Mutex Constructs</h3>
<p>A mutex represents a mutual-exclusive lock It works similar to an <b>AutoResetEvent </b>(or a <b>Semaphore </b>with a count of <b>1) </b>since all three constructs release only one waiting thread at a time Here is what the <b>Mutex </b>class looks like:</p>
<p><code>public sealed class Mutex : WaitHandle { public Mutex(); public void ReleaseMutex();<br/>
}</code></p>
<p>Mutexes have some additional logic in them which makes them more complex than the other constructs. First, <b>Mutex </b>objects record which thread obtained it by querying the calling thread's <b>Int32 </b>ID. When a thread calls <b>ReleaseMutex, </b>the <b>Mutex </b>makes sure that the calling thread is the same thread that obtained the <b>Mutex </b>If the calling thread is not the thread that obtained the <b>Mutex, </b>then the <b>Mutex </b>object's state is unaltered and <b>ReleaseMutex </b>throws a <b>System.ApplicationException </b>. Also, if a thread owning a <b>Mutex </b>terminates for any reason, then some thread waiting on the <b>Mutex </b>will be awakened by having a <b>System.Threading. AbandonedMutexException </b>thrown. Usually, this exception will go unhandled, terminating the whole process. This is good because a thread acquired the <b>Mutex </b>and it is likely that the thread terminated before it finished updating the data that the <b>Mutex </b>was protecting. If a thread catches <b>AbandonedMutexException, </b>then it could attempt to access the corrupt data, leading to unpredictable results and security problems.</p>
<p>Second, <b>Mutex </b>objects maintain a recursion count indicating how many times the owning thread owns the <b>Mutex. </b>If a thread currently owns a <b>Mutex </b>and then that thread waits on the <b>Mutex </b>again, the recursion count is incremented and the thread is allowed to continue running. When that thread calls <b>ReleaseMutex, </b>the recursion count is decremented. Only when the recursion count becomes 0 can another thread become the owner of the <b>Mutex.</b></p>
<p>Most people do not like this additional logic. The problem is that these &quot;features&quot; have a cost associated with them. The <b>Mutex </b>object needs more memory to hold the additional thread ID and recursion count information. And, more importantly, the <b>Mutex </b>code has to maintain this information, which makes the lock slower If an application needs or wants these additional features, then the application code could have done this itself; the code doesn't have to be built into the <b>Mutex </b>object. For this reason, a lot of people avoid using <b>Mutex </b>objects.</p>
<p>Usually a recursive lock is needed when a method takes a lock and then calls another method that also requires the lock, as the following code demonstrates:</p>
<p><code>internal class SomeClass : IDisposable {<br/>
private readonly Mutex m_lock = new Mutex();<br/>
public void Method1() { m_lock.WaitOne(); // Do whatever...<br/>
Method2();   // Method2 recursively acquires the lock m_lock.ReleaseMutex();<br/>
}<br/>
public void Method2() { m_lock.WaitOne(); // Do whatever... m_lock.ReleaseMutex();<br/>
}<br/>
public void Dispose() { m_lock.Dispose(); }<br/>
}</code></p>
<p>In the code above, code that uses a <b>SomeClass </b>object could call <b>Methodl, </b>which acquires the <b>Mutex, </b>performs some thread-safe operation, and then calls <b>Method2, </b>which also performs some thread-safe operation Since <b>Mutex </b>objects support recursion, the thread will acquire the lock twice and then release it twice before another thread can own the <b>Mutex </b>If <b>SomeClass </b>has used an <b>AutoResetEvent </b>instead of a <b>Mutex, </b>then the thread would block when it called <b>Method2</b>'s <b>WaitOne </b>method.</p>
<p>If you need a recursive lock, then you could create one easily by using an <b>AutoResetEvent:</b></p>
<p><code>internal sealed class RecursiveAutoResetEvent : IDisposable { private AutoResetEvent m_lock = new AutoResetEvent(true); private Int32 m_owningThreadId = 0; private Int32 m_recursionCount = 0;<br/>
public void Enter() {<br/>
// Obtain the calling thread's unique Int32 ID<br/>
Int32 currentThreadId = Thread.CurrentThread.ManagedThreadId;<br/>
// If the calling thread owns the lock, increment the recursion count if (m_owningThreadId == currentThreadId) {<br/>
m_recursionCount++;<br/>
return;<br/>
}<br/>
// The calling thread doesn't own the lock, wait for it m_lock.WaitOne();<br/>
// The calling now owns the lock, initialize the owning thread ID &amp; recursion count m_owningThreadId = currentThreadId; m_recursionCount;<br/>
}<br/>
public void Leave() {<br/>
// If the calling thread doesn't own the lock, we have an error if (m_owningThreadId != Thread.CurrentThread.ManagedThreadId) throw new InvalidOperationException();<br/>
// Subtract 1 from the recursion count if (--m_recursionCount == 0) {<br/>
// If the recursion count is 0, then no thread owns the lock<br/>
m_owningThreadId = 0;<br/>
m_lock.Set();     // Wake up 1 waiting thread (if any)<br/>
}<br/>
}<br/>
public void Dispose() { m_lock.Dispose(); }<br/>
}</code></p>
<p>While the behavior of the <b>RecursiveAutoResetEvent </b>class is identical to that of the <b>Mutex </b>class, a <b>RecursiveAutoResetEvent </b>object will have far superior performance when a thread tries to acquire the lock recursively because all the code that is required to track thread ownership and recursion is now in managed code. A thread has to transition into the Windows kernel only when first acquiring the <b>AutoResetEvent </b>or when finally relinquishing it to another thread.</p>
<h3>Calling a Method When a Single Kernel Construct Becomes Available</h3>
<p>Having a thread block indefinitely waiting for a kernel object to become available is wasteful of the thread's memory resources. Therefore, the thread pool offers a way to invoke a method of yours when a kernel object becomes available by using the <b>System.Threading. ThreadPool </b>class's static <b>RegisterWaitForSingleObject </b>method. There are several overloads of this method, but they are all very similar. Here is the prototype for one of the more commonly used overloads:</p>
<p><code>public static RegisteredWaitHandle RegisterWaitForSingleObject(<br/>
WaitHandle waitObject, WaitOrTimerCallback callback, Object state, Int32 millisecondsTimeoutInterval, Boolean executeOnlyOnce);</code></p>
<p>When you call this method, the <b>waitObject </b>argument identifies the kernel object that you want the thread pool to wait for. Since this parameter is of the abstract base class <b>WaitHandle, </b>you can specify any class derived from this base class. Specifically, you can pass a reference to a <b>Semaphore, Mutex, AutoResetEvent, </b>or <b>ManualResetEvent </b>object. The second parameter, <b>callback, </b>identifies the method that you want the thread pool thread to call. The callback method that you write must match the <b>System.Threading. WaitOrTimerCallback </b>delegate, which is defined as follows:</p>
<p><code>public delegate void WaitOrTimerCallback(Object state, Boolean timedOut);</code></p>
<p><b>RegisterWaitForSingleObject</b>'s third parameter, <b>state, </b>allows you to specify some state data that should be passed to the callback method when the thread pool thread calls it; pass <b>null </b>if you have no special state data to pass. The fourth parameter, <b>millisecondsTime-outlnterval, </b>allows you to tell the thread pool how long it should wait for the kernel object to become signaled. It is common to pass <b>Timeout.Infinite (-1) </b>here to indicate an infinite timeout. If the last parameter, <b>executeOnlyOnce, </b>is <b>true, </b>a thread pool thread will execute the callback method just once. But if <b>executeOnlyOnce </b>is <b>false, </b>a thread pool thread will execute the callback method every time the kernel object becomes signaled. This is most useful when waiting for an <b>AutoResetEvent </b>object.</p>
<p>When the callback method is called, it is passed state data and a <b>Boolean </b>value, <b>timedOut. </b>If <b>timedOut </b>is <b>false, </b>the method knows that it is being called because the kernel object became signaled. If <b>timedOut </b>is <b>true, </b>the method knows that it is being called because the kernel object did not become signaled in the time specified. The callback method can perform whatever action it desires based on the value that it receives in the <b>timedOut </b>argument.</p>
<p>You'll notice that the <b>RegisterWaitForSingleObject </b>method returns a reference to a <b>RegisteredWaitHandle </b>object. This object identifies the kernel object that the thread pool is waiting on If, for some reason, your application wants to tell the thread pool to stop watching the registered wait handle, your application can call <b>RegisteredWaitHandle</b>'s <b>Unregister </b>method:</p>
<p><code>public Boolean Unregister(WaitHandle waitObject);</code></p>
<p>The <b>waitObject </b>parameter indicates how you want to be notified when all queued work items for the registered wait have executed. You should pass <b>null </b>for this parameter if you don't want a notification. If you pass a valid reference to a <b>WaitHandle</b>-derived object, the thread pool will signal the object when all pending work items for the registered wait handle have executed.</p>
<p>The code below demonstrates how to have a thread pool thread call a method whenever an <b>AutoResetEvent </b>object becomes signaled:</p>
<p><code>internal static class RegisteredWaitHandleDemo { public static void Main() {<br/>
// Construct an AutoResetEvent (initially false) AutoResetEvent are = new AutoResetEvent(false);<br/>
// Tell the thread.pool to wait on the AutoResetEvent RegisteredWaitHandle rwh = ThreadPool.RegisterWaitForSingleObject(<br/>
are,// Wait on this AutoResetEvent<br/>
EventOperation,// When available, call the EventOperation method<br/>
null,// Pass null to EventOperation<br/>
5000,// Wait 5 seconds for the event to become true<br/>
false);// Call EventOperation every time the event is true<br/>
// Start our loop<br/>
Char operation = (Char) 0;<br/>
while (operation != 'Q') {<br/>
Console.WriteLine(&quot;S=Signal, Q=Quit?&quot;);<br/>
operation = Char.ToUpper(Console.ReadKey(true).KeyChar);<br/>
if (operation == 'S') are.Set(); // User want to set the event<br/>
}<br/>
// Tell the thread pool to stop waiting on the event rwh.Unregister(null);<br/>
}<br/>
// This method is called whenever the event is true or // when 5 seconds have elapsed since the last callback/timeout private static void EventOperation(Object state, Boolean timedOut) { Console.WriteLine(timedOut ? &quot;Timeout&quot; : &quot;Event became true&quot;);<br/>
}<br/>
}</code></p>
<mbp:pagebreak/>
<a name="Chapter29"/>
<h1>Chapter 29: Hybrid Thread Synchronization Constructs</h1>
<p><b>In this chapter:</b></p>
<a href="#b826">A Simple Hybrid Lock</a><br/>
<a href="#b827">Spinning, Thread Ownership, and Recursion</a><br/>
<a href="#b829">A Potpourri of Hybrid Constructs</a><br/>
<a href="#b844">The Famous Double-Check Locking Technique</a><br/>
<a href="#b848">The Condition Variable Pattern</a><br/>
<a href="#b851">Using Collections to Avoid Holding a Lock for a Long Time</a><br/>
<a href="#b856">The Concurrent Collection Classes</a><br/>
<p>In Chapter 28, &quot;Primitive Thread Synchronization Constructs,&quot; I discussed the primitive user-mode and kernel-mode thread synchronization constructs. From these primitive constructs, all other thread synchronization constructs can be built Typically, other thread synchronization constructs are built by combining the user-mode and kernel-mode constructs, and I call these hybrid thread synchronization constructs. Hybrid constructs provide the performance benefit of the primitive user-mode constructs when there is no thread contention. Hybrid constructs also use the primitive kernel-mode constructs to provide the benefit of not spinning (wasting CPU time) when multiple threads are contending for the construct at the same time. Since, in most applications, threads are rarely contending for a construct at the same time, the performance improvements can help your application greatly.</p>
<p>In this chapter, I will first show how hybrid constructs are built from the various primitive constructs. Then, I will introduce you to many of the hybrid constructs that ship with the Framework Class Library (FCL), describe their behavior, and give some insight as to how to use these constructs correctly. I will also mention some constructs that I have created and make available for free in Wintellect's Power Threading library, which can be downloaded from <a href="http://Wintellect.com/">http://Wintellect.com/</a>.</p>
<p>Toward the end of the chapter, I show how to minimize resource usage and improve performance by using the FCL's concurrent collection classes instead of using some of the hybrid constructs. And finally, I discuss the Power Threading library's <b>ReaderWriterGate </b>and <b>SyncGate </b>classes which offer reader-writer semantics without blocking any threads, thereby also reducing resource consumption and improving performance.</p>
<a name="b826"/><h2>A Simple Hybrid Lock</h2>
<p>So, without further ado, let me start off by showing you an example of a hybrid thread synchronization lock:</p>
<p><code>internal sealed class SimpleHybridLock : IDisposable {<br/>
// The Int32 is used by the primitive user-mode constructs (Interlocked methods) private Int32 m_waiters = 0;<br/>
// The AutoResetEvent is the primitive kernel-mode construct private AutoResetEvent m_waiterLock = new AutoResetEvent(false);<br/>
public void Enter() {<br/>
// Indicate that this thread wants the lock if (Interlocked.Increment(ref m_waiters) == 1)<br/>
return; // Lock was free, no contention, just return<br/>
// Another thread is waiting. There is contention, block this thread m_waiterLock.WaitOne();   // Bad performance hit here // When WaitOne returns, this thread now has the lock<br/>
}<br/>
public void Leave() {<br/>
// This thread is releasing the lock<br/>
if (Interlocked.Decrement(ref m_waiters) == 0)<br/>
return; // No other threads are blocked, just return<br/>
// Other threads are blocked, wake 1 of them m_waiterLock.Set();   // Bad performance hit here<br/>
}<br/>
public void Dispose() { m_waiterLock.Dispose(); }<br/>
}</code></p>
<p>The <b>SimpleHybridLock </b>contains two fields: an <b>Int32, </b>which will be manipulated via the primitive user-mode constructs, and an <b>AutoResetEvent, </b>which is a primitive kernel-mode construct. To get great performance, the lock tries to use the <b>Int32 </b>and avoid using the <b>AutoResetEvent </b>as much as possible. Just constructing a <b>SimpleHybridLock </b>object causes the <b>AutoResetEvent </b>to be created, and this is a massive performance hit compared to the overhead associated with the <b>Int32 </b>field. Later in this chapter, we'll see another hybrid construct <b>(AutoResetEventSlim) </b>that avoids the performance hit of creating the <b>AutoResetEvent </b>until the first time contention is detected from multiple threads accessing the lock at the same time. The <b>Dispose </b>method closes the <b>AutoResetEvent, </b>and this is also a big performance hit compared to the overhead of destroying the <b>Int32 </b>field.</p>
<p>While it would be nice to improve the performance of constructing and disposing of a <b>SimpleHybridLock </b>object, it would be better to focus on the performance of its <b>Enter </b>and <b>Leave </b>methods because these methods tend to be called many, many times over the object's lifetime. Let's focus on these methods now.</p>
<p>The first thread to call <b>Enter </b>causes <b>Interlocked.Increment </b>to add one to the <b>m_waiters</b></p>
<p>field, making its value <b>1. </b>This thread sees that there were zero threads waiting before for this lock, so the thread gets to return from its call to <b>Enter </b>The thing to appreciate here is that the thread acquired the lock very quickly. Now, if another thread comes along and calls <b>Enter, </b>this second thread increments <b>m_waiters </b>to <b>2 </b>and sees that another thread has the lock, so this thread blocks by calling <b>WaitOne </b>using the <b>AutoResetEvent. </b>Calling <b>WaitOne </b>causes the thread to transition into the Windows' kernel, and this is a big performance hit However, the thread must stop running anyway, so it is not too bad to have a thread waste some time to stop completely. The good news is that the thread is now blocked and so it is not wasting CPU time by spinning on the CPU, which is what the <b>SimpleSpinLock</b>'s <b>Enter </b>method, introduced in Chapter 28, does.</p>
<p>Now let's look at the <b>Leave </b>method. When a thread calls <b>Leave, Interlocked.Decrement </b>is called to subtract <b>1 </b>from the <b>m_waiters </b>field. If <b>m_waiters </b>is now <b>0, </b>then no other threads are blocked inside a call to <b>Enter </b>and the thread calling <b>Leave </b>can simply return. Again, think about how fast this is: Leaving a lock means that a thread subtracts <b>1 </b>from an <b>Int32, </b>performs a quick <b>if </b>test, and then returns! On the other head, if the thread calling <b>Leave </b>sees that <b>m_waiters </b>was not <b>1, </b>then the thread knows that there is contention and that there is at least one other thread blocked in the kernel This thread must wake up one (and only one) of the blocked threads. It does this by calling <b>Set </b>on <b>AutoResetEvent </b>. This is a performance hit, as the thread must transition into the kernel and back, but this transition occurs only when there was contention. Of course, <b>AutoResetEvent </b>ensures that only one blocked thread wakes up; any other threads blocked on the <b>AutoResetEvent </b>will continue to block until the newly unblocked thread eventually calls <b>Leave.</b></p>
<hr/>
<blockquote><b>Note </b>In reality, any thread could call <b>Leave </b>at any time since the <b>Enter </b>method does not keep a record of which thread successfully acquired the lock. Adding the field and code to maintain this information is easy to do but it would increase the memory required for the lock object itself and hurt performance of the <b>Enter </b>and <b>Leave </b>methods because they would have to manipulate this field. I would rather have a fast-performing lock and make sure that my code uses it the right way. You'll notice that events and semaphores do not maintain this kind of information; only mutexes do.</blockquote>
<hr/>
<a name="b827"/><h2>Spinning, Thread Ownership, and Recursion</h2>
<p>Since transitions into the kernel incur such a big performance hit and threads tend to hold on to a lock for very short periods of time, an application's overall performance can be improved by having a thread spin in user mode for a little while before having the thread transition to kernel mode. If the lock that the thread is waiting for becomes available while spinning, then the transition to kernel mode is avoided.</p>
<p>In addition, some locks impose a limitation where the thread that acquires the lock must be the thread that releases the lock. And some locks allow the currently owning thread to own the lock recursively. The <b>Mutex </b>lock is an example of a lock that has these characteristics. <sup>1 </sup>Using some fancy logic, it is possible to build a hybrid lock that offers spinning, thread ownership, and recursion. Here is what the code looks like:</p>
<p><code>internal sealed class AnotherHybridLock : IDisposable {<br/>
// The Int32 is used by the primitive user-mode constructs (Interlocked methods) private Int32 m_waiters = 0;<br/>
// The AutoResetEvent is the primitive kernel-mode construct private AutoResetEvent m_waiterLock = new AutoResetEvent(false);<br/>
// This field controls spinning in an effort to improve performance private Int32 m_spincount = 4000;     // Arbitrarily chosen count<br/>
// These fields indicate which thread owns the lock and how many times it owns it private Int32 m_owningThreadId = 0, m_recursion = 0;<br/>
public void Enter() {<br/>
// If calling thread already owns the lock, increment recursion count and return<br/>
Int32 threadId = Thread.CurrentThread.ManagedThreadId;<br/>
if (threadId == m_owningThreadId) { m_recursion++; return; }<br/>
// The calling thread doesn't own the lock, try to get it SpinWait spinwait = new SpinWait();<br/>
for (Int32 spinCount = 0; spinCount &lt; m_spincount; spinCount++) {<br/>
// If the lock was free, this thread got it; set some state and return if (Interlocked.CompareExchange(ref m_waiters, 1, 0) == 0) goto GotLock;<br/>
// Black magic: give other threads a chance to run // in hopes that the lock will be released spinwait.SpinOnce();<br/>
}<br/>
// Spinning is over and the lock was still not obtained, try one more time<br/>
if (Interlocked.Increment(ref m_waiters) &gt; 1) {<br/>
// Other threads are blocked and this thread must block too<br/>
m_waiterLock.WaitOne(); // Wait for the lock; performance hit<br/>
// When this thread wakes, it owns the lock; set some state and return<br/>
}<br/>
GotLock:<br/>
// When a thread gets the lock, we record its ID and // indicate that the thread owns the lock once m_owningThreadId = threadId; m_recursion = 1;<br/>
}<br/>
public void Leave() {<br/>
// If the calling thread doesn't own the lock, there is a bug</code></p>
<p>Threads do not spin when waiting on a <b>Mutex </b>object because the <b>Mutex</b>'s code is in the kernel. This means that the thread had to have already transitioned into the kernel to check the <b>Mutex</b>'s state.</p>
<p><code>Int32 threadId = Thread.CurrentThread.ManagedThreadId; if (threadId != m_owningThreadId)<br/>
throw new SynchronizationLockException(&quot;Lock not owned by calling thread&quot;);<br/>
// Decrement the recursion count. If this thread still owns the lock, just return if (--m_recursion &gt; 0) return;<br/>
m_owningThreadId = 0;     // No thread owns the lock now<br/>
// If no other threads are blocked, just return if (Interlocked.Decrement(ref m_waiters) == 0) return;<br/>
// Other threads are blocked, wake 1 of them m_waiterLock.Set();        // Bad performance hit here<br/>
}<br/>
public void Dispose() { m_waiterLock.Dispose(); }<br/>
}</code></p>
<p>As you can see, adding extra behavior to the lock increases the number of fields it has, which increases its memory consumption. The code is also more complex, and this code must execute, which decreases the lock's performance. In Chapter 28's &quot;Event Constructs&quot; section, I compared the performance of incrementing an <b>Int32 </b>without any locking, with a primitive user-mode construct, and with a kernel-mode construct. I repeat the results of those performance tests here and I include the results of using the <b>SimpleHybridlock </b>and the <b>AnotherHybridLock. </b>The results are in fastest to slowest order:</p>
<p><code>Incrementing x: 8.Fastest<br/>
Incrementing x in.M: 50.6x slower<br/>
Incrementing x in.SimpleSpinLock: 210.26x slower<br/>
Incrementing x in.SimpleHybridLock: 211.26x slower (similar to SimpleSpinLock)<br/>
Incrementing x in.AnotherHybridLock: 415.52x slower (due to ownership/recursion)<br/>
Incrementing x in.SimpleWaitLock: 17,615.2,201x slower</code></p>
<p>It is worth noting that the <b>AnotherHybridLock </b>takes twice as much time as the <b>SimpleHybridLock. </b>This is due to the additional logic and error checking required managing the thread ownership and recursion behaviors As you see, every behavior added to a lock impacts its performance.</p>
<a name="b829"/><h2>A Potpourri of Hybrid Constructs</h2>
<p>The FCL ships with many hybrid constructs that use fancy logic to keep your threads in user mode, improving your application's performance. Some of these hybrid constructs also avoid creating the kernel-mode construct until the first time threads contend on the construct. If threads never contend on the construct, then your application avoids the performance of creating the object and also avoids allocating memory for the object. A number of the constructs also support the use of a <b>CancellationToken </b>(discussed in Chapter 26, &quot;Compute-</p>
<p>Bound Asynchronous Operations&quot;) so that a thread can forcibly unblock other threads that might be waiting on the construct. In this section, I introduce you to these hybrid constructs.</p>
<p>s</p>
<p>The first two hybrid constructs are <b>System.Threading.ManualResetEventSlim </b>and <b>System.Threading.SemaphoreSlim.</b><sup>2</sup> These constructs work exactly like their kernel-mode counterparts except that both employ spinning in user mode and they both defer creating the kernel-mode construct until the first time contention occurs. Their <b>Wait </b>methods allow you to pass a timeout and a <b>CancellationToken </b>. Here is what these classes look like (some method overloads are not shown):</p>
<p><code>public class ManualResetEventSlim : IDisposable {<br/>
public ManualResetEventSlim(Boolean initialState, Int32 spinCount); public void Dispose(); public void Reset(); public void Set();<br/>
public Boolean Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken);<br/>
public Boolean IsSet { get; } public Int32 SpinCount { get; } public WaitHandle WaitHandle { get; }<br/>
}<br/>
public class SemaphoreSlim : IDisposable {<br/>
public SemaphoreSlim(Int32 initialCount, Int32 maxCount); public void Dispose();<br/>
public Int32 Release(Int32 releaseCount);<br/>
public Boolean Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken);<br/>
public Int32 CurrentCount { get; }<br/>
public WaitHandle AvailableWaitHandle { get; }<br/>
}</code></p>
<p>s</p>
<p>Probably the most-used hybrid thread synchronization construct is the <b>Monitor </b>class, which provides a mutual-exclusive lock supporting spinning, thread ownership, and recursion This is the most-used construct because it has been around the longest, C# has a built-in keyword to support it, the just-in-time (JIT) compiler has built-in knowledge of it, and the common language runtime (CLR) itself uses it on your application's behalf. However, as you'll see, there are many problems with this construct, making it easy to produce buggy code. I'll start by explaining the construct, and then I'll show the problems and some ways to work around these problems.</p>
<p>While there is no <b>AutoResetEventSlim </b>class, in many situations you can construct a <b>SemaphoreSlim </b>object with a <b>maxCount </b>of <b>1 </b>.</p>
<p>Every object on the heap can have a data structure, called a sync block, associated with it. A sync block contains fields similar to that of the <b>AnotherHybridLock </b>class that appeared earlier in this chapter. Specifically, it has fields for a kernel object, the owning thread's ID, a recursion count, and a waiting threads count. The <b>Monitor </b>class is a <b>static </b>class whose methods accept a reference to any heap object, and these methods manipulate the fields in the specified object's sync block. Here is what the most commonly used methods of the <b>Monitor </b>class look like:</p>
<p><code>public static class Monitor {<br/>
public static void Enter(Object obj); public static void Exit(Object obj);<br/>
// You can also specify a timeout when entered the lock (not commonly used): public static Boolean TryEnter(Object obj, Int32 millisecondsTimeout);<br/>
// I'll discuss the lockTaken argument later public static void Enter(Object obj, ref Boolean lockTaken); public static void TryEnter(Object obj, Int32 millisecondsTimeout, ref Boolean lockTaken);<br/>
}</code></p>
<p>Now obviously, associating a sync block data structure with every object in the heap is quite wasteful, especially since most objects' sync blocks are never used. To reduce memory usage, the CLR team uses a more efficient way to offer the functionality just described. Here's how it works: When the CLR initializes, it allocates an array of sync blocks. As discussed elsewhere in this book, whenever an object is created in the heap, it gets two additional overhead fields associated with it. The first overhead field, the type object pointer, contains the memory address of the type's type object. The second overhead field, the sync block index, contains an integer index into the array of sync blocks.</p>
<p>When an object is constructed, the object's sync block index is initialized to -1, which indicates that it doesn't refer to any sync block. Then, when <b>Monitor.Enter </b>is called, the CLR finds a free sync block in the array and sets the object's sync block index to refer to the sync block that was found. In other words, sync blocks are associated with an object on the fly. When <b>Exit </b>is called, it checks to see if there are any more threads waiting to use the object's sync block. If there are no threads waiting for it, the sync block is free, <b>Exit </b>sets the object's sync block index back to -1, and the free sync block can be associated with another object in the future.</p>
<p>Figure 29-1 shows the relationship between objects in the heap, their sync block indexes, and elements in the CLR's sync block array. Object-A, Object-B, and Object-C all have their type object pointer member set to refer to Type-T (a type object) This means that all three objects are of the same type. As discussed in Chapter 4, &quot;Type Fundamentals,&quot; a type object is also an object in the heap, and like all other objects, a type object has the two overhead members: a sync block index and a type object pointer. This means that a sync block can be associated with a type object and a reference to a type object can be passed to <b>Monitor</b>'s methods. By the way, the sync block array is able to create more sync blocks if necessary, so you shouldn't</p>
<p>worry about the system running out of sync blocks if many objects are being synchronized simultaneously.</p>
<p><b>Figure 29-1 </b>Objects in the heap (including type objects) can have their sync block indexes refer to an entry in the CLR's sync block array</p>
<p>Here is some code that demonstrates how the <b>Monitor </b>class was originally intended to be used:</p>
<p><code>internal sealed class Transaction { private DateTime m_timeOfLastTrans;<br/>
public void PerformTransaction() { Monitor.Enter(this);<br/>
// This code has exclusive access to the data... m_timeOfLastTrans = DateTime.Now; Monitor.Exit(this);<br/>
}<br/>
public DateTime LastTransaction {<br/>
get {<br/>
Monitor.Enter(this);<br/>
// This code has shared access to the data... DateTime temp = m_timeOfLastTrans; Monitor.Exit(this); return temp;<br/>
}<br/>
}<br/>
}</code></p>
<img src="92.jpg"/>
<p>On the surface, this seems simple enough, but there is something wrong with this code The problem is that each object's sync block index is implicitly public. The code below demonstrates the impact of this.</p>
<p><code>public static void SomeMethod() { var t = new Transaction();<br/>
Monitor.Enter(t); // This thread takes the object's public lock<br/>
// Have a thread pool thread display the LastTransaction time<br/>
// NOTE: The thread pool thread blocks until SomeMethod calls Monitor.Exit!<br/>
ThreadPool.QueueUserWorkItem(o =&gt; Console.WriteLine(t.LastTransaction));<br/>
// Execute some other code here... Monitor.Exit(t);<br/>
}</code></p>
<p>In this code, the thread executing <b>SomeMethod </b>calls <b>Monitor.Enter, </b>taking the <b>Transaction </b>object's publicly exposed lock. When the thread pool thread queries the <b>LastTransaction </b>property, this property also calls <b>Monitor.Enter </b>to acquire the same lock, causing the thread pool thread to block until the thread executing <b>SomeMethod </b>calls <b>Monitor.Exit </b>. Using a debugger, you can determine that the thread pool thread is blocked inside the <b>LastTransaction </b>property, but it is very hard to determine which other thread has the lock. If you do somehow figure out which thread has the lock, then you have to figure out what code caused it to take the lock. This is very difficult, and even worse, if you do figure it out, then the code might not be code that you have control over and you might not be able to modify this code to fix the problem. Therefore, my suggestion to you is to always use a private lock instead. Here's how I'd fix the <b>Transaction </b>class:</p>
<p><code>internal sealed class Transaction {<br/>
private readonly Object m_lock = new Object(); // Each transaction has a PRIVATE lock now private DateTime m_timeOfLastTrans;<br/>
public void PerformTransaction() {<br/>
Monitor.Enter(m_lock);        // Enter the private lock // This code has exclusive access to the data... m_timeOfLastTrans = DateTime.Now;<br/>
Monitor.Exit(m_lock);// Exit the private lock<br/>
}<br/>
public DateTime LastTransaction {<br/>
get {<br/>
Monitor.Enter(m_lock);   // Enter the private lock // This code has shared access to the data... DateTime temp = m_timeOfLastTrans; Monitor.Exit(m_lock);     // Exit the private lock return temp;<br/>
}<br/>
}<br/>
}</code></p>
<p>If <b>Transaction</b>'s members were <b>static, </b>then simply make the <b>m_lock </b>field <b>static, </b>too, and now the <b>static </b>members are thread safe.</p>
<p>It should be clear from this discussion that <b>Monitor </b>should not have been implemented as a <b>static </b>class; it should have been implemented like all the other constructs: a class you instantiate and call instance methods on. In fact, <b>Monitor </b>has many other problems associated with it that are all because it is a <b>static </b>class. Here is a list of additional problems:</p>
<p>&#9632; A variable can refer to a proxy object if the type of object it refers to is derived from the <b>System.MarshalByRefObject </b>class (discussed in Chapter 22, &quot;CLR Hosting and AppDomains&quot;). When you call <b>Monitor</b>'s methods, passing a reference to a proxy object, you are locking the proxy object, not the actual object that the proxy refers to.</p>
<p>&#9632; If a thread calls <b>Monitor.Enter, </b>passing it a reference to a type object that has been loaded domain neutral (discussed in Chapter 22), the thread is taking a lock on that type across all AppDomains in the process This is a known bug in the CLR that violates the isolation that AppDomains are supposed to provide. The bug is difficult to fix in a high-performance way, so it never gets fixed. The recommendation is to never pass a reference to a type object into <b>Monitor</b>'s methods.</p>
<p>&#9632; Because strings can be interned (as discussed in Chapter 14, &quot;Chars, Strings, and Working with Text&quot;), two completely separate pieces of code could unknowingly get references to a single <b>String </b>object in memory. If they pass the reference to the <b>String </b>object into <b>Monitor</b>'s methods, then the two separate pieces of code are now synchronizing their execution with each other unknowingly.</p>
<p>&#9632; When passing a string across an AppDomain boundary, the CLR does not make a copy of the string; instead, it simply passes a reference to the string into the other AppDomain. This improves performance, and in theory, it should be OK since <b>String </b>objects are immutable. However, like all objects, <b>String </b>objects have a sync block index associated with them, which is mutable, and this allows threads in different AppDomains to synchronize with each other unknowingly This is another bug in CLR's AppDomain isolation story. The recommendation is never to pass <b>String </b>references to <b>Monitor</b>'s methods.</p>
<p>&#9632; Since <b>Monitor</b>'s methods take an <b>Object, </b>passing a value type causes the value type to get boxed, resulting in the thread taking a lock on the boxed object. Each time <b>Monitor.Enter </b>is called, a lock is taken on a completely different object and you get no thread synchronization at all.</p>
<p>&#9632; Applying the <b>[MethodImpl(MethodImplOptions.Synchronized)] </b>attribute to a method causes the JIT compiler to surround the method's native code with calls to <b>Monitor.Enter </b>and <b>Monitor.Exit </b>. If the method is an instance method, then <b>this </b>is passed to these methods, locking the implicitly public lock. If the method is static, then a reference to the type's type object is passed to these methods, potentially locking a domain-neutral type. The recommendation is to never use this attribute.</p>
<p>&#9632;   When calling a type's type constructor (discussed in Chapter 8, &quot;Methods&quot;), the CLR takes a lock on the type's type object to ensure that only one thread initializes the type object and its static fields. Again, this type could be loaded domain neutral, causing a problem. For example, if the type constructor's code enters an infinite loop, then the type is unusable by all AppDomains in the process. The recommendation here is to avoid type constructors as much as possible or least keep them short and simple.</p>
<p>Unfortunately, the story gets worse. Since it is so common for developers to take a lock, do some work, and then release the lock within a single method, the C# language offers simplified syntax via its <b>lock </b>keyword. Suppose that you write a method like this:</p>
<p><code>private void SomeMethod() {<br/>
lock (this) {<br/>
// This code has exclusive access to the data...<br/>
}<br/>
}</code></p>
<p>It is equivalent to having written the method like this:</p>
<p><code>private void SomeMethod() { Boolean lockTaken = false;<br/>
try {<br/>
//<br/>
Monitor.Enter(this, ref lockTaken);<br/>
// This code has exclusive access to the data...<br/>
}<br/>
finally {<br/>
if (lockTaken) Monitor.Exit(this);<br/>
}<br/>
}</code></p>
<p>The first problem here is that the C# team felt that they were doing you a favor by calling <b>Monitor.Exit </b>in a <b>finally </b>block. Their thinking was that this ensures that the lock is always released no matter what happens inside the <b>try </b>block. However, this is not a good thing. If an exception occurs inside the <b>try </b>block while changing state, then the state is now corrupted When the lock is exited in the <b>finally </b>block, another thread will now start manipulating the corrupted state It is better to have your application hang than it is to continue running with a corrupted state and potential security holes. The second problem is that entering and leaving a <b>try </b>block decreases the performance of the method. And some JIT compilers won't inline a method that contains a <b>try </b>block in it, decreasing performance even more. So now we have slower code that lets threads access corrupted state.<sup>3</sup> The recommendation is not to use C#'s <b>lock </b>statement.</p>
<p>Now we get to the <b>Boolean lockTaken </b>variable. Here is the problem that this variable is trying to solve. Let's say that a thread enters the <b>try </b>block and before calling <b>Monitor.Enter,</b></p>
<p>By the way, while still a performance hit, it is safe to release a lock in a <b>finally </b>block if the code in the <b>try </b>block reads the state without attempting to modify it.</p>
<p>the thread is aborted (as discussed in Chapter 22). Now the <b>finally </b>block is called, but its code should not exit the lock The <b>lockTaken </b>variable solves this problem It is initialized to <b>false, </b>which assumes that the lock has not been entered into Then, if <b>Monitor.Enter </b>is called and successfully takes the lock, it sets <b>lockTaken </b>to <b>true. </b>The <b>finally </b>block examines <b>lockTaken </b>to know whether to call <b>Monitor.Exit </b>or not. <sup>4</sup> By the way, the <b>SpinLock </b>structure also supports this <b>lockTaken </b>pattern.</p>
<p>s</p>
<p>It is common to have threads simply read the contents of some data. If this data is protected by a mutual exclusive lock (like the <b>SimpleSpinLock, SimpleWaitLock, SimpleHybridLock, AnotherHybridLock, Mutex, </b>or <b>Monitor), </b>then if multiple threads attempt this access concurrently, only one thread gets to run and all the other threads are blocked, which can reduce scalability and throughput in your application substantially. However, if all the threads want to access the data in a read-only fashion, then there is no need to block them at all; they should all be able to access the data concurrently. On the other hand, if a thread wants to modify the data, then this thread needs exclusive access to the data. The <b>ReaderWriterLockSlim </b>construct encapsulates the logic to solve this problem. Specifically, the construct controls threads like this:</p>
<p>&#9632; When one thread is writing to the data, all other threads requesting access are blocked.</p>
<p>&#9632; When one thread is reading from the data, other threads requesting read access are allowed to continue executing, but threads requesting write access are blocked.</p>
<p>&#9632; When a thread writing to the data has completed, either a single writer thread is unblocked so it can access the data or all the reader threads are unblocked so that all of them can access the data concurrently If no threads are blocked, then the lock is free and available for the next reader or writer thread that wants it.</p>
<p>&#9632; When all threads reading from the data have completed, a single writer thread is unblocked so it can access the data If no threads are blocked, then the lock is free and available for the next reader or writer thread that wants it.</p>
<p>Here is what this class looks like (some method overloads are not shown):</p>
<p><code>public class ReaderWriterLockSlim : IDisposable {<br/>
public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy); public void Dispose();<br/>
public void EnterReadLock();<br/>
public Boolean TryEnterReadLock(Int32 millisecondsTimeout); public void ExitReadLock();</code></p>
<p>The <b>try/finally </b>blocks and the <b>lockTaken </b>variable are potentially useful if what you're passing to <b>Monitor</b>'s methods is a reference to a domain-agile object, like a <b>String, </b>or a domain-neutral type object. Sure, state in one AppDomain might get corrupted, but threads in other AppDomains will be allowed to keep running.</p>
<p><code>public void EnterWriteLock();<br/>
public Boolean TryEnterWriteLock(Int32 millisecondsTimeout); public void ExitWriteLock();<br/>
// Most applications will never query any of these properties<br/>
public Boolean IsReadLockHeld{ get; }<br/>
public Boolean IsWriteLockHeld{ get; }<br/>
public Int32     CurrentReadCount{ get; }<br/>
public Int32     RecursiveReadCount{ get; }<br/>
public Int32     RecursiveWriteCount{ get; }<br/>
public Int32     WaitingReadCount{ get; }<br/>
public Int32     WaitingWriteCount{ get; }<br/>
public LockRecursionPolicy RecursionPolicy { get; }<br/>
// Members related to upgrading from a reader to a writer not shown<br/>
}</code></p>
<p>Here is some code that demonstrates the use of this construct:</p>
<p><code>internal sealed class Transaction : IDisposable { private readonly ReaderWriterLockSlim m_lock =<br/>
new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion); private DateTime m_timeOfLastTrans;<br/>
public void PerformTransaction() { m_lock.EnterWriteLock();<br/>
// This code has exclusive access to the data... m_timeOfLastTrans = DateTime.Now; m_lock.ExitWriteLock();<br/>
}<br/>
public DateTime LastTransaction {<br/>
get {<br/>
m_lock.EnterReadLock();<br/>
// This code has shared access to the data... DateTime temp = m_timeOfLastTrans; m_lock.ExitReadLock(); return temp;<br/>
}<br/>
}<br/>
public void Dispose() { m_lock.Dispose(); }<br/>
}</code></p>
<p>There are a few concepts related to this construct that deserve special mention First, <b>ReaderWriterLockSlim</b>'s constructor allows you to pass in a <b>LockRecurionsPolicy </b>flag, which is defined as follows:</p>
<p><code>public enum LockRecursionPolicy { NoRecursion, SupportsRecursion }</code></p>
<p>If you pass the <b>SupportsRecursion </b>flag, then the lock will add thread ownership and recursion behaviors to the lock As discussed earlier in this chapter, these behaviors negatively affect the lock's performance, so I recommend that you always pass <b>LockRecursionPolicy. NoRecursion </b>to the constructor (as I've done). For a reader-writer lock, supporting thread ownership and recursion is phenomenally expensive because the lock must keep track of all the reader threads that it has let into the lock and keep a separate recursion count for each reader thread In fact, to maintain all this information in a thread-safe way, the <b>ReaderWriterLockSlim </b>internally uses a mutually exclusive spinlock! No, I'm not kidding.</p>
<p>The <b>ReaderWriterLockSlim </b>class offers additional methods (not shown earlier) that allow a reading thread to upgrade itself to a writer thread. Later, the thread can downgrade itself back to a reader thread The thinking here is that a thread could start reading the data and based on the data's contents, the thread might want to modify the data. To do this, the thread would upgrade itself from a reader to a writer. Having the lock support this behavior deteriorates the lock's performance, and I don't think that this is a useful feature at all. Here's why: A thread can't just turn itself from a reader into a writer. Other threads may be reading, too, and these threads will have to exit the lock completely before the thread trying to upgrade is allowed to become a writer. This is the same as having the reader thread exit the lock and then immediately acquire it for writing.</p>
<hr/>
<blockquote><b>Note </b>The FCL also ships a <b>ReaderWriterLock </b>construct, which was introduced in the Microsoft .NET Framework version 1.0. This construct had so many problems that Microsoft introduced the <b>ReaderWriterLockSlim </b>construct in .NET Framework version 2.0. The team didn't improve the <b>ReaderWriterLock </b>construct for fear of losing compatibility with applications that were using it. Here are the problems with the <b>ReaderWriterLock. </b>Even without thread contention, it is very slow There is no way to opt out of the thread ownership and recursion behaviors, making the lock even slower It favors reader threads over writer threads, and therefore writer threads can get queued up and are rarely serviced, resulting in denial of service problems.</blockquote>
<hr/>
<p>s</p>
<p>I have created my own reader-writer construct that is faster than the FCL's <b>ReaderWriterLockSlim </b>class.<sup>5</sup> My class is called <b>OneManyLock </b>because it allows access to either one writer thread or many reader threads. The class basically looks like this:</p>
<p><code>public sealed class OneManyLock : IDisposable { public OneManyLock(); public void Dispose();<br/>
public void Enter(Boolean exclusive); public void Leave();<br/>
}</code></p>
<p>Now I'd like to give you a sense of how it works. Internally, the class has an <b>Int32 </b>field for the state of the lock, a <b>Semaphore </b>object that reader threads block on, and an <b>AutoResetEvent</b></p>
<p>The code is inside the Ch29-1-HybridThreadSync.cs file that is part of the code that accompanies this book. You can download this code from <a href="http://Wintellect.com/">http://Wintellect.com/</a>.</p>
<p>object that writer threads block on. The <b>Int32 </b>state field is divided into five subfields as follows:</p>
<p>&#9632; Three bits (a number from 0 to 7) represent the state of the lock itself. The possibilities are <b>0</b>=Free, <b>1</b>=OwnedByWriter, <b>2</b>=OwnedByReaders, <b>3</b>=OwnedByReadersAndWriterPending, and <b>4</b>=ReservedForWriter. The values 5, 6, and 7 are unused.</p>
<p>&#9632; Nine bits (a number from 0 to 511) represent the number of reader threads reading (RR) that the lock has currently allowed in.</p>
<p>&#9632; Nine bits (a number from 0 to 511) represent the number of reader threads waiting (RW) to get into the lock These threads block on the auto-reset event object.</p>
<p>&#9632; Nine bits (a number from 0 to 511) represent the number of writer threads waiting (WW) to get into the lock These threads block on the other semaphore object.</p>
<p>&#9632; The two remaining bits are unused and always have a value of <b>0 </b>.</p>
<p>Now, since all the information about the lock fits in a single <b>Int32 </b>field, I can manipulate this field using the methods of the <b>Interlocked </b>class so the lock is incredibly fast and causes a thread to block only when there is contention.</p>
<p>Here's what happens when a thread enters the lock for shared access:</p>
<p>&#9632; If the lock is Free: Set state to OwnedByReaders, RR=1, Return</p>
<p>&#9632; If the lock is OwnedByReaders: RR++, Return</p>
<p>&#9632; Else: RW++, Block reader thread. When the thread wakes, loop around and try again. Here's what happens when a thread that has shared access leaves the lock:</p>
<p>&#9632; RR--</p>
<p>&#9632; If RR &gt; 0: Return</p>
<p>&#9632; If WW &gt; 0: Set state to ReservedForWriter, WW--, Release 1 blocked writer thread, Return</p>
<p>&#9632; If RW==0 &amp;&amp; WW = 0: Set state to Free. Return</p>
<p>Here's what happens when a thread enters the lock for exclusive access:</p>
<p>&#9632; If the lock is Free: Set state to OwnedByWriter, Return</p>
<p>&#9632; If the lock is ReservedForWriter: Set state to OwnedByWriter, Return</p>
<p>&#9632; If the lock is OwnedByWriter: WW++, Block writer thread When thread wakes, loop around and try again.</p>
<p>&#9632; Else: Set state to OwnedByReadersAndWriterPending, WW++, Block writer thread When thread wakes, loop around and try again.</p>
<p>Here's what happens when a thread that has exclusive access leaves the lock:</p>
<p>&#9632; If WW==0 &amp;&amp; RW==0: Set state to Free, Return</p>
<p>&#9632; If WW &gt; 0: Set state to ReservedForWriter, WW--. Release 1 blocked writer thread, Return</p>
<p>&#9632; If WW==0 &amp;&amp; RW&gt;0: Set state to Free. RW=0, Wake all reader blocked read threads, Return</p>
<p>Let's say that there is currently one thread reading from the lock and another thread wants to enter the lock for writing. The writer thread will first check to see if the lock is Free, and since it is not, the thread will advance to perform the next check. However, at this point, the reader thread could leave the lock, and seeing that RR and WW are both 0, the thread could set the lock's state to Free. This is a problem because the writer thread has already performed this test and moved on. Basically what happened is that the reader thread changed the state that the writer thread was accessing behind its back I needed to solve this problem so that the lock would function correctly.</p>
<p>To solve the problem, all of these bit manipulations are performed using the technique I showed in the &quot;The Interlocked Anything Pattern&quot; section from Chapter 28. If you recall, this pattern lets you turn any operation into a thread-safe atomic operation. This is what allows this lock to be so fast and have less state in it than other reader-writer locks When I run performance tests comparing my <b>OneManyLock </b>against the FCL's <b>ReaderWriterLockSlim </b>and <b>ReaderWriterLock </b>classes I get the following results:</p>
<p><code>Incrementing x in OneManyLock: 406 Fastest Incrementing x in ReaderWriterLockSlim: 999        ~2.5x slower Incrementing x in ReaderWriterLock: 2,051.~5.0x slower</code></p>
<p>Of course, since all reader-writer locks perform more logic than a mutually exclusive lock, their performance can be slightly worse. However, you have to weigh this against the fact that a reader-writer lock allows multiple readers into the lock simultaneously.</p>
<p>Before leaving this section, I'll also mention that my Power Threading library (downloadable for free from <a href="http://Wintellect.com/">http://Wintellect.com/</a>) offers a slightly different version of this lock, called <b>OneManyResourceLock. </b>This lock and others in the library offer many additional features such as deadlock detection, the ability to turn on lock ownership and recursion (albeit at a performance cost), a unified programming model for all locks, and the ability to observe the runtime behavior of the locks. For observing behavior, you can see the maximum amount of time that a thread ever waited to acquire a lock and you can see the minimum and maximum amount of time that a lock was held.</p>
<p>s</p>
<p>The next construct is <b>System.Threading.CountdownEvent. </b>Internally, this construct uses a <b>ManualResetEventSlim </b>object. This construct blocks a thread until its internal counter reaches <b>0 </b>In a way, this construct's behavior is the opposite of that of a <b>Semaphore </b>(which blocks threads while its count is <b>0) </b>. Here is what this class looks like (some method overloads are not shown):</p>
<p><code>public class CountdownEvent : IDisposable { public CountdownEvent(Int32 initialCount); public void Dispose();<br/>
public void Reset(Int32 count);// Set CurrentCount to count<br/>
public void AddCount(Int32 signalCount);// Increments CurrentCount by signalCount<br/>
public Boolean TryAddCount(Int32 signalCount); // Increments CurrentCount by signalCount public Boolean Signal(Int32 signalCount);// Decrements CurrentCount by signameCount<br/>
public Boolean Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken);<br/>
public Int32.CurrentCount { get; }<br/>
public Boolean      IsSet{ get; }// true if CurrentCount is 0<br/>
public WaitHandle WaitHandle     { get; }<br/>
}</code></p>
<p>Once a <b>CountdownEvent</b>'s <b>CurrentCount </b>reaches <b>0, </b>it cannot be changed The <b>AddCount </b>method throws <b>InvalidOperationException </b>when <b>CurrentCount </b>is <b>0, </b>while the <b>TryAddCount </b>method simply returns <b>false </b>if <b>CurrentCount </b>is <b>0 </b>.</p>
<p>s</p>
<p>The <b>System.Threading.Barrier </b>construct is designed to solve a very rare problem, so it is unlikely that you will have a use for it. <b>Barrier </b>is used to control a set of threads that are working together in parallel so that they can step through phases of the algorithm together. Perhaps an example is in order: When the CLR is using the server version of its garbage collector, the GC algorithm creates one thread per core. These threads walk up different application threads' stacks, concurrently marking objects in the heap. As each thread completes its portion of the work, it must stop waiting for the other threads to complete their portion of the work After all threads have marked the objects, then the threads can compact different portions of the heap concurrently. As each thread finishes compacting its portion of the heap, the thread must block waiting for the other threads. After all the threads have finished compacting their portion of the heap, then all the threads walk up the application's threads' stacks, fixing up roots to refer to the new location of the compacted object. Only after all the threads have completed this work is the garbage collector considered complete and the application's threads can be resumed.</p>
<p>This scenario is easily solved using the <b>Barrier </b>class, which looks like this (some method overloads are not shown):</p>
<p><code>public class Barrier : IDisposable {<br/>
public Barrier(Int32 participantCount, Action&lt;Barrier&gt; postPhaseAction); public void Dispose();<br/>
public Int64 AddParticipants(Int32 participantCount);     // Adds participants public void RemoveParticipants(Int32 participantCount); // Subtracts participants public Boolean SignalAndWait(Int32 millisecondsTimeout, CancellationToken cancellationToken);<br/>
public Int64 CurrentPhaseNumber { get; } // Indicates phase in process (starts at 0) public Int32 ParticipantCount{ get; }   // Number of participants<br/>
public Int32 ParticipantsRemaining { get; }   // # of threads needing to call SignalAndWait<br/>
}</code></p>
<p>When you construct a <b>Barrier, </b>you tell it how many threads are participating in the work, and you can also pass an <b>Action&lt;Barrier&gt; </b>delegate referring to code that will be invoked whenever all participants complete a phase of the work. You can dynamically add and remove participating threads from the <b>Barrier </b>by calling the <b>AddParticipant </b>and <b>RemoveParticipant </b>methods but, in practice, this is rarely done. As each thread completes its phase of the work, it should call <b>SignalAndWait, </b>which tells the <b>Barrier </b>that the thread is done and the <b>Barrier </b>blocks the thread (using a <b>ManualResetEventSlim) </b>. After all participants call <b>SignalAndWait, </b>the <b>Barrier </b>invokes the delegate (using the last thread that called <b>SignalAndWait) </b>and then unblocks all the waiting threads so they can begin the next phase.</p>
<h3>Thread Synchronization Construct Summary</h3>
<p>My recommendation always is to avoid writing code that blocks any threads. When performing asynchronous compute or I/O operations, hand the data off from thread to thread in such a way to avoid the chance that multiple threads could access the data simultaneously. I demonstrated this with the pipe server and client code shown in Chapter 27, &quot;I/O-Bound Asynchronous Operations.&quot; If you are unable to fully accomplish this, then try to use the <b>VolatileRead, VolatileWrite, </b>and <b>Interlocked </b>methods because they are fast and they also never block a thread. Unfortunately, these methods manipulate only simple types, but you can perform rich operations on these types as described in the &quot;The Interlocked Anything Pattern&quot; section.</p>
<p>There are two main reasons why you would consider blocking threads:</p>
<p>&#9632; The programming model is simplified.   By blocking a thread, you are sacrificing some resources and performance so that you can write your application code sequentially without using callback methods.</p>
<p>&#9632; A thread has a dedicated purpose.   Some threads must be used for specific tasks. The best example is an application's primary thread. If an application's primary thread doesn't block, then it will eventually return and the whole process will terminate. Another example is an application's GUI thread or threads. Windows requires that a</p>
<p>window or control always be manipulated by the thread that created it, so we sometimes write code that blocks a GUI thread until some other operation is done and then the GUI thread updates any windows and controls as needed. Of course, blocking the GUI thread hangs the application and provides a bad end-user experience.</p>
<p>To avoid blocking threads, don't mentally assign a label to your threads. For example, don't create a spell-checking thread, a grammar-checking thread, a thread that handles this particular client request, and so on. The moment you assign a label to a thread, you have also said to yourself that that thread can't do anything else But threads are too expensive a resource to have them dedicated to a particular purpose Instead, you should use the thread pool to rent threads for short periods of time So a thread pool thread starts out spell checking, then it changes to grammar checking, and then it changes again to perform work on behalf of a client request, and so on.</p>
<p>If, in spite of this discussion, you decide to block threads, then use the kernel object constructs if you want to synchronize threads that are running in different AppDomains or processes. To atomically manipulate state via a set of operations, use the <b>Monitor </b>class with a <b>private </b>field. <sup>6</sup> Alternatively, you could use a reader-writer lock instead of <b>Monitor </b>. Reader-writer locks are generally slower than <b>Monitor, </b>but they allow multiple reader threads to execute concurrently, which improves overall performance and minimizes the chance of blocking threads.</p>
<p>In addition, avoid using recursive locks (especially recursive reader-writer locks) because they hurt performance. However, <b>Monitor </b>is recursive and its performance is very good.<sup>7</sup> Also, avoid releasing a lock in a <b>finally </b>block because entering and leaving exception-handling blocks incurs a performance hit, and if an exception is thrown while mutating state, then the state is corrupted and other threads that manipulate it will experience unpredictable behavior and security bugs.</p>
<p>Of course, if you do write code that holds a lock, your code should not hold the lock for a long time because this increases the likelihood of threads blocking In the &quot;Using Collections to Avoid Holding a Lock for a Long Time&quot; section, I will show a technique that uses collection classes as a way to avoid holding a lock for a long time.</p>
<p>Finally, for compute-bound work, you can use tasks (discussed in Chapter 26) to avoid a lot of the thread synchronization constructs In particular, I love that each task can have one or more continue-with tasks associated with it that execute via some thread pool thread when some operation completes This is much better than having a thread block waiting for some operation to complete For I/O-bound work, the Asynchronous Programming Model (APM) invokes your callback method when the I/O operation completes; this is similar to a task's continue-with task.</p>
<p>You could use a <b>SpinLock </b>instead of <b>Monitor </b>because <b>SpinLock</b>s are slightly faster. But a <b>SpinLock </b>is potentially dangerous because it can waste CPU time and, in my opinion, it is not sufficiently faster than <b>Monitor </b>to justify its use.</p>
<p>This is partially because <b>Monitor </b>is actually implemented in native code, not managed code.</p>
<a name="b844"/><h2>The Famous Double-Check Locking Technique</h2>
<p>There is a famous technique called double-check locking, which is used by developers who want to defer constructing a singleton object until an application requests it (sometimes called lazy initialization). If the application never requests the object, it never gets constructed, saving time and memory. A potential problem occurs when multiple threads request the singleton object simultaneously. In this case, some form of thread synchronization must be used to ensure that the singleton object gets constructed just once.</p>
<p>This technique is not famous because it is particularly interesting or useful. It is famous because there has been much written about it. This technique was used heavily in Java, and later it was discovered that Java couldn't guarantee that it would work everywhere. The famous document that describes the problem can be found on this Web page: <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>.</p>
<p>Anyway, you'll be happy to know that the CLR supports the double-check locking technique just fine because of its memory model and volatile field access (described in Chapter 28). Here is code that demonstrates how to implement the double-check locking technique in C#:</p>
<p><code>internal sealed class Singleton {<br/>
// s_lock is required for thread safety and having this object assumes that creating // the singleton object is more expensive than creating a System.Object object and that // creating the singleton object may not be necessary at all. Otherwise, it is more // efficient and easier to just create the singleton object in a class constructor private static readonly Object s_lock = new Object();<br/>
// This field will refer to the one Singleton object private static Singleton s_value = null;<br/>
// Private constructor prevents any code outside this class from creating an instance private Singleton() {<br/>
// Code to initialize the one Singleton object goes here...<br/>
}<br/>
// Public, static method that returns the Singleton object (creating it if necessary) public static Singleton GetSingleton() {<br/>
// If the Singleton was already created, just return it (this is fast)<br/>
if (s_value != null) return s_value;<br/>
Monitor.Enter(s_lock);   // Not created, let 1 thread create it if (s_value == null) {<br/>
// Still not created, create it<br/>
Singleton temp = new Singleton();<br/>
// Save the reference in s_value (see discussion for details) Interlocked.Exchange(ref s_value, temp);<br/>
}<br/>
Monitor.Exit(s_lock);<br/>
// Return a reference to the one Singleton object return s_value;<br/>
}<br/>
}</code></p>
<p>The idea behind the double-check locking technique is that a call to the <b>GetSingleton </b>method quickly checks the <b>s_value </b>field to see if the object has already been created, and if it has, the method returns a reference to it The beautiful thing here is that no thread synchronization is required once the object has been constructed; the application will run very fast. On the other hand, if the first thread that calls the <b>GetSingleton </b>method sees that the object hasn't been created, it takes a thread synchronization lock to ensure that only one thread constructs the single object. This means that a performance hit occurs only the first time a thread queries the singleton object.</p>
<p>Now, let me explain why this pattern didn't work in Java. The Java Virtual Machine read the value of <b>s_value </b>into a CPU register at the beginning of the <b>GetSingleton </b>method and then just queried the register when evaluating the second <b>if </b>statement, causing the second <b>if </b>statement to always evaluate to <b>true, </b>and multiple threads ended up creating <b>Singleton </b>objects. Of course, this happened only if multiple threads called <b>GetSingleton </b>at the exact same time, which in most applications is very unlikely. This is why it went undetected in Java for so long.</p>
<p>In the CLR, calling any lock method is a full memory fence, and any variable writes you have before the fence must complete before the fence and any variable reads after the fence must start after it. For the <b>GetSingleton </b>method, this means that the <b>s_value </b>field must be reread after the call to <b>Monitor.Enter; </b>it cannot be cached in a register across this method call.</p>
<p>Inside <b>GetSingleton, </b>you see the call to <b>Interlocked.Exchange </b>Here's the problem that this is solving. Let's say that what you had inside the second <b>if </b>statement was the following line of code:</p>
<p><code>s_value = new Singleton();   // This is what you'd ideally like to write</code></p>
<p>You would expect the compiler to produce code that allocates the memory for a <b>Singleton, </b>calls the constructor to initialize the fields, and then assigns the reference into the <b>s_value </b>field. Making a value visible to other threads is called publishing. But the compiler could do this instead: allocate memory for the <b>Singleton, </b>publish (assign) the reference into <b>s_value, </b>and then call the constructor From a single thread's perspective, changing the order like this has no impact But what if, after publishing the reference into <b>s_value </b>and before calling the constructor, another thread calls the <b>GetSingleton </b>method? This thread will see that <b>s_value </b>is not <b>null </b>and start to use the <b>Singleton </b>object, but its constructor has not finished executing yet! This can be a very hard bug to track down, especially since it is all due to timing.</p>
<p>The call to <b>Interlocked.Exchange </b>fixes this problem. It ensures that the reference in <b>temp </b>can be published into <b>s_value </b>only after the constructor has finished executing. Another way to solve this problem would be to mark the <b>s_value </b>field with C#'s <b>volatile </b>keyword. This makes the write to <b>s_value </b>volatile, and again, the constructor has to finish running before the write can happen Unfortunately, this makes all reads volatile, too, and since there is no need for this, you are hurting your performance with no benefit.</p>
<p>In the beginning of this section, I mentioned that the double-check locking technique is not that interesting. In my opinion, developers think it is cool, and they use it far more often than they should. In most scenarios, this technique actually hurts efficiency. Here is a much simpler version of the <b>Singleton </b>class that behaves the same as the previous version. This version does not use the double-check locking technique:</p>
<p><code>internal sealed class Singleton {<br/>
private static Singleton s_value = new Singleton();<br/>
// Private constructor prevents any code outside this class from creating an instance private Singleton() {<br/>
// Code to initialize the one Singleton object goes here...<br/>
}<br/>
// Public, static method that returns the Singleton object (creating it if necessary) public static Singleton GetSingleton() { return s_value; }<br/>
}</code></p>
<p>Since the CLR automatically calls a type's class constructor the first time code attempts to access a member of the class, the first time a thread queries <b>Singleton</b>'s <b>GetSingleton </b>method, the CLR will automatically call the class constructor, which creates an instance of the object. Furthermore, the CLR already ensures that calls to a class constructor are thread safe. I explained all of this in Chapter 8 The one downside of this approach is that the type constructor is called when any member of a class is first accessed. If the <b>Singleton </b>type defined some other static members, then the <b>Singleton </b>object would be created when any one of them was accessed. Some people work around this problem by defining nested classes.</p>
<p>Let me show you a third way of producing a single <b>Singleton </b>object:</p>
<p><code>internal sealed class Singleton {<br/>
private static Singleton s_value = null;<br/>
// Private constructor prevents any code outside this class from creating an instance private Singleton() {<br/>
// Code to initialize the one Singleton object goes here...<br/>
}<br/>
// Public, static method that returns the Singleton object (creating it if necessary) public static Singleton GetSingleton() { if (s_value != null) return s_value;<br/>
// Create a new Singleton and root it if another thread didn't do it first Singleton temp = new Singleton();<br/>
Interlocked.CompareExchange(ref s_value, temp, null);<br/>
// If this thread lost, then the second Singleton object gets GC'd<br/>
return s_value; // Return reference to the single object<br/>
}<br/>
}</code></p>
<p>If multiple threads call <b>GetSingleton </b>simultaneously, then this version might create two (or more) <b>Singleton </b>objects. However, the call to <b>Interlocked.CompareExchange </b>ensures that only one of the references is ever published into the <b>s_value </b>field. Any object not rooted by this field will be garbage collected later on. Since, in most applications, it is unlikely that multiple threads will call <b>GetSingleton </b>at the same time, it is unlikely that more than one <b>Singleton </b>object will ever be created.</p>
<p>Now it might upset you that multiple <b>Singleton </b>objects could be created, but there are many benefits to this code. First, it is very fast. Second, it never blocks a thread; if a thread pool thread is blocked on a <b>Monitor </b>or any other kernel-mode thread synchronization construct, then the thread pool creates another thread to keep the CPUs saturated with work So now, another megabyte or more of memory is allocated and initialized and all the DLLs get a thread attach notification. With <b>CompareExchange, </b>this can never happen. Of course, you can use this technique only when the constructor has no side effects.</p>
<p>The FCL offers two types that encapsulate the patterns described in this section The generic <b>System.Lazy </b>class looks like this (some methods are not shown):</p>
<p><code>public class Lazy&lt;T&gt; {<br/>
public Lazy(Func&lt;T&gt; valueFactory, LazyThreadSafetyMode mode); public Boolean IsValueCreated { get; } public T Value { get; }<br/>
}</code></p>
<p>This code demonstrates how it works:</p>
<p><code>public static void Main() {<br/>
// Create a lazy-initialization wrapper around getting the DateTime Lazy&lt;String&gt; s = new Lazy&lt;String&gt;(<br/>
() =&gt; DateTime.Now.ToLongTimeString(), LazyThreadSafetyMode.PublicationOnly);<br/>
Console.WriteLine(s.IsValueCreated);// Returns false since Value not queried yet<br/>
Console.WriteLine(s.Value);// The delegate is invoked now<br/>
Console.WriteLine(s.IsValueCreated);// Returns true since Value was queried<br/>
Thread.Sleep(10000);// Wait 10 seconds and display the time again<br/>
Console.WriteLine(s.Value);// The delegate is NOT invoked now; same result<br/>
}</code></p>
<p>When I run this, I get the following output:</p>
<p><code>False 2:40:42 PM True<br/>
2:40:42 PM.Notice that the time did not change 10 seconds later</code></p>
<p>The code above constructed an instance of the <b>Lazy </b>class and passed one of the <b>LazyThreadSafetyMode </b>flags into it. Here is what these flags look like and what they mean:</p>
<p><code>public enum LazyThreadSafetyMode {<br/>
None,// No thread-safety support at all (good for GUI apps)<br/>
ExecutionAndPublication      // Uses the double-check locking technique PublicationOnly,// Uses the Interlocked.CompareExchange technique<br/>
}</code></p>
<p>In some memory-constrained scenarios, you might not even want to create an instance of the <b>Lazy </b>class. Instead, you can call static methods of the <b>System.Threading. LazyInitializer </b>class The class looks like this:</p>
<p><code>public static class LazyInitializer {<br/>
// These two methods use Interlocked.CompareExchange internally: public static T EnsureInitialized&lt;T&gt;(ref T target) where T: class;<br/>
public static T EnsureInitialized&lt;T&gt;(ref T target, Func&lt;T&gt; valueFactory) where T: class;<br/>
// These two methods pass the syncLock to Monitor's Enter and Exit methods internally public static T EnsureInitialized&lt;T&gt;(ref T target, ref Boolean initialized,<br/>
ref Object syncLock); public static T EnsureInitialized&lt;T&gt;(ref T target, ref Boolean initialized,<br/>
ref Object syncLock, Func&lt;T&gt; valueFactory);<br/>
}</code></p>
<p>Also, being able to explicitly specify a synchronization object to the <b>EnsureInitialized </b>method's <b>syncLock </b>parameter allows multiple initialization functions and fields to be protected by the same lock.</p>
<p>Here is an example using a method from this class:</p>
<p><code>public static void Main() { String name = null;<br/>
// Since name is null, the delegate runs and initializes name LazyInitializer.EnsureInitialized(ref name, () =&gt; &quot;Jeffrey&quot;); Console.WriteLine(name);     // Displays &quot;Jeffrey&quot;<br/>
// Since name is not null, the delegate does not run; name doesn't change LazyInitializer.EnsureInitialized(ref name, () =&gt; &quot;Richter&quot;); Console.WriteLine(name);     // Also displays &quot;Jeffrey&quot;<br/>
}</code></p>
<a name="b848"/><h2>The Condition Variable Pattern</h2>
<p>Let's say that a thread wants to execute some code when a complex condition is true. One option would be to let the thread spin continuously, repeatedly testing the condition. But this wastes CPU time, and it is also not possible to atomically test multiple variables that are making up the complex condition Fortunately, there is a pattern that allows threads to efficiently synchronize their operations based on a complex condition. This pattern is called the condition variable pattern, and we use it via the following methods defined inside the <b>Monitor </b>class:</p>
<p><code>public static class Monitor {<br/>
public static Boolean Wait(Object obj);<br/>
public static Boolean Wait(Object obj, Int32 millisecondsTimeout);<br/>
public static void Pulse(Object obj); public static void PulseAll(Object obj);<br/>
}</code></p>
<p>Here is what the pattern looks like:</p>
<p><code>internal sealed class ConditionVariablePattern { private readonly Object m_lock = new Object(); private Boolean m_condition = false;<br/>
public void Thread1() {<br/>
Monitor.Enter(m_lock);// Acquire a mutual-exclusive lock<br/>
// While under the lock, test the complex condition &quot;atomically&quot;<br/>
while (!m_condition) {<br/>
// If condition is not met, wait for another thread to change the condition Monitor.Wait(m_lock);// Temporarily release lock so other threads can get it<br/>
}<br/>
// The condition was met, process the data... Monitor.Exit(m_lock);// Permanently release lock<br/>
}<br/>
public void Thread2() {<br/>
Monitor.Enter(m_lock);// Acquire a mutual-exclusive lock<br/>
// Process data and modify.the condition... m_condition = true;<br/>
// Monitor.Pulse(m_lock);        // Wakes one waiter AFTER lock is released Monitor.PulseAll(m_lock);        // Wakes all waiters AFTER lock is released<br/>
Monitor.Exit(m_lock);// Release lock<br/>
}<br/>
}</code></p>
<p>In this code, the thread executing the <b>Thread1 </b>method enters a mutual-exclusive lock and then tests a condition. Here, I am just checking a <b>Boolean </b>field, but this condition can be arbitrarily complex. For example, you could check to see if it is a Tuesday in March and if a certain collection object has 10 elements in it. If the condition is false, then you want the thread to spin on the condition, but spinning wastes CPU time, so instead, the thread calls <b>Wait Wait </b>releases the lock so that another thread can get it and blocks the calling thread.</p>
<p>The <b>Thread2 </b>method shows code that the second thread executes. It calls <b>Enter </b>to take ownership of the lock, processes some data, which results in changing the state of the condition, and then calls <b>Pulse(All), </b>which will unblock a thread from its <b>Wait </b>call. <b>Pulse </b>unblocks the longest waiting thread (if any), while <b>PulseAll </b>unblocks all waiting threads</p>
<p>(if any). However, any unblocked threads don't wake up yet. The thread executing <b>Thread2 </b>must call <b>Monitor.Exit, </b>allowing the lock to be owned by another thread. Also, if <b>PulseAll </b>is called, the other threads do not unblock simultaneously. When a thread that called <b>Wait </b>is unblocked, it becomes the owner of the lock, and since it is a mutual-exclusive lock, only one thread at a time can own it. Other threads can get it after an owning thread calls <b>Wait </b>or <b>Exit.</b></p>
<p>When the thread executing <b>Threadl </b>wakes, it loops around and tests the condition again. If the condition is still false, then it calls <b>Wait </b>again. If the condition is true, then it processes the data as it likes and ultimately calls <b>Exit, </b>leaving the lock so other threads can get it. The nice thing about this pattern is that it is possible to test several variables making up a complex condition using simple synchronization logic (just one lock), and multiple waiting threads can all unblock without causing any logic failure, although the unblocking threads might waste some CPU time.</p>
<p>Here is an example of a thread-safe queue that can have multiple threads enqueuing and dequeuing items to it. Note that threads attempting to dequeue an item block until an item is available for them to process.</p>
<p><code>internal sealed class SynchronizedQueue&lt;T&gt; {<br/>
private readonly Object m_lock = new Object(); private readonly Queue&lt;T&gt; m_queue = new Queue&lt;T&gt;();<br/>
public void Enqueue(T item) { Monitor.Enter(m_lock);<br/>
// After enqueuing an item, wake up any/all waiters<br/>
m_queue.Enqueue(item);<br/>
Monitor.PulseAll(m_lock);<br/>
Monitor.Exit(m_lock);<br/>
}<br/>
public T Dequeue() {<br/>
Monitor.Enter(m_lock);<br/>
// Loop while the queue is empty (the condition) while (m_queue.Count == 0) Monitor.Wait(m_queue);<br/>
// Dequeue an item from the queue and return it for processing T item = m_queue.Dequeue(); Monitor.Exit(m_lock); return item;<br/>
}<br/>
}</code></p>
<a name="b851"/><h2>Using Collections to Avoid Holding a Lock for a Long Time</h2>
<p>I'm not terribly fond of any of the thread synchronization constructs that use kernel-mode primitives because all of these primitives exist to block a thread from running, and threads are just too expensive to create and not have them run. Here is an example that hopefully clarifies the problem.</p>
<p>Imagine a Web site into which clients make requests When a client request arrives, a thread pool thread starts processing the client's request. Let's say that this client wants to modify some data in the server in a thread-safe way, so it acquires a reader-writer lock for writing. Let's pretend that this lock is held for a long time. As the lock is held, another client request comes in, so that thread pool creates a new thread for the client request and then the thread blocks trying to acquire the reader-writer lock for reading. In fact, as more and more client requests come in, the thread pool creates more and more threads and all these threads are just blocking themselves on the lock. The server is spending all its time creating threads so that they can stop running! This server does not scale well at all.</p>
<p>Then, to make matters worse, when the writer thread releases the lock, all the reader threads unblock simultaneously and get to run, but now there may be lots of threads trying to run on relatively few CPUs, so Windows is context switching between the threads constantly. The result is that the workload is not being processed as quickly as it could because of all the overhead associated with the context switches.</p>
<p>If you look over all the constructs shown in this chapter, many of the problems that these constructs are trying to solve can be much better accomplished using the <b>Task </b>class discussed in Chapter 26. Take the <b>Barrier </b>class, for example: You could spawn several <b>Task </b>objects to work on a phase and then, when all these tasks complete, you could continue with one or more other <b>Task </b>objects. Compared to many of the constructs shown in this chapter, tasks have many advantages:</p>
<p>&#9632; Tasks use much less memory than threads and they take much less time to create and destroy.</p>
<p>&#9632; The thread pool automatically scales the tasks across available CPUs.</p>
<p>&#9632; As each task completes a phase, the thread running that task goes back to the thread pool where it can do other work if any is available for it.</p>
<p>&#9632; The thread pool has a process-global view of tasks and, as such, it can better schedule these tasks, reducing the number of threads in the process and also reducing context switching.</p>
<p>Reader-writer locks are very popular and useful. <sup>8</sup> Trying to build one of these out of <b>Task </b>objects would be quite challenging. However, my Power Threading library includes a non-blocking read-writer class, which I call <b>ReaderWriterGate. </b>It looks like this (some methods are not shown):</p>
<p><code>public sealed class ReaderWriterGate : IDisposable { public ReaderWriterGate(); public void Dispose();<br/>
public IAsyncResult BeginRead(ReaderWriterGateCallback callback, Object state,<br/>
AsyncCallback asyncCallback, Object asyncState); public Object EndRead(IAsyncResult result);<br/>
public IAsyncResult BeginWrite(ReaderWriterGateCallback callback, Object state,<br/>
AsyncCallback asyncCallback, Object asyncState); public Object EndWrite(IAsyncResult result);<br/>
}</code></p>
<p>The <b>ReaderWriterGateCallback </b>is a delegate that looks like this:</p>
<p><code>public delegate object ReaderWriterGateCallback(ReaderWriterGateReleaser releaser); The <b>ReaderWriterGateReleaser </b>class looks like this (some methods are not shown):<br/>
public sealed class ReaderWriterGateReleaser : IDisposable {<br/>
public Object State { get; }   // Returns the 'state' passed to BeginRead/BeginWrite public void Dispose();<br/>
}</code></p>
<p>The <b>ReaderWriterGate </b>makes a lock look just like an asynchronous I/O operation. In fact, my class even offers <b>BeginRead </b>and <b>BeginWrite </b>methods that take an <b>AsyncCallback </b>delegate and return an <b>IAsyncResult, </b>as well as <b>EndRead </b>and <b>EndWrite </b>methods that accept an <b>IAsyncResult </b>. I designed the class to work exactly like the APM that was discussed in Chapter 27.</p>
<p>Here's how it works. Put the code that requires read access to a resource in its own method and then call <b>BeginRead, </b>passing this method for the <b>ReaderWriterGetCallback </b>delegate parameter When it is safe to read from the resource, the <b>ReaderWriterGate </b>object will have a thread pool thread invoke your method Note that several thread pool threads could be executing methods that read from the resource concurrently Put the code that requires write access to a resource in its own method and then call <b>BeginWrite, </b>passing this method for the <b>ReaderWriterGetCallback </b>delegate parameter. When it is safe to write to the resource, the <b>ReaderWriterGate </b>object will have a thread pool thread invoke your method. Note that the <b>ReaderWriterGate </b>object ensures that there will be only one thread pool thread executing a method that writes to the resource at a particular time.</p>
<p>Of course, if you only need mutual-exclusive access to a resource, you can always use a reader-writer lock and request only write access to the resource it protects.</p>
<p>When your method finishes processing the resource and returns, the <b>ReaderWriterGate </b>object will invoke whatever method you passed to <b>BeginRead</b>'s or <b>BeginWrite</b>'s <b>asyncCallback </b>parameter; this is how you know when the operation completed.</p>
<p>So now, let's return to our Web server discussion. A client makes a request to write to a resource, so a thread pool thread calls <b>ReaderWriterGate</b>'s <b>BeginWrite </b>method. While the thread is processing the callback method, another client makes a request The thread pool creates a new thread, and this thread calls <b>BeginRead </b>. The <b>ReaderWriterGate </b>object sees that reading is not allowed at this time and it adds the <b>callback </b>delegate to an internal queue The queue is a collection class, and it needs to be manipulated in a thread-safe way, so a lock is taken around the manipulation of the collection. However, the lock is held only while items are being added and removed from the queue, which requires a very short amount of time. This means that other threads also using the <b>ReaderWriterGate </b>will not block for long (if at all)!</p>
<p>After the <b>callback </b>delegate has been added to the queue, the thread pool thread returns to the pool. As more client requests come in, the same thread pool thread keeps waking up and calling <b>BeginRead, </b>adding more and more delegates to the internal queue. So now the server has only two threads in it doing all the work.</p>
<p>When the first thread finishes writing to the resource, it returns from the callback method to the <b>ReaderWriterGate </b>object. The <b>ReaderWriterGate </b>sees that there are a bunch of delegates in its internal queue, so it posts all these delegates to the CLR's thread pool Again, a lock has to be taken around the manipulation of the queue, but the lock is held just long enough to queue its <b>callback </b>delegates into the thread pool. The thread pool then spans this work out over the cores using no more threads than there are cores, and so no context switching occurs.<sup>9</sup> Now, we have a scalable server that uses very little resources and runs with great performance.</p>
<p>A <b>ReaderWriterGate </b>object has another internal queue for delegates that wish to write to the resource When a write request shows up, any incoming reader delegates get queued so that the current reader methods can finish and drain out of the gate. After the thread pool threads have finished processing the previously queued reader methods, a single writer delegate is queued to the thread pool. This is how I ensure that only other thread is calling a writer method at any given time.</p>
<p>More details about the <b>ReaderWriterGate </b>can be found here: <a href="http://msdn.microsoft.com">http://msdn.microsoft.com</a> /en-us/magazine/cc163532.aspx. After I came up with this idea, I sold the patent rights to</p>
<p>This is assuming that other threads are not running on the computer which, most of the time, is true since most computers are running at far less than 100 percent CPU usage. And CPU usage can be at 100 percent and this will still work as explained if the running threads have lower priorities. If other threads are running, then context switching occurs This is bad for performance reasons, but it is good for reliability reasons Remember that Windows gives each process at least one thread and performs context switches to ensure that a hung application doesn't stop other applications from running.</p>
<p>Microsoft, and in 2009, the Patent Office issued the patent (Patent #7,603,502). However, even though Microsoft owns the patent for this idea, the FCL does not provide any class that implements this idea. However, I provide an implementation in my Power Threading library. When I sold the rights to Microsoft, I acquired a license allowing Wintellect customers to use this &quot;invention&quot; with the caveat that it can be used only on a Microsoft platform. <sup>10</sup> By downloading the library from the Wintellect Web site, you are a Wintellect customer, and you can use the library subject to the license restriction.</p>
<p>In Chapter 27, I gave a brief introduction to my <b>AsyncEnumerator </b>class, which is also part of my Power Threading library This class enabled you to use a synchronous programming model with classes that support the CLR's APM, and since my <b>ReaderWriterGate </b>supports the APM, you can use it with the <b>AsyncEnumerator </b>. However, when I first tried this, I discovered that I could simplify the programming model even more. So if you want to use my <b>AsyncEnumerator </b>and also have multiple iterators accessing shared data in a thread-safe way, use my <b>SyncGate </b>class instead of <b>ReaderWriterGate </b>. The <b>SyncGate </b>class is also in my Power Threading library, and it looks like this:</p>
<p><code>public sealed class SyncGate { public SyncGate();<br/>
public void BeginRegion(SyncGateMode mode,<br/>
AsyncCallback asyncCallback, Object asyncState); public void EndRegion(IAsyncResult result);<br/>
}</code></p>
<p>You should see the samples in my Power Threading library for examples of using these classes together, but I'll show a brief example here. I took the <b>PipeServerAsyncEnumerator </b>method shown in Chapter 27 and modified it to record the timestamp of the most recent client request in a static field accessible to all threads. Since multiple client requests can be running simultaneously using various threads, updating the static field must be done in a thread-safe way. To accomplish this, I create a static field that holds a reference to a <b>SyncGate </b>object, and I call its <b>BeginRegion </b>and <b>EndRegion </b>methods to acquire and release exclusive access, respectively. Here is the new version of the code with the added lines highlighted:</p>
<p><code>// This field records the timestamp of the most recent client's request private static DateTime s_lastClientRequestTimestamp = DateTime.MinValue;<br/>
// The SyncGate enforces thread-safe access to the s_lastClientRequestTimestamp field private static readonly SyncGate s_gate = new SyncGate();<br/>
private static IEnumerator&lt;Int32&gt; PipeServerAsyncEnumerator(AsyncEnumerator ae) { // Each server object performs asynchronous operations on this pipe using (var pipe = new NamedPipeServerStream(</code></p>
<p>Silverlight is considered a Microsoft platform even if your Silverlight application is running in a non-Microsoft operating system And, my Power Threading library does have a version of this class for Silverlight as well as the Microsoft .NET Compact Framework.</p>
<p><code>&quot;Echo&quot;, PipeDirection.InOut, -1, PipeTransmissionMode.Message, PipeOptions.Asynchronous | PipeOptions.WriteThrough)) {<br/>
// Asynchronously accept a client connection pipe.BeginWaitForConnection(ae.End(), null); yield return 1;<br/>
// A client connected, let's accept another client var aeNewClient = new AsyncEnumerator(); aeNewClient.BeginExecute(<br/>
PipeServerAsyncEnumerator(aeNewClient), aeNewClient.EndExecute);<br/>
// Accept the client connection<br/>
pipe.EndWaitForConnection(ae.DequeueAsyncResult());<br/>
// Asynchronously read a request from the client Byte[] data = new Byte[1000];<br/>
pipe.BeginRead(data, 0, data.Length, ae.End(), null); yield return 1;<br/>
// The client sent us a request, process it.<br/>
Int32 bytesRead = pipe.EndRead(ae.DequeueAsyncResult());<br/>
// Get the timestamp of this client's request DateTime now = DateTime.Now;<br/>
// We want to save the timestamp of the most recent client request. Since multiple // clients are running concurrently, this has to be done in a thread-safe way s_gate.BeginRegion(SyncGateMode.Exclusive, ae.End()); // Request exclusive access yield return 1;     // The iterator resumes when exclusive access is granted<br/>
if (s_lastClientRequestTimestamp &lt; now) s_lastClientRequestTimestamp = now;<br/>
s_gate.EndRegion(ae.DequeueAsyncResult());     // Relinquish exclusive access<br/>
// My sample server just changes all the characters to uppercase // But, you can replace this code with any compute-bound operation data = Encoding.UTF8.GetBytes(<br/>
Encoding.UTF8.GetString(data, 0, bytesRead).ToUpper().ToCharArray());<br/>
// Asynchronously send the response back to the client pipe.BeginWrite(data, 0, data.Length, ae.End(), null); yield return 1;<br/>
// The response was sent to the client, close our side of the connection pipe.EndWrite(ae.DequeueAsyncResult()); } // Close the pipe<br/>
}</code></p>
<a name="b856"/><h2>The Concurrent Collection Classes</h2>
<p>The FCL ships with four thread-safe collection classes, all of which are in the <b>System. Collections.Concurrent </b>namespace. <b>ConcurrentQueue, ConcurrentStack,</b>and <b>ConcurrentDictionary </b>are in MSCorLib.dll, while <b>ConcurrentBag </b>is in System, dll. Here is what some of their most commonly used members look like:</p>
<p><code>// Process items in a first-in, first-out order (FIFO) public class ConcurrentQueue&lt;T&gt; : IProducerConsumerCollection&lt;T&gt;, IEnumerable&lt;T&gt;, ICollection, IEnumerable {<br/>
public ConcurrentQueue();<br/>
public void Enqueue(T item);<br/>
public Boolean TryDequeue(out T result);<br/>
public Int32 Count { get; }<br/>
public IEnumerator&lt;T&gt; GetEnumerator();<br/>
}<br/>
// Process items in a last-in, first-out order (LIFO) public class ConcurrentStack&lt;T&gt; : IProducerConsumerCollection&lt;T&gt;, IEnumerable&lt;T&gt;, ICollection, IEnumerable {<br/>
public ConcurrentStack();<br/>
public void Push(T item);<br/>
public Boolean TryPop(out T result);<br/>
public Int32 Count { get; }<br/>
public IEnumerator&lt;T&gt; GetEnumerator();<br/>
}<br/>
// An unordered set of items where duplicates are allowed public class ConcurrentBag&lt;T&gt; : IProducerConsumerCollection&lt;T&gt;, IEnumerable&lt;T&gt;, ICollection, IEnumerable {<br/>
public ConcurrentBag();<br/>
public void Add(T item);<br/>
public Boolean TryTake(out T result);<br/>
public Int32 Count { get; }<br/>
public IEnumerator&lt;T&gt; GetEnumerator();<br/>
}<br/>
// An unordered set of key/value pairs<br/>
public class ConcurrentDictionary&lt;TKey, TValue&gt; : IDictionary&lt;TKey, TValue&gt;,<br/>
ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IDictionary, ICollection, IEnumerable {<br/>
public ConcurrentDictionary();<br/>
public Boolean TryAdd(TKey key, TValue value);<br/>
public Boolean TryGetValue(TKey key, out TValue value);<br/>
public TValue this[TKey key] { get; set; }<br/>
public Boolean TryUpdate(TKey key, TValue newValue, TValue comparisonValue); public Boolean TryRemove(TKey key, out TValue value); public TValue AddOrUpdate(TKey key, TValue addValue,<br/>
Func&lt;TKey, TValue&gt; updateValueFactory); public TValue GetOrAdd(TKey key, TValue value); public Int32 Count { get; }<br/>
public IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetEnumerator();<br/>
}</code></p>
<p>All these collection classes are non-blocking. That is, if a thread tries to extract an element when no such element exists, the thread returns immediately; the thread does not block waiting for an element to appear. This is why methods like <b>TryDequeue, TryPop, TryTake, </b>and <b>TryGetValue </b>all return <b>true </b>if an item was obtained and <b>false </b>if not.</p>
<p>These non-blocking collections are not necessarily lock-free. The <b>ConcurrentDictionary </b>class uses <b>Monitor </b>internally, but the lock is held for a very short time while manipulating the item in the collection <b>ConcurrentQueue </b>and <b>ConcurrentStack </b>are lock-free; these both internally use <b>Interlocked </b>methods to manipulate the collection. A single <b>ConcurrentBag </b>object internally consists of a mini-collection object per thread. When a thread adds an item to the bag, <b>Interlocked </b>methods are used to add the item to the calling thread's mini-collection When a thread tries to extract an element from the bag, the bag checks the calling thread's mini-collection for the item. If the item is there, then an <b>Interlocked </b>method is used to extract the item. If the thread's mini-collection doesn't have the item, then a <b>Monitor </b>is taken internally to extract an item from another thread's mini-collection. We say that the thread is stealing the item from another thread.</p>
<p>You'll notice that all the concurrent classes offer a <b>GetEnumerator </b>method, which is typically used with C#'s <b>foreach </b>statement but can also be used with Language Integrated Query (LINQ). For the <b>ConcurrentStack, ConcurrentQueue, </b>and <b>ConcurrentBag, </b>the <b>GetEnumerator </b>method takes a snapshot of the collection's contents and returns elements from this snapshot; the contents of the actual collection may change while enumerating over the snapshot. <b>ConcurrentDictionary</b>'s <b>GetEnumerator </b>method does not take a snapshot of its contents, so the contents of the dictionary may change while enumerating over the dictionary; beware of this. Also note that the <b>Count </b>property returns the number of elements that are in the collection at the moment you query it. The count may immediately become incorrect if other threads are adding or removing elements from the collection at the same time.</p>
<p>Three of the concurrent collection classes, <b>ConcurrentStack, ConcurrentQueue, </b>and <b>ConcurrentBag, </b>implement the <b>IProducerConsumerCollection </b>interface, which is defined as follows:</p>
<p><code>public interface IProducerConsumerCollection&lt;T&gt; : IEnumerable&lt;T&gt;, ICollection, IEnumerable { Boolean TryAdd(T item); Boolean TryTake(out T item); T[] ToArray();<br/>
void CopyTo(T[] array, Int32 index);<br/>
}</code></p>
<p>Any class that implements this interface can be turned into a blocking collection where threads producing (adding) items will block if the collection is full and threads consuming (removing) items will block if the collection is empty. Of course, I'd try to avoid using blocking collections as their purpose in life is to block threads To turn a non-blocking collection into a blocking collection, you construct a <b>System.Collections.Concurrent.</b></p>
<p><b>BlockingCollection </b>class, passing in a reference to a non-blocking collection to its constructor. The <b>BlockingCollection </b>class (defined in the System.dll assembly) looks like this (some methods are not shown):</p>
<p><code>public class BlockingCollection&lt;T&gt; : IEnumerable&lt;T&gt;, ICollection, IEnumerable, IDisposable { public BlockingCollection(IProducerConsumerCollection&lt;T&gt; collection, Int32 boundedCapacity);<br/>
public void Add(T item);<br/>
public Boolean TryAdd(T item, Int32 msTimeout, CancellationToken cancellationToken); public void CompleteAdding();<br/>
public T Take();<br/>
public Boolean TryTake(out T item, Int32 msTimeout, CancellationToken cancellationToken);<br/>
public Int32     BoundedCapacity     { get;.}<br/>
public Int32     Count{ get;.}<br/>
public Boolean IsAddingCompleted { get;.}   // true if AddingComplete is called<br/>
public Boolean IsCompleted{ get;.}   // true if IsAddingComplete and Count==0<br/>
public IEnumerable&lt;T&gt; GetConsumingEnumerable(CancellationToken cancellationToken);<br/>
public void CopyTo(T[] array, int index); public T[] ToArray(); public void Dispose();<br/>
}</code></p>
<p>When you construct a <b>BlockingCollection, </b>the <b>boundedCapacity </b>parameter indicates the maximum number of items that you want in the collection. If a thread calls <b>Add </b>when the underlying collection has reached its capacity, the producing thread will block If preferred, the producing thread can call <b>TryAdd, </b>passing a timeout (in milliseconds) and/or a <b>CancellationToken </b>so that the thread blocks until the item is added, the timeout expires, or the <b>CancellationToken </b>is canceled (see Chapter 26 for more about the <b>CancellationToken </b>class).</p>
<p>The <b>BlockingCollection </b>class implements the <b>IDisposable </b>interface. When you call <b>Dispose, </b>it calls <b>Dispose </b>on the underlying collection and also disposes of two <b>SemaphoreSlim </b>objects that the class uses internally to block producers and consumers.</p>
<p>When producers will not be adding any more items into the collection, a producer should call the <b>CompleteAdding </b>method. This will signal the consumers that no more items will be produced. Specifically, this causes a <b>foreach </b>loop that is using <b>GetConsumingEnumerable </b>to terminate. The example code below demonstrates how to set up a producer/consumer scenario and signal completion:</p>
<p><code>public static void Main() {<br/>
var bl = new BlockingCollection&lt;Int32&gt;(new ConcurrentQueue&lt;Int32&gt;());<br/>
// A thread pool thread will do the consuming ThreadPool.QueueUserWorkItem(ConsumeItems, bl);<br/>
// Add 5 items to the collection<br/>
for (Int32 item = 0; item &lt; 5; item++) {<br/>
Console.Writel_ine(&quot;Producing: &quot; + item);<br/>
bl.Add(item);<br/>
}<br/>
// Tell the consuming thread(s) that no more items will be added to the collection bl.CompleteAddingO;<br/>
Console.ReadLineO;   // For testing purposes<br/>
}<br/>
private static void ConsumeItems(Object o) { var bl = (BlockingCollection&lt;Int32&gt;) o;<br/>
// Block until an item shows up, then process it foreach (var item in bl.GetConsumingEnumerable()) { Console.WriteLine(&quot;Consuming: &quot; + item);<br/>
}<br/>
// The collection is empty and no more items are going into it Console.WriteLine(&quot;All items have been consumed&quot;);<br/>
}</code></p>
<p>When I execute the above code, I get the following output:</p>
<p><code>Producing: 0 Producing: 1 Producing: 2 Producing: 3 Producing: 4 Consuming: 0 Consuming: 1 Consuming: 2 Consuming: 3 Consuming: 4<br/>
All items have been consumed</code></p>
<p>If you run this yourself, the <b>Producing </b>and <b>Consuming </b>lines could be interspersed, but the <b>All items have been consumed </b>line will always be last.</p>
<p>The <b>BlockingCollection </b>class also has static <b>AddToAny, TryAddToAny, TakeFromAny, </b>and <b>TryTakeFromAny </b>methods All of these methods take a <b>BlockingCollection&lt;T&gt;[], </b>as well as an item, a timeout, and a <b>CancellationToken. </b>The <b>(Try)AddToAny </b>methods cycle through all the collections in the array until they find a collection that can accept the item because it is below capacity. The <b>(Try)TakeFromAny </b>methods cycle through all the collections in the array until they find a collection to remove an item from.</p>
<mbp:pagebreak/>
<a name="Index"/>
<h1>Index</h1>
<p>s</p>
<p>.NET Framework. See Microsoft .NET Framework</p>
<p><b>A</b></p>
<p>abstract keyword, 167, 187 accessor methods accessibility, 258</p>
<p>AIP support, 241-242</p>
<p>defined, 238</p>
<p>generic, 258</p>
<p>parameterless properties and, 239-241</p>
<p>performance considerations, 257 Action delegate type, 422-423 Address Space Layout Randomization (ASLR), 2 administrative control advanced, 84-89</p>
<p>simple, 61-64 AIPs (automatically implemented properties),</p>
<p>241-242</p>
<p>AL exe See Assembler Linker utility anonymous types, 247-250</p>
<p>APM (Asynchronous Programming Model) AsyncEnumerator class and, 765-768 BeginXxx methods, 761-762, 769, 774, 776, 778 comparing to EAP, 788 compute-bound operations, 774-776 converting IAsyncResult to task, 783-784</p>
<p>drawbacks, 765-766, 776-780</p>
<p>EndXxx methods, 761-762, 769, 774, 777-778</p>
<p>exceptions and, 769-770</p>
<p>implementing servers asynchronously, 773-774</p>
<p>overview, 761-765 AppDomain class, 622 AppDomainManager class, 615 AppDomains accessing objects across boundaries, 597-608</p>
<p>advanced host control, 615-620</p>
<p>first-chance exception notifications, 612</p>
<p>GC handle tables, 555-557</p>
<p>host support, 612-614</p>
<p>monitoring, 610-611</p>
<p>overview, 591, 594-597</p>
<p>process performance, 16 unhandled exceptions, 509</p>
<p>unloading, 609-610</p>
<p>arguments See type arguments arithmetic operations, primitive types, 117-120</p>
<p>arity, defined, 284</p>
<p>Array class, 281, 385, 392</p>
<p>arrays access performance, 396-401</p>
<p>casting, 390-391</p>
<p>defined, 385</p>
<p>derived from Array class, 392 fixed-size, 401-403 implementing interfaces, 393-394 initializing elements, 388-389 jagged, 387</p>
<p>multidimensional, 387, 396</p>
<p>non-zero-lower bounds, 395-396</p>
<p>overview, 385-387</p>
<p>passing/returning, 394-395</p>
<p>SZ, 387, 396</p>
<p>unsafe access, 401-403 as operator, casting with, 95-97 ASLR (Address Space Layout Randomization), 2 ASP.NET Web Form, 613-614, 770 Assembler Linker (AL exe) utility adding resource files, 52-53</p>
<p>building satellite assemblies, 59</p>
<p>command-line switches, 88</p>
<p>creating assemblies, 50-52</p>
<p>delayed signaling, 78</p>
<p>version resource information, 53-56 assemblies. See also strongly named assemblies adding modules, 46</p>
<p>adding resource files, 52-53</p>
<p>adding to projects, 49-50</p>
<p>application development examples, 20-21</p>
<p>binding, 77</p>
<p>building, 43, 45</p>
<p>characteristics, 43</p>
<p>class support, 68</p>
<p>combining managed code, 5-6</p>
<p>combining modules, 43-53</p>
<p>controlling member access, 23-24</p>
<p>creating with Assembly Linker, 50-52</p>
<p>culture tags, 58-59</p>
<p>defined, 5, 43, 101</p>
<p>delayed signaling, 77-79</p>
<p>executing code, 9-17</p>
<p>friend, 159-160</p>
<p>kinds of, 66-67 namespaces and, 97-101</p>
<p>overriding, 689-690</p>
<p>packaging, 59-60</p>
<p>s</p>
<p>privately deployed, 59-60 probing for, 62-64 reflection support, 628 registering, 75</p>
<p>satellite, 59</p>
<p>self-describing, 6</p>
<p>version resource information, 53-58 Assembly class, 622 assembly display names, 68 assembly loading, 621-625 AssemblyDef metadata table, 45 assemblyIdentity element, 85-86 AssemblyName class, 68 AssemblyRef metadata table, 38, 621 assignment operator, 223 AsyncEnumerator class, 765-768 asynchronous exceptions, 509 asynchronous operations See also APM (Asynchronous Programming Model)</p>
<p>applications and threading models, 770-773</p>
<p>AsyncEnumerator class and, 765-768</p>
<p>cache lines, 752-754</p>
<p>cancelling, 778</p>
<p>cooperative cancellation, 722-726 dedicated threads and, 704-705 event-based patterns, 784-788 execution contexts, 721-722 false sharing, 752-754 I/O operations, 755-760 I/O request priorities, 780-782 implementing servers, 773-774 managing threads, 750-752 memory consumption, 778</p>
<p>Parallel class, 739-743</p>
<p>Parallel LINQ, 743-747 periodic, 747-749 simple, 719-720</p>
<p>tasks supported, 726-739</p>
<p>thread pool and, 718-719</p>
<p>Asynchronous Programming Model See APM</p>
<p>(Asynchronous Programming Model) Attribute class derived classes, 438</p>
<p>matching instances, 448-451</p>
<p>methods supported, 445-446 attributes See custom attributes AttributeUsageAttribute class, 440-442 automatic memory management See garbage collection automatically implemented properties (AIPs),</p>
<p>241-242</p>
<p>B</p>
<p>background threads, 713-714</p>
<p>Barrier class, 841-842</p>
<p>base classes add-in support, 634-637</p>
<p>design considerations, 325-326 before-field-init semantics, 198 binary operators, 202 binding assemblies, 77</p>
<p>memory management and, 658-659 type members, 650-659 types, 83</p>
<p>BindingFlags enumerated type, 643-644 bindingRedirect element, 85-86 bit flags, 379-383</p>
<p>Boolean type, 114, 181</p>
<p>boxed value types changing fields, 140-142</p>
<p>nullable, 463</p>
<p>object equality/identity, 143-146 overview, 127-140</p>
<p>Byte type, 114, 181</p>
<p>bytes, encoding/decoding, 361-369</p>
<p><b>C</b></p>
<p>cache lines, 752-754</p>
<p>call (IL) instruction, 168-170 callback functions, 405-406 callback methods delegate chains, 415-419</p>
<p>FirstChanceException, 612</p>
<p>invoking, 259, 408-410</p>
<p>callvirt (IL) instruction, 168-170 CancellationTokenSource class, 723-726 cancelling asynchronous operations, 778</p>
<p>operations, 722-726</p>
<p>tasks, 729-730</p>
<p>CAS (code access security), 165 casting arrays, 390-391</p>
<p>between types, 93-95 generic type variables, 302 with as operator, 95-97 with is operator, 95-97</p>
<p>catch block, 469-470, 494-495</p>
<p>CERs (constrained execution regions), 509-512</p>
<p>Char type, 114, 181, 327-329</p>
<p>characters encoding/decoding, 361-369</p>
<p>examining, 343-345 child tasks, 733</p>
<p>class libraries, 793-794</p>
<p>classes. See also specific types of classes assembly support, 68</p>
<p><b>CSP (Component Software Programming)</b></p>
<p>attribute, 438</p>
<p>defining, 174</p>
<p>generic, 280</p>
<p>inheritance and, 308</p>
<p>instance constructors and, 187-190</p>
<p>non-generic, 287</p>
<p>partial, 164</p>
<p>static, 162-163</p>
<p>CLI (Common Language Infrastructure), 22</p>
<p>closed keyword, 173</p>
<p>closed types, 283-285</p>
<p>CLR (common language runtime)</p>
<p>compiler support, 2</p>
<p>defined, 1</p>
<p>determining versions installed, 6 loading, 6-9</p>
<p>programming language support, 10 CLR hosting advanced control, 615-620 ASP.NET web forms, 613-614 controlling threads, 617-620 defined, 591</p>
<p>executable applications, 612-613</p>
<p>managing via managed code, 615</p>
<p>Microsoft SQL Server, 614</p>
<p>overview, 592-594</p>
<p>Silverlight support, 613</p>
<p>using AppDomains, 612-614</p>
<p>writing robust host applications, 616-617</p>
<p>XML Web services, 613-614</p>
<p>CLR Profiler tool, 590 CLRCreateInstance function, 593 CLRVer.exe utility, 6 CLS (Common Language Specification)</p>
<p>binary operator support, 202</p>
<p>custom attribute classes, 438</p>
<p>exception considerations, 472-473</p>
<p>operator overloads, 156</p>
<p>overview, 25-28</p>
<p>unary operator support, 201 code access security (CAS), 165 Code Analysis tool (FxCopCmd exe), 174 code explosion, 288-289 codeBase element, 44, 80, 85 collection classes concurrent, 856-859</p>
<p>considerations for holding locks, 851-854 generic, 280</p>
<p>initializing, 245-247</p>
<p>Power Collections library, 281-282 Common Language Infrastructure (CLI), 22 common language runtime See CLR (common language runtime) Common Language Specification. See CLS (Common</p>
<p>Language Specification)</p>
<p>Common Type System (CTS), 22-24 compilers checking type definitions, 98</p>
<p>CLR support, 2</p>
<p>compiling source code, 1-4</p>
<p>executing methods, 10-12</p>
<p>generics infrastructure, 282</p>
<p>implementing events, 266-268</p>
<p>namespace considerations, 101</p>
<p>switch settings, 8, 13, 34-36 Component Software Programming (CSP), 165-167 components See also assemblies attributes of, 165</p>
<p>defined, 5</p>
<p>versioning considerations, 166-167 condition variable pattern, 848-850 conditional attribute classes, 454-455 constants declaring methods as, 235</p>
<p>declaring parameters as, 235</p>
<p>defined, 155, 181 constrained execution regions (CERs), 509-512 constraints constructor, 301-302</p>
<p>defined, 285</p>
<p>generics and, 318-319</p>
<p>interface, 318-319 primary, 299-300</p>
<p>secondary, 300-301</p>
<p>verifiability and, 296-305 constructor constraints, 301-302 constructors. See also specific types of constructors defined, 187</p>
<p>defining for custom attributes, 443</p>
<p>reference types and, 187</p>
<p>value types and, 191 Contract class, 513 contract reference assembly, 518 contravariant type arguments, 291-292 conversion operator methods defined, 156, 205</p>
<p>overview, 204-207 CorFlags.exe utility, 7 corrupted state exceptions (CSEs), 503 CountdownEvent class, 841 covariant type argument, 291-292 CPU speeds</p>
<p>NUMA considerations, 700-703</p>
<p>trends in, 699-700</p>
<p>CreateProcess function, 595 CriticalFinalizerObject class, 532</p>
<p>Crypto API, 77</p>
<p>CSC exe tool, 34, 53, 75</p>
<p>CSEs (corrupted state exceptions), 503</p>
<p>CSP (Component Software Programming), 165-167</p>
<p><b>CTS (Common Type System)</b></p>
<p>CTS (Common Type System), 22-24 culture assembly culture tags, 58-59 string considerations, 351-354 custom attributes applying, 435-439</p>
<p>conditional classes, 454-455 defined, 435</p>
<p>defining classes, 439-442 defining constructors, 443</p>
<p>detecting, 444-448, 451-453</p>
<p>matching instances, 448-451 SerializableAttribute, 668 CustomAttributeData class, 451-453</p>
<p><b>D</b></p>
<p>Data Execution Prevention (DEP), 2 deadlock, defined, 795 debugging exceptions, 504-506</p>
<p>garbage collection and, 527-529</p>
<p>generics infrastructure and, 283</p>
<p>memory problems, 590</p>
<p>PDB file support, 13</p>
<p>Decimal type, 114, 181, 207</p>
<p>decoding characters/bytes, 361-369 default keyword, 221 DefaultMember attribute, 257 DefaultParameterValue attribute, 222 delayed signaling, 77-79 delegate chains controlling invocation, 419-422</p>
<p>overview, 415-419</p>
<p>programming language support, 419 Delegate class, 431 delegate keyword, 410 delegates callback functions and, 405</p>
<p>callback methods and, 408-409</p>
<p>defined, 259, 406</p>
<p>generic, 290, 422-423 overview, 405-407, 410-415</p>
<p>reflection and, 431-432</p>
<p>syntax overview, 423-429</p>
<p>type parameters, 291-292 DEP (Data Execution Prevention), 2 dependentAssembly element, 85-86 deployment</p>
<p>.NET Framework goals, 32-33</p>
<p>building types into modules, 33-34</p>
<p>kinds of, 66-67</p>
<p>privately deployed assemblies, 59-60, 80 deserialization controlling, 668-672</p>
<p>controlling data, 673-678 defined, 661</p>
<p>objects as different objects, 682-684 overriding assemblies/types, 689-690 overview, 661-667 streaming contexts, 680-681 dispose pattern defined, 544</p>
<p>forcing clean up, 544-548 types implementing, 548-551 Dns class, 761</p>
<p>Double type, 114, 181 double-check locking, 844-848</p>
<p>DumpBin exe utility, 7 dynamic expressions, 151 dynamic keyword, 151, 224 dynamic primitive type, 115, 148-153 dynamification, 152</p>
<p><b>E</b></p>
<p>EAP (Event-based Asynchronous Pattern), 784-788 ECMA-334 specification, 22 ECMA-335 specification, 22, 202 EIMI (explicit interface method implementation) defined, 315</p>
<p>improving compile-time type safety, 320-322 ramifications using, 320-322</p>
<p>Enum type, 374-379</p>
<p>Enumerable class, 212 enumerated types adding methods, 383-384</p>
<p>BindingFlags, 643-644</p>
<p>overview, 373-379 ephemeral garbage collectors, 568-573 epiloguecode, 102 equality operator, 200 Escalation Policy, 616 EventArgs class, 261</p>
<p>Event-based Asynchronous Pattern (EAP), 784-788</p>
<p>EventDef metadata table, 37</p>
<p>events asynchronous patterms, 784-788 defined, 23, 156 defining members, 262 exposing, 260-266 implementing, 266-268 implementing explicitly, 271-274 listening for, 269-271 overview, 259-260 raising in thread-safe way, 264-265 thread synchronization and, 819 translating input, 266</p>
<p>virtual, 167-171 Exception class, 474-477, 631</p>
<p>s</p>
<p>exception classes defining, 481-483</p>
<p>Exception class, 474-477</p>
<p>FCL-defined, 478-480 exception handling catch block, 469-470, 494-495</p>
<p>code contracts, 512-518</p>
<p>constrained execution regions, 509-512</p>
<p>defined, 467</p>
<p>Escalation Policy, 616</p>
<p>finally block, 470-472, 492-494</p>
<p>guidelines/best practices, 492-499</p>
<p>hiding implementation detail, 497-499</p>
<p>maintaining state, 496-497</p>
<p>overview, 467-468</p>
<p>performance considerations, 506-508</p>
<p>recovering gracefully, 495-496</p>
<p>trading reliability for productivity, 484-492</p>
<p>try block, 468</p>
<p>exception notifications, 612 exceptions</p>
<p>APM and, 769-770</p>
<p>asynchronous, 509</p>
<p>CLS considerations, 472-473</p>
<p>debugging, 504-506</p>
<p>defining, 466-467</p>
<p>recovering gracefully, 495-496</p>
<p>throwing, 480-481</p>
<p>types derived from, 631</p>
<p>unhandled, 500-503, 509</p>
<p>execution process assemblies, 9-17</p>
<p>methods, 10-12</p>
<p>multiple applications, 16 simple administrative control, 61-64 ExecutionContext class, 721</p>
<p>explicit interface method implementation See EIMI</p>
<p>(explicit interface method implementation) explicit keyword, 206 ExportedTypesDef metadata table, 45 Extensible Markup Language (XML), 61 extension methods extending types, 211-212</p>
<p>overview, 207-209</p>
<p>rules and guidelines, 210-211</p>
<p>this keyword, 213 ExtensionAttribute class, 213</p>
<p><b>F</b></p>
<p>false sharing, 752-754</p>
<p>FCL (Framework Class Library)</p>
<p>canceling operations, 722-726</p>
<p>exception classes, 478-480</p>
<p>general namespaces, 21-22</p>
<p>generics support, 280-281 mapping primitive types, 113-115</p>
<p>MSCorLib dll support, 98</p>
<p>on thread safety, 793</p>
<p>overview, 20-22</p>
<p>thread considerations, 703</p>
<p>Feedback delegate, 407, 431</p>
<p>FieldDef metadata table, 37 fields defined, 23, 155, 183</p>
<p>defining attribute constructors, 443</p>
<p>initializing, 196</p>
<p>mapping constructs, 28</p>
<p>modifiers supported, 183-185</p>
<p>private, 174, 238</p>
<p>properties and, 242</p>
<p>File type, 379</p>
<p>FileAttributes type, 379-380, 383-384</p>
<p>FileDef metadata table, 45</p>
<p>FileStream class, 756-757, 780</p>
<p>filtering type members, 643-644 finalization calling methods, 540-541</p>
<p>CriticalFinalizerObject type, 532</p>
<p>defined, 531</p>
<p>forcing clean up, 544-548</p>
<p>overview, 541-544</p>
<p>releasing native resources, 530-531</p>
<p>resurrection and, 566-568</p>
<p>SafeHandle class, 532-535</p>
<p>with managed resources, 537-540 finalization lists, 541 finally block, 470-472, 492-494 FirstChanceException callback methods, 612 fixed statement, 559 float primitive type, 114 For method (Parallel), 739-743 ForEach method (Parallel), 739-743 foreground threads, 713-714 formatters custom, 356-359</p>
<p>defined, 663</p>
<p>multiple objects, 355-356</p>
<p>serializing type instances, 672-673</p>
<p>specifying, 351-354 Framework Class Library See FCL (Framework Class</p>
<p>Library) freachable queues, 542-544 friend assemblies, 159-160 Func delegate type, 422-423 functions callback, 405-406</p>
<p>synchronous I/O support, 762</p>
<p><b>GACUtil.exe tool</b></p>
<p><b>G</b></p>
<p>GACUtil exe tool, 73-75</p>
<p>garbage collection. See also finalization algorithm overview, 523-527 allocating resources, 520-521 controlling object lifetime, 555-566 debugging and, 527-529 dependency issue, 554 dispose pattern, 544-551 generational, 568-573</p>
<p>interoperability with unmanaged code, 537-540</p>
<p>large objects, 588</p>
<p>modes supported, 585-587</p>
<p>monitoring, 589-590</p>
<p>native resource support, 574-577 predicting successful operation, 578-579 programmatic control, 580-583 resurrection and, 566-568 steps for accessing resources, 520-521 suspending threads and, 696 thread hijacking, 583-584 using Statement, 551-553 GC handle tables, 555-557</p>
<p>GC type, 540, 580</p>
<p>GCNotification class, 538, 573 generational garbage collectors, 568-573 generic types casting variables, 302</p>
<p>code explosion, 288-289</p>
<p>comparing variables, 303-304</p>
<p>inheritance and, 285-287</p>
<p>open/closed, 283-285</p>
<p>setting variable default values, 303</p>
<p>syntax considerations, 287-288</p>
<p>using variables as operands, 304 generics delegate support, 290, 422-423 FCL support, 280-281 infrastructure, 282-289 interface support, 289-290, 315-319</p>
<p>other members and, 296</p>
<p>overview, 275-280</p>
<p>Power Collections library, 281-282</p>
<p>type arguments, 291-292</p>
<p>verifiability/constraints, 296-305 GetRuntime function, 593 Global Assembly Cache, 73-75 globally deployed assemblies, 67 GlobalMemoryStatusEx function, 565</p>
<p><b>H</b></p>
<p>hash codes, 146-148</p>
<p><b>I</b></p>
<p>IAsyncResult interface, 769, 783-788 ICLRMetaHost interface, 592</p>
<p>ICLRRuntimeHost interface, 593 ICLRRuntimeInfo interface, 593</p>
<p>ICollection interface, 393-394</p>
<p>IConvertible interface, 677 IDL (Interface Definition Language), 4 IEnumerable interface, 393-394 IFormatterConverter interface, 677 IL (Intermediate Language)</p>
<p>call instruction, 168-170</p>
<p>callvirt instruction, 168-170</p>
<p>defined, 9</p>
<p>generics infrastructure, 282 newjob instruction, 520 newobj instruction, 522 protecting intellectual property, 17 vector considerations, 387 verification support, 15-16 IL Assembler, 9</p>
<p>IL Disassembler tool (ILDasm exe), 28, 38-41, 43 IList interface, 393-394</p>
<p>implicit keyword, 206 IndexerName attribute, 257 inequality operator, 200 inheritance class, 308</p>
<p>generic types and, 285-287 instance constructors, 187</p>
<p>interface, 308, 310-311</p>
<p>initializing array elements, 388-389</p>
<p>collection classes, 245-247</p>
<p>fields, 196</p>
<p>objects, 245-247 instance constructors classes and, 187-190</p>
<p>defined, 155</p>
<p>structures and, 191-194 instance methods, 102, 409 int primitive type, 114</p>
<p>Int16 type, 114, 181 Int32 type, 114, 181</p>
<p>Int64 type, 114, 181 intellectual property, 17-18 Interface Definition Language (IDL), 4 interface methods calling, 312-313</p>
<p>calling via nullable value type, 464 implementing, 314-315 interfaces add-in support, 634-637 applying type constructors, 194 arrays implementing, 393-394</p>
<p>e</p>
<p>compile-time type safety, 320-322 defining, 308-310 design considerations, 325-326 discovering for types, 644-646</p>
<p>generic, 289-290, 315-319</p>
<p>identical method name/signature, 319-320</p>
<p>inheriting, 308, 310-311</p>
<p>partial, 164</p>
<p>Tuple type and, 251</p>
<p>type parameters, 291-292 internal accessibility, 161 invariant type parameter, 291</p>
<p>Invoke method (Parallel), 739-743</p>
<p>is operator, casting with, 95-97 ISerializable interface, 673-680 ISerializationSurrogate interface, 685-687, 689 ISurrogateSelector interface, 688</p>
<p><b>J</b></p>
<p>jagged arrays, 387</p>
<p>JIT (just-in-time) compiler executing methods, 10-12 generics infrastructure, 282 optimizing native code, 13 performance considerations, 14-15 type constructor performance, 198</p>
<p>JITCompiler function, 11</p>
<p><b>K</b></p>
<p>keywords, component versioning and, 166</p>
<p><b>L</b></p>
<p>large objects, 588</p>
<p>lazy initialization, 844</p>
<p>LINQ (Language Integrated Query), 743</p>
<p>listening for events, 269-271</p>
<p>livelock, defined, 795</p>
<p>local variables, implicitly typed, 223-224</p>
<p>long primitive type, 114</p>
<p><b>M</b></p>
<p>Machine.config file, 63 managed code/modules combining into assemblies, 5-6</p>
<p>compilation switch settings, 8</p>
<p>compiling source code, 1-4</p>
<p>defined, 2</p>
<p>managing CLR via, 615 parts, 3 managed heap allocating resources, 520-521</p>
<p>initialized, 568</p>
<p>runtime relationships, 102-111</p>
<p>manifest, 43, 45-47</p>
<p>ManifestResourceDef metadata table, 45 ManualResetEventSlim class, 830</p>
<p>MarshalByRefType type, 601-605 MarshalByValType type, 606-608 MBCS (Multi-Byte Character Set), 361 MemberInfo class, 638-642 MemberRef metadata table, 38 memory management asynchronous operations and, 778</p>
<p>binding and, 658-659</p>
<p>debugging and, 590 MemoryFailPoint class, 578-579 metadata defined, 4, 37, 156</p>
<p>functionality, 4</p>
<p>manifest support, 43</p>
<p>verification process and, 17</p>
<p>viewing, 38 metadata tables common definition, 37</p>
<p>common reference, 37-38</p>
<p>generics infrastructure, 282 MethodDef metadata table, 37 methods. See also specific kinds of methods adding to enumerated types, 383-384</p>
<p>calling first time, 49</p>
<p>declaring as constants, 235</p>
<p>defined, 23, 156</p>
<p>defining as generic, 135</p>
<p>defining to raise events, 263</p>
<p>executing, 10-12</p>
<p>generic, 293-295</p>
<p>interface, 312-315 mapping constructs, 28 passing/returning arrays, 394-395 properties as, 242 runtime relationships, 102 thread synchronization and, 822-823 thread-safe, 793 Microsoft NET Framework combining managed modules, 5-6 compiling source code, 1-4 Framework Class Library, 20-22 installing multiple versions, 6 interoperability with unmanaged code, 29 loading common language runtime, 6-9</p>
<p>NGen exe tool, 18-19</p>
<p>Microsoft Authenticode technology, 76 Microsoft Spy++, 708 Microsoft SQL Server, 614 Microsoft.CSharp.dll assembly, 152 ModuleDef metadata table, 37</p>
<p>e</p>
<p>ModuleRef metadata table, 38 modules See also managed code/modules building types into, 33-34, 43 combining to form assemblies, 43-53</p>
<p>Monitor class, 830-835</p>
<p>monitoring</p>
<p>AppDomains, 610-611</p>
<p>garbage collection, 589-590 MSCorEE.dll file, 6, 592 MSCorLib.dll file, 34, 98 MSI (Windows Installer) tool, 74 Multi-Byte Character Set (MBCS), 361 multidimensional arrays, 387, 396 Mutex class, 820-822</p>
<p><b>N</b></p>
<p>naked type constraints, 300 namespaces assemblies and, 97-101</p>
<p>creating, 21, 100</p>
<p>defined, 97-98</p>
<p>FCL, 21-22</p>
<p>Native Code Generator (NGen exe) tool intellectual property, 18</p>
<p>overview, 18</p>
<p>security, 19</p>
<p>synchronization, 19 new keyword, 167, 187, 221 new operator, 92-93, 410 newjob (IL) instruction, 520 newobj (IL) instruction, 522 NonSerializedAttribute custom attribute, 669 NOP (no-operation) instructions, 13 nullable value types, 457-464 null-coalescing operator, 462 NUMA architecture machines, 700-703, 754</p>
<p><b>O</b></p>
<p>object lifetime, 555-566 Object type class inheritance, 308</p>
<p>compiler restrictions, 162</p>
<p>defined, 114</p>
<p>deriving types from, 91-93</p>
<p>instance constructors and, 188</p>
<p>object equality/identity, 143-146</p>
<p>object hash codes, 146-148</p>
<p>protected methods, 92</p>
<p>public methods, 91-92</p>
<p>ToString method, 350-359 object-oriented programming (OOP), 165, 174, 275 objects accessing across boundaries, 597-608</p>
<p>converting types, 204-207 deserializing, 682-684 discovering types, 93 forcing clean up, 544-548 formatting into strings, 355-356 hash codes, 146-148 initializing, 245-247 large, 588</p>
<p>parsing strings, 359-361 runtime relationships, 102-111 string representation, 350-359</p>
<p>OneManyLock class, 838-840</p>
<p>OOP (object-oriented programming), 165, 174, 275 open types, 283-285 operator keyword, 206 operator overload methods boxing/unboxing, 133</p>
<p>defined, 156, 200</p>
<p>language interoperability, 203</p>
<p>name rules, 203-204</p>
<p>overview, 200-202</p>
<p>primitive types and, 202 operators. See also specific operators assignment, 223</p>
<p>binary, 202</p>
<p>equality/inequality, 200 null-coalescing, 462 relational, 460 unary, 201 Optional attribute, 222</p>
<p>out keyword, 221, 225-228</p>
<p>override keyword, 167, 187 <b>P</b></p>
<p>packaging assemblies, 59-60</p>
<p>Parallel class, 739-743 Parallel LINQ, 743</p>
<p>parallel query, 743</p>
<p>ParallelEnumerable class, 743-745</p>
<p>ParamDef metadata table, 37</p>
<p>ParameterizedThreadStart delegate, 704, 719</p>
<p>parameters declaring as constants, 235 DefaultParameterValue attribute, 222 implicitly typed local variables, 223-224</p>
<p>named, 219-220 optional, 219-220</p>
<p>Optional attribute, 222 passing by reference, 225-230 passing variable number, 231-233 return type guidelines, 233-235 rules and guidelines, 220-222, 233-235 type, 276 params keyword, 231-233</p>
<p>s</p>
<p>Parse method, 359-361 parsing strings, 359-361 partial keyword, 164 partial methods overview, 213-216</p>
<p>rules and guidelines, 216-217 partial signaling, 77-79 payload code, 149 PDB (Program Database) files, 13 PerfMon exe tool, 589 performance considerations accessing instance fields, 605-606</p>
<p>arrays, 396-401</p>
<p>boxing/unboxing, 129</p>
<p>exception handling, 506-508</p>
<p>executing multiple applications, 16</p>
<p>generics, 277</p>
<p>JIT compiling, 14-15</p>
<p>property accessor methods, 257</p>
<p>reflection, 627-634</p>
<p>sealed classes, 172</p>
<p>threads, 696-699</p>
<p>type constructors, 198-200 PEVerify.exe utility, 17 policy control, publisher, 87-89 polymorphism, 165-167 Power Collections library, 281-282 Pratschner, Steven, 594 precise semantics, 198 primary constraints, 299-300 primitive types checked/unchecked operations, 117-120</p>
<p>defined, 113</p>
<p>defining constants, 181</p>
<p>dynamic, 148-153</p>
<p>mapping, 113-115</p>
<p>operator overload methods and, 202</p>
<p>overview, 113-117 private accessibility, 161, 194, 238 privately deployed assemblies defined, 67</p>
<p>overview, 59-60, 80 probing element, 85 process, defined, 692 programming languages</p>
<p>APM considerations, 788-790</p>
<p>defining runtime binders, 152 delegate chain support, 419 generics infrastructure, 282 mapping primitive types, 113-117 nullable value types, 459-461 operator interoperability, 203 type safety, 148 projects adding assemblies, 49-50</p>
<p>publishing assemblies, 60 prologuecode, 102 properties accessor accessibility, 258</p>
<p>anonymous types, 247-250</p>
<p>as methods, 242-243</p>
<p>automatically implemented, 241-242 defined, 23, 156</p>
<p>defining attribute constructors, 443 defining intelligently, 242-244 object/collection initializers, 245-247 parameterful, 252-257 parameterless, 237-241</p>
<p>Tuple type, 250-252 virtual, 167-171</p>
<p>Visual Studio Debugger and, 244 PropertyDef metadata table, 37 protected accessibility, 161 protected internal accessibility, 161 public accessibility, 161 public key tokens defined, 68</p>
<p>security considerations, 71</p>
<p>viewing, 69 publisher policy control, 87-89 publisherPolicy element, 86</p>
<p><b>Q</b></p>
<p>qsort function, 405 quantum, defined, 694</p>
<p><b>R</b></p>
<p>ReaderWriterLockSlim class, 836-838 readonly keyword, 183</p>
<p>recursion, 827-829</p>
<p>ref keyword, 221, 225-228</p>
<p>reference types instance constructors and classes, 187-190</p>
<p>overview, 121-125</p>
<p>resolving, 81-84 reflection defined, 444</p>
<p>delegates and, 431-432</p>
<p>discovering type members, 637-659</p>
<p>dynamically extensible applications, 626</p>
<p>generics infrastructure, 283</p>
<p>performance considerations, 627-634 registry keys adding assemblies, 50</p>
<p>determining .NET Framework installs, 6 relational operators, 460 resource files, adding to assemblies, 52-53 response files, 34-36</p>
<p>n</p>
<p>resurrection, 566-568</p>
<p>return type guidelines, 233-235</p>
<p>RFC 1766, 58</p>
<p>runtime binders, 152 RuntimeType type, 629</p>
<p><b>S</b></p>
<p>safe code, 16 safe point, 584 SafeHandle class derived types, 532-535</p>
<p>dispose pattern and, 545-548</p>
<p>interoperating with unmanaged code, 535-537 satellite assemblies, 59</p>
<p>SByte type, 114, 181</p>
<p>scheduling tasks, 737-739 threads, 708-713</p>
<p>sealed keyword, 167, 172, 187 secondary constraints, 300-301 SecureString class, 369-372 security assembly considerations, 45</p>
<p>deployment considerations, 32</p>
<p>NGen exe considerations, 19</p>
<p>public key tokens and, 71</p>
<p>sealed classes, 173</p>
<p>string considerations, 369-372 Semaphore class, 819 SemaphoreSlim class, 830 sequential query, 743</p>
<p>SerializableAttribute custom attribute, 668 serialization controlling, 668-672</p>
<p>controlling data, 673-678</p>
<p>defined, 661</p>
<p>for types, 667-668</p>
<p>overview, 661-667</p>
<p>streaming contexts, 680-681</p>
<p>surrogates, 684-687</p>
<p>type instances, 672-673</p>
<p>types as different types, 682-684 SerializationBinder class, 689 SerialPort class, 761</p>
<p>servers, implementing asynchronously, 773-774</p>
<p>servicings, 165</p>
<p>short primitive type, 114</p>
<p>Silverlight, 613, 770 Single type, 114, 181 Singleton class, 683, 846-847 SN exe (Strong Name) utility, 70, 77 Socket class, 761</p>
<p>SOS Debugging Extension (SOS dll), 590</p>
<p>source code</p>
<p>.NET Framework interoperability, 29</p>
<p>code contracts, 512-518</p>
<p>code explosion, 288-289</p>
<p>compiling, 1-4</p>
<p>epiloguecode, 102</p>
<p>generics and, 277</p>
<p>partial keyword, 164</p>
<p>payload, 149</p>
<p>prologuecode, 102</p>
<p>safe, 16</p>
<p>unsafe, 16-17 SqlCommand class, 761 state management constrained execution regions, 509-512</p>
<p>corrupted state exceptions, 503</p>
<p>maintaining state, 496-497</p>
<p>static classes, 162-163, 188 static keyword, 102, 183, 205 static methods, call back, 408-409</p>
<p>StreamingContext structure, 680-681 StreamWriter type, 362 String type comparing strings, 334-340</p>
<p>constant support, 181</p>
<p>constructing strings, 330-333, 346-350</p>
<p>description, 114, 330</p>
<p>examining characters, 343-345</p>
<p>immutable nature, 333</p>
<p>methods for copying strings, 346</p>
<p>Parse method, 359-361</p>
<p>security considerations, 369-372</p>
<p>string interning, 340-342</p>
<p>string pooling, 343</p>
<p>StringBuilder class, 207-209, 346-350</p>
<p>strings comparing, 334-340</p>
<p>constructing, 330-333, 346-350</p>
<p>custom formatting, 356-359</p>
<p>encoding/decoding, 361-369</p>
<p>formatting multiple objects, 355-356</p>
<p>methods for copying, 346</p>
<p>object representation, 350</p>
<p>parsing, 359-361</p>
<p>security considerations, 369-372 Strong Name (SN exe) utility, 70, 77 strongly named assemblies as tamper-resistant, 76-77</p>
<p>creating, 69-70</p>
<p>defined, 68</p>
<p>overview, 67-72</p>
<p>privately deploying, 80</p>
<p>recommendations, 67</p>
<p>referencing, 75-76 structures generic, 293</p>
<p>s</p>
<p>instance constructors and, 191-194</p>
<p>partial, 164 SurrogateSelector class, 688 symbolic names, 383-384</p>
<p>sync blocks, 830-835</p>
<p>synchronization See thread synchronization SynchronizationContext class, 771-772 synchronous operations, 755-760, 779 System Monitor control, 589 SZ arrays, 387, 396</p>
<p><b>T</b></p>
<p>task factories, 735-737</p>
<p>Task Manager (Windows), 697-698</p>
<p>tasks cancelling, 729-730</p>
<p>converting EAP, 786</p>
<p>converting IAsyncResult, 783-784</p>
<p>defined, 726</p>
<p>internal components, 733-735</p>
<p>overview, 726-727</p>
<p>scheduling, 737-739</p>
<p>starting automatically, 731-732</p>
<p>starting child tasks, 733</p>
<p>waiting for completion of, 727-729 TaskScheduler type, 737, 743 TEB (thread environment block), 693</p>
<p>this keyword, 210, 213 Thread class, 800</p>
<p>thread environment block (TEB), 693 thread ownership, 827-829 thread pool</p>
<p>APM considerations, 776-777</p>
<p>calling methods asynchronously, 720</p>
<p>managing threads, 750-752</p>
<p>overview, 718-719</p>
<p>setting limits, 750-751 thread synchronization blocking threads, 842-843</p>
<p>calling methods, 822-823 class libraries and, 793-794 concurrent collection classes, 856-859 condition variable pattern, 848-850 considerations for holding locks, 851-854</p>
<p>double-check locking, 844-848</p>
<p>event constructs, 817-819</p>
<p>hybrid constructs, 829-843 hybrid locks, 826-829</p>
<p>implementing spin locks, 807-811</p>
<p>interlocked constructs, 803-807, 811-812</p>
<p>kernel-mode constructs, 813-816 mutex constructs and, 820-822 overview, 791-793 primitive constructs, 794-796</p>
<p>recursion, 827-829</p>
<p>semaphore constructs, 819 user-mode constructs, 796-797 volatile constructs, 797-803</p>
<p>ThreadPool class, 719-720, 726</p>
<p>threads application models, 770-773 asynchronous operations and, 704-705</p>
<p>blocking, 842-843</p>
<p>CLR considerations, 703 controlling, 617-620</p>
<p>CPU trends and, 699-700</p>
<p>delaying processing, 809-811 execution contexts, 721-722 foreground versus background, 713-714 garbage collection and, 696</p>
<p>hijacking, 583-584</p>
<p>managing, 750-752 NUMA considerations, 700-703 overhead considerations, 692-696 performance considerations, 696-699 priority considerations, 708-713 rationale for supporting, 691-692 reasons for using, 706-708 runtime relationships, 102-111</p>
<p>scheduling, 708-713</p>
<p>worker, 751-752 ThreadsSharingData class, 801 throwing exceptions, 480-481 Timer class, 747-749 TimerCallback delegate type, 719, 747</p>
<p>ToString method, 350-359, 381 try block, 468</p>
<p>Tuple type, 247, 250-252</p>
<p>type arguments code explosion, 288-289 contravariant/covariant, 291-292 defined, 277</p>
<p>type constructors calling, 195</p>
<p>defined, 155, 194 overview, 194-197</p>
<p>performance considerations, 198-200 type inference, 294-295 type members accessibility, 160-162, 172-174 binding, 650-659</p>
<p>discovering, 637-659 filtering, 643-644 invoking, 646-650 kinds supported, 155-158 partial keyword, 164 static classes, 162-163</p>
<p>type objects, 283, 628-631</p>
<p>type parameter constraints, 300</p>
<p>s</p>
<p>type parameters arity and, 284</p>
<p>contravariant/covariant, 291-292</p>
<p>defined, 276 type safety casting between types, 93-95</p>
<p>generics and, 277</p>
<p>improving compile-time, 320-322</p>
<p>programming languages and, 148</p>
<p>quiz about, 96-97 Type type, 628 TypeDef metadata table, 37 TypeRef metadata table, 38, 621 types. See also specific types arity of, 284</p>
<p>binding, 83</p>
<p>building into modules, 33-34, 43 casting between, 93-95 casting with is/as operators, 95-97 constructing instances, 632-634 controlling field layout, 126-127 controlling member access, 23-24 CTS examples, 24 defined, 156</p>
<p>deriving from System.Object, 91-93 design considerations, 172-174 discovering interfaces, 644-646 exception-derived, 631 exposing events, 260-266 extending, 211-212 functionality, 22 listening for events, 269-271 making serializable, 667-668</p>
<p>overriding, 689-690</p>
<p>runtime relationships, 102-111</p>
<p>serializing, 682-684</p>
<p>serializing instances, 672-673</p>
<p>versioning, 175-179</p>
<p>visibility considerations, 158, 172-174</p>
<p><b>u</b></p>
<p>uint primitive type, 114</p>
<p>UInt16 type, 114, 181 UInt32 type, 114, 181</p>
<p>UInt64 type, 114, 181 ulong primitive type, 114 unary operators, 201 unboxed value types nullable, 463</p>
<p>object equality/identity, 143-146</p>
<p>overview, 127-140 unhandled exceptions, 500-503, 509 Unicode characters, 361 union, explicit layout and, 126 unloading AppDomains, 609-610</p>
<p>unmanaged code .NET Framework interoperability, 29 SafeHandle class interoperability, 535-537</p>
<p>unsafe code, 16-17</p>
<p>ushort primitive type, 114</p>
<p>using directive, 98-99, 115</p>
<p>using Statement, 551-553</p>
<p><b>V</b></p>
<p>value types boxing/unboxing, 127-140 changing fields, 140-142 enumerated types, 383-384 instance constructors and structures, 191-194</p>
<p>nullable, 457-464</p>
<p>object equality/identity, 143-146</p>
<p>overview, 121-125 var keyword, 151, 224 variables generic type, 302-305</p>
<p>local, 223-224</p>
<p>type parameters, 276</p>
<p>vectors, 387, 396</p>
<p>verifiability and constraints, 296-305 verification process (IL), 15-16 version numbers assembly resource information, 53-58</p>
<p>format of, 57-58</p>
<p>type considerations, 45 versioning challenges, 66</p>
<p>component considerations, 166-167, 172 design considerations, 325 servicing components, 165-166</p>
<p>types, 175-179</p>
<p>virtual events, 167-171 virtual keyword, 167, 187 virtual methods calling, 102, 167-171, 188</p>
<p>versioning types and, 175-179 virtual properties, 167-171 visibility, type, 158 Visual Studio adding assemblies to projects, 49-50</p>
<p>Code Analysis tool, 174</p>
<p>code contracts, 513</p>
<p>code spitters, 164</p>
<p>debugger properties, 244</p>
<p>debugging exceptions, 504-506</p>
<p>generics infrastructure and, 283</p>
<p>publishing assemblies, 60 volatile keyword, 183</p>
<p><b>W</b></p>
<p>WaitCallback delegate, 719</p>
<p>Windows Installer (MSI), 74</p>
<p>Windows Presentation Foundation (WPF), 612, 770</p>
<p>Windows Task Manager, 697-698</p>
<p>Wintellect Power Collections library, 281-282</p>
<p>Wintellect Power Threading Library, 715 worker threads, 751-752</p>
<p>WoW64 technology, 8</p>
<p>WPF (Windows Presentation Foundation), 612, 770 writing robust host applications, 616-617</p>
<p><b>X</b></p>
<p>XML (Extensible Markup Language), 61 XML Web services, 613-614, 770</p>
<mbp:pagebreak/>
<a name="About"/>
<h1>About the Author</h1>
<p>Jeffrey Richter is a cofounder of Wintellect (<a href="http://www.Wintellect.com/">http://www.Wintellect.com/</a>), a training, consulting, and debugging company dedicated to helping companies produce better software faster. Wintellect also offers its own twice-yearly Devscovery conference (<a href="http://Devscovery.com/">http://Devscovery.com/</a>). Jeffrey has written many books about Win32 and Microsoft .NET Framework programming, including CLR via C#, 3rd Edition (Microsoft Press, 2010), Windows via C/C++, 5<sup>th</sup> Edition (Microsoft Press, 2007), and Programming Server-Side Applications for Microsoft Windows 2000 (Microsoft Press, 2000). Jeffrey is a contributing editor for MSDN Magazine, where he has written numerous feature articles and has been the Win32 Q&amp;A columnist, .NET Q&amp;A columnist, and Concurrent Affairs columnist. Jeffrey also speaks at various trade conferences worldwide, including Wintellect's Devscovery, VSLive!, and Microsoft's TechEd and Professional Developers Conference.</p>
<p>Jeffrey has consulted for many companies, including AT&amp;T, DreamWorks, General Electric, Hewlett-Packard, IBM, and Intel. His code has shipped in many Microsoft products, among them Microsoft Visual Studio, Microsoft Golf, Windows Sound System, and various versions of Microsoft Windows. Jeff consulted with the .NET Framework team for eight years and maintains an ongoing close relationship with that team as well as the Windows team.</p>
<p>On the personal front, Jeffrey holds both airplane and helicopter pilot licenses, though he never gets to fly as often as he'd like. He is also a member of the International Brotherhood of Magicians and enjoys showing friends sleight-of-hand card tricks from time to time. Jeff's other hobbies include music (especially jazz and progressive rock from the 1970s), drumming, model railroading, and karate. He also enjoys traveling and theater. He lives in Kirkland, Washington, with his wife, Kristin, and his two sons, Aidan and Grant..</p>
<img src="93.jpg"/>
</body>
</html>
